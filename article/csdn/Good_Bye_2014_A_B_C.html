<!DOCTYPE html>
<html>
  <!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  
  <title>Good Bye 2014 A B C - mfcheer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  
  <meta name="keywords" content="算法,acm,codeforces">
  
    <meta name="description" content="help change the world">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.02">
  
  
    <link rel="alternate" href="/atom.xml " title="mfcheer" type="application/atom+xml">
  

  <link rel="stylesheet" href="/css/style.css">
  <script src="//cdn.bootcss.com/jquery/2.1.0/jquery.min.js" type="text/javascript"></script>
  <script src="/js/search.js"></script>
  <script src="/js/load.js"></script>
  <link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" href="/css/prism-solarizedlight.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>
</html>
  <body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container">
      <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">mfcheer</a>
    <div class="subtitle">help change the world</div>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
    </ul>
  </nav>
  <link rel="stylesheet" href="/css/highlight/styles/atelier-forest-dark.css">
  <script src="/js/md5.min.js"></script>
  <script src="/js/highlight.pack.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
</header>

<article class="post">
  <div class="post-title">
    <span style="text-align: center;display:block;font-size:24px;font-weight:bold;color:#E00000;" class="article--title">Good Bye 2014 A B C</span>
	<br>
  </div>

  <div class="post-meta">
  </div>
  <div class="post-content">
    <p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/42287993" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/42287993</a></p>
<p>A. New Year Transportation</p>
<p>time limit per test</p>
<p>2 seconds</p>
<p>memory limit per test</p>
<p>256 megabytes</p>
<p>input</p>
<p>standard input</p>
<p>output</p>
<p>standard output</p>
<p>New Year is coming in Line World! In this world, there are  _n_ cells numbered<br>by integers from  1  to  _n_ , as a  1 × _n_ board. People live in cells.<br>However, it was hard to move between distinct cells, because of the difficulty<br>of escaping the cell. People wanted to meet people who live in other cells.</p>
<p>So, user tncks0121 has made a transportation system to move between these<br>cells, to celebrate the New Year. First, he thought of  _n_ - 1  positive<br>integers  _a_ 1  , _a_ 2  , …, _a_ _n_ - 1  . For every integer  _i_ where<br>1 ≤ _i_ ≤ _n_ - 1  the condition  1 ≤ _a_ _i_ ≤ _n_ - _i_ holds. Next, he<br>made  _n_ - 1  portals, numbered by integers from 1 to  _n_ - 1  . The  _i_<br>-th (  1 ≤ _i_ ≤ _n_ - 1  ) portal connects cell  _i_ and cell  ( _i_ + _a_<br>_i_ )  , and one can travel from cell  _i_ to cell  ( _i_ + _a_ _i_ )  using<br>the  _i_ -th portal. Unfortunately, one cannot use the portal backwards, which<br>means one cannot move from cell  ( _i_ + _a_ _i_ )  to cell  _i_ using the<br>_i_ -th portal. It is easy to see that because of condition  1 ≤ _a_ _i_ ≤ _n_<br>- _i_ one can’t leave the Line World using portals.</p>
<p>Currently, I am standing at cell  1  , and I want to go to cell  _t_ .<br>However, I don’t know whether it is possible to go there. Please determine<br>whether I can go to cell  _t_ by only using the construted transportation<br>system.</p>
<p>Input</p>
<p>The first line contains two space-separated integers  _n_ (  3 ≤ _n_ ≤ 3 × 10<br>4  ) and  _t_ (  2 ≤ _t_ ≤ _n_ ) — the number of cells, and the index of the<br>cell which I want to go to.</p>
<p>The second line contains  _n_ - 1  space-separated integers  _a_ 1  , _a_ 2  ,<br>…, _a_ _n_ - 1  (  1 ≤ _a_ _i_ ≤ _n_ - _i_ ). It is guaranteed, that using<br>the given transportation system, one cannot leave the Line World.</p>
<p>Output</p>
<p>If I can go to cell  _t_ using the transportation system, print “  YES  “.<br>Otherwise, print “  NO  “.</p>
<p>Sample test(s)</p>
<p>input</p>
<pre><code>8 4
1 2 1 2 1 2 1
</code></pre><p>output</p>
<pre><code>YES
</code></pre><p>input</p>
<pre><code>8 5
1 2 1 2 1 1 1
</code></pre><p>output</p>
<pre><code>NO
</code></pre><p>Note</p>
<p>In the first sample, the visited cells are:  1, 2, 4  ; so we can successfully<br>visit the cell  4  .</p>
<p>In the second sample, the possible cells to visit are:  1, 2, 4, 6, 7, 8  ; so<br>we can’t visit the cell  5  , which we want to visit.</p>
<p>A 水题</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt;
#include&lt;malloc.h&gt;

using namespace std;

int n, t;

int p[30010];

int main()
{
    while (cin &gt;&gt; n &gt;&gt; t)
    {
        for (int i = 1; i &lt;= n-1; i++)
            cin &gt;&gt; p[i];

        int pos = 1;

        for (int i = 1; i &lt;= n-1;i++)
        {
            if (pos &gt;= t)
                break;
            pos += p[pos];
        }
        if (pos == t)
            cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;
        else
            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;
    }
    return 0;
}
</code></pre><p>B. New Year Permutation</p>
<p>time limit per test</p>
<p>2 seconds</p>
<p>memory limit per test</p>
<p>256 megabytes</p>
<p>input</p>
<p>standard input</p>
<p>output</p>
<p>standard output</p>
<p>User ainta has a permutation  _p_ 1  , _p_ 2  , …, _p_ _n_ . As the New Year<br>is coming, he wants to make his permutation as pretty as possible.</p>
<p>Permutation  _a_ 1  , _a_ 2  , …, _a_ _n_ is  prettier  than permutation<br>_b_ 1  , _b_ 2  , …, _b_ _n_ , if and only if there exists an integer  _k_ (<br>1 ≤ _k_ ≤ _n_ ) where  _a_ 1  = _b_ 1  , _a_ 2  = _b_ 2  , …, _a_ _k_ - 1  =<br>_b_ _k_ - 1  and  _a_ _k_ &lt; _b_ _k_ all holds.</p>
<p>As known, permutation  _p_ is so sensitive that it could be only modified by<br>swapping two distinct elements. But swapping two elements is harder than you<br>think. Given an  _n_ × _n_ binary matrix  _A_ , user ainta can swap the values<br>of  _p_ _i_ and  _p_ _j_ (  1 ≤ _i_ , _j_ ≤ _n_ ,  _i_ ≠ _j_ ) if and only if<br>_A_ _i_ , _j_ = 1  .</p>
<p>Given the permutation  _p_ and the matrix  _A_ , user ainta wants to know the<br>prettiest permutation that he can obtain.</p>
<p>Input</p>
<p>The first line contains an integer  _n_ (  1 ≤ _n_ ≤ 300  ) — the size of the<br>permutation  _p_ .</p>
<p>The second line contains  _n_ space-separated integers  _p_ 1  , _p_ 2  , …,<br>_p_ _n_ — the permutation  _p_ that user ainta has. Each integer between  1<br>and  _n_ occurs exactly once in the given permutation.</p>
<p>Next  _n_ lines describe the matrix  _A_ . The  _i_ -th line contains  _n_<br>characters ‘  0  ‘ or ‘  1  ‘ and describes the  _i_ -th row of  _A_ . The<br>_j_ -th character of the  _i_ -th line  _A_ _i_ , _j_ is the element on the<br>intersection of the  _i_ -th row and the  _j_ -th column of A. It is<br>guaranteed that, for all integers  _i_ , _j_ where  1 ≤ _i_ &lt; _j_ ≤ _n_ ,  _A_<br>_i_ , _j_ = _A_ _j_ , _i_ holds. Also, for all integers  _i_ where  1 ≤ _i_ ≤<br>_n_ ,  _A_ _i_ , _i_ = 0  holds.</p>
<p>Output</p>
<p>In the first and only line, print  _n_ space-separated integers, describing<br>the prettiest permutation that can be obtained.</p>
<p>Sample test(s)</p>
<p>input</p>
<pre><code>7
5 2 4 3 6 7 1
0001001
0000000
0000010
1000001
0000000
0010000
1001000
</code></pre><p>output</p>
<pre><code>1 2 4 3 6 7 5
</code></pre><p>input</p>
<pre><code>5
4 2 1 5 3
00100
00011
10010
01101
01010
</code></pre><p>output</p>
<pre><code>1 2 3 4 5
</code></pre><p>Note</p>
<p>In the first sample, the swap needed to obtain the prettiest permutation is:<br>( _p_ 1  , _p_ 7  )  .</p>
<p>In the second sample, the swaps needed to obtain the prettiest permutation is<br>( _p_ 1  , _p_ 3  ), ( _p_ 4  , _p_ 5  ), ( _p_ 3  , _p_ 4  )  .</p>
<p><img src="http://espresso.codeforces.com/9b5f3d9ddb6b034c5fdb75722cfa3acc418fe643.png" alt=""></p>
<p>A  permutation  _p_ is a sequence of integers  _p_ 1  , _p_ 2  , …, _p_ _n_<br>, consisting of  _n_ distinct positive integers, each of them doesn’t exceed<br>_n_ . The  _i_ -th element of the permutation  _p_ is denoted as  _p_ _i_ .<br>The size of the permutation  _p_ is denoted as  _n_ .</p>
<p>B 弗洛伊德算法 ，并查集也可以做 ，有时间敲一下。</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;algorithm&gt;  
#include &lt;string.h&gt;  

using namespace std;

int p[305];
int b[305][305];

int n;

int main()
{
    while (cin &gt;&gt; n)
    {
        for (int i = 1; i &lt;= n; i++)
            cin &gt;&gt; p[i];
        getchar();
        for (int i = 1; i &lt;= n; i++)
        {
            for (int j = 1; j &lt;= n; j++)
            {
                char c = getchar();
                b[i][j] = (c == &#39;1&#39;);
            }
            getchar();
        }

        for (int k = 1; k &lt;= n;k++)
            for (int  i= 1; i &lt;= n; i++)
                for (int j = 1; j &lt;= n; j++)
                {
                    if (b[i][k] &amp; b[k][j])
                    {
                        b[i][j] = b[j][i] = 1;
                    }
                }

        for (int i = 1; i &lt;= n; i++)
            for (int j = i + 1; j &lt;= n; j++)
            {
                if (b[i][j] )
                {
                    if (p[i] &gt; p[j])
                    {
                        swap(p[i],p[j]);
                    }
                }
            }
        for (int i = 1; i &lt;= n; i++)
            cout &lt;&lt; p[i] &lt;&lt; &quot; &quot;;
    }
    return 0;
}
</code></pre><p>C. New Year Book Reading</p>
<p>New Year is coming, and Jaehyun decided to read many books during 2015, unlike<br>this year. He has  _n_ books numbered by integers from 1 to  _n_ . The weight<br>of the  _i_ -th (  1 ≤ _i_ ≤ _n_ ) book is  _w_ _i_ .</p>
<p>As Jaehyun’s house is not large enough to have a bookshelf, he keeps the  _n_<br>books by stacking them vertically. When he wants to read a certain book  _x_ ,<br>he follows the steps described below.</p>
<ol>
<li>He  lifts  all the books above book  _x_ . </li>
<li>He pushes book  _x_ out of the stack. </li>
<li>He puts down the lifted books without changing their order. </li>
<li>After reading book  _x_ , he puts book  _x_ on the top of the stack. </li>
</ol>
<p><img src="http://espresso.codeforces.com/16bdcfb1c75c6e60439f74c69133b7baaa9d8b13.png" alt=""></p>
<p>He decided to read books for  _m_ days. In the  _j_ -th (  1 ≤ _j_ ≤ _m_ )<br>day, he will read the book that is numbered with integer  _b_ _j_ (  1 ≤ _b_<br>_j_ ≤ _n_ ). To read the book, he has to use the process described in the<br>paragraph above. It is possible that he decides to re-read the same book<br>several times.</p>
<p>After making this plan, he realized that the total weight of books he should<br>lift  during  _m_ days would be too heavy. So, he decided to change the order<br>of the stacked books before the New Year comes, and minimize the total weight.<br>You may assume that books can be stacked in any possible order. Note that book<br>that he is going to read on certain step isn’t considered as  lifted  on that<br>step. Can you help him?</p>
<p>Input</p>
<p>The first line contains two space-separated integers  _n_ (  2 ≤ _n_ ≤ 500  )<br>and  _m_ (  1 ≤ _m_ ≤ 1000  ) — the number of books, and the number of days<br>for which Jaehyun would read books.</p>
<p>The second line contains  _n_ space-separated integers  _w_ 1  , _w_ 2  , …,<br>_w_ _n_ (  1 ≤ _w_ _i_ ≤ 100  ) — the weight of each book.</p>
<p>The third line contains  _m_ space separated integers  _b_ 1  , _b_ 2  , …,<br>_b_ _m_ (  1 ≤ _b_ _j_ ≤ _n_ ) — the order of books that he would read. Note<br>that he can read the same book more than once.</p>
<p>Output</p>
<p>Print the minimum total weight of books he should  lift  , which can be<br>achieved by rearranging the order of stacked books.</p>
<p>Sample test(s)</p>
<p>Input</p>
<pre><code>3 5
1 2 3
1 3 2 3 1
</code></pre><p>Output</p>
<pre><code>12
</code></pre><p>Note</p>
<p>Here’s a picture depicting the example. Each vertical column presents the<br>stacked books.</p>
<p><img src="http://espresso.codeforces.com/e0d6b73c8901945918e014ebece081e75529eb5c.png" alt=""></p>
<p>贪心后模拟。</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt;
#include&lt;malloc.h&gt;

using namespace std;

int n, m;
int p[510];
int q[1010], qq[1010];
int vis[1010];

int main()
{
    while (cin &gt;&gt; n &gt;&gt; m)
    {
        for (int i = 1; i &lt;= n; i++)
        {
            cin &gt;&gt; p[i];
        }

        memset(vis,0,sizeof(vis));

        int pos = 1;
        for (int i = 1; i &lt;= m; i++)
        {
            int jjq;
            cin &gt;&gt; jjq;
            q[i] = jjq;
            if (!vis[jjq])
            {
                qq[pos++] = jjq;
                vis[jjq] = 1;
            }
        }

        long long ans = 0;
        for (int i = 1; i &lt;= m; i++)
        {
            int tt = q[i];
            for (int j = 1; j &lt;= n; j++)
            {
                if (qq[j] != tt)
                {
                    ans += p[qq[j]];
                }
                else 
                {
                    for (int k = j; k &gt; 1 ; k--)
                    {
                        qq[k] = qq[k-1];
                    }
                    qq[1] = tt;
                    break;
                }
            }
        }

        cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
  </div>
  <div class="post-footer">
    <br>
    
      <ul class="post-categories-list"><li class="post-categories-list-item"><a class="post-categories-list-link" href="/categories/CSDN备份/">CSDN备份</a></li></ul>
    

    <a href="#top" class="top" style="color:#E00000;">返回顶部</a>
    <br>
  </div>
</article>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?d10cb6eccb01550fa2e97b1d8908b2f6";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<footer>
  &copy; 2022
  <span class="author">
    mfcheer
  </span>
</footer>


    </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  </body>
</html>
			      <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
			      <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
			      <script src="/js/md5.min.js"></script>
			      <div id="gitalk-container" style="position:absolute;width:60%;left:0;right:0;margin:auto">
			      </div>
			      <script>
		      if(location.pathname == '/' || location.pathname.indexOf("categories") != -1 || location.pathname == '/archives/' ||  location.pathname == '/feed/')  {} 
		      else if (location.pathname.indexOf("about") != -1) { 
			            var gitalk = new Gitalk({
					            clientID: 'ae1d662690808720bf41',
					            clientSecret: 'c4d4d901a6fca52d5172519420dda00f8a2d9693',
					            repo: 'mfcheer.github.io',
					            owner: 'mfcheer',
					            admin: 'mfcheer',
					            id: md5(location.pathname),
					            distractionFreeMode: false
					          });
			            
			            gitalk.render('gitalk-container');
			          }
		      </script>
			      