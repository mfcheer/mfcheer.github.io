<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Apache Kylin</title>
    <url>/article/ApacheKylin.html</url>
    <content><![CDATA[<h1><span id="apache-kylin">Apache Kylin</span></h1><hr>
<p><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/4.png" alt=""></p>
<p>Kylin官方文档：<a href="http://kylin.apache.org/cn/" target="_blank" rel="noopener">http://kylin.apache.org/cn/</a></p>
<p>Apache Kylin是一个开源的分布式分析引擎，提供Hadoop之上的SQL查询接口及多维分析（OLAP）能力以支持超大规模数据，最初由eBay Inc. 开发并贡献至开源社区。它能在亚秒内查询巨大的Hive表。</p>
<a id="more"></a>
<h2><span id="cube维度">cube维度</span></h2><p>Kyliin是个预查询系统，将查询结果(Cube)存储在自己的存储系统(Hbase)中，但其中有很多结果是我们不需要的。这些不需要的我们可以做维度优化来去掉。</p>
<p>Cube所占用的存储空间和维度数、维度值之间不同的组合数、度量，有关。</p>
<p>Cube中有4种维度分别是：</p>
<p>  1.普通维度(General dimension)，普通维度是不做任何优化的维度。n个普通的cuboid的数量为2^n</p>
<p>  2.强制维度(Mandatory Dimensions)，强制维度是所有cuboid中必有的维度。强制维度可以使cuboid减少一半。</p>
<p>  3.层级维度(Hierarchy Dimensions)，层级维度是有层次关系的维度，使得cuboid中低层次的维度总是伴随着高层次维度的出现。一个有n个层次的层次维度可以使cuboid的数量从2^n 降到n+1。</p>
<p>  4.组合维度(Joint Dimensions)，组合维度是将几个维度组合成一个维度，使得这几个维度在cuboid中总是同时出现，适合总是出现在一起的维度。一个有n个维度的组合维度可以使cuboid数量从2^n 降到2</p>
<h2><span id="注意事项">注意事项</span></h2><p>当我们的度量中有count distinct 类型的时候, 我们在构建cube的时候需要编辑配置，点击Edit(Json),然后在配置中加上:</p>
<pre><code>&quot;dictionaries&quot;: [ 
  { 
    &quot;column&quot;: &quot;colname&quot;, 
    &quot;reuse&quot;: &quot;colname&quot;, 
    &quot;builder&quot;: &quot;org.apache.kylin.dict.GlobalDictionaryBuilder&quot;
  } 
],
</code></pre><p>度量sum类型必选是数字类型，不能是字符串类型，如果是字符串类型需要先在hive中将其修改成数字类型</p>
<p>Kylin将空字符串认为是null</p>
<p>不同版本的Kylin对sql完善度不同，例如有些版本union all会出错。</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
  </entry>
  <entry>
    <title>DFA算法敏感词过滤</title>
    <url>/article/DFA%E7%AE%97%E6%B3%95%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4.html</url>
    <content><![CDATA[<p>DFA全称为：Deterministic Finite Automaton,即确定有穷自动机。其特征为：有一个有限状态集合和一些从一个状态通向另一个状态的边，每条边上标记有一个符号，其中一个状态是初态，某些状态是终态。但不同于不确定的有限自动机，DFA中不会有从同一状态出发的两条边标志有相同的符号。常常应用于敏感词过滤，具体的细节原理可以在网上搜到很多，这里就不具体说了。</p>
<p>下面给出简单的实现。</p>
<p>简单实现代码：</p>
<a id="more"></a>
<pre><code>import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;


public class DFA {

    public static Map&lt;String,String&gt; sensitiveWordsMap = new HashMap&lt;String, String&gt;();  

    public void addSensitiveWords(Set&lt;String&gt; wordSet){ 
        for (String word : wordSet) {  
            Map nowMap = sensitiveWordsMap;  
            for (int i = 0; i &lt; word.length(); i++) {  
                char keyChar = word.charAt(i);  
                Object nextMap = nowMap.get(keyChar);  
                if (nextMap != null) {
                    nowMap = (Map&lt;String,String&gt;) nextMap;  
                }else {  
                    Map&lt;String, String&gt; newMap = new HashMap&lt;String, String&gt;();  
                    newMap.put(&quot;isEnd&quot;, &quot;0&quot;);  
                    nowMap.put(keyChar, newMap);  
                    nowMap = newMap;  
                } 

                if (i == word.length() - 1) {  
                    nowMap.put(&quot;isEnd&quot;, &quot;1&quot;);  
                }
            }  
        }
    }

     public boolean isSensitiveWord(String word) {  
            Map nowMap = sensitiveWordsMap;

            for(int i=0;i&lt;word.length();i++){
                char keyChar = word.charAt(i);
                nowMap = (Map) nowMap.get(keyChar);
                if(nowMap == null)
                    return false;
                if(nowMap.get(&quot;isEnd&quot;).equals(&quot;1&quot;)){
                    return true;
                }
            }
            return false;
    }   

    public boolean isContainSensitiveWord(String txt){
        for(int i=0; i &lt; txt.length(); i++){
            String subTxt = txt.substring(i);
            if(isSensitiveWord(subTxt))
                return true;
        }
        return false;
    }

    public static void main(String[] args){
        Set&lt;String&gt; wordSet = new HashSet&lt;String&gt;();
        wordSet.add(&quot;赌博&quot;);
        wordSet.add(&quot;赌博赌博&quot;);
        wordSet.add(&quot;嫖娼&quot;);
        wordSet.add(&quot;毒品&quot;);
        wordSet.add(&quot;枪支&quot;);

        DFA dfa = new DFA();
        //添加敏感词
        dfa.addSensitiveWords(wordSet);
        System.out.println(sensitiveWordsMap.toString());

        //查询测试
        System.out.println(dfa.isContainSensitiveWord(&quot;赌博&quot;));
        System.out.println(dfa.isContainSensitiveWord(&quot;赌博赌&quot;));
        System.out.println(dfa.isContainSensitiveWord(&quot;博赌&quot;));
        System.out.println(dfa.isContainSensitiveWord(&quot;赌&amp;博&quot;));
        System.out.println(dfa.isContainSensitiveWord(&quot;赌博不许&quot;));
        System.out.println(dfa.isContainSensitiveWord(&quot;不许赌博&quot;));
        System.out.println(dfa.isContainSensitiveWord(&quot;&amp;赌博&amp;嫖娼&amp;毒品&amp;枪支&amp;&quot;));
     }
}
/*
{枪={支={isEnd=1}, isEnd=0}, 赌={isEnd=0, 博={isEnd=1, 赌={isEnd=0, 博={isEnd=1}}}}, 
嫖={isEnd=0, 娼={isEnd=1}}, 毒={品={isEnd=1}, isEnd=0}}
true
true
false
false
true
true
true
*/
</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>BloomFilter</title>
    <url>/article/BloomFilter.html</url>
    <content><![CDATA[<h1><span id="布隆过滤器">布隆过滤器</span></h1><h1><span id="适用范围">适用范围</span></h1><p>可以用来实现数据字典，进行数据的判重，或者集合求交集，网页URL的去重，垃圾邮件的判别，集合重复元素的判别，查询加速（比如基于key-value的存储系统）等。</p>
<h1><span id="原理">原理</span></h1><p>Bloom Filter是一种空间效率很高的随机概率数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。</p>
<p>原理：位数组+k个独立hash函数。将hash函数对应的值的位数组置1，查找时如果发现所有hash函数对应位都是1说明存在，很明显这个过程并不保证查找的结果是100%正确的。同时也不支持删除一个已经插入的关键字，因为该关键字对应的位会牵动到其他的关键字。</p>
<p>一个字节有8个比特位，位图就是利用比特位进行信息存储，节省资源开销的一种方式。这种方法可以用在大数据排序，查询，去重等操作中</p>
<h1><span id="位图">位图</span></h1><p>依赖下面三个元操作</p>
<pre><code>将第n位置为1
set_bit(char x,int n)
x |= 1&lt;&lt;n
将第n位置为0
clear_bit(char x,int n)
1 &amp;= ~(1&lt;&lt;n)
取第n位的值
get_bit(char x,int n)
1 &amp; (x&gt;&gt;n)
</code></pre><h1><span id="详细的介绍">详细的介绍</span></h1><p><a href="http://blog.csdn.net/dadoneo/article/details/6847481" target="_blank" rel="noopener">http://blog.csdn.net/dadoneo/article/details/6847481</a></p>
<h1><span id="java简单实现">Java简单实现</span></h1><a id="more"></a>
<pre><code>import java.util.*;

public class BloomFilter {

    int [] seeds;
    BitSet bitset;

    public BloomFilter(int bloomfiterSize,int [] seeds){
        this.seeds = seeds;
        this.bitset = new BitSet(bloomfiterSize);
    }

    void add(String s){
        for(int i=0;i&lt;seeds.length;i++){
            int pos = hashFunc(s, seeds[i]);
            bitset.set(pos, true);
        }
    }

    Boolean isContain(String s){
        for(int i=0;i&lt;seeds.length;i++){
            int pos = hashFunc(s, seeds[i]);
            if(bitset.get(pos) == false){
                return false;
            }
        }
        return true;
    }

    public static int hashFunc(String key, int hashCode){  
        int arraySize = 100000007;
        for(int i=0;i&lt;key.length();i++){        
            int letterValue = key.charAt(i) - 96;
            hashCode = ((hashCode &lt;&lt; 5) + letterValue) % arraySize;
        }  
        return Math.abs(hashCode); 
    }  

    public static void main(String[] args){
        int bloomfiterSize = (int) Math.pow(2, 32);
        int [] seeds = {1,3,5,7,9,11};

        BloomFilter bloomFilter = new BloomFilter(bloomfiterSize, seeds);

        String s1 = &quot;1234567&quot;;
        String s2 = &quot;12345678&quot;;

        bloomFilter.add(s1);
        System.out.println(bloomFilter.isContain(s1));
        System.out.println(bloomFilter.isContain(s2));
        bloomFilter.add(s2);
        System.out.println(bloomFilter.isContain(s2));
    }
}
/*
true
false
true
*/
</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>Docker：安装及入门</title>
    <url>/article/Docker%E5%AE%89%E8%A3%85%E5%8F%8A%E5%85%A5%E9%97%A8.html</url>
    <content><![CDATA[<h1><span id="基础概念">基础概念</span></h1><p>简单来说，<br>仓库是存储镜像的地方<br>镜像是一个包含配置和运行环境的文件系统<br>容器是镜像的一个实体，一个镜像可生成多个容器</p>
<h1><span id="下载安装">下载安装</span></h1><p>mac下docker下载及入门<br><a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="noopener">官网</a></p>
<p>下载dmg文件后按步骤安装<br>运行docker命令查看是否安装成功</p>
<pre><code>docker --version
Docker version 17.09.0-ce, build afdb6d4
</code></pre><p>docker执行pull的时候出现超时,改为使用国内的仓库</p>
<pre><code>echo &quot;DOCKER_OPTS=\&quot;\$DOCKER_OPTS --registry-mirror=http://f2d6cb40.m.daocloud.io\&quot;&quot; | sudo tee -a /etc/default/docker
</code></pre><h1><span id="实践">实践</span></h1><h2><span id="例子1">例子1</span></h2><p>helloworld<br>下载一个镜像</p>
<pre><code>docker pull hello-world
</code></pre><p>下载成功后查看镜像信息</p>
<pre><code>docker images hello-world
</code></pre><p><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/39.png" alt=""></p>
<a id="more"></a>
<p>制作一个容器</p>
<pre><code>docker run hello-world
</code></pre><p><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/40.png" alt=""><br>查看所有容器</p>
<pre><code>docker ps -a
</code></pre><p><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/41.png" alt=""></p>
<p>删除容器</p>
<pre><code>docker rm id
</code></pre><p><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/42.png" alt=""></p>
<h2><span id="例子2">例子2</span></h2><p>docker的web服务</p>
<pre><code>docker pull nginx
docker run -d -p 80:80 --name webserver nginx
</code></pre><p>访问80端口<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/43.png" alt=""><br>进入docker容器</p>
<pre><code>docker exec -it webserver bash
</code></pre><p>修改网页</p>
<pre><code>echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html
</code></pre><p><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/45.png" alt=""><br>再次访问80端口<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/44.png" alt=""><br>修改了容器的内容，查看不同，和svn类似</p>
<pre><code>docker diff webserver
</code></pre><p><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/46.png" alt=""></p>
<p>生成新的镜像</p>
<pre><code>docker commit --author &quot;mfcheer&quot; --message &quot;修改了默认网页&quot; webserver nginx:v2
</code></pre><p><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/47.png" alt=""><br>查看当前nginx镜像</p>
<pre><code>docker images nginx
</code></pre><p><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/48.png" alt=""><br>查看所有容器</p>
<pre><code>docker ps -a
</code></pre><p><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/49.png" alt=""></p>
]]></content>
      <categories>
        <category>容器</category>
      </categories>
  </entry>
  <entry>
    <title>Docker：基本命令</title>
    <url>/article/Docker%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4.html</url>
    <content><![CDATA[<pre><code>docker --help
查看所有命令
</code></pre><h1><span id="常用命令">常用命令</span></h1><pre><code>容器版本
docker --version
从仓库获取镜像
docker pull &lt;镜像名:tag&gt;
查看正在运行的容器
docker ps 
查看所有容器，包括退出的
docker ps -a
删除镜像
docker rmi &lt;镜像名&gt; 
删除容器
docker rm &lt;容器名orID&gt;
停止容器
docker stop &lt;容器名orID&gt;
启动容器
docker start &lt;容器名orID&gt;
杀死运行的容器
docker kill &lt;容器名orID&gt;
查看所有镜像
docker images
制作运行容器，-d是后台运行，-p是本地端口到容器端口的映射，
--name为容器起名字
docker run -d -p 80:80 --name &lt;容器名&gt; &lt;镜像名&gt;
进入容器bash界面
docker exec -it &lt;容器名&gt; bash
</code></pre><a id="more"></a>
<h1><span id="所有命令">所有命令</span></h1><pre><code>Usage:    docker COMMAND
Management Commands:
  checkpoint  Manage checkpoints
  config      Manage Docker configs
  container   Manage containers
  image       Manage images
  network     Manage networks
  node        Manage Swarm nodes
  plugin      Manage plugins
  secret      Manage Docker secrets
  service     Manage services
  stack       Manage Docker stacks
  swarm       Manage Swarm
  system      Manage Docker
  volume      Manage volumes
Commands:
  attach      Attach local standard input, output, and error streams to a running container
  build       Build an image from a Dockerfile
  commit      Create a new image from a container&#39;s changes
  cp          Copy files/folders between a container and the local filesystem
  create      Create a new container
  deploy      Deploy a new stack or update an existing stack
  diff        Inspect changes to files or directories on a container&#39;s filesystem
  events      Get real time events from the server
  exec        Run a command in a running container
  export      Export a container&#39;s filesystem as a tar archive
  history     Show the history of an image
  images      List images
  import      Import the contents from a tarball to create a filesystem image
  info        Display system-wide information
  inspect     Return low-level information on Docker objects
  kill        Kill one or more running containers
  load        Load an image from a tar archive or STDIN
  login       Log in to a Docker registry
  logout      Log out from a Docker registry
  logs        Fetch the logs of a container
  pause       Pause all processes within one or more containers
  port        List port mappings or a specific mapping for the container
  ps          List containers
  pull        Pull an image or a repository from a registry
  push        Push an image or a repository to a registry
  rename      Rename a container
  restart     Restart one or more containers
  rm          Remove one or more containers
  rmi         Remove one or more images
  run         Run a command in a new container
  save        Save one or more images to a tar archive (streamed to STDOUT by default)
  search      Search the Docker Hub for images
  start       Start one or more stopped containers
  stats       Display a live stream of container(s) resource usage statistics
  stop        Stop one or more running containers
  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE
  top         Display the running processes of a container
  unpause     Unpause all processes within one or more containers
  update      Update configuration of one or more containers
  version     Show the Docker version information
  wait        Block until one or more containers stop, then print their exit codes
</code></pre>]]></content>
      <categories>
        <category>容器</category>
      </categories>
  </entry>
  <entry>
    <title>Go-基准测试</title>
    <url>/article/Go-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95.html</url>
    <content><![CDATA[<a id="more"></a>
<h2><span id="go-test">go test</span></h2><p>Go语言拥有一套单元测试和性能测试系统，go test 命令，会自动读取源码目录下面名为 *_test.go 的文件，生成并运行测试用的可执行文件</p>
<ul>
<li>测试用例文件不会参与正常源码编译，不会被包含到可执行文件中</li>
<li>命名文件时需要让文件必须以_test结尾</li>
<li>每个测试用例函数需要以Test为前缀</li>
</ul>
<p>常用的参数：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token operator">-</span>v 显示测试的详细命令
<span class="token operator">-</span>run regexp 只运行 regexp 匹配的函数，例如 <span class="token operator">-</span>run<span class="token operator">=</span>Array 那么就执行包含有 Array 开头的函数
<span class="token operator">-</span>cover 开启测试覆盖率
<span class="token operator">-</span>bench regexp 执行相应的 benchmarks，例如 <span class="token operator">-</span>bench<span class="token operator">=</span><span class="token punctuation">.</span>；
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>单元测试源码<em>_test文件可以由多个测试用例组成，每个测试用例函数需要以Test为前缀，一般参数为 </em>testing.T</p>
<p>日志：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token operator">*</span>t testing<span class="token punctuation">.</span>T
t<span class="token punctuation">.</span>Log
t<span class="token punctuation">.</span>Logf
t<span class="token punctuation">.</span>Error
t<span class="token punctuation">.</span>Errorf
t<span class="token punctuation">.</span>Fatal
t<span class="token punctuation">.</span>Fatalf
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面是例子：<br>文件</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token string">"testing"</span>
<span class="token keyword">func</span> <span class="token function">TestA</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    t<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">TestAB</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    t<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"AB"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">TestC</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    t<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-go"><code class="language-go">执行：
<span class="token keyword">go</span> test <span class="token operator">-</span>v <span class="token operator">-</span>run TestA select_test<span class="token punctuation">.</span><span class="token keyword">go</span>
输出：
<span class="token operator">==</span><span class="token operator">=</span> RUN   TestA
<span class="token operator">--</span><span class="token operator">-</span> PASS<span class="token punctuation">:</span> <span class="token function">TestA</span> <span class="token punctuation">(</span><span class="token number">0.</span>00s<span class="token punctuation">)</span>
        select_test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">:</span> A
<span class="token operator">==</span><span class="token operator">=</span> RUN   TestAB
<span class="token operator">--</span><span class="token operator">-</span> PASS<span class="token punctuation">:</span> <span class="token function">TestAB</span> <span class="token punctuation">(</span><span class="token number">0.</span>00s<span class="token punctuation">)</span>
        select_test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">:</span> AB
PASS
ok          command<span class="token operator">-</span>line<span class="token operator">-</span>arguments        <span class="token number">0.</span>003s
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>TestA 和 TestAB 的测试用例都被执行，原因是-run跟随的测试用例的名称支持正则表达式，使用-run TestA$即可只执行 TestA 测试用例。</p>
<h2><span id="基准测试">基准测试</span></h2><p>go test包支持基准测试，区别是传入的参数改为 b *testing.B，函数名称为 Benchmark为前缀。默认执行go test时是不执行基准的，需要使用 -bench标时</p>
<ul>
<li>可以使用-cpu标识更改测试使用的GOMAXPROCS 值</li>
<li>如果函数耗时高，1s内不能准确测试性能的话， 可以使用-benchtime标识增加运行时间：go test -bench=. -benchtime=10s</li>
<li>执行测试次数过多的话，测试结果会受GC等影响，可以使用-count参数多次运行基准测试来解决，go test -count=10 </li>
<li>-run=none  表示过滤掉单元测试</li>
<li>-bench=.   表示的是运行所有的基准测试，. 表示全部</li>
<li>-benchmem:表示显示memory的指标</li>
<li>有些测试需要一定的启动和初始化时间，如果从 Benchmark() 函数开始计时会很大程度上影响测试结果的精准性。StopTimer() 可以停止这个计数过程，做一些耗时的操作，通过 StartTimer() 重新开始计时。ResetTimer() 可以重置计数器的数据</li>
</ul>
<p>b.N 标示函数需要执行的次数。b.N 从 1 开始，如果基准测试函数在1秒内就完成 (默认值)，则 b.N 增加，并再次运行基准测试函数。b.N 在近似这样的序列中不断增加；1, 2, 3, 5, 10, 20, 30, 50, 100 等等。 基准框架试图变得聪明，如果它看到当b.N较小而且测试很快就完成的时候，它将让序列增加地更快。</p>
<p>例子：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">BenchmarkFuncA</span><span class="token punctuation">(</span>b <span class="token operator">*</span>testing<span class="token punctuation">.</span>B<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        b<span class="token punctuation">.</span><span class="token function">ResetTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> n <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>N<span class="token punctuation">;</span> n<span class="token operator">++</span> <span class="token punctuation">{</span>
                <span class="token function">FuncA</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 运行 Fib 函数 N 次</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">go</span> test <span class="token operator">-</span>bench<span class="token operator">=</span>FuncA <span class="token operator">-</span>count<span class="token operator">=</span><span class="token number">10</span> <span class="token operator">-</span>benchtime<span class="token operator">=</span>10s <span class="token operator">-</span>cpu<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token operator">-</span>run<span class="token operator">=</span>none
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Git命令笔记</title>
    <url>/article/Git%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<h1><span id="连接github">连接GitHub</span></h1><pre><code>创建SSH Key，在用户主目录（~）下创建SSH Key: 
ssh-keygen -t rsa -C “youremail@example.com”
然后一路回车使用默认值即可。
执行完之后，我们可以找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的密钥对，id_rsa是私钥，id_rsa.pub是公钥。
登录GitHub，打开”Account settings”，找到”SSH Keys”页面，点击”Add SSH Key”，把id_rsa.pub文件中的内容粘贴过来。
</code></pre><a id="more"></a>
<h1><span id="创建版本库repository">创建版本库(Repository)</span></h1><pre><code>新建一个目录: mkdir my_dir &amp;&amp; cd my_dir
用 git init 把目录变成Git可以管理Repository
git clone: 克隆已有的远端仓库
git add filename 将文件添加到仓库
git commit -m “xxxxx” 告诉Git把文件提交到Repository 
git add 命令可以执行多次，添加多个文件到仓库 
git commit 命令中 -m 后面输入的是本次提交的说明，可以输入任意内容
版本修改
git status 命令查看Repository当前的状态
git diff filename 查看修改过的但还没提交的文件与已经commit到仓库中的区别
git log 查看从最近到最远的提交日志
</code></pre><h1><span id="分支">分支</span></h1><pre><code>git branch: 查看所有本地分支，带*的是当前分支。
git checkout –b dev: 以当前分支为基础，创建一个新的dev分支，并切换到dev.
git checkout ${br_name}: 切换到名为${br_name}的分支。
git branch -a: 查看所有分支，包括远端
git merge ${br_name}: 把分支${br_name}的最新内容合并到当前分支
</code></pre><h1><span id="工作区">工作区</span></h1><pre><code>工作区（Working Directory）和版本库（Repository）的区别 
工作区就是指的某个目录，例如上面的my_dir。
在my_dir中有一个隐藏目录.git，这个就是版本库。 
版本库中最重要的就是被称为stage（或者index）的暂存区，还有Git为我们自动创建的第一个分支master以及指向master的指针HEAD。
git add 命令就是把文件添加的暂存区
git commit 命令提交更改后，就是把暂存区的所有内容提交到当前分支
git checkout – filename 命令可以把文件在工作区的修改全部撤消掉，有两种情况： 
一种是filename文件修改后还没添加到暂存区，撤消修改之后就和版本库一样。
一种是filename文件修改后添加到暂存区，撤消修改之后就回到添加到暂存区后的状态。
当在工作区把某个文件删除了之后，版本库中还存在，这时用git status 命令可以看到版本库中那些文件在工作区被删除了，这时有两种选择： 
一种是确实要删除某个文件，那么版本库中也应该相应删除，可以使用git rm filename 并且git commit -m “xxxx” 命令在版本库中删除。
另一种是删错了，那么可以使用git checkout – filename 命令把工作区误删的文件恢复到最新版。
</code></pre><h1><span id="远程仓库">远程仓库</span></h1><pre><code>git remote add origin git@github.com:xxxx/xxxx.git 命令将本地仓库与GitHub仓库关联。 
执行之后，远程库的名字就是origin。
git pull 把远程仓库的东西pull到本地
git push -u origin master 命令把本地库中的所有内容推送到远程库中。 
git push 命令就是把当前分支master推送到远程
由于一开始远程库是空的，-u参数不仅能够将本地master分支内容推送到远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送和拉取时就可以简化命令。
之后就可以用git push origin master 命令了。
注意可以用git push -f命令来强制推送。
git clone git@github.com:xxxx/xxxx.git 命令从远程库中克隆一个到本地仓库
git fetch [origin] [br_name]: 从远端仓库origin拉取分支br_name的最新代码到本地。用于更新本地代码。
git pull = git fetch + git merge
</code></pre><h1><span id="缓存回滚">缓存回滚</span></h1><pre><code>git stash: 把当前分支上的修改缓存起来，得到一个干净的working directory。缓存是独立于分支的，可以在任何分支git stash pop恢复最近的被缓存起来的修改。
git reset: 对于未push到远端的修改，优先使用这个。
git revert: 对于push到远端的修改。
</code></pre><h1><span id="常见错误">常见错误</span></h1><pre><code>error: failed to push some refs to ...
出现错误的主要原因是github中的README.md文件不在本地代码目录中
可以通过如下命令进行代码合并【注：pull=fetch+merge]
git pull --rebase origin master
</code></pre><pre><code>提交代码成功后并不显示绿格子
原因是本地Git的配置邮箱和github上面的邮箱不一致。
git config --global user.name &quot;youname&quot;
git config --global user.email &quot;youeamil@email.com&quot;
</code></pre>]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>HDFS基本命令</title>
    <url>/article/HDFS%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4.html</url>
    <content><![CDATA[<p>基本格式</p>
<pre><code>hadoop fs -cmd &lt; args &gt;
</code></pre><p>ls命令，列出目录下的目录和文件</p>
<pre><code>hadoop fs -ls  /
</code></pre><p>get命令，拷贝文件或目录到本地</p>
<pre><code>hadoop fs -get &lt; hdfs file &gt; &lt; local file or dir&gt;
</code></pre><p>put</p>
<pre><code>hadoop fs -put &lt; local file &gt; &lt; hdfs file &gt;
</code></pre><p>copyFromLocal</p>
<pre><code>hadoop fs -copyFromLocal  &lt; local src &gt; ... &lt; hdfs dst &gt;
</code></pre><p>moveFromLocal</p>
<pre><code>hadoop fs -moveFromLocal  &lt; local src &gt; ... &lt; hdfs dst &gt;
</code></pre><a id="more"></a>
<p>rm命令，删除多个文件或目录</p>
<pre><code>hadoop fs -rm &lt; hdfs file &gt;
hadoop fs -rm -r &lt; hdfs dir&gt;
</code></pre><p>cp</p>
<pre><code>hadoop fs -cp  &lt; hdfs file &gt;  &lt; hdfs file &gt;
</code></pre><p>mv</p>
<pre><code>hadoop fs -mv &lt; hdfs file &gt;  &lt; hdfs file &gt;
</code></pre><p>du 显示hdfs对应路径下每个文件夹和文件的大小</p>
<pre><code>hadoop fs -du &lt; hdsf path&gt; 
hadoop fs -du -s &lt; hdsf path&gt; 
hadoop fs -du - h &lt; hdsf path&gt; 
</code></pre><p>mkdir</p>
<pre><code>hadoop fs -mkdir &lt; hdfs path&gt;
</code></pre>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo搭建博客</title>
    <url>/article/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2.html</url>
    <content><![CDATA[<p>hexo建站步骤：<a href="http://www.jianshu.com/p/e99ed60390a8" target="_blank" rel="noopener">http://www.jianshu.com/p/e99ed60390a8</a></p>
<p>每次部署的步骤，可按以下三步来进行。</p>
<pre><code>hexo clean
hexo generate
hexo deploy
</code></pre><p>常用命令：</p>
<pre><code>hexo new &quot;postName&quot; #新建文章
hexo new page &quot;pageName&quot; #新建页面
hexo generate #生成静态页面至public目录
hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）
hexo deploy #将.deploy目录部署到GitHub
hexo help  #查看帮助
hexo version  #查看Hexo的版本
</code></pre><a id="more"></a>
<p>文章在 source/_posts，编辑器可以用 Sublime，支持 markdown 语法。如果想修改头像可以直接在主题的 _config.yml 文件里面修改，友情链接，之类的都在这里，修改名字在 public/index.html 里修改</p>
<p>文章链接设置，避免出现中文：</p>
<pre><code>_config.yml中添加：
permalink: :year:month:day-:urlname.html
permalink_defaults: 
  urlname: index
文章中添加：
urlname: hexo_permalink
</code></pre><p>换电脑时，只需要拷贝下面几个文件：</p>
<pre><code>_config.yml
 package.json
 scaffolds/
 source/
 themes/
</code></pre><p>Markdown使用方法：<a href="http://www.appinn.com/markdown/#p" target="_blank" rel="noopener">http://www.appinn.com/markdown/#p</a></p>
<p>MarkDowm常用</p>
<pre><code>图片：![](https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/19.png)
链接：[链接](https://www.xxx.com)
</code></pre><p>添加disqus评论</p>
<pre><code>1、注册https://disqus.com
2、根目录下的config.yml, 添加disqus_shortname: your_disqus_short_name
</code></pre><p>添加访问统计<br><a href="http://www.jianshu.com/p/8a8f880f40c0" target="_blank" rel="noopener">链接</a></p>
<p>Hexo备份<br><a href="https://github.com/coneycode/hexo-git-backup" target="_blank" rel="noopener">https://github.com/coneycode/hexo-git-backup</a></p>
<p><a href="https://gitee.com/sjclub/hexo-search-plugin" target="_blank" rel="noopener">添加搜索功能</a></p>
<p><a href="https://cndrew.cn/2020/03/03/calender/" target="_blank" rel="noopener">文章日历</a></p>
<p><a href="https://artitalk.js.org/doc.html#%F0%9F%95%B8-jsdelivr" target="_blank" rel="noopener">说说</a></p>
<p>douban需要的node版本v10.14.2</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>Go-并发基础组件</title>
    <url>/article/Go-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6.html</url>
    <content><![CDATA[<a id="more"></a>
<h2><span id="go语言的csp模型">Go语言的CSP模型</span></h2><p>CSP 是 Communicating Sequential Process 的简称，中文可以叫做通信顺序进程，是一种并发编程模型。<br>Go 通过 channel 实现 CSP 通信模型，主要用于 goroutine 之间的消息传递和事件通知。</p>
<h2><span id="goroutine">goroutine</span></h2><p>goroutine上下文切换的耗时，相较于Linux线程上下文之间切换 降低90%(1.46us-&gt;0.225us)，且消耗的内存少，8G内存即可创建百万级别的协程</p>
<h3><span id="并发中的闭包">并发中的闭包</span></h3><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    runtime<span class="token punctuation">.</span><span class="token function">GOMAXPROCS</span><span class="token punctuation">(</span>runtime<span class="token punctuation">.</span><span class="token function">NumCPU</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
        wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
            wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果：5 5 5 5 5<br>为什么呢？ for循环内每次都会调用一个goroutine，但是调用的goroutine启动的速度远比循环要慢，可以把i认为处于主函数的goroutine中。因此当循环中的goroutine开始执行的时候，i的值已经被赋为5，所以打印的值都是共享的i也就是5</p>
<p>解决：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
        wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
            wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="sync包">sync包</span></h2><h3><span id="waitgroup">WaitGroup</span></h3><h3><span id="互斥锁与读写锁">互斥锁与读写锁</span></h3><ul>
<li>sync.Mutex互斥锁</li>
<li>sync.RWMutex读写锁</li>
</ul>
<p>将程序对资源的访问分为读操作和写操作，这样它的效率就比Mutex要高些。<br>1、当有人还在占用写锁时，不允计有人读数据<br>2、多个人（线程）读取数据（拥有读锁）时，互不影响不会造成阻塞</p>
<p>RWMutex 里提供了两种锁：<br>读锁：调用 RLock 方法开启锁，调用 RUnlock 释放锁<br>写锁：调用 Lock 方法开启锁，调用 Unlock 释放锁（和 Mutex类似）</p>
<p>例子：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"sync"</span>
    <span class="token string">"time"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    lock <span class="token operator">:=</span> <span class="token operator">&amp;</span>sync<span class="token punctuation">.</span>RWMutex<span class="token punctuation">{</span><span class="token punctuation">}</span>
    lock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
        <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"第 %d 个协程准备开始... \n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
            lock<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"第 %d 个协程获得读锁, sleep 1s 后，释放锁\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
            time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
            lock<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>

    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"准备释放写锁，读锁不再阻塞"</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 写锁一释放，读锁就自由了</span>
    lock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">// 由于会等到读锁全部释放，才能获得写锁</span>
    <span class="token comment" spellcheck="true">// 因为这里一定会在上面 4 个协程全部完成才能往下走</span>
    lock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"程序退出..."</span><span class="token punctuation">)</span>
    lock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/*
第 1 个协程准备开始... 
第 0 个协程准备开始... 
第 3 个协程准备开始... 
第 2 个协程准备开始... 
准备释放写锁，读锁不再阻塞
第 2 个协程获得读锁, sleep 1s 后，释放锁
第 3 个协程获得读锁, sleep 1s 后，释放锁
第 1 个协程获得读锁, sleep 1s 后，释放锁
第 0 个协程获得读锁, sleep 1s 后，释放锁
程序退出...
*/</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="cond">cond</span></h3><p>用途：goroutine 的集合点，或等待或发布一个event。一个cond 是&gt;=2个goroutine之间的任意信号。当条件还没有达成的时候，后续的 goroutine 都会被阻塞。一旦条件达成，被阻塞的 goroutine 会被唤醒。</p>
<p>Cond 的初始化需要传入一个 Locker 接口的实例（通常传入 Mutex 和 RWMutex）如：c := sync.NewCond(&amp;sync.Mutex{})</p>
<p>Wait、Signal 和 Broadcast</p>
<p>调用Wait方法的 goroutine 会被放到 Cond 的等待队列中并阻塞，直到被 Signal 或者 Broadcast 方法唤醒。调用 Wait 方法的时候一定要持有锁 c.L 。c.Wait 并不会阻塞，只是挂起了当前的 goroutine，并允许其他goroutine继续在os上运行<br>Signal 和 Broadcast两种方式发送信号给其他的goroutine，Signal 是唤醒其中一个，Broadcast唤醒全部</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main
<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"sync"</span>
    <span class="token string">"time"</span>
<span class="token punctuation">)</span>

<span class="token keyword">var</span> m sync<span class="token punctuation">.</span>Mutex
<span class="token keyword">var</span> c <span class="token operator">=</span> sync<span class="token punctuation">.</span><span class="token function">NewCond</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span>
<span class="token keyword">var</span> n <span class="token operator">=</span> <span class="token number">5</span>

<span class="token keyword">func</span> <span class="token function">syncCondtest</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">,</span> running <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    c<span class="token punctuation">.</span>L<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"goroutine:%d wait\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
    running <span class="token operator">&lt;-</span> i
    c<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    c<span class="token punctuation">.</span>L<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"goroutine:%d quit \n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    running <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
        <span class="token keyword">go</span> <span class="token function">syncCondtest</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> running<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">//wait all goroutine running if no goroutine running c.Signal do nothing</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
        <span class="token operator">&lt;-</span>running
    <span class="token punctuation">}</span>

    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"one goroutine runnningn"</span><span class="token punctuation">)</span>
    c<span class="token punctuation">.</span><span class="token function">Signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>

    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"all goroutine runnningn"</span><span class="token punctuation">)</span>
    c<span class="token punctuation">.</span><span class="token function">Broadcast</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">/*
goroutine:4 wait
goroutine:1 wait
goroutine:0 wait
goroutine:2 wait
goroutine:3 wait
one goroutine runnningn
goroutine:4 quit 
all goroutine runnningn
goroutine:1 quit 
goroutine:3 quit 
goroutine:2 quit 
goroutine:0 quit
*/</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3><span id="once">once</span></h3><p>sync.Once</p>
<p>var one sync.Once<br>one.Do(xxx)保证传入的xxx只会调用一次，one再次使用是无效的，因为one保证的是Do方法只被调用一次</p>
<h3><span id="syncpool池">sync.Pool池</span></h3><p>池是用来做缓存进行 存取 对象的池子，较少GC带来的损耗，避免重复的创建、销毁<br>通过Get方法获取对象，Put方法存入对象</p>
<p>初始化 Pool时，需要设置好 New 函数。当调用 Get 方法时，如果池子里缓存了对象，就直接返回缓存的对象。如果没有存货，则调用 New 函数创建一个新的对象。</p>
<p>下面的例子：</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"sync"</span>
<span class="token punctuation">)</span>

<span class="token keyword">var</span> pool <span class="token operator">*</span>sync<span class="token punctuation">.</span>Pool

<span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Name <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">initPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pool <span class="token operator">=</span> <span class="token operator">&amp;</span>sync<span class="token punctuation">.</span>Pool <span class="token punctuation">{</span>
        New<span class="token punctuation">:</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>
            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Creating a new Person"</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token operator">&amp;</span>Person<span class="token punctuation">{</span>Name<span class="token punctuation">:</span> <span class="token string">"None"</span><span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">initPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    p <span class="token operator">:=</span> pool<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>Person<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// A</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"首次从 pool 里获取："</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span>

    p<span class="token punctuation">.</span>Name <span class="token operator">=</span> <span class="token string">"first"</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"设置 p.Name = %s\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span>Name<span class="token punctuation">)</span>

    pool<span class="token punctuation">.</span><span class="token function">Put</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>

    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Pool 里已有一个对象，调用 Get: "</span><span class="token punctuation">,</span> pool<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>Person<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// B</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Pool 没有对象了，调用 Get: "</span><span class="token punctuation">,</span> pool<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>Person<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// C</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/*
Creating a new Person
首次从 pool 里获取： &amp;{None}
设置 p.Name = first
Pool 里已有一个对象，调用 Get:  &amp;{first}
Creating a new Person
Pool 没有对象了，调用 Get:  &amp;{None}

运行结束，执行耗时：1毫秒
*/</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>A、C处获取对象时，池中已为空，所以获取到的是New的新对象</p>
<h2><span id="channel">channel</span></h2><p>充当goroutine之间通信的管道</p>
<p>channel 是阻塞的，当从空的channel读取数据时如果 channel为空，则会等待有数据写入channel<br>下面的例子：main的goroutine并不会退出导致而创建的匿名goroutine无法写入内容，反而会阻塞等待写入</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main
<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    stringStream <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span>
    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        stringStream <span class="token operator">&lt;-</span> <span class="token string">"hello"</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

     fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>stringStream<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="select语句">select语句</span></h2><p>当select 的 case中多个channel 可用时，Go会随机选取其中一个进行读取<br>如果没有channel可用，我们可以选取超时机制避免阻塞</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">var</span> c <span class="token operator">&lt;-</span> <span class="token keyword">chan</span> <span class="token builtin">int</span>
<span class="token keyword">select</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>c<span class="token punctuation">:</span> xxx
    <span class="token keyword">case</span> time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">:</span> xxx
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>或者使用default</p>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">var</span> c <span class="token operator">&lt;-</span> <span class="token keyword">chan</span> <span class="token builtin">int</span>
<span class="token keyword">select</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>c<span class="token punctuation">:</span> xxx
    <span class="token keyword">default</span><span class="token punctuation">:</span> xxx
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="gomaxprocs控制">GOMAXPROCS控制</span></h2><p>runtime的GOMAXPROCS函数，控制使用的CPU核数。<br><a href="https://zhuanlan.zhihu.com/p/111346689" target="_blank" rel="noopener">Go 为什么这么“快”</a>  中讲解了Go的GPM模型</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Java：hashcode和equals</title>
    <url>/article/Hashcode%E5%92%8CEquals.html</url>
    <content><![CDATA[<p>两个类哈希值相等，不一定equals值相等，因为两个类可能发生哈希冲突，导致哈希的位置是一样的</p>
<p>如果两个类equals值相等，哈希值一定是一样的</p>
<p>如果两个类相等，那么哈希值和equals值都相等，也可以通过“=”进行判断<br><a id="more"></a><br>equals只能用来判断两个类的内容是否相同</p>
<p>哈希的作用是为了加快查找速度，通过计算哈希值的方法减少遍历的时间消耗，但是不同的对象的哈希值也可能是相同的，这就发生了哈希冲突，需要进行处理，拉链法、再哈希等</p>
<p>例如hashset，在检查元素是否存在时，通过判断元素的哈希值是否已经存在，如果没有，可以直接将元素放入set，否则再对元素进行equals值得比较，因为哈希冲突是可能的</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Https与Http区别</title>
    <url>/article/Https%E4%B8%8EHttp%E5%8C%BA%E5%88%AB.html</url>
    <content><![CDATA[<h1><span id="概述">概述</span></h1><p>HTTP协议以明文方式发送内容，不提供任何方式的数据加密。HTTP + TLS/SSL = HTTPS，是以安全为目标的HTTP通道。TLS (Transport Layer Security)是传输层加密协议，它的前身是 SSL 协议。</p>
<h1><span id="tls-协议如何保证安全">TLS 协议如何保证安全</span></h1><pre><code>1，    内容加密。
2，    身份认证。
3，    数据完整性。
</code></pre><h1><span id="tls加密方式">TLS加密方式</span></h1><ul>
<li>对称加密<br>加密强度较高<br>无法安全的保管密钥<br>常见算法:DES、3DES、Blowfish、<br>IDEA、RC4、RC5、RC6和AES</li>
<li>非对称加密<br>比对称加密更安全<br>CPU消耗大<br>加密长度有限制，不可超过公钥长度<br>常见算法:  RSA / ECDHE / DH / DHE</li>
</ul>
<a id="more"></a>
<h1><span id="https的优点">HTTPS的优点</span></h1><ul>
<li>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li>
<li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li>
<li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li>
</ul>
<h1><span id="https的缺点">HTTPS的缺点</span></h1><ul>
<li>HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</li>
<li>HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</li>
<li>SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</li>
<li>SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</li>
<li>HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>Hive数据仓库</title>
    <url>/article/Hive%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93.html</url>
    <content><![CDATA[<p>Hive是Hadoop中一个类SQL的数据仓库。支持查询操作。</p>
<h1><span id="hive-shell">Hive Shell</span></h1><p>hive -f file 命令可以运行脚本文件<br>hive -e “sql” 命令可以运行语句</p>
<h2><span id="创建表">创建表</span></h2><h3><span id="内部表">内部表</span></h3><p>create table test(r1 string, r2 string) ;<br>创建一个内部表时，hive会在hdfs上创建一个相应的表目录，该表目录位于hive配置文件中参数 ${hive.metastore.warehouse.dir}  指定的数据仓库目录下，所有的表数据（不包括外部表数据）都保存在这个目录中。如该参数默认值是 /user/hive/warehouse，则创建test表会创建hdfs目录/user/hive/warehouse/test</p>
<h3><span id="外部表">外部表</span></h3><p>external 关键字可以让用户创建一个外部表，在建表的同时需要指定一个location，为已存在的hdfs目录。与Hive 创建内部表时会在hdfs上创建数据仓库表目录不同，创建外部表时不会创建表目录，而是直接使用指定的location作为表目录。这种方式下，在删除表的时候，只删除元数据，不删除实际数据。而内部表删除表时将所有数据均删除。此外，创建外部表的同时可以指定分隔符。</p>
<pre><code>CREATE EXTERNAL TABLE `test`(
 `r1` string, 
 `r2` string, 
 `r3` string, 
 `r4` string, 
 `r5` string)
PARTITIONED BY ( 
 `dt` string)
ROW FORMAT DELIMITED 
 FIELDS TERMINATED BY &#39;\t&#39;
 LINES TERMINATED BY &#39;\n&#39; 
LOCATION
 &#39;/home/work/mfcheer/test&#39;;
</code></pre><h1><span id="与传统数据库相比">与传统数据库相比</span></h1><p>不支持更新和删除操作</p>
<h2><span id="分区">分区</span></h2><p>通过分区可以增加数据分片的查询速度</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
  </entry>
  <entry>
    <title>Hadoop初识</title>
    <url>/article/Hadoop%E5%88%9D%E8%AF%86.html</url>
    <content><![CDATA[<h1><span id="hadoop核心">Hadoop核心</span></h1><p>Hadoop的核心是HDFS和MapReduce。Hadoop旗下有很多经典子项目，比如HBase、Hive等，这些都是基于HDFS和MapReduce发展出来的。要想了解Hadoop，就必须知道HDFS和MapReduce是什么。</p>
<h1><span id="hdfs">HDFS</span></h1><p>HDFS（Hadoop Distributed File System，Hadoop分布式文件系统），能提供高吞吐量的数据访问。<br>HDFS的设计特点是：<br>1、大数据文件，非常适合上T级别的大文件或者一堆大数据文件的存储，如果文件只有几个G甚至更小就没啥意思了。</p>
<p>2、文件分块存储，HDFS会将一个完整的大文件平均分块存储到不同计算器上，它的意义在于读取文件时可以同时从多个主机取不同区块的文件，多主机读取比单主机读取效率要高得多得都。</p>
<p>3、流式数据访问，一次写入多次读写，这种模式跟传统文件不同，它不支持动态改变文件内容，而是要求让文件一次写入就不做变化，要变化也只能在文件末添加内容。</p>
<p>4、廉价硬件，HDFS可以应用在普通PC机上，这种机制能够让给一些公司用几十台廉价的计算机就可以撑起一个大数据集群。</p>
<p>5、硬件故障，HDFS认为所有计算机都可能会出问题，为了防止某个主机失效读取不到该主机的块文件，它将同一个文件块副本分配到其它某几个主机上，如果其中一台主机失效，可以迅速找另一块副本取文件。<br><a id="more"></a></p>
<h2><span id="hdfs的关键元素">HDFS的关键元素</span></h2><pre><code>Block：将一个文件进行分块，通常是64M。
NameNode：保存整个文件系统的目录信息、文件信息及分块信息，这是由唯一一台主机专门保存，当然这台主机如果出错，NameNode就失效了。在Hadoop2.*开始支持activity-standy模式----如果主NameNode失效，启动备用主机运行NameNode。
DataNode：分布在廉价的计算机上，用于存储Block块文件。
</code></pre><h1><span id="mapreduce">MapReduce</span></h1><p>MapReduce是一套从海量源数据提取分析元素最后返回结果集的编程模型，将文件分布式存储到硬盘是第一步，而从海量数据中提取分析我们需要的内容就是MapReduce做的事。</p>
<p>MapReduce以某几个块为一个Map，计算出Map中的值，然后将每个Map中的值做Reduce操作，Reduce再取值给用户。</p>
<h1><span id="总结">总结</span></h1><p>Hadoop适合应用于大数据存储和大数据分析的应用，适合于服务器几千台到几万台的集群运行，支持PB级的存储容量。<br>Hadoop典型应用有：搜索、日志处理、推荐系统、数据分析、视频图像分析、数据保存等。</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
  </entry>
  <entry>
    <title>ITerm2</title>
    <url>/article/ITerm2.html</url>
    <content><![CDATA[<h1><span id="下载配色">下载配色</span></h1><p>打开iterm的官方主题配置站  github.com/mbadolato/iTerm2-Color-Schemes，将资源下载至本地,解压。</p>
<p>打开iTerm2，import导入配置。<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/17.png" alt=""><br><a id="more"></a></p>
<h1><span id="设置">设置</span></h1><p>vim ~/.bash_profile</p>
<p>添加以下代码</p>
<pre><code>black=$&#39;\[\e[1;30m\]&#39;
red=$&#39;\[\e[1;31m\]&#39;
green=$&#39;\[\e[1;32m\]&#39;
yellow=$&#39;\[\e[1;33m\]&#39;
blue=$&#39;\[\e[1;34m\]&#39;
magenta=$&#39;\[\e[1;35m\]&#39;
cyan=$&#39;\[\e[1;36m\]&#39;
white=$&#39;\[\e[1;37m\]&#39;
normal=$&#39;\[\e[m\]&#39;
PS1=&quot;$white[$white@$green\h$white:$cyan\W$yellow\$git_branch$white]\$ $normal&quot;
</code></pre><p>配置生效<br>source ~/.bash_profile</p>
<p>结束，然后就可以随意切换啦。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>Java：Hibernate笔记</title>
    <url>/article/Hibernate%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<p>Hibernate是一个开源，轻量级的ORM(对象关系映射)工具。<br>ORM工具简化了数据创建，数据处理和数据访问。它是将对象映射到数据库中存储的数据(表)的编程技术。</p>
<h1><span id="hibernate框架有很多优点">Hibernate框架有很多优点。</span></h1><p>开源和轻量级： Hibernate框架是根据LGPL许可证和轻量级的开源工具。</p>
<p>快速性能： Hibernate框架的性能很快，因为缓存在Hibernate框架内部使用。 </p>
<p>hibernate框架中有两种类型的缓存：一级缓存和二级缓存。一级缓存默认是启用的。<br>数据库独立查询： HQL(Hibernate查询语言)是面向对象的SQL版本。它生成数据库独立查询。 所以你不需要编写数据库特定的查询语句。</p>
<p>在Hibernate之前，如果项目更改了数据库，我们需要更改SQL查询，从而导致维护变得非常复杂。</p>
<p>自动创建表： Hibernate框架提供了自动创建数据库表的功能。 因此，无需手动在数据库中创建表。</p>
<p>简化复杂连接： 在hibernate框架中可轻松获取多个表中的数据。<br>提供查询统计和数据库状态： </p>
<p>Hibernate支持查询缓存，并提供有关查询和数据库状态的统计信息。<br><a id="more"></a></p>
<h1><span id="hibernate和mybatis">Hibernate和MyBatis</span></h1><p>Hibernate：Hibernate是当前最流行的ORM框架之一，对JDBC提供了较为完整的封装。Hibernate的O/R Mapping实现了POJO 和数据库表之间的映射，以及SQL的自动生成和执行。</p>
<p>Mybatis：Mybatis同样也是非常流行的ORM框架，主要着力点在于 POJO 与 SQL 之间的映射关系。然后通过映射配置文件，将SQL所需的参数，以及返回的结果字段映射到指定 POJO 。相对Hibernate“O/R”而言，Mybatis 是一种“Sql Mapping”的ORM实现。</p>
<p>区别：<br>Hibernate的DAO层开发比MyBatis简单，Mybatis需要维护SQL和结果映射。<br>Hibernate对对象的维护和缓存要比MyBatis好，对增删改查的对象的维护要方便。<br>Hibernate数据库移植性很好，MyBatis的数据库移植性不好，不同的数据库需要写不同SQL。<br>Hibernate有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳。<br>MyBatis可以进行更为细致的SQL优化，可以减少查询字段。<br>MyBatis容易掌握，而Hibernate门槛较高。</p>
<h1><span id="hibernate的get和load">Hibernate的get和load</span></h1><p>get和load的最大区别是，如果在缓存中没有找到相应的对象，get将会直接访问数据库并返回一个完全初始化好的对象，而这个过程有可能会涉及到多个数据库调用；而load方法在缓存中没有发现对象的情况下，只会返回一个代理对象，只有在对象getId()之外的其它方法被调用时才会真正去访问数据库，这样就能在某些情况下大幅度提高性能。</p>
<h1><span id="hibernate中的延迟加载">Hibernate中的延迟加载</span></h1><p>延迟加载机制是为了避免一些无谓的性能开销而提出来的，所谓延迟加载就是当在真正需要数据的时候，才真正执行数据加载操作。</p>
<p>在Hibernate中提供了对实体对象的延迟加载以及对集合的延迟加载，另外在Hibernate3中还提供了对属性的延迟加载。</p>
<p>Hibernate 的延迟加载（lazy load）本质上就是代理模式的应用，我们在过去的岁月里就经常通过代理模式来降低系统的内存开销、提升应用的运行性能。Hibernate 充分利用了代理模式的这种优势，并结合了 Javassist 或 CGLIB 来动态地生成代理对象，这更加增加了代理模式的灵活性。</p>
<h1><span id="hibernate中的查询方式">Hibernate中的查询方式</span></h1><p>SQL语句查询、Criteria、Hql</p>
<h1><span id="hibernate中的缓存">Hibernate中的缓存</span></h1><p>一级缓存：</p>
<p>hibernate支持两个级别的缓存，默认只支持一级缓存；<br>每个Session内部自带一个一级缓存；<br>某个Session被关闭时，其对应的一级缓存自动清除；<br>一级缓存实际上保存的是sql查询的结果，这样再进行相同的sql查询就可以之间从缓存中拿到结果了；</p>
<p>二级缓存：</p>
<p>是在SessionFactory这个级别维护的缓存；<br>针对整个应用而不是某个特定的Session，默认不开启；<br>可以指定Cache工具，如Ehcache（默认）、OSCache、JBossCache<br>原理：条件查询的时候，选择所有字段，一次获得所有的数据对象并根据id放入二级缓存。当Hibernate根据ID访问数据对象的时候，首先从Session一级缓存中查，查不到，如果配置了二级缓存，那么从二级缓存中查，查不到，再查询数据库，把结果按照ID放入到缓存。</p>
<p>查询缓存：</p>
<p>Hibernate的二级缓存策略，是针对于ID查询的缓存策略，对于条件查询则毫无作用。为此，Hibernate提供了针对条件查询的Query缓存。</p>
<p>Hibernate首先根据这些信息组成一个Query Key，Query Key包括条件查询的请求一般信息：SQL, SQL需要的参数，记录范围等。</p>
<p>Hibernate根据这个Query Key到Query缓存中查找对应的结果列表。如果存在，那么返回这个结果列表；如果不存在，查询数据库，获取结果列表，把整个结果列表根据Query Key放入到Query缓存中。</p>
<p>Query Key中的SQL涉及到一些表名，如果这些表的任何数据发生修改、删除、增加等操作，这些相关的Query Key都要从缓存中清空。</p>
<h1><span id="session和sessionfactory">Session和SessionFactory</span></h1><p>SessionFactory就是一个用于创建Hibernate的Session对象的工厂。SessionFactory通常是在应用启动时创建好的，应用程序中的代码用它来获得Session对象。作为一个单个的数据存储，它也是 线程安全的，所以多个线程可同时使用同一个SessionFactory。Java JEE应用一般只有一个SessionFactory，服务于客户请求的各线程都通过这个工厂来获得Hibernate的Session实例，这也是为什么SessionFactory接口的实现必须是线程安全的原因。还有，SessionFactory的内部状态包含着同对象关系影射有关的所有元数据，它是 不可变的，一旦创建好后就不能对其进行修改了。</p>
<p>Session代表着Hibernate所做的一小部分工作，它负责维护者同数据库的链接而且 不是线程安全的，也就是说，Hibernate中的Session不能在多个线程间进行共享。虽然Session会以主动滞后的方式获得数据库连接，但是Session最好还是在用完之后立即将其关闭。</p>
<h1><span id="hibernate中java对象的状态">Hibernate中Java对象的状态</span></h1><p>瞬时态(Transient)：不存在持久化标识OID，尚未与Hibernate Session关联对象，被认为处于瞬时态，失去引用将被JVM回收<br>持久态(Persistent)：存在持久化标识OID，与当前session有关联，并且相关联的session没有关闭 ,并且事务未提交<br>脱管态(Detached)：存在持久化标识OID，但没有与当前session关联，脱管状态改变hibernate不能检测到</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java并发程序(1)：基础</title>
    <url>/article/Java%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F(1)%EF%BC%9A%E5%9F%BA%E7%A1%80.html</url>
    <content><![CDATA[<h1><span id="线程中断interrupted">线程中断（interrupted）</span></h1><p>意义是通知线程，有人希望你退出啦！但是线程会如何处理，由线程自己决定。</p>
<pre><code>package Chapter02;

public class InterruptDemo {
    public static void main(String[] args) throws InterruptedException{
        Thread t1 = new Thread(){
            public void run(){
                while (true){
                    System.out.println(&quot;hello&quot;);
                }
            }
        };
        t1.start();
        t1.sleep(1000);
        t1.interrupt();
    }
}
不会发生任何中断
</code></pre><a id="more"></a>
<pre><code>package Chapter02;

public class InterruptDemo {
    public static void main(String[] args) throws InterruptedException{
        Thread t1 = new Thread(){
            public void run(){
                while (true){
                    System.out.println(&quot;hello&quot;);
                    if(Thread.currentThread().interrupted())
                        break;
                }
            }
        };
        t1.start();
        t1.sleep(1000);
        t1.interrupt();
    }
}
会发生中断
</code></pre><h1><span id="等待wait和通知notify">等待（wait）和通知（notify）</span></h1><p>wait和notify方法在Object类中。什么时候会等待呢，当线程A中调用了obj.wait()，A就会停止继续执行，何时结束呢？当其他线程调用了obj.notify()</p>
<pre><code>package Chapter02;

import java.security.PublicKey;

import org.omg.CORBA.PUBLIC_MEMBER;

public class wnDemo {
        final static Object object = new Object();
        public static class T1 extends Thread{
            public void run(){
                synchronized (object) {
                    System.out.println(&quot;T1 start&quot;);
                    try{
                        System.out.println(&quot;T1 wait start&quot;);
                        object.wait();
                    }catch(Exception e){
                        System.out.println(e);
                    }
                    System.out.println(&quot;T1 end&quot;);
                }
            }
        }
        public static class T2 extends Thread{
            public void run(){
                synchronized (object) {
                    System.out.println(&quot;T2 start&quot;);
                    try{
                        System.out.println(&quot;T2 notify start&quot;);
                        Thread.sleep(2000);
                        object.notify();
                        System.out.println(&quot;T2 end&quot;);
                    }catch(Exception e){
                        System.out.println(e);
                    }
                }
            }
        }

        public static void main(String[] args){

            Thread t1 = new T1();
            Thread t2 = new T2();

            t1.start();
            t2.start();
        }
}
/*
T1 start
T1 wait start
T2 start
T2 notify start
T2 end
T1 end
*/
</code></pre><h1><span id="挂起和继续执行">挂起和继续执行</span></h1><p>Thread类的方法。</p>
<h1><span id="等待线程结束join和谦让yield">等待线程结束（join）和谦让（yield）</span></h1><p>等待线程结束。等待run方法执行结束，再继续执行。</p>
<pre><code>package Chapter02;

public class joinDemo {
    private  static int i = 0;

    public static class AddThread extends Thread{
        public void run(){
            for(i=0;i&lt;100000000;i++){
                ;
            }
        }
    }

    public static void main(String[] args) throws InterruptedException{
        AddThread t1 = new AddThread();
        t1.start();
        t1.join();

        System.out.println(i);
    }
}
//100000000
</code></pre><p>Thread.yield()需要解释一下，它是对线程调度器的一种建议，它在声明：”我已经执行完生命周期中最重要的部分了，此刻可以切换给别的任务，让它们执行吧。”这仅仅是一种建议，线程调度器不一定会执行。当调用 yield()时，其实是在建议线程调度器去调度具有相同优先级的其他线程工作。</p>
<h1><span id="volatile与java内存模型jmm">volatile与Java内存模型（JMM）</span></h1><p>用volatile修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的最的值。volatile很容易被误用，用来进行原子性操作。</p>
<p>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。<br>2）禁止进行指令重排序。</p>
<h1><span id="线程组threadgroup">线程组（ThreadGroup）</span></h1><pre><code>package Chapter02;

public class ThreadGroupDemo implements Runnable{
    @Override
    public void run() {
        String groupName = Thread.currentThread().getThreadGroup().getName()
                + &quot;-&quot; + Thread.currentThread().getName();
        while(true){
            System.out.println(&quot;I am &quot; + groupName);
            try{
                Thread.sleep(2000);
            }catch(Exception e){
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args){
        ThreadGroup tg = new ThreadGroup(&quot;Group&quot;);
        Thread t1 = new Thread(tg, new ThreadGroupDemo(), &quot;T1&quot;); 
        Thread t2 = new Thread(tg, new ThreadGroupDemo(), &quot;T2&quot;); 
        t1.start();
        t2.start();
        System.out.println(tg.activeCount());
        tg.list();
    }
}
/*
2
I am Group-T1
I am Group-T2
java.lang.ThreadGroup[name=Group,maxpri=10]
    Thread[T1,5,Group]
    Thread[T2,5,Group]
I am Group-T2
I am Group-T1
I am Group-T2
I am Group-T1
I am Group-T1
I am Group-T2
*/
</code></pre><h1><span id="守护进程daemon">守护进程（Daemon）</span></h1><p>Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。<br>User和Daemon两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果 User Thread已经全部退出运行了，只剩下Daemon Thread存在了，虚拟机也就退出了。</p>
<pre><code>package Chapter02;

public class DaemonDemo{
    static class daemonDemo extends Thread{
        public void run(){
            while (true){
                System.out.println(&quot;i am alive&quot;);
                try{
                    Thread.sleep(1000);
                }catch(Exception e){
                    e.printStackTrace();
                }
            }
        }    
    }
    public static void main(String[] args) throws InterruptedException{
        Thread t = new daemonDemo();
        t.setDaemon(true);
        t.start();

        Thread.sleep(2000);
    }
}

</code></pre><h1><span id="线程优先级">线程优先级</span></h1><pre><code>package Chapter02;

public class PrirityDemo {
    public static class HighPri extends Thread{
        static int count = 0;
        public void run(){
            while (true){
                synchronized (PrirityDemo.class) {
                    count++;
                    if(count &gt; 10000000){
                        System.out.println(&quot;HighPri Thread end&quot;);
                        break;
                    }
                }
            }
        }
    }
    public static class LowPri extends Thread{
        static int count = 0;
        public void run(){
            while (true){
                synchronized (PrirityDemo.class) {
                    count++;
                    if(count &gt; 10000000){
                        System.out.println(&quot;LowPri Thread end&quot;);
                        break;
                    }
                }
            }
        }
    }
    public static void main(String[] args){
        Thread highThread = new HighPri();
        Thread lowThread = new LowPri();
        highThread.setPriority(Thread.MAX_PRIORITY);
        lowThread.setPriority(Thread.MIN_PRIORITY);
        lowThread.start();
        highThread.start();
    }
}
/*
大多数情况：
HighPri Thread end
LowPri Thread end
*/
</code></pre><h1><span id="线程安全与synchronized">线程安全与synchronized</span></h1><p>当synchronized用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。</p>
<h1><span id="程序中的幽灵隐蔽的错误">程序中的幽灵：隐蔽的错误</span></h1>]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java BIO/NIO/AIO</title>
    <url>/article/Java-BIO-NIO-AIO.html</url>
    <content><![CDATA[<h1><span id="三种io">三种IO</span></h1><h2><span id="java-bio">Java BIO</span></h2><p>同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理。</p>
<h2><span id="java-nio准备好了再通知我">Java NIO：准备好了再通知我</span></h2><p>同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。JDK1.4开始支持。</p>
<h2><span id="java-aionio2读完了再通知我">Java AIO(NIO.2)：读完了再通知我</span></h2><p>异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。JDK7开始支持。</p>
<h1><span id="关于nio">关于NIO</span></h1><ul>
<li>缓冲区Buffer</li>
</ul>
<p>Buffer是一个对象，包含一些要写入或者读出的数据。在NIO库中，所有数据都是用缓冲区处理的。缓冲区实际上是一个数组，并提供了对数据结构化访问以及维护读写位置等信息。具体的缓存区有这些：ByteBuffe、CharBuffer、 ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer。</p>
<ul>
<li>通道Channel</li>
</ul>
<p>我们对数据的读取和写入要通过Channel，它就像水管一样，是一个通道。通道不同于流的地方就是通道是双向的，可以用于读、写和同时读写操作。Channel主要分两大类，SelectableChannel用于网络读写，FileChannel用于文件操作。</p>
<ul>
<li>多路复用器Selector</li>
</ul>
<p>Selector可以不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作。一个Selector可以同时轮询多个Channel，因为JDK使用了epoll()代替传统的select实现，所以没有最大连接句柄1024/2048的限制。所以，只需要一个线程负责Selector的轮询，就可以接入成千上万的客户端。</p>
<h1><span id="适用场景分析">适用场景分析</span></h1><p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，但程序直观简单易理解。</p>
<p>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂。</p>
<p>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂。<br><a id="more"></a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java：垃圾回收</title>
    <url>/article/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html</url>
    <content><![CDATA[<h1><span id="哪些内存需要回收">哪些内存需要回收</span></h1><p>如果一个对象已经没有引用指向它了，那么就认为这个对象是一个垃圾对象，需要被回收掉，将内存空间释放给其它对象.</p>
<h2><span id="判断对象存活">判断对象存活</span></h2><ul>
<li><p>引用计数器<br>创建一个对象的时候，JVM就会同时为这个对象分配一个引用计数器，每当有一个新的引用指向这个对象的时候，引用计数器加1，而当有一个引用脱离了这个对象的时候，引用计数器就减1。这样，在JVM进行垃圾回收操作的时候，通过判断一个对象的引用计数器是否为0便可以获知这个对象是否为一个垃圾对象。这种方式实现起来比较简单，但是有一个很严重的问题，就是不能处理循环引用问题。具体而言，就是当内存中存在循环引用时，这些循环引用的对象的引用计数器均不为0，也就是说这些对象均不能被判定为垃圾对象。但是也有可能这些循环引用作为一个整体是一个垃圾，这样的话，JVM无法对这一块内存进行回收，从而造成了内存的浪费。</p>
</li>
<li><p>可达性分析<br>在创建一个对象的时候，会有一个由该对象指向一个称之为GC ROOT的对象的链接，如果在JVM进行垃圾回收操作时，某个对象有到GC ROOT的链接，即该对象是可达的，那么这个对象就不能被当作垃圾处理，否则如果某个对象到GC ROOT是不可达的，则认为该对象是一个垃圾对象，应该被回收掉。</p>
</li>
</ul>
<h1><span id="如何垃圾回收">如何垃圾回收</span></h1><ul>
<li>标记清除算法<br>标记–清除策略，这种策略是说在进行GC操作时，将垃圾对象加上标记，然后将有标记的对象进行清除，从而达到释放垃圾对象的内存空间的目的。这种方式的优点是实现比较简单，但其缺点也是很严重的。因为采用这种方式进行垃圾回收后，得到的内存空间是零散的，所以经过几轮GC后，内存的碎片化会非常严重</li>
<li>复制算法<br>首先将一片内存区域一分为二，然后先在其中一片区域中创建对象，等到需要进行垃圾垃圾回收操作时，将不是垃圾的对象复制到另一片内存区域，然后将这一片区域清空。经过复制后，所有的非垃圾对象都被重新排列到一片连续的内存区域中了，所以几乎不存在碎片化问题，然而该策略的缺陷在于一开始就需要将一片内存一分为二，交替使用，这样的话，内存利用率只有50%，利用率太低。</li>
<li>分代回收<br>大部分的对象的存活周期很短，只有一小部分对象的存活周期比较长。所以基于这样一个观察，JVM将一片内存区域分为两部分：新生代和年老代，其中新生代又按照8:1:1的比例分为生成区、From Survivor区 和 To Survivor区。创建一个对象时，先将这个对象放入新生代区，当进行GC操作时，将没有引用的对象清除，还幸存的对象放入From Survivor区，如果From Survivor区存放不下，再将对象移到年老代。其中这个算法的核心在于：每次进行GC操作时，都自动会对对象的生存期有一个记录机制，经过几轮GC操作后仍然存活的对象被认为是那些生存周期比较长的对象，而被加入年老代。采用这种方式进行GC操作既能避免内存的碎片化问题，又能拥有比较好的内存利用率。</li>
</ul>
<h1><span id="垃圾回收回收的过程">垃圾回收回收的过程</span></h1><h2><span id="java堆内存">Java堆内存</span></h2><p>堆内存以下2个主要区域：</p>
<h3><span id="新生代young-generation">新生代（Young Generation）</span></h3><ul>
<li>Eden空间，当一个实例被创建了，首先会被存储在堆内存年轻代的 Eden 区中。</li>
<li>S0 Survivor空间（S0 Survivor space，存在时间长的实例将会从Eden空间移动到S0 Survivor空间）</li>
<li>S1 Survivor空间 （存在时间更长的实例将会从S0 Survivor空间移动到S1 Survivor空间）</li>
</ul>
<p>Eden区和Survivor区默认大小比例是8：1</p>
<ul>
<li>老年代（Old Generation）<br>是堆内存中的第二块逻辑区。当垃圾回收器执行 Minor GC 周期时，在 S1 Survivor 区中的存活实例将会被晋升到老年代，而未被引用的对象被标记为回收。<br>老年代 GC（Major GC）：相对于 Java 垃圾回收过程，老年代是实例生命周期的最后阶段。Major GC 扫描老年代的垃圾回收过程。如果实例不再被引用，那么它们会被标记为回收，否则它们会继续留在老年代中。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/12.png" alt=""></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java：HttpServletRequest对象</title>
    <url>/article/Java%EF%BC%9AHttpServletRequest%E5%AF%B9%E8%B1%A1.html</url>
    <content><![CDATA[<p>HttpServletRequest对象代表客户端的请求，当客户端通过HTTP协议访问服务器时，HTTP请求头中的所有信息都封装在这个对象中，通过这个对象的方法，可以获得请求信息。</p>
<h2><span id="httpservletrequest常用方法">HttpServletRequest常用方法</span></h2><pre><code>getRequestURL方法返回客户端发出请求时的完整URL。
getRequestURI方法返回请求行中的资源名部分。
getQueryString 方法返回请求行中的参数部分。
getPathInfo方法返回请求URL中的额外路径信息。额外路径信息是请求URL中的位于Servlet的路径之后和查询参数之前的内容，它以“/”开头。
getRemoteAddr方法返回发出请求的客户机的IP地址。
getRemoteHost方法返回发出请求的客户机的完整主机名。
getRemotePort方法返回客户机所使用的网络端口号。
getLocalAddr方法返回WEB服务器的IP地址。
getLocalName方法返回WEB服务器的主机名。
getHeader(string name)方法:String 
getHeaders(String name)方法:Enumeration 
getHeaderNames()方法

获得客户机请求参数:
getParameter(String)方法(常用)
getParameterValues(String name)方法(常用)
getParameterNames()方法(不常用)
getParameterMap()方法(编写框架时常用)

参数放入request域对象：
setAttribute(String name,Object o)方法，将数据作为request对象的一个属性存放到request对象中，例如：request.setAttribute(&quot;data&quot;, data);
getAttribute(String name)方法，获取request对象的name属性的属性值，例如：request.getAttribute(&quot;data&quot;)
removeAttribute(String name)方法，移除request对象的name属性，例如：request.removeAttribute(&quot;data&quot;)
getAttributeNames方法，获取request对象的所有属性名，返回的是一个，例如：Enumeration&lt;String&gt; attrNames = request.getAttributeNames();
</code></pre><h2><span id="请求重定向和请求转发的区别">请求重定向和请求转发的区别</span></h2><ul>
<li>一个web资源收到客户端请求后，通知服务器去调用另外一个web资源进行处理，称之为请求转发/307。</li>
<li>一个web资源收到客户端请求后，通知浏览器去访问另外一个web资源进行处理，称之为请求重定向/302。</li>
</ul>
<p>参考:<a href="http://www.cnblogs.com/xdp-gacl/p/3798347.html" target="_blank" rel="noopener">http://www.cnblogs.com/xdp-gacl/p/3798347.html</a><br><a id="more"></a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java并发程序(3)：共享受限资源</title>
    <url>/article/Java%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F-3-%EF%BC%9A%E5%85%B1%E4%BA%AB%E5%8F%97%E9%99%90%E8%B5%84%E6%BA%90.html</url>
    <content><![CDATA[<h1><span id="synchronized关键字">synchronized关键字</span></h1><p>当任务要执行被synchronized保护的代码片段的时候，会检查锁是否可用，然后获取锁，执行代码，释放锁。</p>
<h2><span id="同步规则">同步规则</span></h2><p>如果你正在写一个变量，它接下来可能将被另一个线程读取，或者读取一个上一次已经被另一个线程写过的变量，那么你必须使用同步，并且，读写线程都必须使用相同的监视器锁同步。</p>
<pre><code>
public class synchronizedDemo implements Runnable {
    public void run() {
        synchronized (this) {
            for (int i = 0; i &lt; 5; i++) {
                System.out.println(Thread.currentThread().getName() + &quot; synchronized loop lock &quot; + i);
            }
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        for (int i = 0; i &lt; 5; i++) {
            System.out.println(Thread.currentThread().getName() + &quot; synchronized loop no lock &quot; + i);
        }
    }

    public static void main(String[] args) {
        synchronizedDemo common = new synchronizedDemo();

        Thread ta = new Thread(common, &quot;A&quot;);
        Thread tb = new Thread(common, &quot;B&quot;);
        ta.start();
        tb.start();
    }
}
输出：
A synchronized loop lock 0
A synchronized loop lock 1
A synchronized loop lock 2
A synchronized loop lock 3
A synchronized loop lock 4
A synchronized loop no lock 0
B synchronized loop lock 0
A synchronized loop no lock 1
B synchronized loop lock 1
B synchronized loop lock 2
B synchronized loop lock 3
B synchronized loop lock 4
A synchronized loop no lock 2
A synchronized loop no lock 3
A synchronized loop no lock 4
B synchronized loop no lock 0
B synchronized loop no lock 1
B synchronized loop no lock 2
B synchronized loop no lock 3
B synchronized loop no lock 4
</code></pre><p>被synchronized修饰的代码片段会被阻塞，其它代码块不会阻塞。</p>
<h1><span id="使用显示的lock对象">使用显示的Lock对象</span></h1><p>Lock对象必须显示的被创建、锁定和释放。优点的更加的灵活。</p>
<pre><code>import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class lockDemo implements Runnable{
    Lock lock = new ReentrantLock();

    @Override
    public void run() {
        lock.lock();
        for(int i = 0; i &lt; 10; i++) {
            System.out.println(&quot;hello &quot; + Thread.currentThread().getName());
        }
        lock.unlock();
    }

    public static void main(String[] args) {
        ExecutorService executorService = Executors.newCachedThreadPool();
        lockDemo lk = new lockDemo();
        for(int i = 0;i &lt; 5; i++) {
            executorService.execute(lk);
        }
    }

}
</code></pre><ul>
<li>lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。</li>
<li>tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。</li>
<li>tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</li>
<li>lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。</li>
<li>unlock()方法，释放锁。<a id="more"></a>
</li>
</ul>
<h1><span id="volatile关键字">volatile关键字</span></h1><ul>
<li>读和写一个volatile变量有全局的排序。也就是说每个线程访问一个volatile作用域时会在继续执行之前读取它的当前值，而不是（可能）使用一个缓存的值。(但是并不保证经常读写volatile作用域时读和写的相对顺序，也就是说通常这并不是有用的线程构建)。</li>
<li>volatile的读和写建立了一个happens-before关系，类似于申请和释放一个互斥锁</li>
</ul>
<p>1、保证所有线程对该变量的可见性<br>2、禁止指令重排序优化</p>
<h1><span id="临界区">临界区</span></h1><p>希望防止多个线程同时访问方法内部的部分代码而不是整个方法，分离出来的代码片段成为“临界区“，也成为同步控制块</p>
<pre><code>synchronized(syncObject){
    //临界区
}
</code></pre><p>也可以使用Lock对象实现。</p>
<h1><span id="线程本地存储-threadlocal">线程本地存储 ThreadLocal</span></h1><p>通常情况下，创建的变量是可以被任何一个线程访问并修改的。而使用ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改。</p>
<ul>
<li>set方法，将数据插入线程的存储对象中并返回对象</li>
<li>get方法，返回线程相关联对象的副本</li>
</ul>
<pre><code>public class threadLocalDemo {

    public static void main(String[] args) {
        Thread t = new Thread() {
            ThreadLocal&lt;String&gt; mStringThreadLocal = new ThreadLocal&lt;&gt;();

            @Override
            public void run() {
                super.run();
                mStringThreadLocal.set(&quot;mfcheer&quot;);
                System.out.println(mStringThreadLocal.get());
            }
        };
        t.start();
    }
}
输出：
mfcheer
</code></pre>]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java并发程序(4)：JDK的并发容器</title>
    <url>/article/Java%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F-4-%EF%BC%9AJDK%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8.html</url>
    <content><![CDATA[<h1><span id="线程安全的hashmap">线程安全的HashMap</span></h1><h2><span id="concurrenthashmap">ConcurrentHashMap</span></h2><p>线程安全的并发HashMap</p>
<p>java.util.Collections.synchronizedMap,通过这种方式产生的HashMap是线程安全的。</p>
<h1><span id="线程安全的list">线程安全的List</span></h1><h2><span id="copyonwritearraylist">CopyOnWriteArrayList</span></h2><p>适合读多写少场景的线程安全List</p>
<p>ArrayList不是线程安全的，Vector是线程安全的</p>
<p>java.util.Collections.synchronizedList,通过这种方式产生的List是线程安全的。</p>
<h1><span id="线程安全的queue">线程安全的Queue</span></h1><h2><span id="concurrentlinkedqueue">ConcurrentLinkedQueue</span></h2><p>链表实现的线程安全并发队列</p>
<h2><span id="blockingqueue">BlockingQueue</span></h2><p>适合用做数据共享的阻塞队列</p>
<h1><span id="随机数据结构跳表">随机数据结构：跳表</span></h1><h2><span id="跳表的原理">跳表的原理</span></h2><p>可以看我CSDN的一篇文章: <a href="https://blog.csdn.net/u014427196/article/details/52454462" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/52454462</a></p>
<h2><span id="concurrentskiplistmap">ConcurrentSkipListMap</span></h2><p>通过跳表实现的map可以进行快速查找</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java：异常机制</title>
    <url>/article/Java%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6.html</url>
    <content><![CDATA[<h2><span id="概念">概念</span></h2><p>异常 是在程序执行期间发生的破坏正常的程序指令流的事件。异常处理是 Java 编程的一项基础技术。您将代码包装在一个 try 代码块中（这表示 “尝试此代码并让我知道它是否导致了异常”），并使用它捕获 (catch) 各种类型的异常。</p>
<h2><span id="异常分层">异常分层</span></h2><p>异常分层结构</p>
<p><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/79.png" alt=""></p>
<p>Java 语言包含一个完整的异常分层结构，它由许多类型的异常组成，这些异常划分为两大主要类别：</p>
<ul>
<li>已检查的异常已由编译器检查（表示编译器确定它们已在您代码中的某处处理过）。一般而言，这些异常是 java.lang.Exception 的直接子类。</li>
<li>未检查的异常（也称为运行时异常）未由编译器检查。这些是 java.lang.RuntimeException 的子类。</li>
</ul>
<p>程序导致异常时，您可以说它抛出了 异常。已检查的异常可由任何方法在方法名中包含 throws 关键字来声明。后跟该方法可能在执行期间抛出的异常的逗号分隔列表。如果代码调用的一个方法指定它抛出一种或多种类型的异常，您必须对它进行一定的处理，或者向方法名中添加一个 throws 来传递该异常类型。</p>
<h2><span id="多个catch代码块">多个catch代码块</span></h2><p>可以拥有多个 catch代码块，但必须采用某种特定方式来搭建它们。如果所有异常都是其他异常的子类，那么子类会按照 catch 代码块的顺序放在父类前面。<br><a id="more"></a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java：空字符串与null区别</title>
    <url>/article/Java%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8Enull%E5%8C%BA%E5%88%AB.html</url>
    <content><![CDATA[<p>Java空字符串与null区别</p>
<h1><span id="1-类型">1、类型</span></h1><p>null表示的是一个对象的值，而并不是一个字符串。例如声明一个对象的引用，String a = null ;</p>
<p>“”表示的是一个空字符串，也就是说它的长度为0。例如声明一个字符串String str = “” ;</p>
<h1><span id="2-内存分配">2、内存分配</span></h1><p>String str = null ; 表示声明一个字符串对象的引用，但指向为null，也就是说还没有指向任何的内存空间；</p>
<p>String str = “”;    表示声明一个字符串类型的引用，其值为””空字符串，这个str引用指向的是空字符串的内存空间；</p>
<p>在java中变量和引用变量是存在栈中（stack），而对象（new产生的）都是存放在堆中（heap）：<br><a id="more"></a><br>就如下：</p>
<p>String str = new String(“abc”) ;</p>
<p>ps：=左边的是存放在栈中（stack），=右边是存放在堆中（heap）。</p>
<h1><span id="3-示例程序">3、示例程序：</span></h1><pre><code>public class String_Demo01 {
    public static void main(String[] args) {        
        String str1 = new String() ;
        String str2 = null ;
        String str3 = &quot;&quot; ;
        System.out.println(str1==str2);                //内存地址的比较，返回false
        System.out.println(str1.equals(str2));         //值的比较，返回false
        System.out.println(str2==str3);                //内存地址的比较，返回false
        System.out.println(str3.equals(str2));         //值的比较，返回false
        System.out.println(str1==str3);                //内存地址的比较，返回false
        System.out.println(str1.equals(str3));         //值的比较，返回true
    }
}
</code></pre><p>通过如上的程序可以得出如下结论：</p>
<p>字符串对象与null的值不相等，且内存地址也不相等；</p>
<p>空字符串对象与null的值不相等，且内存地址也不相等；</p>
<p>创建一个字符串对象的默认值为””</p>
<h1><span id="4-nulla和anull">4、 null!=a和a!=null</span></h1><p>java判断null!=a和a!=null实际上没区别。</p>
<p>建议在判断时，把常量放在前面，<br>比如 if(4 == a)，<br>这样写的好处是当你不小心少写一个=时，会有错误报告，而不是继续运行</p>
<pre><code>String str = null;
    if (&quot;hello&quot;.equals(str))
        System.out.println(&quot;true&quot;);
    else 
        System.out.println(&quot;false&quot;);
</code></pre><p>输出 false</p>
<pre><code>String str = null;
    if (str.equals(&quot;hello&quot;))
    System.out.println(&quot;true&quot;);
    else 
    System.out.println(&quot;false&quot;);
</code></pre><p>错误Exception</p>
<p>所以在代码中，最好把常量放在前面。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java：final关键字和static关键字</title>
    <url>/article/Java%EF%BC%9Afinal%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8Cstatic%E5%85%B3%E9%94%AE%E5%AD%97.html</url>
    <content><![CDATA[<h1><span id="final关键字">final关键字</span></h1><p>final在Java中是一个保留的关键字，可以声明成员变量、方法、类以及本地变量。</p>
<h2><span id="final变量">final变量</span></h2><p>凡是对成员变量或者本地变量(在方法中的或者代码块中的变量称为本地变量)声明为final的都叫作final变量。final变量经常和static关键字一起使用，作为常量。final变量是只读的</p>
<h2><span id="final方法">final方法</span></h2><p>final也可以声明方法。方法前面加上final关键字，代表这个方法不可以被子类的方法重写。如果你认为一个方法的功能已经足够完整了，子类中不需要改变的话，你可以声明此方法为final。final方法比非final方法要快，因为在编译的时候已经静态绑定了，不需要在运行时再动态绑定。<br><a id="more"></a></p>
<h2><span id="final类">final类</span></h2><p>使用final来修饰的类叫作final类。final类通常功能是完整的，它们不能被继承。Java中有许多类是final的，譬如String, Interger以及其他包装类。</p>
<h2><span id="final关键字的好处">final关键字的好处</span></h2><ul>
<li>final关键字提高了性能。JVM和Java应用都会缓存final变量。</li>
<li>final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。</li>
<li>使用final关键字，JVM会对方法、变量及类进行优化。</li>
</ul>
<h1><span id="static关键字">static关键字</span></h1><p>static关键字使用的对象为：类、方法、变量、代码块</p>
<h2><span id="static方法">static方法</span></h2><p>静态方法也叫做类方法，静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法（因为它们是与具体方法关联的），只能访问所属类的静态成员变量和成员方法。</p>
<p>因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract。</p>
<p>Java中很多使用static的方法，如Math类中所有的方法都是静态的，而一般类内部的static方法也是方便其它类对该方法的调用。</p>
<h2><span id="static变量">static变量</span></h2><p>按照是否静态的对类成员变量进行分类可分两种：</p>
<ul>
<li>一种是被static修饰的变量，叫静态变量或类变量；</li>
<li>另一种是没有被static修饰的变量，叫实例变量。</li>
</ul>
<p>两者的区别是：</p>
<ul>
<li>对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问；</li>
<li>对于实例变量，每创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。<br>一般在在对象之间使用共享值和方便访问变量时，就会去使用静态变量。</li>
</ul>
<h2><span id="static代码块">static代码块</span></h2><p>static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。</p>
<h2><span id="其他">其他</span></h2><ul>
<li>一个类的静态方法只能访问其静态变量；</li>
<li>一个类的静态方法不能够直接调用非静态方法；</li>
<li>静态方法中不存在当前对象，因而不能使用 this，当然也不能使用 super；</li>
<li>静态方法不能被非静态方法覆盖；</li>
<li>构造方法不允许声明为 static 的；</li>
<li>局部变量不能使用static修饰。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java：Java8新特性</title>
    <url>/article/Java%EF%BC%9AJava8%E6%96%B0%E7%89%B9%E6%80%A7.html</url>
    <content><![CDATA[<h1><span id="函数式接口">函数式接口</span></h1><p>首先它是一个接口，有且只有一个抽象方法<br>接口上使用注解 @FunctionalInterface 进行声明，这个注解是非必须的，该注解是提醒编译器去检查该接口是否仅包含一个抽象方法</p>
<ul>
<li>函数式接口里是可以包含默认方法，因为默认方法不是抽象方法</li>
<li>函数式接口里是可以包含静态方法，因为静态方法不能是抽象方法</li>
</ul>
<pre><code>@FunctionalInterface
public interface funcInterfaceDemo {
    public abstract void hello();
}
</code></pre><h1><span id="lambda表达式">Lambda表达式</span></h1><p>我们能够使用 Lambda 实例化函数式接口<br>Lambda表达式由三个部分组成：第一部分为一个括号内用逗号分隔的形式参数，参数是函数式接口里面方法的参数；第二部分为一个箭头符号：-&gt;；第三部分为方法体，可以是表达式和代码块。<br>若方法体为代码块，必须用 {} 来包裹起来。</p>
<p>要使用 Lambda 表达式，需要定义一个函数式接口，这样会让程序充斥着过量的仅为 Lambda 表达式服务的函数式接口。为了减少这样过量的函数式接口，Java 8 在 java.util.function 中增加了不少新的函数式通用接口。</p>
<ul>
<li>Function&lt;T, R&gt;：将 T 作为输入，返回 R 作为输出</li>
<li>Predicate<t> ：将 T 作为输入，返回一个布尔值作为输出</t></li>
<li>Consumer<t> ：将 T 作为输入，不返回任何内容</t></li>
</ul>
<pre><code>Function&lt;Integer, String&gt; f = (t)-&gt;String.valueOf(t);
String fString = f.apply(5);
System.out.println(fString);
</code></pre><a id="more"></a>
<h1><span id="foreach方法">forEach方法</span></h1><p>使用forEach方法遍历List和Map</p>
<pre><code>public static void main(String args[]) {
    List&lt;String&gt; rlList = Arrays.asList(&quot;1&quot;,&quot;2&quot;);
    rlList.forEach(t-&gt;{
            System.out.println(t);
    });

    Map&lt;String, String&gt; items = new HashMap&lt;&gt;();
    items.put(&quot;1&quot;, &quot;A&quot;);
    items.put(&quot;2&quot;, &quot;B&quot;);
    items.forEach((k,v)-&gt;{
        System.out.println(k + v);
    });
}
</code></pre><h1><span id="接口的增强">接口的增强</span></h1><p>在接口中可以添加使用 default 关键字修饰的非抽象方法,还可以在接口中定义静态方法。</p>
<h1><span id="流式操作stream">流式操作（Stream）</span></h1><p>通过Stream可以实现对集合（Collection）的并行处理和函数式操作。根据操作返回的结果不同，流式操作分为中间操作和最终操作两种。最终操作返回一特定类型的结果，而中间操作返回流本身，这样就可以将多个操作依次串联起来。根据流的并发性，流又可以分为串行和并行两种。流式操作实现了集合的过滤、排序、映射等功能。</p>
<p>Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。</p>
<p>通过 stream.sequential() 返回串行的流，通过 stream.parallel() 返回并行的流。相比较串行的流，并行的流可以很大程度上提高程序的执行效率。</p>
<h2><span id="中间操作">中间操作</span></h2><ul>
<li>filter()：对元素进行过滤；</li>
<li>sorted()：对元素排序；</li>
<li>map()：元素的映射；</li>
<li>distinct()：去除重复元素；</li>
<li>subStream()：获取子 Stream 等。</li>
</ul>
<p>sorted()排序</p>
<pre><code>List&lt;Integer&gt; rlList = Arrays.asList(1,6,4,2,7,9,3);
rlList.forEach(t-&gt;{
    System.out.print(t);
});

rlList = rlList.stream().parallel().sorted().collect(Collectors.toList());
rlList.forEach(t-&gt;{
    System.out.print(t);
});
</code></pre><h2><span id="最终操作">最终操作</span></h2><ul>
<li>forEach()：对每个元素做处理；</li>
<li>toArray()：把元素导出到数组；</li>
<li>findFirst()：返回第一个匹配的元素；</li>
<li>anyMatch()：是否有匹配的元素等。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java：JVM内存分配总结</title>
    <url>/article/Java%EF%BC%9AJVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<a id="more"></a>
<h1><span id="java虚拟机运行时数据区">Java虚拟机运行时数据区</span></h1><p>包括如下几部分<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/83.png" alt=""></p>
<h2><span id="程序计数器">程序计数器</span></h2><p>线程私有内存。用于保存当前正常执行的程序的内存地址。Java虚拟机的多线程就是通过线程轮流切换并分配处理器时间来实现的，为了线程切换后能恢复到正确的位置，每条线程都需要一个独立的程序计数器，互不影响，该区域为“线程私有”。</p>
<h2><span id="虚拟机栈">虚拟机栈</span></h2><p>线程私有内存，用于存储局部变量表，操作栈，方法返回值。局部变量表放着基本数据类型，还有对象的引用。 </p>
<h2><span id="本地方法栈">本地方法栈</span></h2><p>与虚拟机栈一样，只不过服务的是Native方法，也就是调用C、C++代码时。</p>
<h2><span id="java堆">Java堆</span></h2><p>所有线程共享区域,对象实例几乎都在这分配内存。垃圾回收区域就在此。可细分为新生代和老年代，再可细分为Eden区，From Survivor<br>区，To Survivor区。用来存储程序中的一些对象，比如你用new关键字创建的对象，它就会被存储在堆内存中，但是这个对象在堆内存中的首地址会存储在栈中。</p>
<h2><span id="方法区">方法区</span></h2><p>所有线程共享区域。储存虚拟机加载的类信息，常量，静态变量，编译后的代码。</p>
<h3><span id="运行时常量池">运行时常量池</span></h3><p>属于方法区的一部分,代表运行时每个class文件中的常量表。包括几种常量：编译时的数字常量、方法或者域的引用。</p>
<h1><span id="常用jvm参数">常用JVM参数</span></h1><h2><span id="栈设置">栈设置</span></h2><ul>
<li>-Xss256K:每个线程的栈大小<h2><span id="堆设置">堆设置</span></h2></li>
<li>-Xms:初始堆大小</li>
<li>-Xmx:最大堆大小</li>
<li>-XX:NewSize=n:设置年轻代大小</li>
<li>-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4</li>
<li>-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5</li>
<li>-XX:MaxPermSize=n:设置持久代大小</li>
</ul>
<h2><span id="收集器设置">收集器设置</span></h2><ul>
<li>-XX:+UseSerialGC:设置串行收集器</li>
<li>-XX:+UseParallelGC:设置并行收集器</li>
<li>-XX:+UseParalledlOldGC:设置并行年老代收集器</li>
<li>-XX:+UseConcMarkSweepGC:设置并发收集器</li>
</ul>
<h2><span id="垃圾回收统计信息">垃圾回收统计信息</span></h2><ul>
<li>-XX:+PrintGC</li>
<li>-XX:+PrintGCDetails</li>
<li>-XX:+PrintGCTimeStamps</li>
<li>-Xloggc:filename</li>
</ul>
<h2><span id="并行收集器设置">并行收集器设置</span></h2><ul>
<li>-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。</li>
<li>-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间</li>
<li>-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</li>
<li>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。</li>
<li>-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</li>
</ul>
<h1><span id="java-new一个对象的过程">Java new一个对象的过程</span></h1><ul>
<li>检测类是否被加载</li>
<li>为新生对象分配内存</li>
<li>将分配到的内存空间都初始化为零值（不包括对象头）</li>
<li>对对象进行必要的设置（例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中）</li>
<li>执行init方法（构造方法）</li>
</ul>
<h1><span id="java-内存分配原则">Java 内存分配原则</span></h1><ul>
<li>对象优先分配在Eden区</li>
<li>大对象直接进入年老带</li>
<li>长期存活对象进入年老带</li>
<li>动态对象年龄判断</li>
<li>空间分配担保</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习：KNN算法</title>
    <url>/article/KNN%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<p>KNN（K Nearest Neighbor）算法是机器学习里面常用的一种分类算法，假设一个样本空间被分为几类，然后给定一个待分类所有的特征数据，通过计算距离该数据的最近的K个样本来判断这个数据属于哪一类。如果距离待分类属性最近的K个类大多数都属于某一个特定的类，那么这个待分类的数据也就属于这个类。</p>
<p><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/78.jpg" alt=""></p>
<p>如图所示，假设现在需要对中间绿色的圆进行分类，假设我们寻找距离这个绿色圆最近的3个样本，即K=3，那么可以看出这个绿色圆属于红色三角形所在的类；如果K=5，因为蓝色方框最多，所以此时绿色圆属于蓝色方框所在的类。从而得到当K值取值不同时，得到的分类结果也可能不一样，所以很多时候K值得选取很关键，这就是KNN的核心思想。如果类别个数为偶数，那么K通常会设置为一个奇数；如果类别个数为奇数，K通常设置为偶数，这样就能保证不会有平局的发生。</p>
<p>每预测一个新样本的所属类别时，都会对整体样本进行遍历，可以看出KNN的效率实际上是十分低下的。<br><a id="more"></a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习：K-Means算法</title>
    <url>/article/K-Means%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<h1><span id="原理">原理</span></h1><p>K-Means算法属于基于划分的聚类算法，对N维欧氏空间中的点进行聚类，是一种最简单的无监督学习方法。它通过迭代来实现，其基本思想是：每次确定K个类别中心，然后将各个结点归属到与之距离最近的中心点所在的Cluster，然后将类别中心更新为属于各Cluster的所有样本的均值，反复迭代，直至类别中心不再发生变化或变化小于某阈值。</p>
<h1><span id="算法描述">算法描述</span></h1><p>（1）随机生成c个类的初始中心；<br>（2）在第k次迭代中，对任意一个样本，求其到c各中心的距离，将该样本归到距离最短的那个中心所在的类；<br>（3）利用均值等方法更新该类的中心值；<br>（4）对于所有的C个聚类中心，如果利用（2）（3）的迭代法更新后，值保持不变，则迭代结束；否则继续迭代。<br><a id="more"></a></p>
<p>不同的初始化k值和中心点的选择有可能引起不同的聚类结果</p>
<h1><span id="聚类数k的选取评价方法">聚类数k的选取评价方法</span></h1><h3><span id="1-事前的数据分析选取合适的k值">1、事前的数据分析，选取合适的k值</span></h3><h3><span id="2-手肘法">2、手肘法</span></h3><p>手肘法的核心指标是SSE(误差平方和)。取名的原因是拟合曲线形状和手肘形状相似。</p>
<p>手肘法的核心思想是：随着聚类数k的增大，样本划分会更加精细，每个簇的聚合程度会逐渐提高，那么误差平方和SSE自然会逐渐变小。并且，当k小于真实聚类数时，由于k的增大会大幅增加每个簇的聚合程度，故SSE的下降幅度会很大，而当k到达真实聚类数时，再增加k所得到的聚合程度回报会迅速变小，所以SSE的下降幅度会骤减，然后随着k值的继续增大而趋于平缓，也就是说SSE和k的关系图是一个手肘的形状，而这个肘部对应的k值就是数据的真实聚类数。当然，这也是该方法被称为手肘法的原因。</p>
<h3><span id="3-轮廓系数法">3、轮廓系数法</span></h3><p>轮廓系数的公式为 s = (a-b)/max(a,b)。其中a为当前样本点x与同簇的其他样本的平均距离，称为凝聚度，b为x与最近簇中所有样本的平均距离，称为分离度。顾名思义，最近簇为除了同簇的最近的簇。</p>
<p>求出所有样本的轮廓系数后再求平均值就得到了平均轮廓系数。平均轮廓系数的取值范围为[-1,1]，且簇内样本的距离越近，簇间样本距离越远，平均轮廓系数越大，聚类效果越好。</p>
<h1><span id="随机点的选取评价方法">随机点的选取评价方法</span></h1><h3><span id="1-事前的数据分析选取合适中心点">1、事前的数据分析，选取合适中心点</span></h3><h3><span id="2-随机化选择">2、随机化选择</span></h3><p>第一个簇心A随机找；第二个簇心B要找距离A最远的，是因为簇心之间要相距远一些，如果很近的话，很容易当作一类，影响聚类效果；第三个簇心C也是同样的，它得离A、B远一些；如此类推。</p>
<h1><span id="时间复杂度">时间复杂度</span></h1><p>k-means算法的时间复杂度为：<br>O(mnkd)，m为迭代次数。n为数据集中数据样本数量，k为聚类个数，d为数据的维数。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>Java：LinkedHashMap实现LRU算法</title>
    <url>/article/LinkedHashMap%E5%AE%9E%E7%8E%B0LRU%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<h1><span id="lru">LRU</span></h1><p>LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，把最近一次使用时间离现在时间最远的数据删除掉，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p>
<h1><span id="linkedhashmap">LinkedHashMap</span></h1><p>在LinkedHashMap初始化的时候可以选择一个参数accessOrder，默认为false，map内部会按照插入顺序进行维护。如果设置为true，那么map内部会按照访问顺序进行维护。</p>
<p>LinkedHashMap也提供了一个方法removeEldestEntry，只要重写这个方法，就很容易实现LRU的cache。当调用map的put和putAll方法后会调用removeEldestEntry()检查是否应该删除eldest元素。</p>
<h1><span id="代码">代码</span></h1><a id="more"></a>
<p>构造了一个大小为3的LRU缓存</p>
<pre><code>public class LRUDemo {
    public static void main(String[] args) {

        LinkedHashMap&lt;String, String&gt; lru = new LinkedHashMap&lt;String, String&gt;(5, 0.75f, true) {
            @Override
             protected boolean removeEldestEntry(Map.Entry&lt;String, String&gt; eldest) {
                return size() &gt; 3;
            }
        };

        lru.put(&quot;a&quot;, &quot;1&quot;);
        lru.put(&quot;b&quot;, &quot;2&quot;);
        lru.put(&quot;c&quot;, &quot;3&quot;);
        System.out.println(lru.toString());
        lru.get(&quot;b&quot;);
        System.out.println(lru.toString());
        lru.put(&quot;d&quot;, &quot;4&quot;);
        System.out.println(lru.toString());
    }
}
{a=1, b=2, c=3}
{a=1, c=3, b=2}
{c=3, b=2, d=4}
</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>MacOS下防止rm命令误删</title>
    <url>/article/MacOS%E4%B8%8B%E9%98%B2%E6%AD%A2rm%E5%91%BD%E4%BB%A4%E8%AF%AF%E5%88%A0.html</url>
    <content><![CDATA[<p>linux下的rm删除是不能恢复的。mac下有废纸篓的概念，我们可以对rm进行修改，将删除的文件放到废纸篓里</p>
<p>安全删除脚本, safe_rm.sh</p>
<pre><code>TRASH_DIR=&quot;/Users/mfcheer/.Trash&quot;
for i in $*; do
    mv -f $i $TRASH_DIR
done
</code></pre><p>将安全删除脚本文件的目录，修改~/.bash_profile文件将脚本加入到PATH中，再对rm命令重定向</p>
<pre><code>alias rm=&#39;safe_rm.sh&#39;
</code></pre><p>这样就能安全的使用rm了</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>Linux下TCP/IP及内核参数优化</title>
    <url>/article/Linux%E4%B8%8BTCP-IP%E5%8F%8A%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96.html</url>
    <content><![CDATA[<h1><span id="linux下tcpip及内核参数优化">Linux下TCP/IP及内核参数优化</span></h1><p>Linux下TCP/IP及内核参数优化有多种方式，参数配置得当可以大大提高系统的性能，也可以根据特定场景进行专门的优化，如TIME_WAIT过高，DDOS攻击等等。</p>
<p>如下配置是写在/etc/sysctl.conf中，可使用sysctl -p生效，</p>
<p>相关参数仅供参考，具体数值还需要根据机器性能，应用场景等实际情况来做更细微调整。</p>
<h2><span id="具体参数">具体参数</span></h2><p>net.core.netdev_max_backlog = 400000<br>该参数决定了，网络设备接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。<br><a id="more"></a><br>net.core.optmem_max = 10000000<br>该参数指定了每个套接字所允许的最大缓冲区的大小</p>
<p>net.core.rmem_default = 10000000<br>指定了接收套接字缓冲区大小的缺省值（以字节为单位）。</p>
<p>net.core.rmem_max = 10000000<br>指定了接收套接字缓冲区大小的最大值（以字节为单位）。</p>
<p>net.core.somaxconn = 100000<br>Linux kernel参数，表示socket监听的backlog(监听队列)上限</p>
<p>net.core.wmem_default = 11059200<br>定义默认的发送窗口大小；对于更大的 BDP 来说，这个大小也应该更大。</p>
<p>net.core.wmem_max = 11059200<br>定义发送窗口的最大大小；对于更大的 BDP 来说，这个大小也应该更大。</p>
<p>net.ipv4.conf.all.rp_filter = 1<br>net.ipv4.conf.default.rp_filter = 1<br>严谨模式 1 (推荐)<br>松散模式 0</p>
<p>net.ipv4.tcp_congestion_control = bic<br>默认推荐设置是 htcp</p>
<p>net.ipv4.tcp_window_scaling = 0<br>关闭tcp_window_scaling<br>启用 RFC 1323 定义的 window scaling；要支持超过 64KB 的窗口，必须启用该值。</p>
<p>net.ipv4.tcp_ecn = 0<br>把TCP的直接拥塞通告(tcp_ecn)关掉</p>
<p>net.ipv4.tcp_sack = 1<br>关闭tcp_sack<br>启用有选择的应答（Selective Acknowledgment），<br>这可以通过有选择地应答乱序接收到的报文来提高性能（这样可以让发送者只发送丢失的报文段）；<br>（对于广域网通信来说）这个选项应该启用，但是这会增加对 CPU 的占用。</p>
<p>net.ipv4.tcp_max_tw_buckets = 10000<br>表示系统同时保持TIME_WAIT套接字的最大数量</p>
<p>net.ipv4.tcp_max_syn_backlog = 8192<br>表示SYN队列长度，默认1024，改成8192，可以容纳更多等待连接的网络连接数。</p>
<p>net.ipv4.tcp_syncookies = 1<br>表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；</p>
<p>net.ipv4.tcp_timestamps = 1<br>开启TCP时间戳<br>以一种比重发超时更精确的方法（请参阅 RFC 1323）来启用对 RTT 的计算；为了实现更好的性能应该启用这个选项。</p>
<p>net.ipv4.tcp_tw_reuse = 1<br>表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</p>
<p>net.ipv4.tcp_tw_recycle = 1<br>表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</p>
<p>net.ipv4.tcp_fin_timeout = 10<br>表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。</p>
<p>net.ipv4.tcp_keepalive_time = 1800<br>表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为30分钟。</p>
<p>net.ipv4.tcp_keepalive_probes = 3<br>如果对方不予应答，探测包的发送次数</p>
<p>net.ipv4.tcp_keepalive_intvl = 15<br>keepalive探测包的发送间隔</p>
<p>net.ipv4.tcp_mem<br>确定 TCP 栈应该如何反映内存使用；每个值的单位都是内存页（通常是 4KB）。<br>第一个值是内存使用的下限。<br>第二个值是内存压力模式开始对缓冲区使用应用压力的上限。<br>第三个值是内存上限。在这个层次上可以将报文丢弃，从而减少对内存的使用。对于较大的 BDP 可以增大这些值（但是要记住，其单位是内存页，而不是字节）。</p>
<p>net.ipv4.tcp_rmem<br>与 tcp_wmem 类似，不过它表示的是为自动调优所使用的接收缓冲区的值。</p>
<p>net.ipv4.tcp_wmem = 30000000 30000000 30000000<br>为自动调优定义每个 socket 使用的内存。<br>第一个值是为 socket 的发送缓冲区分配的最少字节数。<br>第二个值是默认值（该值会被 wmem_default 覆盖），缓冲区在系统负载不重的情况下可以增长到这个值。<br>第三个值是发送缓冲区空间的最大字节数（该值会被 wmem_max 覆盖）。</p>
<p>net.ipv4.ip_local_port_range = 1024 65000<br>表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000。</p>
<p>net.ipv4.netfilter.ip_conntrack_max=204800<br>设置系统对最大跟踪的TCP连接数的限制</p>
<p>net.ipv4.tcp_slow_start_after_idle = 0<br>关闭tcp的连接传输的慢启动，即先休止一段时间，再初始化拥塞窗口。</p>
<p>net.ipv4.route.gc_timeout = 100<br>路由缓存刷新频率，当一个路由失败后多长时间跳到另一个路由，默认是300。</p>
<p>net.ipv4.tcp_syn_retries = 1<br>在内核放弃建立连接之前发送SYN包的数量。</p>
<p>net.ipv4.icmp_echo_ignore_broadcasts = 1<br>避免放大攻击</p>
<p>net.ipv4.icmp_ignore_bogus_error_responses = 1开启恶意icmp错误消息保护</p>
<p>net.inet.udp.checksum=1<br>防止不正确的udp包的攻击</p>
<p>net.ipv4.conf.default.accept_source_route = 0<br>是否接受含有源路由信息的ip包。参数值为布尔值，1表示接受，0表示不接受。<br>在充当网关的linux主机上缺省值为1，在一般的linux主机上缺省值为0。<br>从安全性角度出发，建议你关闭该功能。</p>
<h2><span id="以上转自">以上转自</span></h2><p><a href="http://www.cnblogs.com/jking10/p/5472386.html" target="_blank" rel="noopener">链接</a></p>
]]></content>
      <categories>
        <category>Unix/Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux基本命令</title>
    <url>/article/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4.html</url>
    <content><![CDATA[<p>查看端口占用情况：</p>
<pre class="line-numbers language-shell"><code class="language-shell">lsof -i:端口号 用于查看某一端口的占用情况，比如查看8000端口使用情况，lsof -i:8000
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>压缩命令</p>
<pre class="line-numbers language-shell"><code class="language-shell">单个文件压缩打包 tar czvf my.tar file1
多个文件压缩打包 tar czvf my.tar file1 file2,...
单个目录压缩打包 tar czvf my.tar dir1
多个目录压缩打包 tar czvf my.tar dir1 dir2
解包至当前目录：tar xzvf my.tar
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>解压war文件</p>
<pre class="line-numbers language-shell"><code class="language-shell">jar -xvf name.war
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>Linux 统计某个字符串出现的次数</p>
<pre class="line-numbers language-shell"><code class="language-shell">cat filename |grep str |wc -l
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>定时任务</p>
<pre class="line-numbers language-shell"><code class="language-shell">crontab -e 
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>查看文件内容 </p>
<pre><code>如果你只想看文件的前5行，可以使用head命令，如： 
head -5 /etc/passwd 
如果你想查看文件的后10行，可以使用tail命令，如： 
tail -10 /etc/passwd 或 tail -n 10 /etc/passwd 
tail -f /var/log/messages 
参数-f使tail不停地去读最新的内容，这样有实时监视的效果 用Ctrl＋c来终止！ 
</code></pre><p>本地文件上传到主机</p>
<pre><code>rz -be
</code></pre><p>主机文件下载到本地</p>
<pre><code>sz &quot;filename&quot;
</code></pre><a id="more"></a>
<p>日志定期清理sh</p>
<pre><code>#!/bin/bash
log_path=/opt/web/mFangchanIndex #日志路径
export log_path
expried_time=7      #此处定义你的日志过期时间，如7天
find $log_path -type f -mtime +7 -iname &quot;log.*&quot; | xargs rm  1&gt;/dev/null 2&gt;&amp;1
</code></pre><p>查看进程和删除进程</p>
<pre><code>ps 命令用于查看当前正在运行的进程。
grep 是搜索
ps [选项]
-e 显示所有进程,环境变量
-f 全格式
-h 不显示标题
-l 长格式
-w 宽输出
kill 命令用于终止进程
-9 表示强迫进程立即停止

例子：
ps -ef | grep java
ps aux|grep tcp
kill -9 [PID]
</code></pre><p>Linux间进行文件传送-scp命令</p>
<pre><code>linux 的 scp 命令可以在 linux 之间复制文件和目录；  
scp 可以在 2个 linux 主机间复制文件； 
命令基本格式： 
scp [可选参数] file_source file_target 
从本地复制到远程： 
复制文件： 
scp local_file remote_ip:remote_file 
scp /home/space/music/1.mp3 root@www.cumt.edu.cn:/home/root/others/music 
复制目录：  
scp -r local_folder remote_username@remote_ip:remote_folder 
命令执行后需要输入密码； 
例子： 
scp -r /home/space/music/ root@www.cumt.edu.cn:/home/root/others/ 
从远程复制到本地 ，只要将从本地复制到远程的命令的后2个参数调换顺序即可； 
</code></pre><p>解压 .lzop压缩文件</p>
<pre><code># lzop -v test # 创建test.lzo压缩文件，输出详细信息，保留test文件不变
# lzop -Uv test # 创建test.lzo压缩文件，输出详细信息，删除test文件
# lzop -t test.lzo # 测试test.lzo压缩文件的完整性
# lzop –info test.lzo # 列出test.lzo中各个文件的文件头
# lzop -l test.lzo # 列出test.lzo中各个文件的压缩信息
# lzop –ls test.lzo # 列出test.lzo文件的内容，同ls -l功能
# cat test | lzop &gt; t.lzo # 压缩标准输入并定向到标准输出
# lzop -dv test.lzo # 解压test.lzo得到test文件，输出详细信息，保留test.lzo不变
</code></pre><p>rsync命令</p>
<pre><code>kinit username
例子：
rsync -av rec/ work@10.12.90.13:/opt/rec --exclude=&#39;logs&#39;
--exclude=&#39;logs&#39;说明 ： 不拷贝logs文件夹
</code></pre><p>SSH基本的用法</p>
<pre><code>SSH主要用于远程登录。假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。
$ ssh user@host
如果本地用户名与远程用户名一致，登录时可以省略用户名。
$ ssh host
SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。
$ ssh -p 2222 user@host
上面这条命令表示，ssh直接连接远程主机的2222端口。
</code></pre><p>搜索输入过的命令</p>
<pre><code>ctrl+r:搜索某个以前输入过的命令 或者!command
</code></pre><p>cat合并文件</p>
<pre><code>使用cat合并文件，如cat 1.txt 2.txt 3.txt &gt; 4.txt；
如果1/2/3.txt中存在多个空行，最终保存到4.txt时，连续的空行会被替换为1行。
如果我们希望去掉空行，可以使用如下：cat -s 1.txt 2.txt 3.txt &gt; 4.txt
</code></pre><p>diff命令</p>
<pre><code>在使用diff命令的时候有3种显示，但是如果我们仅仅需要查看2个文件所有不同的记录，
去掉diff加上的123a124或者&gt;或者&lt;,可以先diff a b &gt; difflog，
然后使用grep+sed：cat difflog
</code></pre><p>df -h 查看磁盘使用情况</p>
<pre><code>df -h
</code></pre><p>nohup 后台运行</p>
<pre><code>nohup command 1&gt;output 2&gt;&amp;1 &amp;
</code></pre><p>split 将一个大文件分割成很多个小文件</p>
<pre class="line-numbers language-shell"><code class="language-shell">每3行（-l 3）拆分成一个文件，拆分后的文件名以name开头，以数字作为后缀（-d）后缀长度为1（-a 1）
split -l 3 test -d -a 1 name
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>自定义命令，例如mac不支持ll命令</p>
<pre class="line-numbers language-shell"><code class="language-shell">vim ~/.bash_profile
输入以下内容
alias ll='ls -lF'
保存完成之后
source ~/.bash_profile
可以使用ll等命令了
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>自动拉起后台程序脚本例子</p>
<pre class="line-numbers language-shell"><code class="language-shell">function monitorService()
{
    cnt=$( ps -ef | grep java | grep -v grep | grep service | wc -l )
    echo $cnt
    if [ $cnt -eq 0 ]; then
        msg="$bin service is not running, start it."
        echo $msg
        #发送短信到负责人
        sh /opt/server server.sh
    else
        echo "$bin service is running."
    fi
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>hadoop 查看文件夹下文件名称，按存储从大到小排列</p>
<pre class="line-numbers language-shell"><code class="language-shell">hadoop fs -du xxx|sort -n -r  | awk '/^[0-9]+/ { print int($1/(1024**3)) " [GB]\t" $2 $3}'
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>Win10打开Ubuntu的文件夹</p>
<pre class="line-numbers language-shell"><code class="language-shell">在Shell界面输入命令
explorer.exe .
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>Python Lib库加载</p>
<pre class="line-numbers language-shell"><code class="language-shell">export LD_LIBRARY_PATH=/opt/xxx/ss_lib/so:$LD_LIBRARY_PATH
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>Python sqlacodegen 生成 ORM文件</p>
<pre class="line-numbers language-shell"><code class="language-shell">sqlacodegen mysql://db_name:password@ip:port/table
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>markdown2激活码</p>
<pre><code>邮箱地址：
Soar360@live.com
授权秘钥：
GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==
</code></pre><p>kepler 地图可视化</p>
<pre><code>https://kepler.gl/

切换地图为中文，设置map style = mapbox://styles/mapbox/streets-zh-v1  
</code></pre><p>常用</p>
<pre><code>alias ll=&#39;ls -lh&#39;
alias lll=&#39;ls -alFh&#39;
alias la=&#39;ls -Ah&#39;
alias l=&#39;ls -CFh&#39;
alias srm=&#39;sudo rm&#39;
alias tree=&quot;find . -print | sed -e &#39;s;[^/]*/;|____;g;s;____|; |;g&#39;&quot;
alias rm=&#39;safe_rm.sh&#39;
alias du=&quot;du -h&quot;
alias grep=&quot;grep --color=auto&quot;
alias vim=&quot;vim -p&quot;
alias vi=&#39;vim -p&#39;

ps aux | grep $1 | awk &#39;{print $2}&#39; | xargs kill

current_dir=`pwd`
rsync -rav --exclude &quot;.git&quot; --exclude=&quot;output&quot; --exclude=&quot;*.pyc&quot; --exclude=&quot;\.*.swp&quot; &quot;${current_dir}&quot; &quot;${user_at_host}:${destination_dir}&quot;
</code></pre><p>linux安全删除</p>
<pre><code>safe_rm.sh
TRASH_DIR=&quot;/Users/mengfanqiang/.Trash&quot;
for i in $*; do
    mv -f $i $TRASH_DIR
done
将safe_rm.sh加入到PATH

alias rm=&#39;safe_rm.sh&#39;
</code></pre>]]></content>
      <categories>
        <category>Unix/Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Mac下使用Kerberos</title>
    <url>/article/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8Kerberos.html</url>
    <content><![CDATA[<h1><span id="安装">安装</span></h1><p>在命令行下输入kinit，若是有这个命令，说明kerberos已经装好了。否则需要自己安装。</p>
<h1><span id="配置">配置</span></h1><p>安装完成后，修改/etc/ssh/ssh_config</p>
<pre><code>GSSAPIAuthentication yes 
GSSAPIDelegateCredentials yes 
GSSAPITrustDNS yes 
GSSAPIKeyExchange yes
</code></pre><a id="more"></a>
<h2><span id="升级macos-sierra报错处理">升级MacOs sierra报错处理</span></h2><pre><code>报错如下：
/etc/ssh/ssh_config: line 4: Bad configuration option: gssapitrustdns
/etc/ssh/ssh_config: line 5: Bad configuration option: gssapikeyexchange  
/etc/ssh/ssh_config: terminating, 2 bad configuration options
</code></pre><h2><span id="解决方式">解决方式</span></h2><pre><code>注释报错中的两行，然后：
  当前用户目录新建文件 .ssh/config
  内容： 
  Host *
     ControlMaster auto
     ControlPath ~/.ssh/%h-%p-%r
     ControlPersist yes
</code></pre><h1><span id="简单使用">简单使用</span></h1><pre><code>登陆：kinit 账户
查看：klist
注销：kdestroy
修改密码：kpasswd 用户名
登录服务器：ssh IP
</code></pre>]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL：单引号的性能问题</title>
    <url>/article/MySQL%E4%B8%AD%E5%8D%95%E5%BC%95%E5%8F%B7%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<p>对于这样一张表</p>
<pre><code>+-------+----------+------+-----+---------+-------+
| Field | Type     | Null | Key | Default | Extra |
+-------+----------+------+-----+---------+-------+
| id    | char(16) | NO   | PRI | NULL    |       |
| name  | char(16) | YES  |     | NULL    |       |
+-------+----------+------+-----+---------+-------+
</code></pre><p>两个查询语句</p>
<pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> test <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token string">'1'</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> test <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>有什么区别吗？答案是有的</p>
<p><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/22.png" alt=""></p>
<p>关键在于type上<br><a id="more"></a></p>
<pre><code>使用字符串类型查找的type是const，用的是索引
使用数字查找的type是ALL，也就是全表扫描
</code></pre><p>使用数字的时候没有用到索引，使用单引号的时候用到了索引。所以数据量较大时，在效率上会有很大的差别！<br>mysql不会自动把数字转成字符串，而是把每个查询到的结果转成了数字去比较。<br>所以平时使用的时候要注意语法规则！</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>Java：Maven</title>
    <url>/article/Maven.html</url>
    <content><![CDATA[<h1><span id="maven的用途">maven的用途</span></h1><p>maven是一个项目构建和管理的工具。可以将项目过程规范化、自动化、高效化以及强大的可扩展性。利用maven自身及其插件还可以获得代码检查报告、单元测试覆盖率、实现持续集成等等.</p>
<h1><span id="核心概念">核心概念</span></h1><h2><span id="pom">pom</span></h2><p>pom是指project object Model。pom是一个xml文件。是maven工作的基础，maven会去项目根目录下读取pom.xml获得需要的配置信息。</p>
<p>pom文件中包含了项目的信息和maven build项目所需的配置信息，通常有项目信息(如版本、成员)、项目的依赖、插件和goal、build选项等等。</p>
<p>pom是可以继承的，通常对于一个大型的项目或是多个module的情况，子模块的pom需要指定父模块的pom。<br>pom文件中节点含义如下：<br><a id="more"></a></p>
<pre><code>project pom文件的顶级元素
modelVersion 所使用的object model版本，为了确保稳定的使用，这个元素是强制性的。除非maven开发者升级模板，否则不需要修改
groupId 是项目创建团体或组织的唯一标志符，通常是域名倒写，如groupId  org.apache.maven.plugins就是为所有maven插件预留的
artifactId 是项目artifact唯一的基地址名
packaging artifact打包的方式，如jar、war、ear等等。默认为jar。这个不仅表示项目最终产生何种后缀的文件，也表示build过程使用什么样的lifecycle。
version artifact的版本，通常能看见为类似0.0.1-SNAPSHOT，其中SNAPSHOT表示项目开发中，为开发版本
name 表示项目的展现名，在maven生成的文档中使用
url表示项目的地址，在maven生成的文档中使用
description 表示项目的描述，在maven生成的文档中使用
dependencies 表示依赖，在子节点dependencies中添加具体依赖的groupId artifactId和version
build 表示build配置
parent 表示父pom
</code></pre><h2><span id="artifact">Artifact</span></h2><p>一个项目将要产生的文件，可以是jar文件，源文件，二进制文件，war文件。每个artifact都由groupId:artifactId:version组成的标识符唯一识别</p>
<h2><span id="repositories">Repositories</span></h2><p>Repositories是用来存储Artifact的。在项目中需要使用某种工具时，在pom中声明dependency，编译代码时就会根据dependency去下载工具（Artifact），供自己使用。<br>对于自己的项目完成后可以通过mvn install命令将项目放到仓库（Repositories）中。<br>仓库分为本地仓库和远程仓库，远程仓库是指远程服务器上用于存储Artifact的仓库，本地仓库是指本机存储Artifact的仓库，对于windows机器本地仓库地址为系统用户的.m2/repository下面。</p>
<h1><span id="常用命令">常用命令</span></h1><p>将依赖包打包进一个文件夹</p>
<pre><code>dependency:copy-dependencies
</code></pre><p>将依赖包打包成一个包</p>
<pre><code>&lt;build&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;!-- &lt;version&gt;2.1&lt;/version&gt; --&gt;
        &lt;configuration&gt;
            &lt;descriptorRefs&gt;
                &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;
            &lt;/descriptorRefs&gt;
        &lt;/configuration&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/build&gt;
assembly::assembly
</code></pre><p>排除依赖包</p>
<pre><code>&lt;exclusions&gt;
    &lt;exclusion&gt;
        &lt;groupId&gt;redis.clients&lt;/groupId&gt;
        &lt;artifactId&gt;jedis&lt;/artifactId&gt;
    &lt;/exclusion&gt;
&lt;/exclusions&gt;
</code></pre><p>设定编译jdk版本</p>
<pre><code>&lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;source&gt;1.8&lt;/source&gt;
                    &lt;target&gt;1.8&lt;/target&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL：基本命令</title>
    <url>/article/MySQL%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4.html</url>
    <content><![CDATA[<p>下面是网上找的资料：<a href="http://www.cnblogs.com/mr-wid/archive/2013/05/09/3068229.html" target="_blank" rel="noopener">http://www.cnblogs.com/mr-wid/archive/2013/05/09/3068229.html</a></p>
<p>复制过来，用到的时候翻出来看看</p>
<hr>
<p>MySQL 为关系型数据库(Relational Database Management System), 这种所谓的”关系型”可以理解为”表格”的概念, 一个关系型数据库由一个或数个表格组成</p>
<h1><span id="登录到mysql">登录到MySQL</span></h1><p>当 MySQL 服务已经运行时, 我们可以通过MySQL自带的客户端工具登录到MySQL数据库中, 首先打开命令提示符, 输入以下格式的命名:</p>
<pre><code>mysql -h 主机名 -u 用户名 -p
-h : 该命令用于指定客户端所要登录的MySQL主机名, 登录当前机器该参数可以省略;
-u : 所要登录的用户名;
-p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。
</code></pre><p>以登录刚刚安装在本机的MySQL数据库为例, 在命令行下输入 mysql -u root -p 按回车确认</p>
<p>然后命令提示符会一直以 mysql&gt; 加一个闪烁的光标等待命令的输入</p>
<p>例子：</p>
<pre><code>mysql -h10.16.44.210 -P3350 -uuser -ppassword
</code></pre><a id="more"></a>
<h1><span id="创建一个数据库">创建一个数据库</span></h1><p>使用 create database 语句可完成对数据库的创建, 创建命令的格式如下:</p>
<p>create database 数据库名 [其他选项];</p>
<p>例如我们需要创建一个名为 samp_db 的数据库, 在命令行下执行以下命令:</p>
<p>create database samp_db character set gbk;</p>
<p>为了便于在命令提示符下显示中文, 在创建时通过 character set gbk 将数据库字符编码指定为 gbk。创建成功时会得到 Query OK, 1 row affected(0.02 sec) 的响应。</p>
<p>提示: 可以使用 show databases; 命令查看已经创建了哪些数据库。</p>
<h1><span id="选择所要操作的数据库">选择所要操作的数据库</span></h1><p>要对一个数据库进行操作, 必须先选择该数据库</p>
<p>登录后使用 use 语句指定, 命令: use 数据库名;</p>
<p>use 语句可以不加分号, 执行 use samp_db 来选择刚刚创建的数据库, 选择成功后会提示: Database changed</p>
<h1><span id="创建数据库表">创建数据库表</span></h1><p>使用 create table 语句可完成对表的创建, create table 的常见形式:</p>
<p>create table 表名称(列声明);</p>
<p>以创建 students 表为例, 表中将存放 学号(id)、姓名(name)、性别(sex)、年龄(age)、联系电话(tel) 这些内容:</p>
<pre><code>create table students
（
    id int unsigned not null auto_increment primary key,
    name char(8) not null,
    sex char(4) not null,
    age tinyint unsigned not null,
    tel char(13) null default &quot;-&quot;
);
</code></pre><h1><span id="向表中插入数据">向表中插入数据</span></h1><p>insert 语句可以用来将一行或多行数据插到数据库表中, 使用的一般形式如下:</p>
<p>insert [into] 表名 [(列名1, 列名2, 列名3, …)] values (值1, 值2, 值3, …);</p>
<p>其中 [] 内的内容是可选的, 例如, 要给 samp_db 数据库中的 students 表插入一条记录, 执行语句:</p>
<p>insert into students values(NULL, “王刚”, “男”, 20, “13811371377”);</p>
<p>按回车键确认后若提示 Query Ok, 1 row affected (0.05 sec) 表示数据插入成功。<br>alter table 语句用于创建后对表的修改, 基础用法如下:</p>
<h1><span id="添加列">添加列</span></h1><p>基本形式: alter table 表名 add 列名 列数据类型 [after 插入位置];</p>
<p>示例:</p>
<p>在表的最后追加列 address: alter table students add address char(60);</p>
<p>在名为 age 的列后插入列 birthday: alter table students add birthday date after age;</p>
<h1><span id="修改列">修改列</span></h1><p>基本形式: alter table 表名 change 列名称 列新名称 新数据类型;</p>
<p>示例:</p>
<p>将表 tel 列改名为 telphone: alter table students change tel telphone char(13) default “-“;</p>
<p>将 name 列的数据类型改为 char(16): alter table students change name name char(16) not null;</p>
<h1><span id="删除列">删除列</span></h1><p>基本形式: alter table 表名 drop 列名称;</p>
<p>示例:</p>
<p>删除 birthday 列: alter table students drop birthday;</p>
<h1><span id="重命名表">重命名表</span></h1><p>基本形式: alter table 表名 rename 新表名;</p>
<p>示例:</p>
<p>重命名 students 表为 workmates: alter table students rename workmates;</p>
<h1><span id="删除整张表">删除整张表</span></h1><p>基本形式: drop table 表名;</p>
<p>示例: 删除 workmates 表: drop table workmates;</p>
<h1><span id="清空表">清空表</span></h1><p>truncate table 表名;</p>
<h1><span id="删除整个数据库">删除整个数据库</span></h1><p>基本形式: drop database 数据库名;</p>
<p>示例: 删除 samp_db 数据库: drop database samp_db;</p>
<h1><span id="导出数据">导出数据</span></h1><p>mysqldump -uusername -ppassword -hhost -Pport database table –skip-lock-tables &gt; table.sql</p>
<h1><span id="导入数据">导入数据</span></h1><p>mysqldump -uusername -ppassword -hhost -Pport database &lt; table.sql</p>
<h1><span id="可视化管理工具">可视化管理工具</span></h1><p>MySQL Workbench</p>
<h1><span id="查看端口">查看端口</span></h1><p>启动，并进入mysql后，输入命令：show global variables like ‘port’</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>Python：执行sh或py文件</title>
    <url>/article/Python%E6%89%A7%E8%A1%8Csh%E6%88%96py%E6%96%87%E4%BB%B6.html</url>
    <content><![CDATA[<p>不获取返回结果：</p>
<pre><code>import os

os.system(&quot;sh /path/xx.sh &#39;%s&#39;&quot; %(params))
</code></pre><p>获取返回结果：</p>
<pre><code>import commands

(status,output) = commands.getstatusoutput(&quot;/path/xx.sh &#39;%s&#39;&quot; %(params))
status是返回状态
output是返回结果
</code></pre><a id="more"></a>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL：安装</title>
    <url>/article/MySQL%E5%AE%89%E8%A3%85.html</url>
    <content><![CDATA[<p>下载地址<br><a href="https://cdn.mysql.com//Downloads/MySQL-5.7/mysql-5.7.19-macos10.12-x86_64.dmg" target="_blank" rel="noopener">链接</a></p>
<p>安装后终端输入</p>
<pre><code>mysql --version
</code></pre><p>提示错误</p>
<pre><code>mysql command not found
</code></pre><p>这是由于系统默认会查找/usr/bin下的命令，如果命令不在目录下，会找不到，需要映射一个链接到/usr/bin目录下，相当于建立一个链接文件。<br>首先要知道mysql命令或mysqladmin命令的完整路径，比如mysql的路径是：/usr/local/mysql/bin/mysql，则可以这样执行命令</p>
<pre><code>ln -s /usr/local/mysql/bin/mysql /usr/bin
</code></pre><a id="more"></a>
<p>启动mysql<br>进入系统偏好设置，最下边一行，找到mysql打开，点击”Start MySQL Server”，启动mysql<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/19.png" alt=""><br>设置密码</p>
<pre><code>sudo mysqladmin -u root -p password newpasswd
</code></pre><p>此时会提示你输入旧密码，旧密码在哪呢？<br>右侧的通知栏里会有<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/20.png" alt=""><br>提示</p>
<pre><code>mysqladmin: [Warning] Using a password on the command line interface can be insecure.
Warning: Since password will be sent to server in plain text, use ssl connection to ensure password safety.
</code></pre><p>密码设置成功<br>登陆</p>
<pre><code>mysql -u root -p
</code></pre><p>登陆成功！可以开始刺激了！</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL：数据库索引</title>
    <url>/article/MySQL%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95.html</url>
    <content><![CDATA[<p>mysql中索引是对数据库表中一列或多列的值进行排序的一种结构。</p>
<h1><span id="mysql数据库索引种类">MySQL数据库索引种类</span></h1><ul>
<li>主键索引。数据列不允许重复，不允许为NULL.一个表只能有一个主键</li>
<li>唯一索引。数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</li>
<li>普通索引。基本的索引类型，没有唯一性的限制，允许为NULL值。</li>
<li>全文索引。</li>
</ul>
<h1><span id="索引使用的规则">索引使用的规则</span></h1><ul>
<li>索引的列是出现在where子句中的列，或者连接子句中指定的列</li>
<li>数量较少的列，没有必要在此列建立索引。</li>
<li>使用短索引。如果对长字符串列进行索引，指定一个前缀长度，能够节省大量索引空间。</li>
<li>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构。</li>
<li>最左前缀<br>顾名思义，就是最左优先。在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。 </li>
</ul>
<h1><span id="索引实现算法">索引实现算法</span></h1><ul>
<li>B树<br>B树实现的索引可以被用在=,&gt;,&gt;=,&lt;,&lt;=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量.</li>
<li>Hash<br>Hash索引只能用于对等比较，例如=,&lt;=&gt;（相当于=）操作符。</li>
</ul>
<h1><span id="in-和exists">in 和exists</span></h1><p>mysql中的in语句是把外表和内表作连接，而exists语句是对外表作循环，每次循环再对内表进行查询。</p>
<ul>
<li>如果查询两个表大小相当，那么用in和exists差别不大。</li>
<li>如果两个表大小差距较大，则子查询表大的用exists，子查询表小的用in。</li>
<li>not in 和not exists，查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。</li>
</ul>
<a id="more"></a>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL：Limit分页优化</title>
    <url>/article/MySQL%EF%BC%9ALimit%E5%88%86%E9%A1%B5%E4%BC%98%E5%8C%96.html</url>
    <content><![CDATA[<h2><span id="传统分页">传统分页：</span></h2><p>Select * from table limit 10000,10;</p>
<p>Limit 10000,10 偏移量越大则越慢，这句 SQL 的执行逻辑是:<br>1.从数据表中读取第N条数据添加到数据集中<br>2.重复第一步直到 N = 10000 + 10<br>3.根据 offset 抛弃前面 10000 条数<br>4.返回剩余的 10 条数据</p>
<h2><span id="推荐分页">推荐分页：</span></h2><ul>
<li>分页方式一：<br>Select * from table WHERE id&gt;=23434 limit 11;</li>
<li>分页方式二：<br>Select * from table WHERE id &gt;= ( select id from table limit 10000,1 ) limit 10;</li>
<li>分页方式三：<br>Select * from table INNER JOIN (SELECT id from table limit 10000,10) USING(id)</li>
<li>分页方式四：<br>程序取ID: Select id from table limit 10000,10;<br>Select * from table WHERE ID in(123,456…);<a id="more"></a>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL：基础知识</title>
    <url>/article/MySQL%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</url>
    <content><![CDATA[<h1><span id="数据库事务">数据库事务</span></h1><p>事务是指作为单个逻辑工作单元执行的一系列操作，可以被看作一个单元的一系列SQL语句的集合。要么完全地执行，要么完全地不执行。</p>
<ul>
<li>原子性<br>事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。通常，与某个事务关联的操作具有共同的目标，并且是相互依赖的。如果系统只执行这些操作的一个子集，则可能会破坏事务的总体目标。原子性消除了系统处理操作子集的可能性。</li>
<li>一致性<br>事务将数据库从一种一致状态转变为下一种一致状态。也就是说，事务在完成时，必须使所有的数据都保持一致状态。</li>
<li>隔离性 由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。换句话说，一个事务的影响在该事务提交前对其他事务都不可见。</li>
<li>持久性<br>事务完成之后，它对于系统的影响是永久性的。该修改即使出现致命的系统故障也将一直保持。</li>
</ul>
<a id="more"></a>
<h1><span id="事务隔离">事务隔离</span></h1><p>基于锁实现<br>在DBMS中，可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</p>
<ul>
<li><p>行级锁<br>行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。<br>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
</li>
<li><p>表级锁<br>表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。<br>开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p>
</li>
<li><p>页级锁<br>页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。<br>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p>
</li>
</ul>
<h2><span id="事务隔离级别">事务隔离级别</span></h2><p>常见问题</p>
<ul>
<li>脏读：一个事务读到另一个事务，尚未提交的修改，就是脏读</li>
<li>幻读：同样的条件, 第1次和第2次读出来的记录数不一样。幻读的重点在于新增或者删除。</li>
<li>不可重复读：同样的条件, 你读取过的数据, 再次读取出来发现值不一样了。不可重复读的重点是修改。</li>
</ul>
<p>事务的隔离级别有4个，由低到高依次为：</p>
<ul>
<li>Read uncommitted（读未提交）</li>
<li>Read committed（读提交）</li>
<li>Repeatable read（重复读）</li>
<li>Serializable（序列化）</li>
</ul>
<h1><span id="死锁">死锁</span></h1><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方资源的现象。四个必要条件：互斥、请求和保持、非剥夺、循环等待。<br>常见的解决死锁的方法：</p>
<ul>
<li>事务中按同一顺序访问对象</li>
<li>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</li>
<li>尝试使用低隔离级别，升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</li>
</ul>
<h2><span id="悲观锁">悲观锁</span></h2><p>悲观锁指对数据被意外修改持保守态度，依赖数据库原生支持的锁机制来保证当前事务处理的安全性，防止其他并发事务对目标数据的破坏或破坏其他并发事务数据，将在事务开始执行前或执行中申请锁定，执行完后再释放锁定。这对于长事务来讲，可能会严重影响系统的并发处理能力。自带的数据库事务就是典型的悲观锁。</p>
<h2><span id="乐观锁">乐观锁</span></h2><p>乐观锁（Optimistic Lock），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>Python：调用jar包</title>
    <url>/article/Python%E8%B0%83%E7%94%A8jar%E5%8C%85.html</url>
    <content><![CDATA[<h1><span id="原理">原理</span></h1><p>python中,通过shell命令 commands.getoutput() 调用java</p>
<h1><span id="运行jar常见错误">运行jar常见错误</span></h1><p>linux运行</p>
<pre><code>java -cp hello.jar hello
java -cp dependencies.jar com.bj.spat.hello
</code></pre><p>产生错误</p>
<pre><code>Exception in thread &quot;main&quot; java.lang.UnsupportedClassVersionError: hello : Unsupported major.minor version 52.0
    at java.lang.ClassLoader.defineClass1(Native Method)
    at java.lang.ClassLoader.defineClass(ClassLoader.java:800)
    at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
    at java.net.URLClassLoader.defineClass(URLClassLoader.java:449)
    at java.net.URLClassLoader.access$100(URLClassLoader.java:71)
    at java.net.URLClassLoader$1.run(URLClassLoader.java:361)
    at java.net.URLClassLoader$1.run(URLClassLoader.java:355)
    at java.security.AccessController.doPrivileged(Native Method)
    at java.net.URLClassLoader.findClass(URLClassLoader.java:354)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:425)
    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:358)
    at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:482)
</code></pre><p>原因是由较高版本的JDK编译的java class文件试图在较低版本的JVM上运行产生的错误。<br><a id="more"></a><br>1、解决措施就是保证jvm（java命令）和jdk（javac命令）版本一致。如果是linux版本，则在命令行中分别输入java -version和javac-version命令来查看版本是否一致。这里假设都是1.7版本。</p>
<p>2、如果都一致，但还是解决不了问题，那么你肯定不是直接在命令行中用javac来编译的，而是用类似于eclipse、netbeans这样的编译器来编译的。因为很多编译器都自带javac，而不是采用操作系统中的编译器。如果你的编译器是eclipse的话，那么需要在项目的属性里设置jdk版本，方法是右击项目–&gt;properties–&gt;java compiler –&gt; Enable project specific settings –&gt;将compiler compliance  level设置为1.7，也就是与jvm一致的版本（在命令行中java -version所显示的版本）。</p>
<p>综上，如果你是用编译器来编译的话，请首先确保编译器自带的jdk版本是否和操作系统中的java版本一致。</p>
<h1><span id="给jar传参数">给jar传参数</span></h1><pre><code>java -cp hello.jar hello &quot;参数&quot;
</code></pre><pre><code>public class hello {
    public static void main(String []args) {
         System.out.println(args.length);
         for(int i=0;i&lt;args.length;i++)
         {
             System.out.println(args[i]);
         }
    }
}
</code></pre><pre><code>java -cp hello.jar hello 123456
</code></pre><p>输出<br>1<br>123456</p>
<h1><span id="python代码">python代码</span></h1><pre><code>import commands
import json

if __name__ == &quot;__main__&quot;:
    id = str(123)
    command = &quot;java -cp hello.jar hello &quot; + id
    line = str(commands.getoutput(command))
    print line

</code></pre><p>运行python<br>输出<br>1<br>123456</p>
<h1><span id="maven依赖包打jar包">maven依赖包打jar包</span></h1><p>1、maven pom中添加：</p>
<pre><code>  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
          &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
          &lt;!-- &lt;version&gt;2.1&lt;/version&gt; --&gt;
          &lt;configuration&gt;
              &lt;descriptorRefs&gt;
                  &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;
              &lt;/descriptorRefs&gt;
          &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
</code></pre><p>maven build输入命令：</p>
<pre><code>assembly::assembly
</code></pre><p>或</p>
<pre><code>mvn build： 把工程依赖包打到lib路径下
dependency:copy-dependencies -DoutputDirectory=lib

</code></pre>]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Redis：主从同步</title>
    <url>/article/Redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5.html</url>
    <content><![CDATA[<h1><span id="全量同步">全量同步</span></h1><p>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下：<br>　　1）从服务器连接主服务器，发送SYNC命令；<br>　　2）主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令；<br>　　3）主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；<br>　　4）从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；<br>　　5）主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；<br>　　6）从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；<br><a id="more"></a></p>
<h1><span id="增量同步">增量同步</span></h1><p>Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。<br>增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令</p>
<h1><span id="redis主从同步策略">Redis主从同步策略</span></h1><p>　　主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>Python集合</title>
    <url>/article/Python%E9%9B%86%E5%90%88.html</url>
    <content><![CDATA[<a id="more"></a>
<p><a href="https://www.streamlit.io/" target="_blank" rel="noopener">Streamlit</a></p>
<p><a href="http://hhkbp2.com/gevent-tutorial/#" target="_blank" rel="noopener">Gevent指南</a></p>
<p><a href="http://magic.iswbm.com/zh/latest/index.html" target="_blank" rel="noopener">Python黑魔法</a></p>
<p><a href="https://towardsdatascience.com/learn-advanced-features-for-pythons-main-data-analysis-library-in-20-minutes-d0eedd90d086" target="_blank" rel="noopener">A Comprehensive Guide to Pandas’ Advanced Features in 20 Minutes</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Redis：持久化</title>
    <url>/article/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html</url>
    <content><![CDATA[<h1><span id="rdb持久化">RDB持久化</span></h1><p>直接保存数据库的键值对。是二进制文件存储。指定的时间间隔内生成数据集的时间点快照</p>
<h2><span id="两个命令">两个命令:</span></h2><p>1 SAVE 会阻塞进程<br>2 BGSAVE 创建子进程处理文件，不会阻塞。父进程继续处理client请求，子进程负责将内存内容写入到临时文件。由于os的写时复制机制（copy on write)父子进程会共享相同的物理页面，当父进程处理写请求时os会为父进程要修改的页面创建副本，而不是写共享的页面。所以子进程的地址空间内的数 据是fork时刻整个数据库的一个快照。</p>
<p>redis可以设置自动性间隔保存<br>如:save 300 10<br>表明服务器300秒内至少调用10次，会自动调用BGSAVE命令</p>
<p>rdb文件结构：<br>redis-db_version-databases-EOF-check_sum</p>
<h2><span id="优势">优势</span></h2><p>一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这样非常方便进行备份。比如你可能打算没1天归档一些数据。<br>方便备份，我们可以很容易的将一个一个RDB文件移动到其他的存储介质上<br>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。<br>RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。<br><a id="more"></a></p>
<h2><span id="劣势">劣势</span></h2><p>如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。<br>每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， fork() 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端； 如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然 AOF 重写也需要进行 fork() ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。</p>
<h1><span id="aof持久化">AOF持久化</span></h1><p>redis会将每一个收到的写命令都通过write函数追加到文件中(默认是 appendonly.aof)。<br>当redis重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。当然由于os会在内核中缓存 write做的修改，所以可能不是立即写到磁盘上。这样aof方式的持久化也还是有可能会丢失部分修改。不过我们可以通过配置文件告诉redis我们想要 通过fsync函数强制os写入到磁盘的时机。有三种方式如下（默认是：每秒fsync一次）</p>
<p>如果：appendonly yes              //启用aof持久化方式，则redis优先使用aof<br>appendfsync 选项直接决定AOF持久化的效率与安全性。<br>appendfsync - always每次都把缓冲区的内容写入AOF文件。<br>appendfsync - everysec每秒都把缓冲区的内容写入AOF文件。</p>
<p>aof保存的是服务器的写命令。</p>
<p>aof重写优化</p>
<h2><span id="优势">优势</span></h2><p>使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync 。 AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。</p>
<p>AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 seek ， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， redis-check-aof 工具也可以轻易地修复这种问题。<br>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</p>
<p>AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。</p>
<h2><span id="劣势">劣势</span></h2><p>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</p>
<p>根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。</p>
<p>AOF 在过去曾经发生过这样的 bug ： 因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。 （举个例子，阻塞命令 BRPOPLPUSH 就曾经引起过这样的 bug 。） 测试套件里为这种情况添加了测试： 它们会自动生成随机的、复杂的数据集， 并通过重新载入这些数据来确保一切正常。 虽然这种 bug 在 AOF 文件中并不常见， 但是对比来说， RDB 几乎是不可能出现这种 bug 的。</p>
<h1><span id="抉择">抉择</span></h1><p>一般来说， 如果想达到高要求的数据安全性， 应该同时使用两种持久化功能。<br>如果你可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>SSH</title>
    <url>/article/SSH.html</url>
    <content><![CDATA[<h1><span id="ssh-是什么">SSH 是什么</span></h1><p>SSH(the Secure Shell), 是一个很流行的、强大的、基于软件的网络安全工具。它监听端口22的连接。任何时候，只要电脑向网络上发送数据，SSH都会自动加密。当接受到数据时，SSH会自动解密。这就是所谓的透明加密：用户象往常一样工作，并不会意识到他们的网络通讯受到了安全加密的保护。另外，SSH使用了现代的安全加密算法，可以用于大公司的关键应用。</p>
<p>SSH采用了client/server体系结构。管理员在服务器上运行SSH server, 用户使用SSH client向服务器发出请求，比如“让我登录吧”，“传送个文件给我”，“请执行这个命令”。client与server之间的所有通讯都进行了安全加密，以防被人修改。</p>
<p>基于SSH的产品可以是client或server, 也可以两者都包括。Uinx上的产品通常包含client和server两者；其它平台通常只有client，现在也出现了基于Windows的服务器。</p>
<a id="more"></a>
<h1><span id="ssh-不是什么">SSH 不是什么</span></h1><p>虽然SSH代表Secure Shell, 但是它并不是真正意义上的shell，他不是命令解释器，也不提供通配符扩展，命令历史等等。SSH的作用是创建一个“通道”，以便在远程计算机上运行 shell，类似于unix的rsh命令，但是在本地与远程计算机之间增加了端对端的加密。</p>
<p>SSH也不是一个完整的安全解决方案，不过所谓“完整的安全解决方案”是不存在的。它也不能防止“尝试闯入攻击”或“拒绝服务攻击”。它也无法消除病毒、木马、把咖啡洒到键盘上等其它危害。但是，它的确提供了稳固的、用户友好的加密与认证。</p>
<h1><span id="ssh-协议">SSH 协议</span></h1><p>SSH是一个协议，不是一个产品。它说明了在网络上如何进行安全通讯。SSH协议覆盖了认证、加密、网络数据传送的完整性等方面。简而言之，SSH在计算机之间构建网络连接，确保连接双方身份的真实性，同时，它还保证在此连接上传送的数据到达时不会被人更改，不会被他人窃听。</p>
<h1><span id="ssh-特点概述">SSH 特点概述</span></h1><p>安全远程登录、安全的文件传送、安全的远程命令执行、密钥与认证代理</p>
]]></content>
      <categories>
        <category>Unix/Linux</category>
      </categories>
  </entry>
  <entry>
    <title>TIMEWAIT状态过多的解决办法</title>
    <url>/article/TIMEWAIT%E7%8A%B6%E6%80%81%E8%BF%87%E5%A4%9A%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html</url>
    <content><![CDATA[<p>TIME_WAIT发生在TCP连接的四次挥手的阶段，在发起中断请求的一方产生<br>以客户端发起中断为例</p>
<pre><code>客户端先发送FIN，进入FIN_WAIT1状态
服务端收到FIN，发送ACK，进入CLOSE_WAIT状态
客户端收到这个ACK，进入FIN_WAIT2状态
服务端发送FIN，进入LAST_ACK状态
客户端收到FIN，发送ACK，进入TIME_WAIT状态，服务端收到ACK，进入CLOSE状态
客户端TIME_WAIT持续2倍MSL时长，在linux体系中大概是60s，转换成CLOSE状态
</code></pre><p>出现TIME_WAIT状态过多，怎么解决呢？<br>可以通过修改内核参数进行缓解<br>设置如下参数：<br><a id="more"></a></p>
<pre><code>net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_tw_recycle = 1
net.ipv4.tcp_fin_timeout = 30
</code></pre><p>/etc/sysctl.conf中进行配置<br>使用sysctl -p生效</p>
<p>含义：<br>net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭。<br>net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭。<br>net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。<br>net.ipv4.tcp_fin_timeout 修改系統默认的TIMEOUT 时间。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>tcpcopy工具</title>
    <url>/article/Tcpcopy%E5%B7%A5%E5%85%B7.html</url>
    <content><![CDATA[<h1><span id="tcpcopy工具分享">tcpcopy工具分享</span></h1><h1><span id="1工具介绍">1工具介绍</span></h1><p>tcpcopy 是一个分布式在线压力测试工具，可以将线上流量拷贝到测试机器，实时的模拟线上环境，达到在程序不上线的情况下实时承担线上流量的效果，尽早发现 bug，增加上线信心。</p>
<p>tcpcopy 的优势在于其实时性及真实性，除了少量的丢包，完全拷贝线上流量到测试机器，真实的模拟线上流量的变化规律。</p>
<h1><span id="2tcpcopy原理">2tcpcopy原理</span></h1><h2><span id="21tcpcopy原理">2.1tcpcopy原理</span></h2><p>下面以推荐系统中的内核作为后端说明tcpcopy的原理。</p>
<p>线上内核后端机开启 tcpcopy 客户端（tcpcopy 进程），测试内核后端机开启 tcpcopy 服务端（intercept 进程），且两台机器上都启动了推荐内核服务。</p>
<p>tcpcopy 拷贝一次流量访问的步骤如下：</p>
<pre><code>1.一个访问请求到达线上内核后端机；
2.socket 包在 IP 层被拷贝了一份传给tcpcopy 进程；
3.tcpcopy 修改包的目的及源地址，发给测试内核后端机；
4.拷贝的包到达测试内核后端机；
5.测试内核后端机的推荐内核处理访问，并返回结果；
6.返回结果在 IP 层被截获、丢弃，由 intercept 拷贝返回结果的 IP header 返回；
7.IP header 被发送给线上内核后端机的 tcpcopy 进程。
</code></pre><a id="more"></a>
<h2><span id="22引流模式">2.2引流模式</span></h2><p>引流模式分为离线回放、部分引流和放大引流三种模式。下面分别介绍这三种模式。</p>
<h3><span id="221离线回放">2.2.1离线回放</span></h3><p>　　用法：离线回放模式需要在configure 的时候加上–enable-offline 参数，离线回放还需要安装pcap 库和pcap 开发库（需要用到pcap 库的头文件），另外运行的时候需要指定-i 参数。</p>
<pre><code>#./tcpcopy -x 110-xxx.xxx.xxx.148:110 -i ./online.pcap
</code></pre><p>　　这里oline.pcap（利用tcpdump 的工具来抓请求数据包，存放到pcap 格式的文件中去）文件作为数据源，把请求转发到测试服务器上。此外增加-a参数对请求数据包的访问进行加速</p>
<pre><code>#./tcpcopy -x 80-xxx.xxx.x.xx:8080 -a 2 -i online.pcap
</code></pre><p>假设online.pcap 文件为在线请求数据包的抓包文件，时间间隔为60 分钟执行此命令后，离线回放加速了2 倍，只需要30 分钟离线回放就能完成，-a 参数设置不宜设置过大，越大丢请求的概率也越大。</p>
<p>　　适用场景：由于离线方式依赖于抓包工具（如tcpdump），而抓包工具在压力比较大的场合一般丢包非常严重，而且还会严重影响在线IO，因此一般不推荐在高压情况下使用离线回放方式</p>
<h3><span id="222部分引流">2.2.2部分引流</span></h3><p>　　用法：tcpcopy可以通过-r参数实现在线服务器应用的部分流量复制，参数范围是1～99，其它值都是全流量复制。-r 参数常用于测试服务器配置不如在线服务器的场合。</p>
<pre><code>#./tcpcopy -x 2080-xxx.xx.xx.xxx:9999 -r 20
</code></pre><p>这里tcpcopy 复制在线服务器2080 端口应用的20%流量给测试服务器，这里的20%是根据session（这里session 是由客户端IP，客户端端口决定）来统计的。<br>　　适用场景：部分引流主要适用于线上请求压力很多，而测试环境的处理能力较弱，这时候就只需复制部分线上的请求到测试环境，就可以压到测试环境的极限。</p>
<h3><span id="223放大引流">2.2.3放大引流</span></h3><p>　　用法：Tcpcopy可以通过-n参数对在线服务器应用的流量进行复制放到到测试服务器，如果你要进行多重复制，-n参数</p>
<pre><code>#./tcpcopy -x 2080-xxx.xx.x.xxx:9999 -n 3
</code></pre><p>表示复制3 倍的在线服务器的80 端口应用请求流量到192.168.0.2 的8080 端口<br>适用场景：放大引流主要用于线上压力较小时，想要通过无限构造压力通过成倍引流达到对测试服务器进行压力测试的目的。</p>
<h2><span id="23tcpcopy注意事项">2.3tcpcopy注意事项</span></h2><pre><code>1)Linux平台，内核2.6+ ；
2)TCPCOPY类似于UDP，所以会丢包，进而丢失请求 ；
3)本系统不支持域名，只支持ip地址 ；
4)tcpcopy服务端有可能会成为性能瓶颈；
5)丢失请求率跟网络状况有关，最好在内网内复制请求 ；
6)tcpcopy中的tcpcopy和intercept程序运行需要root权限；
7)tcpcopy只与ip、tcp层的数据有关，如果请求验证与tcp层以上的协议有关，则系统不能`正常运行。
</code></pre><h1><span id="3操作方法">3操作方法</span></h1><h2><span id="31安装方法">3.1安装方法</span></h2><p>1.tcpcopy：安装到线上内核后端机，tcpcopy.tar解压后放到线上内核后端机的目录下（/opt/soft/）</p>
<p>2.intercept：安装到测试内核后端机，intercept.tar解压后放到测试内核后端机的目录下(/opt/soft/)，</p>
<h2><span id="32部署方法">3.2部署方法</span></h2><p>假如有两台机器：</p>
<pre><code>机器A：线上内核后端机，ip：10.9.20.20，端口号：9909；
 机器B：测试内核后端机，ip：10.4.20.51，端口号：49908；
 两台机器上都起了推荐内核服务，操作者在两台机器上都需有root权限
操作步骤：
1.进入B机器root用户，在B上依次执行，
1)加载 ip_queue 模块，modprobe ip_queue；
2)配置 iptables 规则，
sudo -S /root/.init_sys/iptables -I OUTPUT -p tcp --sport 49908 -j QUEUE；
3)启动 tcpcopy 服务端，后台运行，sudo ./interception -d；(-d表示后台运行)
2.进入A机器root用户，在A上执行，
1)启动 tcpcopy 客户端，后台启动：
sudo ./tcpcopy -d -x 9909-10.4.20.51:49908；(-x表示分布式引流，-d 表示后台启动)；
2)若要复制线上多份流量，则如下启动tcpcopy客户端：
sudo ./tcpcopy -d -x 9909-10.4.20.51:49908 -n 10；(-x表示分布式引流，-d 表示后台启动，-n后的数字表示复制的份数)。
</code></pre><h1><span id="4总结">4总结</span></h1><p>tcpcopy工具可用于从前端到后端的请求的测试，可用于复制线上流量到本地测试机，因此，可以通过该工具在不上线时完成测试。利用此工具测试有以后优势：</p>
<pre><code>1.引用线上流量测试，减少上线bug，增加上线信心； 
2.分布式压力测试，将多台机器的请求集中到某台机器进行压力测试；
3.可复制线上多倍流量测试，可采用流量递增的方式，进行压力测试，发现系统bug和性能瓶颈；
4.tcpcopy分为在线模式和离线模式。在线模式就是实时拷贝线上流量，因此具有随机性，可以进行定性和定量分析。离线模式就是将线上流量保存到测试机器的磁盘上，可以用于定量分析；
5.占用系统资源很少，对在线系统影响很小。
</code></pre>]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>do{}while(false)</title>
    <url>/article/do%7B%7Dwhile(false).html</url>
    <content><![CDATA[<p>今天遇到了一段代码，类似下面</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>开始很疑惑，为什么这样写，后来上网搜了一下才恍然大悟。这种语法是为了解决代码嵌套、实现goto的用途</p>
<p>下面是同样功能的三段代码</p>
<p>1、代码嵌套<br><a id="more"></a></p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span> A<span class="token operator">==</span><span class="token boolean">true</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>B <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>C <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>D <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//doSomething</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样箭头形代码很丑，且可读性差</p>
<p>2、goto代码</p>
<pre><code>if( A==false )  
    goto tag;  
if( B==false )  
    goto tag;  
if( C==false )  
    goto tag;  
if( D==false )  
    goto tag; 
//doSomething
tag: 
</code></pre><p>3、do{}while(false)</p>
<p>这样的结构能够创造可读性良好的代码，又可以避免goto可能产生的问题</p>
<pre><code>do  
{  
    if( A==false )  
        break;  
    if( B==false )  
        break;  
    if( C==false )  
        break;  
    if( D==false )  
        break; 
    //doSomething
}while(false); 
</code></pre>]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>mlens-SuperLearner 模型集成</title>
    <url>/article/mlens-SuperLearner-%E6%A8%A1%E5%9E%8B%E9%9B%86%E6%88%90.html</url>
    <content><![CDATA[<a id="more"></a>
<p>SuperLearner所做的事情就是将多个模型的输出结果作为特征输入选择的基模型，弥补单个模型准召的不足。</p>
<p><a href="https://zhuanlan.zhihu.com/p/32949396" target="_blank" rel="noopener">每个Kaggle冠军的获胜法门：揭秘Python中的模型集成</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/36161812" target="_blank" rel="noopener">集成学习三大法宝-bagging、boosting、stacking</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>Java：使用ReentrantLock解决哲学家就餐问题</title>
    <url>/article/%E4%BD%BF%E7%94%A8ReentrantLock%E8%A7%A3%E5%86%B3%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<p>哲学家就餐问题可以这样表述，假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌中间有一大碗意大利面，每两个哲学家之间有一只餐叉。因为用一只餐叉很难吃到意大利面，所以假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐叉。哲学家就餐问题有时也用米饭和筷子而不是意大利面和餐叉来描述，因为很明显，吃米饭必须用两根筷子。</p>
<p>哲学家从来不交谈，这就很危险，可能产生死锁，每个哲学家都拿着左手的餐叉，永远都在等右边的餐叉（或者相反）。即使没有死锁，也有可能发生资源耗尽。</p>
<a id="more"></a>
<p>使用重入锁ReentrantLock解决。</p>
<p>代码：</p>
<pre><code>
public class Dinner {

    public static int SIZE = 10;
    public static ReentrantLock[] locks = new ReentrantLock[SIZE];

    public static class Person extends Thread{
        int pos;
        public Person(int pos) {
            this.pos = pos;
        }
         public void run() {
             while(true) {
                     try {
                         //哲学家思考
                         Thread.sleep(1000);
                    } catch (InterruptedException e1) {
                        e1.printStackTrace();
                    }
                    if(locks[pos].tryLock()) {
                        try {
                            if(locks[(pos+1)%SIZE].tryLock()) {
                                try {
                                     System.out.println(&quot;哲学家&quot; + pos + &quot;就餐中...&quot;);
                                     Thread.sleep(1000);
                                } catch (Exception e) {
                                    e.printStackTrace();
                                } finally {
                                     locks[(pos+1)%SIZE].unlock();
                                }
                             }
                         } finally {
                             locks[pos].unlock();
                         }
                     }
             }
         }
    };    
     public static void main(String[] args) {
            for (int i = 0; i &lt; SIZE; ++i)
                locks[i] = new ReentrantLock();

            for (int i = 0; i &lt; SIZE; ++i)
                new Person(i).start();
        }
}
</code></pre><p>输出：</p>
<pre><code>哲学家4就餐中...
哲学家8就餐中...
哲学家0就餐中...
哲学家6就餐中...
哲学家2就餐中...
哲学家9就餐中...
哲学家7就餐中...
哲学家5就餐中...
哲学家4就餐中...
哲学家6就餐中...
哲学家8就餐中...
哲学家1就餐中...
哲学家7就餐中...
哲学家0就餐中...
哲学家5就餐中...
哲学家3就餐中...
...
</code></pre>]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>协同过滤</title>
    <url>/article/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4.html</url>
    <content><![CDATA[<h1><span id="协同过滤">协同过滤</span></h1><p>什么是协同过滤 (Collaborative Filtering, 简称CF)，首先想一个简单的问题，如果你现在想看个电影，但你不知道具体看哪部，你会怎么做？大部分的人会问问周围的朋友，看看最近有什么好看的电影推荐，而我们一般更倾向于从口味比较类似的朋友那里得到推荐。这就是协同过滤的核心思想。</p>
<p>　　协同过滤一般是在海量的用户中发掘出一小部分和你品位比较类似的，在协同过滤中，这些用户成为邻居，然后根据他们喜欢的其他东西组织成一个排序的目录作为推荐给你。当然其中有一个核心的问题：如何确定一个用户是不是和你有相似的品位？如何将邻居们的喜好组织成一个排序的目录？<br><a id="more"></a></p>
<h1><span id="计算步骤">计算步骤</span></h1><p>1.收集用户偏好。<br>2.找到相似的用户或物品。<br>3.计算推荐。</p>
<h1><span id="找到相似的用户或物品">找到相似的用户或物品</span></h1><h2><span id="相似度计算">相似度计算</span></h2><p>最典型的 CF 的两个分支：基于用户的CF和基于物品的CF。这两种方法都需要计算相似度。<br>关于相似度的计算，现有的几种基本方法都是基于向量（Vector）的，其实也就是计算两个向量的距离，距离越近相似度越大，最简单的是欧几里德距离计算。</p>
<p>基于用户的协同过滤算法主要包括两个步骤：<br>(1) 找到和目标用户兴趣相似的用户集合。<br>(2) 找到这个集合中的用户喜欢的，且目标用户没有听说过的物品推荐给目标用户。</p>
<p>基于物品的协同过滤算法主要包括两步：<br>（1）计算物品之间的相似度。<br>（2）根据物品的相似度和用户的历史行为给用户生成推荐列表。</p>
<h2><span id="相似邻居的计算">相似邻居的计算</span></h2><p>可以使用K近邻算法。</p>
<h1><span id="优缺点">优缺点</span></h1><p>基于用户的CF和基于物品的CF，在使用中主要依靠用户/物品的数量及场景进行选择。<br>协同过滤存在冷启动的问题。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>天津之行</title>
    <url>/article/%E5%A4%A9%E6%B4%A5%E4%B9%8B%E8%A1%8C.html</url>
    <content><![CDATA[<p>前几周就想来天津玩，看权健的比赛。找了几次也没有找到志同的人。昨天在朋友圈看到同事去天津了，哇哇哇，不能把自己的事束缚在别人身上吧，所以今天一个人来天津了</p>
<p>简单的记录一下今天的天津之旅，整个过程还是值得推荐的</p>
<p>9.30出发，21.00返程</p>
<p>天津的建筑很有特色，街道很整洁。<br>首先到了天津站，外面就是海河，每隔几百米就有一座桥，沿着河走了一会，两侧的建筑和桥都很美<br><a id="more"></a><br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/25.jpg" alt=""><br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/26.jpg" alt=""><br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/27.jpg" alt=""><br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/28.jpg" alt=""></p>
<p>意大利风情街，像不像一堆小朋友向大叔脸上撒尿？哈哈哈哈哈<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/29.jpg" alt=""></p>
<p>去了文化街，果然各个城市的文化街都是一个样子，以后出去玩再也不去这种地方了，千篇一律。失望之后我也没有去小吃街</p>
<p>吃过午饭后，直奔本次的主题。天津权健主场，海河教育园体育场。权健的气氛真的和某球队不同，没有对对手的谩骂，甚至在对手进了一记漂亮的远射后，全场响起掌声。为天津，赢天下<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/30.jpg" alt=""><br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/31.jpg" alt=""><br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/32.jpg" alt=""></p>
<p>天津之眼！不评价太多，酷<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/33.jpg" alt=""><br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/34.jpg" alt=""></p>
<p>夜景也很好<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/35.jpg" alt=""><br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/36.jpg" alt=""><br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/37.jpg" alt=""></p>
<p>返程<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/38.jpg" alt=""></p>
]]></content>
      <categories>
        <category>扯淡</category>
      </categories>
  </entry>
  <entry>
    <title>威尔逊区间</title>
    <url>/article/%E5%A8%81%E5%B0%94%E9%80%8A%E5%8C%BA%E9%97%B4.html</url>
    <content><![CDATA[<p>在对物品进行排序时，我们会计算物品的好评度。</p>
<p>进行以下假设</p>
<pre><code>1、用户对物品的喜好是相互独立的
2、喜好问题是二分类，喜欢和不喜欢
3、假设好评的概率=点击数/曝光数
</code></pre><p>所以，具有这样特征的分布是二项分布。<br><a id="more"></a></p>
<p>假设A物品曝光10次，被点击9次，B物品曝光1000次，被点击900次。<br>如果按照点击率排序的话，A和B应该是获得一样分数的。但是B明显是优于A的，因为A样本少不具有说服性，所以需要进行优化。</p>
<p>我们需要计算物品的受欢迎程度，引入<a href="https://en.wikipedia.org/wiki/Binomial_proportion_confidence_interval#Wilson_score_interval" target="_blank" rel="noopener">威尔逊区间公式</a>，对样本数目进行惩罚。<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/62.png" alt=""></p>
<p>其中u是该物品点击数，v是曝光未点击数，n是曝光数，p是点击率，z是设置的正态分布参数，S是威尔逊分数。<br>我们可以看到，n足够大的时候，S无限趋于p，n很小时，S远小于p。</p>
<p>这样就解决了样本数目带来的干扰。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>小米路由器通过Clash设置代理</title>
    <url>/article/%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A8%E9%80%9A%E8%BF%87Clash%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86.html</url>
    <content><![CDATA[<a id="more"></a>
<p>分为以下几个步骤：</p>
<ul>
<li>首先开启路由器SSH功能</li>
<li>SSH登录到路由器</li>
<li>在路由器下载Clash</li>
<li>配置Clash，重启生效</li>
</ul>
<h4><span id="开启ssh权限">开启SSH权限</span></h4><p>首先登陆你的路由器管理界面，点击路由状态页签，此时地址栏应该显示如下地址：</p>
<p><a href="http://miwifi.com/cgi-bin/luci/;stok=xxxxxxx****/web/home#router***" target="_blank" rel="noopener">http://miwifi.com/cgi-bin/luci/;stok=xxxxxxx****/web/home#router***</a>*</p>
<p>或者</p>
<p><a href="http://192.168.31.1/cgi-bin/luci/;stok=xxxxxxx****/web/home#router" target="_blank" rel="noopener">http://192.168.31.1/cgi-bin/luci/;stok=xxxxxxx****/web/home#router</a></p>
<p>将/web/home#router 替换为如下文本，之后输入回车访问，此时页面返回{“code”:0}，即可使用ssh工具测试是否开启成功。</p>
<pre class="line-numbers language-shell"><code class="language-shell">/api/misystem/set_config_iotdev?bssid=Xiaomi&user_id=longdike&ssid=-h%3B%20nvram%20set%20ssh_en%3D1%3B%20nvram%20commit%3B%20sed%20-i%20's%2Fchannel%3D.*%2Fchannel%3D%5C%22debug%5C%22%2Fg'%20%2Fetc%2Finit.d%2Fdropbear%3B%20%2Fetc%2Finit.d%2Fdropbear%20start%3B%20echo%20-e%20'admin%5Cnadmin'%20%7C%20passwd%20root%3B
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4><span id="登陆ssh">登陆SSH</span></h4><p>Mac下的iTerm即可  ssh <a href="mailto:root@192.168.31.1" target="_blank" rel="noopener">root@192.168.31.1</a>  默认密码为 admin （刚刚那串破解码中设定的密码）</p>
<h4><span id="安装shellclash">安装ShellClash</span></h4><p>成功登陆SSH后，直接输入以下命令</p>
<pre class="line-numbers language-shell"><code class="language-shell">sh -c "$(curl -kfsSl https://cdn.jsdelivr.net/gh/juewuy/clash-for-Miwifi@master/install.sh)" && source /etc/profile &> /dev/null
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>按照提示即可完成安装！<br>安装完成后，直接在SSH中使用：</p>
<pre class="line-numbers language-shell"><code class="language-shell">clash
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>命令即可管理脚本</p>
<h4><span id="导入clash配置文件">导入clash配置文件</span></h4><p>订阅是用的 cmy.network，使用该邀请链接注册可增加时长！  邀请链接：<a href="http://www.gotomony.com/register?aff=S33P5H" target="_blank" rel="noopener">http://www.gotomony.com/register?aff=S33P5H</a></p>
<p>然后通过  <a href="https://acl4ssr-sub.github.io/" target="_blank" rel="noopener">ACL4SSR 在线订阅转换</a>  转化cmy.network的订阅链接为clash配置链接</p>
<p>最后添加clash配置链接到路由器即可使用</p>
<ul>
<li>可视化界面：clash服务成功启动后可以通过在浏览器访问 <a href="http://192.168.31.1:9999/ui" target="_blank" rel="noopener">http://192.168.31.1:9999/ui</a> 设置代理 </li>
</ul>
<p>参考：</p>
<p><a href="https://qust.me/post/ax9000_shellclash/" target="_blank" rel="noopener">小米 AX9000 解锁 SSH 安装 ShellClash 教程｜地表最强硬路由💪 | 酱紫表 (qust.me)</a></p>
<p><a href="https://juewuy.github.io/post/clash-for-miwifi-an-zhuang-ji-shi-yong-jiao-cheng/" target="_blank" rel="noopener">在路由器上安装及使用ShellClash的教程 | Juewuy’s Blog</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>感知哈希</title>
    <url>/article/%E6%84%9F%E7%9F%A5%E5%93%88%E5%B8%8C.html</url>
    <content><![CDATA[<p>感知哈希算法，可用来进行图像之间相似度的计算。简单理解，速度快，思想上是用字符串去描述一幅图像。<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/61.PNG" alt=""><br><a id="more"></a></p>
<p>算法简单实现：<br>1、缩小尺寸<br>将图像处理成8*8大小的尺寸，64个像素。</p>
<p>2、灰度处理<br>将8*8的图像处理成灰度图。</p>
<p>3、计算平均值<br>计算64个像素灰度的平均值。</p>
<p>4、比较灰度值<br>将小于平均值的像素点值置为0，否则置为1。</p>
<p>5、计算哈希值<br>8*8的图片像素值可以构成一串64位的01数字。</p>
<p>比较图片是否相似：计算两个图片哈希值的汉明距离，小于5则认为十分接近，大于10的话则认为是不同的图片。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习：L1/L2正则化</title>
    <url>/article/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-L1-L2%E6%AD%A3%E5%88%99%E5%8C%96.html</url>
    <content><![CDATA[<a id="more"></a>
<h1><span id="正则化概念">正则化概念</span></h1><p>是机器学习中一种常用的技术，其主要目的是控制模型复杂度，减小过拟合。最基本的正则化方法是在原目标（代价）函数 中添加惩罚项，对复杂度高的模型进行“惩罚”。</p>
<p>下面图中黑色的折线就是过拟合的例子：<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos2/2.png" alt=""></p>
<p>常用的正则化函数有两种，L1正则化和L2正则化<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos2/3.png" alt=""></p>
<p>其中，<br>L1正则化表示某个向量中所有元素绝对值的和。<br>性质是能产生稀疏性，导致 W 中许多项变成零。会使原最优解的元素产生不同量的偏移，并使某些元素为0或趋近于0。</p>
<p>L2正则化表示某个向量中所有元素平方和再开根， 也就是欧几里得距离公式。<br>不具有产生稀疏解的能力，计算量上并没有得到提升。 L2正则化的效果是对原最优解的每个元素进行不同比例的放缩。</p>
<p>引用知乎上文章的解释：<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos2/6.png" alt=""></p>
<p>上图中，若不加正则项，最优解是靠近中心点的等高线，加入正则项之后，最优解对应的等高线不会离中心太近，避免了过拟合。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习：常用损失函数</title>
    <url>/article/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B8%B8%E7%94%A8%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0.html</url>
    <content><![CDATA[<ol>
<li>铰链损失（Hinge Loss）：主要用于支持向量机（SVM） 中； </li>
<li>互熵损失 （Cross Entropy Loss，Softmax Loss ）：用于Logistic 回归与Softmax 分类中； </li>
<li>平方损失（Square Loss）：主要是最小二乘法（OLS）中； </li>
<li>指数损失（Exponential Loss） ：主要用于Adaboost 集成学习算法中； </li>
<li>其他损失（如0-1损失，绝对值损失）<a id="more"></a>
</li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习笔记：XGBoost</title>
    <url>/article/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AXGBoost.html</url>
    <content><![CDATA[<h1><span id="xgboost">XGBoost</span></h1><p>XGBoost可以看做是GBDT的一种实现方式，目前在竞赛和工业界都被大量应用，并取得了很好的效果。</p>
<h2><span id="boostedtree">BoostedTree</span></h2><h3><span id="回归树">回归树</span></h3><p>BoostedTree的基本组成部分是回归树（Classification And Regression Tree），称作CART。<br>回归树会把输入的数据，分配到叶子节点上去，每个叶子节点都对应一个实数，非叶子节点都是一个二叉树。属于决策树的一种。<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/52.png" alt=""></p>
<a id="more"></a>
<p>决策树自上而下建立，根据属性值大小分裂为左右两个节点。</p>
<h3><span id="treeensemble">TreeEnsemble</span></h3><p>一颗回归树往往无法正确的做出预测，所以可以将多棵树的预测进行一个组合，得到最终的结果。<br>预测结果就是各个回归树的和。<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/53.png" alt=""></p>
<h2><span id="模型组成">模型组成</span></h2><h3><span id="模型和参数">模型和参数</span></h3><p>简单来说，模型是指给定xi如何去预测yi.<br>比较常见的模型如线性模型，yi=w*xi+z,其中w和z就是我们需要预测的值。</p>
<h3><span id="目标函数误差函数正则项">目标函数=误差函数+正则项</span></h3><p><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/54.png" alt=""></p>
<p>误差函数又称损失函数，是为了尽可能的提高模型预测正确性。一般代表误差，如平方误差等。<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/84.png" alt=""></p>
<p>正则项是为了防止过拟合样本数据。常见线性模型有L1、L2正则。</p>
<h2><span id="模型原理">模型原理</span></h2><p>boosting的过程中，每次保留前面的模型不变，加入一个新的函数到模型中，目标函数如下：<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/55.png" alt=""></p>
<p>每次加入怎样的函数呢？当然是使得目标函数尽量小的函数<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/56.png" alt=""></p>
<p>如果为平方误差的情形下，目前函数可以写成<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/57.png" alt=""></p>
<p>对于不是平方误差的情况，我们会采用如下的泰勒展开近似来定义一个近似的目标函数，方便我们进行这一步的计算。<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/58.png" alt=""></p>
<p>当我们把常数项移除之后，我们会发现如下一个比较统一的目标函数。这一个目标函数有一个非常明显的特点，它只依赖于每个数据点的在误差函数上的一阶导数和二阶导数. 误差函数为<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/59.png" alt=""></p>
<p>一阶导数、二阶导数为</p>
<p><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/60.png" alt=""></p>
<h2><span id="模型参数">模型参数</span></h2><h3><span id="增加随机性">增加随机性</span></h3><ul>
<li>eta 为了防止过拟合，更新过程中用到的收缩步长。</li>
<li>subsample 这个就是随机森林的方式，每次不是取出全部样本，而是有放回地取出部分样本。有人把这个称为行抽取，subsample就表示抽取比例</li>
<li>colsample_bytree和colsample_bylevel 这个是模仿随机森林的方式，这是列抽取。colsample_bytree是每次准备构造一棵新树时，选取部分特征来构造，colsample_bytree就是抽取比例。colsample_bylevel表示的是每次分割节点时，抽取特征的比例。</li>
<li>max_delta_step 这个是构造树时，允许得到ft(x)的最大值。如果为0，表示无限制。也是为了后续构造树留出空间，和eta相似</li>
</ul>
<h3><span id="控制模型复杂度">控制模型复杂度</span></h3><ul>
<li>max_depth 树的最大深度</li>
<li>min_child_weight 叶节点最小样本数</li>
<li>gamma 每次分开一个节点后，造成的最小下降的分数。类似于上面的Gain</li>
<li>alpha和lambda就是目标函数里的表示模型复杂度中的L1范数和L2范数前面的系数</li>
</ul>
<h3><span id="其他参数">其他参数</span></h3><ul>
<li>num_class 分类数</li>
<li>booster 表示用哪种模型，一共有gbtree, gbline, dart三种选择。一般用gbtree。</li>
<li>nthread 并行线成数。如果不设置就是能采用的最大线程。</li>
<li>sketch_eps 这个就是近似算法里的ϵ。</li>
<li>scale_pos_weight 这个是针对二分类问题时，正负样例的数量差距过大。</li>
</ul>
<h2><span id="控制过拟合">控制过拟合</span></h2><p>通常可以通过两种方式来控制xgboost中的过拟合</p>
<ul>
<li>第一种方式是直接控制模型的复杂性<br>包括参数：max_depth，min_child_weight 和 gamma</li>
<li>第二种方法是增加随机性<br>包括参数：subsample，colsample_bytree，eta</li>
</ul>
<h2><span id="与gbdt的差别">与GBDT的差别</span></h2><ul>
<li>传统GBDT以CART作为基分类器，xgboost还支持线性分类器。</li>
<li>传统GBDT在优化时只用到一阶导数信息，xgboost则对代价函数进行了二阶泰勒展开，同时用到了一阶和二阶导数。</li>
<li>xgboost在代价函数里加入了正则项，用于控制模型的复杂度。</li>
<li>xgboost的权重衰减。</li>
<li>xgboost支持更好的并行。</li>
</ul>
<h1><span id="如何画xgboost里面的决策树">如何画XGBoost里面的决策树</span></h1><p><a href="https://zhuanlan.zhihu.com/p/32943164" target="_blank" rel="noopener">如何画XGBoost里面的决策树</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习笔记：特征工程基本方法</title>
    <url>/article/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95.html</url>
    <content><![CDATA[<h1><span id="为什么要做特征工程">为什么要做特征工程？</span></h1><p>“数据和特征决定了机器学习的上限，而模型和算法是在逼近这个上限而已”，所以数据是机器学习的基础。数据来源是各种各样的，文本、语音、视频、图片等，原始的数据必须以特征的形式，加入到模型中，才能进行训练</p>
<h1><span id="特征工程方法">特征工程方法</span></h1><h2><span id="1-one-hot编码">1、One-Hot编码</span></h2><p>避免连续值导致模型的“误解”</p>
<h2><span id="2-离散化">2、离散化</span></h2><p>对数据进行分区分桶操作</p>
<h2><span id="3-连续值">3、连续值</span></h2><p>使用属性的连续值，某些模型对连续型的特征处理有比较好的效果</p>
<h2><span id="4-特征交叉">4、特征交叉</span></h2><p>两个甚至多个特征，进行特征组合，形成一组新的特征</p>
<h2><span id="5-归一化">5、归一化</span></h2><p>机器学习中，对数据进行分析之前，都会对数据进行归一化处理，这样做是为了消除部分特征数据对整体结果的影响。一般来说，是通过特定的方法，对数据的区间进行缩放处理，使之达到一个合适值，使各个指标处于同一个数量级。常见的是将数值处理成[0,1]之间的小数</p>
<h3><span id="51-最大最小标准化">5.1 最大最小标准化</span></h3><p>通过特征的最大最小值，将每个值处理成[0,1]区间的数字，公式如下<br>设最大maxA,最小值为minA，y=(x-minA)/(maxA-minA)</p>
<h3><span id="52-对数函数">5.2 对数函数</span></h3><p>y=log10(x)</p>
<h3><span id="53-z-score标准化">5.3 z-score标准化</span></h3><p>通过特征的平均值和标准差，进行数据处理，公式为：<br>y=(x-μ)/σ 其中x为某一分数，μ为平均数，σ为标准差。<br>y的含义就是x与平均值之间的距离，衡量单位是标准差</p>
<h1><span id="6-二值化">6、二值化</span></h1><p>取值为 0,1</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习笔记：基本数学公式</title>
    <url>/article/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.html</url>
    <content><![CDATA[<h1><span id="概率论">概率论</span></h1><h2><span id="全概率公式">全概率公式</span></h2><p>对一复杂事件A的概率求解问题转化为了在不同情况下发生的简单事件的概率的求和问题。如果事件B1、B2、B3…Bn 构成一个完备事件组，即它们两两互不相容，其和为全集；并且P(Bi)大于0，则对任一事件A有 P(A)=P(A|B1)<em>P(B1) + P(A|B2)</em>P(B2) + … + P(A|Bn)*P(Bn).</p>
<h2><span id="贝叶斯公式">贝叶斯公式</span></h2><p>贝叶斯公式用来描述两个条件概率之间的关系，比如 P(A|B) 和 P(B|A)。按照乘法法则：P(A∩B)=P(A)<em>P(B|A)=P(B)</em>P(A|B)，可以立刻导出。如上公式也可变形为：P(B|A)=P(A|B)*P(B)/P(A)。而其中的P(A)可以由全概率公式展开。得到最终的贝叶斯公式<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/71.jpg" alt=""><br>如果B事件是有多个独立子事件构成，那么公式如下：<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/72.jpg" alt=""><br><a id="more"></a></p>
<h2><span id="常见离散型分布">常见离散型分布</span></h2><h3><span id="bernoulli分布">Bernoulli分布</span></h3><p>又名两点分布或者0-1分布。若Bernoulli试验成功，则Bernoulli随机变量X取值为1，否则X为0。记试验成功概率为θ，即P(X=1)=θ,p(X=0)=1-θ。均值μ=θ，方差 =θ(1-θ)</p>
<h3><span id="二项分布">二项分布</span></h3><p>二项分布即重复n次独立的伯努利试验。在每次试验中只有两种可能的结果，而且两种结果发生与否互相对立，并且相互独立，与其它各次试验结果无关，事件发生与否的概率在每一次独立试验中都保持不变，则这一系列试验总称为n重伯努利实验<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/73.png" alt=""></p>
<h3><span id="多项分布">多项分布</span></h3><p>把二项分布公式推广至多种状态，就得到了多项分布。例如1出现k1次，2出现k2次，3出现k3次的概率分布情况。<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/74.png" alt=""></p>
<h3><span id="泊松分布">泊松分布</span></h3><p>这个分布是S.-D.泊松研究二项分布的渐近公式时提出来的。泊松分布P (λ)中只有一个参数λ ，它既是泊松分布的均值，也是泊松分布的方差。在实际事例中，当一个随机事件，例如某电话交换台收到的呼叫、来到某公共汽车站的乘客、某放射性物质发射出的粒子、显微镜下某区域中的白血球等等，以固定的平均瞬时速率λ(或称密度)随机且独立地出现时，那么这个事件在单位时间（面积或体积）内出现的次数或个数就近似地服从泊松分布。<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/75.png" alt=""></p>
<h2><span id="常见连续型分布">常见连续型分布</span></h2><h3><span id="均匀分布">均匀分布</span></h3><p>随机变量X在区间[a,b]上均匀分布。<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/76.jpg" alt=""></p>
<h3><span id="高斯分布">高斯分布</span></h3><p>对模型残差或噪声能很好建模。<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/77.png" alt=""></p>
<h3><span id="t分布laplace分布gamma分布beta分布">t分布，laplace分布，gamma分布，beta分布</span></h3><p>Laplace分布：相比于高斯分布，Laplace分布更集中有均值附近。<br>Gamma分布：a为形状参数，b为比率度参数<br>Beta分布：beta分布的支持区间为[0,1]</p>
<h2><span id="弱大数定律和中心极限定理">弱大数定律和中心极限定理</span></h2><p>独立同分布的随机变量序列X1,x2,…,Xn，E(Xi)=u,方差σ2，则样本均值依概率收敛于期望u。即</p>
<p>中心极限定理：设从均值为μ、方差为σ^2;（有限）的任意一个总体中抽取样本量为n的样本，当n充分大时，样本均值的抽样分布近似服从均值为μ、方差为σ^2/n 的正态分布。</p>
<h2><span id="极大似然估计">极大似然估计</span></h2><p>极大似然估计是建立在这样的思想上：已知某个参数能使这个样本出现的概率最大，我们当然不会再去选择其他小概率的样本，所以干脆就把这个参数作为估计的真实值。</p>
<p>求极大似然函数估计值的一般步骤：</p>
<pre><code>（1） 写出似然函数，即每个随机实验出现概率相乘，为这个抽样出现的概率。
（2） 对似然函数取对数，为了方便求导；
（3） 对参数求导数。
（4） 令导数=0，即求解极值，由实际情况知，该极值为极大值。解似然方程。
</code></pre>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习笔记：矩阵</title>
    <url>/article/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%9F%A9%E9%98%B5.html</url>
    <content><![CDATA[<h2><span id="矩阵的行列式">矩阵的行列式</span></h2><p><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/70.png" alt=""></p>
<h2><span id="奇异矩阵">奇异矩阵</span></h2><p>奇异矩阵是线性代数的概念，就是对应的行列式等于0的矩阵。</p>
<p>奇异矩阵的判断方法：首先，看这个矩阵是不是方阵（即行数和列数相等的矩阵。若行数和列数不相等，那就谈不上奇异矩阵和非奇异矩阵）。 然后，再看此方阵的行列式|A|是否等于0，若等于0，称矩阵A为奇异矩阵；若不等于0，称矩阵A为非奇异矩阵。 同时，由|A|≠0可知矩阵A可逆，这样可以得出另外一个重要结论:可逆矩阵就是非奇异矩阵，非奇异矩阵也是可逆矩阵。<br><a id="more"></a></p>
<h2><span id="非奇异矩阵">非奇异矩阵</span></h2><p>n 阶方阵 A 是非奇异矩阵的充要条件是 A 可逆，即可逆方阵就是非奇异矩阵。</p>
<h2><span id="单位矩阵">单位矩阵</span></h2><p>在矩阵的乘法中，有一种矩阵起着特殊的作用，如同数的乘法中的1，这种矩阵被称为单位矩阵。它是个方阵，从左上角到右下角的对角线（称为主对角线）上的元素均为1。除此以外全都为0。</p>
<h2><span id="逆矩阵">逆矩阵</span></h2><p>设A是数域上的一个n阶方阵，若在相同数域上存在另一个n阶矩阵B，使得： AB=BA=E ，则我们称B是A的逆矩阵，而A则被称为可逆矩阵。注：E为单位矩阵。<br>A的逆矩阵记作A-1。</p>
<h2><span id="矩阵转置">矩阵转置</span></h2><p>设A为m×n阶矩阵（即m行n列），第i 行j 列的元素是a(i,j)，即：A=a(i,j)<br>定义A的转置为这样一个n×m阶矩阵B，满足B=a(j,i)，即 b (i,j)=a (j,i)（B的第i行第j列元素是A的第j行第i列元素），记A’=B。(有些书记为A^T，这里T为A的上标）</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习：ROC曲线及AUC含义</title>
    <url>/article/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%9AROC%E6%9B%B2%E7%BA%BF%E5%8F%8AAUC%E5%90%AB%E4%B9%89.html</url>
    <content><![CDATA[<h1><span id="roc曲线">ROC曲线</span></h1><p>Receiver Operating Characteristic curve（受试者工作特征曲线）</p>
<p>我们将二分类器的所有可能取值，做一个方格图如下：<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/81.png" alt=""></p>
<ul>
<li>TP —— True Positive （真正, TP）被模型预测为正的正样本（原来为正预测为正）</li>
<li>TN —— True Negative（真负 , TN）被模型预测为负的负样本（原来为负预测为负）</li>
<li>FP ——False Positive （假正, FP）被模型预测为正的负样本（原来为负预测为正）</li>
<li>FN—— False Negative（假负 , FN）被模型预测为负的正样本 （原来为正预测为负）</li>
</ul>
<p>TP + TN + FP + FN = 样本总数。<br>两个指标，准确率和召回率</p>
<ul>
<li>准确率 P = TP/(TP + FP)</li>
<li>召回率 R = TP/(TP + FN)</li>
</ul>
<p>下图为ROC曲线图：<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/82.png" alt=""><br>图像的横轴是False Positive rate值（不是FP值），也就是实际为负并且预测错误的个数占总的负值的比例；图像的纵轴是True Positive rate值（不是TP值），也就是实际为正值并且预测正确的个数占总的正值的比例。</p>
<h2><span id="roc曲线中的四点一线">ROC曲线中的“四点一线”</span></h2><ul>
<li>第一个点，(0,1)，即FPR=0, TPR=1，这意味着FN（false negative）=0，并且FP（false positive）=0。这是一个完美的分类器，它将所有的样本都正确分类。</li>
<li>第二个点，(1,0)，即FPR=1，TPR=0，类似地分析可以发现这是一个最糟糕的分类器，因为它成功避开了所有的正确答案。</li>
<li>第三个点，(0,0)，即FPR=TPR=0，即FP（false positive）=TP（true positive）=0，可以发现该分类器预测所有的样本都为负样本（negative）。</li>
<li>第四个点（1,1），分类器实际上预测所有的样本都为正样本。</li>
</ul>
<p>对于ROC曲线，我们可以这样理解，对于二分类问题，曲线的每一个点都代表一个阈值，分类器给每个样本一个得分，得分大于阈值的我们认为是正样本，小于阈值的我们认为是负样本。</p>
<ul>
<li>若学习器A的ROC曲线将另外一个学习器B的曲线完全包住，则A的性能一定比B好</li>
<li>AUC值等于0.5时，我们可以认为分类器不起作用</li>
</ul>
<h1><span id="auc值">AUC值</span></h1><p>Area Under Curve score (曲线下面积值)，也就是ROC曲线之下与坐标轴围成的面积。<br>AUC值是一个概率值，当你随机挑选一个正样本以及一个负样本，当前的分类算法根据计算得到的Score值将这个正样本排在负样本前面的概率就是AUC值。AUC值越大，当前的分类算法越有可能将正样本排在负样本前面，即能够更好的分类。</p>
<h1><span id="下面是觉得不错的相关文章">下面是觉得不错的相关文章</span></h1><p><a href="https://zhuanlan.zhihu.com/p/52930683" target="_blank" rel="noopener">乱弹机器学习评估指标AUC</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习笔记：线性回归</title>
    <url>/article/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92.html</url>
    <content><![CDATA[<h2><span id="线性回归linearregreesion">线性回归（LinearRegreesion）</span></h2><p>线性回归主要用来解决连续值预测的问题.</p>
<p>线性回归，是利用数理统计中回归分析，来确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法，运用十分广泛。其表达形式为y = w’x+e，e为误差服从均值为0的正态分布。中学就有接触线性回归，那么线性回归应用在什么地方呢？它适用于有监督学习的预测。 </p>
<p>一元线性回归分析：y=ax+b，只包括一个自变量和一个因变量，且二者的关系可用一条直线近似表示。</p>
<p>多元线性回归分析：包括两个或两个以上的自变量，并且因变量和自变量是线性关系。</p>
<h2><span id="损失函数">损失函数</span></h2><p>损失函数：是指一种将一个事件（在一个样本空间中的一个元素）映射到一个表达与其事件相关的经济成本或机会成本的实数上的一种函数。更通俗地说，损失函数用来衡量参数选择的准确性。损失函数得到的值越小，损失也就越小。<br><a id="more"></a></p>
<h2><span id="梯度下降">梯度下降</span></h2><p>怎样最小化损失函数?损失函数的定义是一个凸函数，就可以使用凸优化的一些方法：<br>１) 梯度下降：逐步最小化损失函数的过程。如同下山的过程，找准下山方向（梯度），每次迈进一步，直至山底。如果有多个特征，对应多个参数θ，需要对每一个参数做一次迭代，做完以后再求J函数。<br>　　学习率：上段公式中的α就是学习率。它决定了下降的节奏快慢，就像一个人下山时候步伐的快慢。α过小会导致收敛很慢，α太大有可能会导致震荡。如何选择学习率呢，目前也有好多关于学习率自适应算法的研究。工程上，一般会调用一些开源包，包含有一些自适应方法。自己做的话会选择相对较小的α，比如0.01。下图展示了梯度下降的过程。<br>2）牛顿法：速度快适用于小数据，大数据比较耗内存。</p>
<h2><span id="过拟合与正则化">过拟合与正则化</span></h2><p>回归与欠/过拟合：<br>１) 欠拟合：函数假设太简单导致无法覆盖足够的原始数据，可能造成数据预测的不准确。 </p>
<p>２) 拟合问题：比如我们有很多的特征，假设的函数曲线对原始数据拟合的非常好，从而丧失一般性，导致对新给的待预测样本，预测效果差。</p>
<p>过拟合解决方法：<br>1) 减少特征个数：手工选择保留特征、模型选择的算法选择特征。<br>2) 正则化：在原来的损失函数中加入θ的平方项，来防止波动太大。即L2正则化。留下所有的特征，但是减少参数的大小。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习笔记：逻辑回归</title>
    <url>/article/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92.html</url>
    <content><![CDATA[<a id="more"></a>
<p>逻辑回归（Logistic Regression）是机器学习中的一种分类模型，用概率的方法预测。</p>
<h2><span id="损失函数">损失函数</span></h2><p>交叉熵损失函数的推导:<br><a href="https://www.cnblogs.com/bonelee/p/7253508.html" target="_blank" rel="noopener">https://www.cnblogs.com/bonelee/p/7253508.html</a></p>
<h2><span id="逻辑函数">逻辑函数</span></h2><p>sigmoid 函数</p>
<p><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/85.png" alt=""><br>带入的x为样本的特征向量。</p>
<p>从上图可以看到sigmoid函数是一个严格单调递增的s形的曲线，它的取值在[0, 1]之间，在远离0的地方函数的值会很快接近0/1，收敛速度较快。</p>
<h2><span id="优点">优点</span></h2><p>1) LR是以概率的形式输出结果，不只是0和1的判定；<br>2) LR的可解释强，可控性高；<br>3) 训练快，feature engineering之后效果赞；<br>4) 因为结果是概率，可以做ranking model；<br>5) 添加feature简单。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习：决策树之CART算法</title>
    <url>/article/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%86%B3%E7%AD%96%E6%A0%91%E4%B9%8BCART%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<a id="more"></a>
<h1><span id="cart算法概念">CART算法概念</span></h1><p>Classification And Regression Tree，即分类回归树算法。它是决策树的一种实现。</p>
<p>CART是一种二分的分割技术，把当前的样本划分成两个子样本，每个非叶子节点都有两个分支，生成的决策树是二叉树。</p>
<h1><span id="cart算法流程">CART算法流程</span></h1><p>使用基尼系数判断样本集的“不纯度”，尽可能“纯”就是尽量让一个分裂子集中待分类项属于同一类别。基尼系数越低越好。</p>
<p>基尼系数的公式：<br>其中，C样本分类的数量。Pi表示属于i类的概率。<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/90.png" alt=""></p>
<p>下面举例CART中基尼系数的计算，图片来自网络。<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/86.png" alt=""><br>属性有3个，分别是有房情况，婚姻状况和年收入。房和婚姻是离散值，收入是连续值，是否贷款是分类结果。</p>
<p><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/87.png" alt=""></p>
<p>下面是婚姻状况属性，有三种情况。<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/88.jpg" alt=""></p>
<p>最后是收入属性，它是连续值，连续值的计算使用分裂点的方法，选择基尼系数最小的点作为决策树的划分。<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/89.png" alt=""></p>
<p>根据这样的分裂规则CART算法就能完成建树过程。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习：决策树</title>
    <url>/article/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%86%B3%E7%AD%96%E6%A0%91.html</url>
    <content><![CDATA[<h1><span id="基本概念">基本概念</span></h1><p>决策树是对样本进行分类的树形模型。树由结点和有向边组成：</p>
<ul>
<li>内部结点表示一个特征或者属性。</li>
<li>叶子结点表示一个分类。</li>
<li>有向边代表了一个划分规则。</li>
</ul>
<p>用决策树对需要测试的实例进行分类：从根节点开始，对实例的某一特征进行测试，根据测试结果，将实例分配到其子结点；这时，每一个子结点对应着该特征的一个取值。如此递归地对实例进行测试并分配，直至达到叶结点。最后将实例分配到叶结点的类中。</p>
<p>它可以认为是 if-then 规则的集合，也可以认为是定义在特征空间与类空间上的条件概率分布。</p>
<p>决策树的优点：可读性强，分类速度快。</p>
<p>决策树学习通常包括 3 个步骤：特征选择、决策树的生成和决策树的修剪。</p>
<a id="more"></a>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习：基本概念</title>
    <url>/article/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</url>
    <content><![CDATA[<h1><span id="bias偏差-error误差-variance方差">Bias(偏差)、 Error(误差)、 Variance(方差)</span></h1><ul>
<li>Bias(偏差)<br>衡量模型拟合训练数据的能力，bias 越小拟合能力越高，越大拟合能力越低。</li>
<li>Error(误差)<br>指模型的泛化能力。</li>
<li>Variance(方差)<br>衡量每次在不同数据上训练生成的不同模型之间的差异性大小的度量值。</li>
</ul>
<a id="more"></a>
<h1><span id="常用性能度量指标">常用性能度量指标</span></h1><ul>
<li>均方误差</li>
<li>平方误差</li>
<li>准确率</li>
<li>召回率</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习：集成学习方法</title>
    <url>/article/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%9A%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95.html</url>
    <content><![CDATA[<p>集成学习是通过构建并结合多个学习器来完成学习任务。</p>
<h1><span id="bagging-和-boosting">bagging 和 boosting</span></h1><ul>
<li>bagging 是一种与 boosting 很类似的技术, 所使用的多个分类器的类型（数据量和特征量）都是一致的。</li>
<li>bagging 是由不同的分类器（1.数据随机化 2.特征随机化）经过训练，综合得出的出现最多分类结果；boosting 是通过调整已有分类器错分的那些数据来获得新的分类器，得出目前最优的结果。</li>
<li>bagging 中的分类器权重是相等的；而 boosting 中的分类器加权求和，所以权重并不相等，每个权重代表的是其对应分类器在上一轮迭代中的成功度。</li>
</ul>
<a id="more"></a>
<h1><span id="随机森林">随机森林</span></h1><p>Bagging + 决策树 = 随机森林<br>构建n个决策树进行投票</p>
<h1><span id="adaboost">AdaBoost</span></h1><p>boosting的adaboost每次训练的时候用的是同一个数据集，但是前一棵决策树分错的样本在后面的权重会升高，相当于说，后面的决策树利用了前面决策树学习的结果，不断的优化这个结果，也就是说，后面的决策树恰恰擅长的是前面决策树不擅长（分错）的样本.</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>生产者消费者模式</title>
    <url>/article/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h1><span id="定义">定义</span></h1><p>某个模块负责产生数据，这些数据由另一个模块来负责处理。产生数据的模块，就形象地称为生产者；而处理数据的模块，就称为消费者。</p>
<p>该模式还需要有一个缓冲区处于生产者和消费者之间，作为一个中介。生产者把数据放入缓冲区，而消费者从缓冲区取出数据。</p>
<pre><code>1、生产者仅仅在仓储未满时候生产，仓满则停止生产。
2、消费者仅仅在仓储有产品时候才能消费，仓空则等待。
3、当消费者发现仓储没产品可消费时候会通知生产者生产。
4、生产者在生产出可消费产品时候，应该通知等待的消费者去消费。
</code></pre><p>缓冲区作用</p>
<ul>
<li>解耦，生产者和消费者只依赖缓冲区，而不互相依赖。</li>
<li>支持并发和异步。</li>
</ul>
<p>网上看到一个代码示例，觉得很不错。<br>代码示例：<br><a id="more"></a></p>
<pre><code>import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;

public class ProducerConsumer {

    public class Product {
        private int id;

        public Product(int id) {
            this.id = id;
        }

        public String toString() {
            return &quot;产品：&quot; + this.id;
        }
    }

    public class Storage {
        BlockingQueue&lt;Product&gt; queues = new LinkedBlockingQueue&lt;Product&gt;(10);

        public void push(Product p) throws InterruptedException {
            queues.put(p);
        }

        public Product pop() throws InterruptedException {
            return queues.take();
        }
    }

     class Producer implements Runnable {
            private String name;
            private Storage s = null;

            public Producer(String name, Storage s) {
                this.name = name;
                this.s = s;
            }

            public void run() {
                try {
                    while (true) {
                        Product product = new Product((int) (Math.random() * 10000)); // 产生0~9999随机整数
                        System.out.println(name + &quot;准备生产(&quot; + product.toString() + &quot;).&quot;);
                        s.push(product);
                        System.out.println(name + &quot;已生产(&quot; + product.toString() + &quot;).&quot;);
                        System.out.println(&quot;===============&quot;);
                        Thread.sleep(500);
                    }
                } catch (InterruptedException e1) {
                    e1.printStackTrace();
                }

            }
        }

    class Consumer implements Runnable {
        private String name;
        private Storage s = null;

        public Consumer(String name, Storage s) {
            this.name = name;
            this.s = s;
        }

        public void run() {
            try {
                while (true) {
                    System.out.println(name + &quot;准备消费产品.&quot;);
                    Product product = s.pop();
                    System.out.println(name + &quot;已消费(&quot; + product.toString() + &quot;).&quot;);
                    System.out.println(&quot;===============&quot;);
                    Thread.sleep(500);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }

    }

    public static void main(String[] args) {
        ProducerConsumer pc = new ProducerConsumer();

        Storage s = pc.new Storage();

        Producer p = pc.new Producer(&quot;张三&quot;, s);
        Producer p2 = pc.new Producer(&quot;李四&quot;, s);

        Consumer c = pc.new Consumer(&quot;王五&quot;, s);
        Consumer c2 = pc.new Consumer(&quot;老刘&quot;, s);
        Consumer c3 = pc.new Consumer(&quot;老林&quot;, s);

        ExecutorService service = Executors.newCachedThreadPool();

        service.submit(p);
        //service.submit(p2);
        service.submit(c);
        service.submit(c2);
        service.submit(c3);        
    }    
}
</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>网络协议基础知识</title>
    <url>/article/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</url>
    <content><![CDATA[<h2><span id="tcp层级">TCP层级</span></h2><p>4层：应用层、运输层、网络层、链路层<br>7层：物理层、数据链路层、网络层、传输层、应用会话层、表示层、应用层</p>
<h2><span id="http过程">Http过程</span></h2><p>一次HTTP操作称为一个事务，其工作整个过程如下：</p>
<p>1 ) 、地址解析，</p>
<p>如用客户端浏览器请求这个页面：<a href="http://localhost.com:8080/index.htm" target="_blank" rel="noopener">http://localhost.com:8080/index.htm</a></p>
<p>从中分解出协议名、主机名、端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下：<br>​     协议名：http<br>​     主机名：localhost.com<br>​     端口：8080<br>​     对象路径：/index.htm</p>
<p>在这一步，需要域名系统DNS解析域名localhost.com,得主机的IP地址。</p>
<p>2）、封装HTTP请求数据包</p>
<p>把以上部分结合本机自己的信息，封装成一个HTTP请求数据包</p>
<p>3）封装成TCP包，建立TCP连接（TCP的三次握手）</p>
<p>在HTTP工作开始之前，客户机（Web浏览器）首先要通过网络与服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。这里是8080端口</p>
<p>4）客户机发送请求命令</p>
<p>建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可内容<br>​<br>5）服务器响应</p>
<p>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</p>
<p>实体消息是服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据</p>
<p>6）服务器关闭TCP连接</p>
<p>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码</p>
<pre><code>Connection:keep-alive
</code></pre><p>TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p>
<h2><span id="http10-http11-http20">http1.0 http1.1 http2.0</span></h2><h3><span id="http10-http11">http1.0 http1.1</span></h3><h3><span id="长连接">长连接</span></h3><p>HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。</p>
<p>HTTP是基于TCP/IP协议的，创建一个TCP连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用个长连接来发多个请求。</p>
<h3><span id="节约带宽">节约带宽</span></h3><p>HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。</p>
<p>这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。</p>
<p>另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。</p>
<h3><span id="host域">HOST域</span></h3><p>现在可以web server例如tomat，设置虚拟站点是非常常见的，也即是说，web server上的多个虚拟站点可以共享同一个ip和端口。</p>
<p>HTTP1.0是没有host域的，HTTP1.1才支持这个参数。</p>
<h3><span id="http10-http20">http1.0 http2.0</span></h3><p>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</p>
<p>当然HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。</p>
<p>TCP连接有一个预热和保护的过程，先检查数据是否传送成功，一旦成功过，则慢慢加大传输速度。因此对应瞬时并发的连接，服务器的响应就会变慢。所以最好能使用一个建立好的连接，并且这个连接可以支持瞬时并发的请求。</p>
<h3><span id="数据压缩">数据压缩</span></h3><p>HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</p>
<h3><span id="服务器推送">服务器推送</span></h3><p>当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。</p>
<p>服务器端推送的这些资源其实存在客户端的某处地方，客户端直接从本地加载这些资源就可以了，不用走网络，速度自然是快很多的。</p>
<h2><span id="三次握手-四次挥手">三次握手 四次挥手</span></h2><h3><span id="3次">3次</span></h3><p>1）第一次握手：<br>Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p>
<p>（2）第二次握手：<br>Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p>
<p>（3）第三次握手：<br>Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p>
<p>SYN攻击：Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃</p>
<h3><span id="4次">4次</span></h3><p>第一次挥手：<br>Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</p>
<p>第二次挥手：<br>Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</p>
<p>第三次挥手：<br>Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p>
<p>第四次挥手：<br>Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p>
<h2><span id="https">https</span></h2><p>HTTP协议由于是明文传送，所以存在三大风险：</p>
<p>1、被窃听的风险：第三方可以截获并查看你的内容</p>
<p>2、被篡改的危险：第三方可以截获并修改你的内容</p>
<p>3、被冒充的风险：第三方可以伪装成通信方与你通信</p>
<p>HTTPS涉及到了很多概念，比如SSL/TLS，数字证书、数字签名、加密、认证、公钥和私钥等</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>Java：通过JNI调用Fasttext模型</title>
    <url>/article/%E9%80%9A%E8%BF%87JNI%E8%B0%83%E7%94%A8Fasttext%E6%A8%A1%E5%9E%8B.html</url>
    <content><![CDATA[<p>fastText是facebook开源的一个词向量与文本分类工具<br><a href="https://github.com/facebookresearch/fastText" target="_blank" rel="noopener">https://github.com/facebookresearch/fastText</a></p>
<p>提供了python和c的接口。<br>通过Java使用fastText，搜到了这个项目 <a href="https://github.com/vinhkhuc/JFastText" target="_blank" rel="noopener">https://github.com/vinhkhuc/JFastText</a> ，使用起来很方便，性能也不错；但是有一个问题，就是如果模型多次更新，就会产生僵尸进程导致程序挂掉，并引起机器的负载升高。</p>
<p>所以决定使用JNI的方式调用fastText</p>
<p>步骤：<br>1、编写Java程序</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FastTextJNI</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> FastTextJNI ftJNI<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> String LIB_PATH <span class="token operator">=</span> ConstantsConfig<span class="token punctuation">.</span>CONFIG_BASE_PATH <span class="token operator">+</span> <span class="token string">"libfasttext.so"</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">long</span> <span class="token function">FastTextJNILoadModel</span><span class="token punctuation">(</span>String fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">float</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">FastTextSentenceVector</span><span class="token punctuation">(</span><span class="token keyword">long</span> modelHandle<span class="token punctuation">,</span> String words<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">FastTextJNIReleaseModel</span><span class="token punctuation">(</span><span class="token keyword">long</span> modelHandle<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        System<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>LIB_PATH<span class="token punctuation">)</span><span class="token punctuation">;</span>
        ftJNI <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FastTextJNI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token function">FastTextJNI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token function">FastTextJNI</span><span class="token punctuation">(</span>String fileName<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">FastTextJNILoadModel</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">float</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getSentenceVector</span><span class="token punctuation">(</span><span class="token keyword">long</span> modelHandle<span class="token punctuation">,</span> String words<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">FastTextSentenceVector</span><span class="token punctuation">(</span>modelHandle<span class="token punctuation">,</span> words<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span>Long modelHandle<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">FastTextJNIReleaseModel</span><span class="token punctuation">(</span>modelHandle<span class="token punctuation">)</span><span class="token punctuation">;</span>
        modelHandle <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<a id="more"></a>
<p>2、编译Java程序 javac FastTextJNI.java</p>
<p>3、继续编译生成c的头文件（给c/c++程序用）<br>javah -jni -classpath . FastTextJNI，生成了头文件FastTextJNI.h</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/* DO NOT EDIT THIS FILE - it is machine generated */</span>
#include <span class="token operator">&lt;</span>jni<span class="token punctuation">.</span>h<span class="token operator">></span>
<span class="token comment" spellcheck="true">/* Header for class FastTextJNI */</span>

#ifndef FastTextJNI
#define FastTextJNI
#ifdef __cplusplus
extern <span class="token string">"C"</span> <span class="token punctuation">{</span>
#endif

JNIEXPORT jlong JNICALL <span class="token function">Java_FastTextJNI_FastTextJNILoadModel</span>
  <span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span><span class="token punctuation">,</span> jobject<span class="token punctuation">,</span> jstring<span class="token punctuation">)</span><span class="token punctuation">;</span>

JNIEXPORT jfloatArray JNICALL <span class="token function">Java_FastTextJNI_FastTextSentenceVector</span>
  <span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span><span class="token punctuation">,</span> jobject<span class="token punctuation">,</span> jlong<span class="token punctuation">,</span> jstring<span class="token punctuation">)</span><span class="token punctuation">;</span>

JNIEXPORT <span class="token keyword">void</span> JNICALL <span class="token function">Java_FastTextJNI_FastTextJNIReleaseModel</span>
  <span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span><span class="token punctuation">,</span> jobject<span class="token punctuation">,</span> jlong<span class="token punctuation">)</span><span class="token punctuation">;</span>

#ifdef __cplusplus
<span class="token punctuation">}</span>
#endif
#endif
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>4、新建cpp文件，实现jni编译生成的头文件中的函数</p>
<pre class="line-numbers language-java"><code class="language-java">#include <span class="token operator">&lt;</span>iostream<span class="token operator">></span>
#include <span class="token operator">&lt;</span>sstream<span class="token operator">></span>

#include <span class="token string">"FastTextJNI.h"</span>
#include <span class="token string">"fastText/src/fasttext.h"</span>

using namespace fasttext<span class="token punctuation">;</span>

JNIEXPORT jlong JNICALL <span class="token function">Java_FastTextJNI_FastTextJNILoadModel</span>
  <span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span>jenv<span class="token punctuation">,</span> jobject jobj<span class="token punctuation">,</span> jstring jmodelName<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> modelName <span class="token operator">=</span> jenv<span class="token operator">-</span><span class="token operator">></span><span class="token function">GetStringUTFChars</span><span class="token punctuation">(</span>jmodelName<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    FastText <span class="token operator">*</span>fastText <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FastText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    fastText<span class="token operator">-</span><span class="token operator">></span><span class="token function">loadModel</span><span class="token punctuation">(</span>modelName<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">if</span><span class="token punctuation">(</span>modelName<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        jenv<span class="token operator">-</span><span class="token operator">></span><span class="token function">ReleaseStringUTFChars</span><span class="token punctuation">(</span>jmodelName<span class="token punctuation">,</span> modelName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>jlong<span class="token punctuation">)</span>fastText<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

JNIEXPORT jfloatArray JNICALL <span class="token function">Java_FastTextJNI_FastTextSentenceVector</span>
  <span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span>jenv<span class="token punctuation">,</span> jobject jobj<span class="token punctuation">,</span> jlong jmodelHandle<span class="token punctuation">,</span> jstring jwords<span class="token punctuation">)</span>
<span class="token punctuation">{</span>   
    FastText<span class="token operator">*</span> fastText <span class="token operator">=</span> <span class="token punctuation">(</span>FastText<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>jmodelHandle<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> words <span class="token operator">=</span> jenv<span class="token operator">-</span><span class="token operator">></span><span class="token function">GetStringUTFChars</span><span class="token punctuation">(</span>jwords<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span><span class="token operator">*</span> wordschar <span class="token operator">=</span> const_cast<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">;</span>

    std<span class="token operator">:</span><span class="token operator">:</span>istringstream <span class="token function">in</span><span class="token punctuation">(</span>wordschar<span class="token punctuation">)</span><span class="token punctuation">;</span>    
    fasttext<span class="token operator">:</span><span class="token operator">:</span>Vector <span class="token function">vec</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">try</span><span class="token punctuation">{</span>
        fastText<span class="token operator">-</span><span class="token operator">></span><span class="token function">getSentenceVector</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> vec<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>std<span class="token operator">:</span><span class="token operator">:</span>exception<span class="token operator">&amp;</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token operator">:</span><span class="token operator">:</span>cout <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">:</span><span class="token operator">:</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">float</span><span class="token operator">*</span> data <span class="token operator">=</span> vec<span class="token punctuation">.</span>data_<span class="token punctuation">;</span>

    jfloatArray result<span class="token punctuation">;</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    result <span class="token operator">=</span> jenv<span class="token operator">-</span><span class="token operator">></span><span class="token function">NewFloatArray</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    jenv<span class="token operator">-</span><span class="token operator">></span><span class="token function">SetFloatArrayRegion</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

JNIEXPORT <span class="token keyword">void</span> JNICALL <span class="token function">Java_FastTextJNI_FastTextJNIReleaseModel</span>
  <span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span>jenv<span class="token punctuation">,</span> jobject jobj<span class="token punctuation">,</span> jlong jmodelHandle<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
     <span class="token keyword">if</span><span class="token punctuation">(</span>jmodelHandle<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">delete</span> <span class="token punctuation">(</span>FastText<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>jmodelHandle<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>5、最后编译so库，生成 libfasttext.so 文件使用</p>
<pre class="line-numbers language-java"><code class="language-java">g<span class="token operator">++</span> <span class="token operator">-</span>fpic <span class="token operator">-</span>shared a<span class="token punctuation">.</span>cpp <span class="token operator">-</span>o libfasttext<span class="token punctuation">.</span>so <span class="token operator">-</span>I<span class="token punctuation">.</span>/ <span class="token operator">-</span>I<span class="token operator">/</span>opt<span class="token operator">/</span>soft<span class="token operator">/</span>jdk<span class="token operator">/</span>jdk1<span class="token number">.6</span><span class="token punctuation">.</span>0_45<span class="token operator">/</span>include <span class="token operator">-</span>I<span class="token operator">/</span>opt<span class="token operator">/</span>soft<span class="token operator">/</span>jdk<span class="token operator">/</span>jdk1<span class="token number">.6</span><span class="token punctuation">.</span>0_45<span class="token operator">/</span>include<span class="token operator">/</span>linux
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>生成so库之后，执行ldd libfasttext.so，如果有关联其他库说明生成库没有问题</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习：决策树之ID3算法与C4.5算法</title>
    <url>/article/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%86%B3%E7%AD%96%E6%A0%91%E4%B9%8BID3%E7%AE%97%E6%B3%95%E4%B8%8EC4.5%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<a id="more"></a>
<h1><span id="id3概念">ID3概念</span></h1><p>即Iterative Dichotomiser 3，迭代二叉树3代。该算法是以信息论为基础，以信息熵和信息增益为衡量标准。</p>
<h2><span id="信息熵">信息熵</span></h2><p>描述信息的混乱程度，熵越大，表示信息越混乱。<br>信息熵的计算公式：其中P(Xi)表示类别Xi在样本出现的概率。<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos2/1.png" alt=""></p>
<h2><span id="信息增益">信息增益</span></h2><p>用于度量属性A降低样本集合X熵的贡献大小。信息增益越大，越适于对X分类。<br>Gain(A, X) = H(X) - Sum(|Xv| / |X| * H(Xv))  {v: A的所有可能值}，Xv表示A中所有为v的值；|Xv|表示A中所有为v的值的数量；</p>
<h1><span id="算法流程">算法流程</span></h1><p>ID3算法就是在每次需要分裂时，计算每个属性的增益率，然后选择增益率最大的属性进行分裂。</p>
<h1><span id="c45算法">C4.5算法</span></h1><p>它是对ID3算法的改进，改进如下</p>
<ul>
<li>1）用信息增益率来选择属性</li>
<li>2）在决策树的构造过程中对树进行剪枝</li>
<li>3）对非离散数据也能处理</li>
<li>4）能够对不完整数据进行处理</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>遗憾的两件事</title>
    <url>/article/%E9%81%97%E6%86%BE%E7%9A%84%E4%B8%A4%E4%BB%B6%E4%BA%8B.html</url>
    <content><![CDATA[<p>经历了遗憾的两件事</p>
<p>1 justinbieber在中国的世界巡演取消。13年的时候因为当时大一没太多的零花钱，放弃了比伯在国内的演唱会</p>
<p><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/9.jpg" alt=""></p>
<a id="more"></a>
<p>2 MSN解散了，内马尔去了巴黎</p>
<p>”攒够钱就能去诺坎普寻找MSN三叉戟“，这是我之前的想法。想不到这么快就破灭了。希望巴塞罗那越来越辉煌，内少早日登上世界之巅。</p>
<p><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/10.jpg" alt=""></p>
<p><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/11.jpg" alt=""></p>
<p>所以，有机会就要抓住，不要拖。有钱真好，至少在很多情况下有选择的权利。</p>
<!--more-->]]></content>
      <categories>
        <category>扯淡</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式：MVC模式</title>
    <url>/article/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9AMVC%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h2><span id="三层体系结构">三层体系结构</span></h2><p>三层体系结构是在客户端和数据库端之间引入一个“组件层”，并以业务逻辑为核心，将整个项目在逻辑逻辑上分为表现层、业务层、数据访问层。</p>
<h2><span id="mvc设计思想">MVC设计思想</span></h2><p>M代表model V代表view C代表controller。view即为客户所能看到的页面,controller即为控制器，model即为模型。MVC设计思想主要用于表现层，准确来说 MVC 是以页面为核心，将表现层分为模型、视图、控制器三部分，是基于界面开发的指导思想。</p>
<h2><span id="三层体系结构内涵">三层体系结构内涵</span></h2><p>层与层之间：1.上层依赖下层 2.下层不可依赖上层，上层对下层是不可见的。3.层与层之间通过接口联系。</p>
<p>表现层负责用户界面的交互，表现层不能直接访问数据。业务层负责数据的传递和业务方法的处理，业务层不能直接访问数据库，而是要通过数据访问层提供的接口实现数据的调用。数据访问层负责数据的处理工作，封装了所有与数据库的交互操作。</p>
<h2><span id="mvc设计思想的内涵">MVC设计思想的内涵</span></h2><p>web中引入MVC设计思想是为了实现表现层与业务层的分离，MVC提供了视图与模型分离的机制–控制器。一般把跳转关系的管理、表单数据的封装、国际化、验证等任务交给控制器处理。<br><a id="more"></a><br>controller、view、model并不像三层体系结构那样存在上下层的关系，各层之间是平行的，不是分层模式，而是彼此独立的组件，是相互协作的关系。</p>
<p>controller接受用户的请求，完成视图与模型的匹配，不负责处理业务信息，只是把用户请求的消息传递给模型，告诉模型的做什么，返回符合要求的视图，起到控制业务流程的作用。一个视图可以对应多个模型，一个模型也可以对应多个视图。</p>
<p>model是MVC的核心，负责业务流程/状态、业务规则、数据模型的制定。业务流程的处理对其他层是不可见的。model拥有最多的处理任务，其返回的数据是与格式无关的。这样一个model就可以为多个视图提供数据，提高了代码利用率。</p>
<p>view是用户看到并与之交互的界面。视图向用户显示相关的数据，并能接收用户的输入数据，但是它并不进行任何实际的业务处理。视图可以向模型查询业务状态，但不能改变模型。视图还能接受模型发出的数据更新事件，从而对用户界面进行同步更新。</p>
<h2><span id="mvc工作流程">MVC工作流程</span></h2><p>在 MVC 模式中，Web 用户向服务器提交的所有请求都由控制器接管。接受到请求之后，控制器负责决定应该调用哪个模型来进行处理；然后模型根据用户请求进行相应的业务逻辑处理，并返回数据；最后控制器调用相应的视图来格式化模型返回的数据，并通过视图呈现给用户。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java并发程序(2)：学会使用线程池</title>
    <url>/article/Java%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F(2)%EF%BC%9A%E5%AD%A6%E4%BC%9A%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0.html</url>
    <content><![CDATA[<h1><span id="runnable-或者-callable">Runnable 或者 Callable</span></h1><p>通过实现接口的run方法，实现任务</p>
<pre><code>public class LiftOff implements Runnable {
    protected int countDown = 10;
    private static int taskCount = 0;
    private int id = taskCount++;
    public LiftOff() {

    }
    public LiftOff(int countDown) {
        this.countDown = countDown;
    }
    public String Status() {
        return &quot;#&quot; + id + &quot;(&quot; + 
                (countDown &gt; 0?countDown : &quot;LiftOff!&quot;) + &quot;).&quot;;
    }
    @Override
    public void run() {
        while (countDown-- &gt; 0) {
            System.out.print(Status());
            Thread.yield();
        }

    }
    public static void main(String[] args) {
        LiftOff launch = new LiftOff(10);
        launch.run();
    }
}
/*
 * Output：
 * #0(9).#0(8).#0(7).#0(6).#0(5).#0(4).#0(3).#0(2).#0(1).#0(LiftOff!).
 * 
 */
</code></pre><p>任务和线程是各自独立的。我们实现了 Runnable 接口的 run（）方法，这只是定义任务，和线程没有任何关系。要实现线程行为，必须显式地将一个任务附着到线程上。</p>
<p>Thread.yield() 它是对线程调度器的一种建议，它在声明：”我已经执行完生命周期中最重要的部分了，此刻可以切换给别的任务，让它们执行吧。”这仅仅是一种建议，线程调度器不一定会执行。当调用 yield()时，其实是在建议线程调度器去调度具有相同优先级的其他线程工作。</p>
<h1><span id="thread类">Thread类</span></h1><p>将runnable的任务提交给Thread构造器</p>
<pre><code>public class BasicThreads {
    public static void main(String[] args) {
        Thread t = new Thread(new LiftOff(10));
        t.start();
        System.out.println(&quot;Waiting for LiftOff&quot;);
    }
}

/*
 * Output:
 * Waiting for LiftOff
 * #0(9).#0(8).#0(7).#0(6).#0(5).#0(4).#0(3).#0(2).#0(1).#0(LiftOff!)
 * */
 * 
</code></pre><p>Thread 构造器只需要一个 Runnable 对象。调用 start()方法为该线程执行必需的初始化操作，然后调用 Runnable 接口的 run()方法，以便在这个新线程中启动该任务。注意执行结果，在 start()方法执行时，虽然调用了 run()方法，但是 start()迅速返回了（先输出了 Waiting for LiftOff），这是因为：main()方法本身就是一个线程，调用 Thread.start()后系统又创建了一个新的线程，而LiftOff就依附在这个线程上执行。两个线程是同时执行的，互不影响。</p>
<p>Thread 里面有 start()和 run()方法：</p>
<ul>
<li>start(): 它的作用是启动一个新线程，新线程会执行相应的run()方法。start()不能被重复调用。</li>
<li>run()  : run()就和普通的成员方法一样，可以被重复调用。单独调用run()的话，会在当前线程中执行run()，而并不会启动新线程</li>
</ul>
<h1><span id="使用-executorservice-管理-thread">使用 ExecutorService 管理 Thread</span></h1><p>单个 Executor 被用来管理系统中所有的任务</p>
<pre><code>import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CachedThreadPool {
    public static void main(String[] args) {
        ExecutorService exec = Executors.newCachedThreadPool();
        for(int i = 0; i &lt; 5; i++) {
            exec.execute(new LiftOff(5));
        }
        exec.shutdown();
    }
}
</code></pre><p>在执行完所有的任务后，只需要调用一个 shutdown()即可关闭所有管理的 Thread 对象，非常优雅。我刚开始看这块的时候有个问题，我在 for 循环里调用 exec.execute()，那就相当于 Executor 启动了5个线程，但是下面立马调用了 shutdown()，shutdown()的意思是不能再向当前 exec 提交新任务了。而已经执行的任务则会继续执行；shutdownNow()是强制性的 shutdown,不仅不让提交新任务，还会停止当前正在运行的任务。</p>
<h2><span id="executor的类型">Executor的类型</span></h2><pre><code>FixedThreadPool(n) 线程数量有限的线程池
CachedThreadPool() 线程数量自动调节的线程池
SingleThreadExecutor() 线程数量为1的线程池
</code></pre><h1><span id="callable">Callable</span></h1><p>Runnable执行独立任务的没有返回值的。<br>Callable接口，实现call方法，call方法是有返回值的。<br>但是必须使用ExecutorService.submit()方法去调用它。submit方法会产生Future对象</p>
<pre><code>class TaskWithResult implements Callable&lt;String&gt;{
    private int id;

    public TaskWithResult(int id){
        this.id = id;
    }

    public String call() {
        return &quot;resulit id: &quot; + this.id;
    }
}
public class CallableDemo {
    public static void main(String[] args) throws InterruptedException, ExecutionException{
        ExecutorService exec = Executors.newCachedThreadPool();

        ArrayList&lt;Future&lt;String&gt;&gt; results = new ArrayList&lt;Future&lt;String&gt;&gt;();

        for(int i = 0;i &lt; 10; i++){
            results.add(exec.submit(new TaskWithResult(i)));
        }

        for(Future&lt;String&gt; fs: results){
            if(fs.isDone()){
                System.out.println(fs.get());
            }
        }
        exec.shutdown();
    }
}
resulit id: 0
resulit id: 1
resulit id: 2
resulit id: 3
resulit id: 4
resulit id: 5
resulit id: 6
resulit id: 7
resulit id: 8
resulit id: 9
</code></pre><h1><span id="休眠">休眠</span></h1><pre><code>import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class SleepingTask extends LiftOff{

    public void run(){
        try{
            while (countDown-- &gt; 0){
                System.out.print(Status());
                TimeUnit.MILLISECONDS.sleep(1000);
            }
        }catch(InterruptedException e){
            System.err.println(&quot;Interrupted&quot;);
        }
    }

    public static void main(String[] args){
        ExecutorService exec = Executors.newCachedThreadPool();
        for(int i=0;i&lt;5;i++){
            exec.execute(new SleepingTask());
        }
        exec.shutdown();
    }
}
/*
 * 异常不能跨线程 
 * */
</code></pre><p>对 sleep()的调用可能抛出 InterruptedException 异常（很容易想象，你在睡觉的时候也会被闹钟打断。这里是调用 Thread.interrupt()），并且你可以看到，它在 run()中被捕获。因为异常不能跨线程传播，所以这里抛出的异常是不能被 main 线程捕获的。线程之间只共享指定的临界资源，像异常处理都是线程私有的</p>
<h1><span id="优先级">优先级</span></h1><p>通过setPriority和getPriority去修改和获取线程的优先级</p>
<pre><code>import java.util.concurrent.*;

import com.sun.corba.se.spi.orb.StringPair;
import com.sun.xml.internal.bind.v2.runtime.RuntimeUtil.ToStringAdapter;

public class SimplePriorities implements Runnable{
    private int countDown = 5;
    private volatile double d;
    private int priority;
    public SimplePriorities(int priority) {
        this.priority = priority;
    }
    public String ToString(){
        return Thread.currentThread() + &quot;: &quot; + countDown;
    }

    @Override
    public void run() {
        Thread.currentThread().setPriority(priority);
        while(true){
            for(int i=0;i&lt;100000;i++){
                d += (Math.PI + Math.E) / i;
                if (i % 1000 == 0){
                    Thread.yield();
                }
            }
            System.out.println(this.priority);
            if (--countDown == 0)
                return;
        }

    }

    public static void main(String[] args){
        ExecutorService exec = Executors.newCachedThreadPool();
        for(int i=0;i&lt;5;i++){
            exec.execute(new SimplePriorities(Thread.MIN_PRIORITY));
            exec.execute(new SimplePriorities(Thread.MAX_PRIORITY));
        }
        exec.shutdown();
    }
}
</code></pre><h1><span id="后台线程">后台线程</span></h1><p>后台线程是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分（意思是非必要，比如在项目中定时打印线程池的使用状况）。因此，当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。所以，只要有任何非后台线程还在运行，程序就不会终止。main()就是一个非后台线程。设置后台线程有一个注意点：必须在 start()之前设定。</p>
<pre><code>public class SimpleDaemons implements Runnable {
    public void run() {
        try {
                while (true) {
                    TimeUnit.MILLISECONDS.sleep(100);
                    System.out.println(Thread.currentThread() + &quot; &quot; + this);
                }
            } catch (InterruptedException e) {
                System.out.println(&quot;sleep() interrupted&quot;);
                e.printStackTrace();
            }
    }

    public static void main(String[]() args) throws InterruptedException {
        for(int i = 0; i &lt; 10; i++) {
            Thread daemon = new Thread(new SimpleDaemons());
            daemon.setDaemon(true); // Must call before start();
            daemon.start();
        }
        System.out.println(&quot;All daemons started&quot;);
        TimeUnit.MILLISECONDS.sleep(275);
    }
}

</code></pre>]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Kafka消息队列</title>
    <url>/article/Kafka%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html</url>
    <content><![CDATA[<h1><span id="概述">概述</span></h1><p>Kafka是Linkedin于2010年12月份开源的消息系统，它可以处理消费者规模的网站中的所有动作流数据。活跃的流式数据在web网站应用中非常常见，这些数据包括网站的pv、用户访问了什么内容，搜索了什么内容等。 这些数据通常以日志的形式记录下来，然后每隔一段时间进行一次统计处理。<br>传统的日志分析系统提供了一种离线处理日志信息的可扩展方案，但若要进行实时处理，通常会有较大延迟。而现有的消（队列）系统能够很好的处理实时或者近似实时的应用，但未处理的数据通常不会写到磁盘上，这对于Hadoop之类（一小时或者一天只处理一部分数据）的离线应用而言，可能存在问题。Kafka正是为了解决以上问题而设计的，它能够很好地离线和在线应用。<br>kafka对消息保存时根据Topic进行归类，发送消息者成为Producer,消息接受者成为Consumer,此外kafka集群有多个kafka实例组成，每个实例(server)成为broker。无论是kafka集群，还是producer和consumer都依赖于zookeeper来保证系统可用性集群保存一些meta信息。</p>
<h1><span id="相关术语">相关术语</span></h1><a id="more"></a>
<ul>
<li>Broker<br>Kafka集群包含一个或多个服务器，这种服务器被称为broker</li>
<li>Topic<br>每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</li>
<li>Partition<br>Partition是物理上的概念，每个Topic包含一个或多个Partition.</li>
<li>Producer<br>负责发布消息到Kafka broker</li>
<li>Consumer<br>消息消费者，向Kafka broker读取消息的客户端。</li>
<li>Consumer Group<br>每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。</li>
</ul>
<h1><span id="结构">结构</span></h1><p><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/13.jpg" alt=""></p>
<p>kafka是显式分布式架构，producer、broker（Kafka）和consumer都可以有多个。Kafka的作用类似于缓存，即活跃的数据和离线处理系统之间的缓存。几个基本概念：</p>
<ul>
<li><p>（1）message（消息）是通信的基本单位，每个producer可以向一个topic（主题）发布一些消息。如果consumer订阅了这个主题，那么新发布的消息就会广播给这些consumer。</p>
</li>
<li><p>（2）Kafka是显式分布式的，多个producer、consumer和broker可以运行在一个大的集群上，作为一个逻辑整体对外提供服务。对于consumer，多个consumer可以组成一个group，这个message只能传输给某个group中的某一个consumer.</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/14.png" alt=""></p>
<ul>
<li>（1）一个Topic可以认为是一类消息，每个topic将被分成多个partition(区),每个partition在存储层面是append log文件。任何发布到此partition的消息都会被直接追加到log文件的尾部，每条消息在文件中的位置称为offset（偏移量），offset为一个long型数字，它是唯一标记一条消息。它唯一的标记一条消息。kafka并没有提供其他额外的索引机制来存储offset，因为在kafka中几乎不允许对消息进行“随机读写”。</li>
<li>（2）消息被消费,消息仍然不会被立即删除.日志文件将会根据broker中的配置要求,保留一定的时间之后删除;比如log文件保留2天,那么两天后,文件会被清除,无论其中的消息是否被消费.kafka通过这种简单的手段,来释放磁盘空间,以及减少消息消费之后对文件内容改动的磁盘IO开支.</li>
<li>（3）分布式：一个Topic的多个partitions,被分布在kafka集群中的多个server上;每个server(kafka实例)负责partitions中消息的读写操作;此外kafka还可以配置partitions需要备份的个数(replicas),每个partition将会被备份到多台机器上,以提高可用性.基于replicated方案,那么就意味着需要对多个备份进行调度;每个partition都有一个server为”leader”;leader负责所有的读写操作,如果leader失效,那么将会有其他follower来接管(成为新的leader);follower只是单调的和leader跟进,同步消息即可..由此可见作为leader的server承载了全部的请求压力,因此从集群的整体考虑,有多少个partitions就意味着有多少个”leader”,kafka会将”leader”均衡的分散在每个实例上,来确保整体的性能稳定.</li>
<li><p>（4）partitions的设计目的有多个.最根本原因是kafka基于文件存储.通过分区,可以将日志内容分散到多个server上,来避免文件尺寸达到单机磁盘的上限,每个partiton都会被当前server(kafka实例)保存;可以将一个topic切分多任意多个partitions,来消息保存/消费的效率.此外越多的partitions意味着可以容纳更多的consumer,有效提升并发消费的能力.</p>
</li>
<li><p>Distributed<br>日志的分区分布在kafka集群的多台服务器上，每台服务器保存数据以及对每个分区数据的请求。每个分区会在多台服务器上进行副本备份以便容错，副本的数量是可配置的。<br>每个分区分有一个“leader”的服务器，剩下的都是“follower”。leader处理对这个分区的所有读写请求，与此同时，follower会被动地去复制leader上的数据。如果leader发生故障，其中一个follower会自动成为新的leader。每台服务器可以作为一些分区的leader，同时也作为其他一些分区的follower，这样在集群内部就可以做到一个很好的负载均衡。</p>
</li>
<li><p>Producer<br>生产者（producer）可以根据具情况将消息发布（publish）到一个主题（topic）上。生产者可以选择将哪条消息发布到这个主题下的某一个分区（partition）。这可以用传统的轮询方式以保证负载均衡，也可以根据一些语义分区函数来做。更多的有关分区的内容后面会讲到。</p>
</li>
<li><p>Consumer<br>传统的消息系统有两种模型：队列和发布-订阅模式。在队列模型中，一堆消费者会从一台机子上读消息，每一条消息只会被一个消费者读到；在发布订阅模型中，消息会向所有的消费者广播。Kafka提供了一种单一的将这两种模型进行抽象的消费者模式——消费者组（consumer group）。</p>
</li>
<li><p>消费者会属于某一个组，发布到每个主题的消息会递送给订阅了这个主题的消费者组中的一个消费者。消费者实例可以是不同的进程或者在不同的机器上。如果所有的消费者从属于同一个组，这就跟传统的队列模式一样了。如果每个消费者自成一组，那么这就是发布订阅模式了，所有的消息会被广播给所有的消费者。但是通常情况下，我们发现，主题会有多个消费者组，每个组对应一个逻辑上的订阅者，每个组由多个消费者实例组成以保证扩展性和容错性。</p>
</li>
<li><p>Kafka处理定序问题上也去传统的消息系统不一样。传统的队列允许消息被任何一个消费者实例所消费。这意味着消息的顺序丢失了。也就是说，尽管在队列中消息是有顺序的，但这些消息会到达不同的消费者并且被无序地处理。在Kafka里，因为有并行的概念——分区，Kafka可以同时提供顺序保证和负载均衡。这可以通过将主题中的分区分配给消费者组中的消费者来实现，这样的话每个分区只被这个组中的一个消费者所消费。这样我们还可以保证这个消费者是这个分区的唯一消费者，并且是按原来的顺序来处理数据的。因为有许多分区，所以也就可以在多个消费者实例中实现负载均衡。需要注意的是，消费者实例的数量不可能比分区多。</p>
</li>
<li><p>Guarantees:<br>1) 发送到partitions中的消息将会按照它接收的顺序追加到日志中<br>2) 对于消费者而言,它们消费消息的顺序和日志中消息顺序一致.<br>3) 如果Topic的”replicationfactor”为N,那么允许N-1个kafka实例失效.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
  </entry>
  <entry>
    <title>51nod 1090 3个数和为0</title>
    <url>/article/csdn/51nod_1090_3%E4%B8%AA%E6%95%B0%E5%92%8C%E4%B8%BA0.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48898885" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48898885</a></p>
<h4><span id="题目链接">题目链接： [</span></h4><p><a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1090" target="_blank" rel="noopener">http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1090</a><br>](<a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1090" target="_blank" rel="noopener">http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1090</a>)</p>
<p>水题。<br>枚举前两项 二分第三项。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;

using namespace std;

int n;
int a[10010];

int main()
{
    while (scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        for (int i = 1;i &lt;= n;i++)
            scanf(&quot;%d&quot;, &amp;a[i]);
        sort(a + 1, a + 1 + n);
        int ok = 0;
        for (int i = 1;i &lt;= n;i++)
            for (int j = i + 1;j &lt;= n;j++)
            {
                if (i != j)
                {
                    int sum = a[i] + a[j];
                    int left = 1, right = n;
                    int mid;
                    int k = 0;
                    int pos;
                    while (left &lt;= right)
                    {
                        mid = (left + right) / 2;
                        if (a[mid] == -sum &amp;&amp; mid != i &amp;&amp; mid != j)
                        {
                            k = 1;
                            pos = mid;
                        }
                        if (a[mid] + sum &gt; 0) right = mid - 1;
                        else left = mid + 1;
                    }
                    if (k &amp;&amp; pos &gt; j)
                    {
                        printf(&quot;%d %d %d\n&quot;, a[i], a[j], a[pos]);
                        ok = 1;
                    }
                }
            }
        if (!ok) puts(&quot;No Solution&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>51nod 1174 区间中最大的数【线段树】</title>
    <url>/article/csdn/51nod_1174_%E5%8C%BA%E9%97%B4%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E6%95%B0%E3%80%90%E7%BA%BF%E6%AE%B5%E6%A0%91%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48862221" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48862221</a></p>
<h4><span id="题目链接">题目链接： [</span></h4><p><a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1174" target="_blank" rel="noopener">http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1174</a><br>](<a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1174" target="_blank" rel="noopener">http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1174</a>)</p>
<p>好久没写线段树了，区间最大值，水题。。</p>
<p>代码:</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;iostream&gt;  
#include &lt;string&gt;  
#include &lt;cstring&gt;  
#include &lt;cmath&gt;  
#include &lt;cstdlib&gt;  
#include &lt;algorithm&gt;  
#include &lt;queue&gt;  
#include &lt;stack&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;vector&gt;  

#define Mid(a,b) ( a+((b-a)&gt;&gt;1))  
#define ll(x) (x&lt;&lt;1)  
#define rr(x) (x&lt;&lt;1|1)  

const int N = 100100;

using namespace std;

int t, n;

int a[N];

struct node
{
    int left;
    int right;
    int sum;
    int mid() { return Mid(left, right); }
};

struct segtree
{
    node tree[N * 4];

    void buildtree(int left, int right, int ind)
    {
        tree[ind].left = left;
        tree[ind].right = right;
        tree[ind].sum = 0;

        if (left == right)
            tree[ind].sum = a[left];
        else
        {
            int mid = tree[ind].mid();
            buildtree(left, mid, ll(ind));
            buildtree(mid + 1, right, rr(ind));
            tree[ind].sum = max(tree[ll(ind)].sum, tree[rr(ind)].sum);
        }
    }

    int query(int st, int ed, int ind)
    {
        int left = tree[ind].left;
        int right = tree[ind].right;

        if (st &lt;= left &amp;&amp; right &lt;= ed)
            return tree[ind].sum;
        else
        {
            int mid = tree[ind].mid();
            int sum1 = 0;
            int sum2 = 0;
            if (st &lt;= mid)
                sum1 = query(st, ed, ll(ind));
            if (ed &gt; mid)
                sum2 = query(st, ed, rr(ind));

            return max(sum1, sum2);
        }
    }
}seg;

int main()
{
    while (scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        for (int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;, &amp;a[i]);
        }

        seg.buildtree(1, n, 1);

        int m;
        scanf(&quot;%d&quot;, &amp;m);
        while(m--)
        {
            int c, d;
            scanf(&quot;%d%d&quot;, &amp;c, &amp;d);
            printf(&quot;%d\n&quot;, seg.query(c + 1, d + 1, 1));
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>51nod 1181 质数中的质数（质数筛法）</title>
    <url>/article/csdn/51nod_1181_%E8%B4%A8%E6%95%B0%E4%B8%AD%E7%9A%84%E8%B4%A8%E6%95%B0%EF%BC%88%E8%B4%A8%E6%95%B0%E7%AD%9B%E6%B3%95%EF%BC%89.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48872087" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48872087</a></p>
<h4><span id="题目链接">题目链接： [</span></h4><p><a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1181" target="_blank" rel="noopener">http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1181</a><br>](<a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1181" target="_blank" rel="noopener">http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1181</a>)</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;iostream&gt;  
#include &lt;string.h&gt;  
#include &lt;algorithm&gt;  
#include &lt;math.h&gt;  
#include &lt;stack&gt;  
#include &lt;queue&gt;  

using namespace std;
const int MAXN = 10000010;

bool com[MAXN];
int primes, prime[MAXN / 10];
int num[MAXN];

void solve(int n)
{
    primes = 0;
    memset(com, false, sizeof(com));
    com[0] = com[1] = true;
    for (int i = 2; i &lt;= n; ++i)
    {
        if (!com[i])
        {
            prime[++primes] = i;
            num[i] = primes;
        }
        for (int j = 1; j &lt;= primes &amp;&amp; i*prime[j] &lt;= n; ++j)
        {
            com[i*prime[j]] = true;
            if (!(i % prime[j]))
                break;
        }
    }
}

int main()
{
    solve(1000010);
    int n;
    while (cin &gt;&gt; n)
    {
        while (!(!com[n] &amp;&amp; !com[num[n]]))
        n++;
        cout &lt;&lt; n &lt;&lt; endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>51nod 1135 原根</title>
    <url>/article/csdn/51nod_1135_%E5%8E%9F%E6%A0%B9.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48872107" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48872107</a></p>
<h4><span id="题目链接">题目链接： [</span></h4><p><a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1135" target="_blank" rel="noopener">http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1135</a><br>](<a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1135" target="_blank" rel="noopener">http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1135</a>)</p>
<p>代码：</p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;math.h&gt;

using namespace std;

const int MAXN = 100000;

int prime[MAXN + 1];

void getPrime()
{
    memset(prime, 0, sizeof(prime));
    for (int i = 2; i &lt;= MAXN; i++)
    {
        if (!prime[i]) prime[++prime[0]] = i;
        for (int j = 1; j &lt;= prime[0] &amp;&amp; prime[j] &lt;= MAXN / i; j++)
        {
            prime[prime[j] * i] = 1;
            if (i%prime[j] == 0) break;
        }
    }
}
long long factor[100][2];
int fatcnt;
int getFactor(long long x)
{
    fatcnt = 0;
    long long tmp = x;
    for (int i = 1; prime[i] &lt;= tmp / prime[i]; i++)
    {
        factor[fatcnt][1] = 0;
        if (tmp%prime[i] == 0)
        {
            factor[fatcnt][0] = prime[i];
            while (tmp%prime[i] == 0)
            {
                factor[fatcnt][1]++;
                tmp /= prime[i];
            }
            fatcnt++;
        }
    }
    if (tmp != 1)
    {
        factor[fatcnt][0] = tmp;
        factor[fatcnt++][1] = 1;
    }
    return fatcnt;
}
long long pow_m(long long m, long long n, long long  k)
{
    long long  b = 1;
    while (n)
    {
        if (n &amp; 1)
            b = (b*m) % k;
        n = n &gt;&gt; 1;
        m = (m*m) % k;
    }
    return b;
}

void solve(int p)
{
    if (p == 2)
    {
        printf(&quot;1\n&quot;);
        return;
    }
    getFactor(p - 1);
    for (int g = 2; g &lt; p; g++)
    {
        bool flag = true;
        for (int i = 0; i &lt; fatcnt; i++)
        {
            int t = (p - 1) / factor[i][0];
            if (pow_m(g, t, p) == 1)
            {
                flag = false;
                break;
            }
        }
        if (flag)
        {
            printf(&quot;%d\n&quot;, g);
            return;//若求所有原根去掉return即可。
        }
    }
}

int main()
{
    getPrime();
    int p;
    while (scanf(&quot;%d&quot;, &amp;p) != EOF)
    {
        solve(p);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>51nod 1212 无向图最小生成树</title>
    <url>/article/csdn/51nod_1212_%E6%97%A0%E5%90%91%E5%9B%BE%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48871905" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48871905</a></p>
<h4><span id="题目链接">题目链接： [</span></h4><p><a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1212" target="_blank" rel="noopener">http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1212</a><br>](<a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1212" target="_blank" rel="noopener">http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1212</a>)</p>
<p>水题。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;iostream&gt;  
#include &lt;string.h&gt;  
#include &lt;algorithm&gt;  
#include &lt;math.h&gt;  
#include &lt;stack&gt;  
#include &lt;queue&gt;  

using namespace std;
#define INF 10000000  

int n, m;
int a, b, c;

int map[1010][1010], dis[1010], v[1010];

int prim(int n)
{
    int i, j, k, min, sum = 0;
    for (i = 1; i &lt;= n; i++)
        dis[i] = map[1][i];

    memset(v, 0, sizeof(v));
    v[1] = 1;
    dis[1] = 0;

    for (i = 2; i &lt;= n; i++)
    {
        k = 1;
        min = INF;
        for (j = 1; j &lt;= n; j++)
            if (!v[j] &amp;&amp; min&gt;dis[j])
            {
                k = j;
                min = dis[j];
            }
        sum += min;
        v[k] = 1;
        for (j = 1; j &lt;= n; j++)
            if (!v[j] &amp;&amp; dis[j]&gt;map[k][j])
                dis[j] = map[k][j];
    }
    return sum;
}

int main()
{
    while (scanf(&quot;%d %d&quot;, &amp;n, &amp;m) != EOF)
    {
        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= n; j++)
                map[i][j] = INF;

        while (m--)
        {
            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
            if (map[a][b] &gt;= c)
            {
                map[a][b] = map[b][a] = c;
            }
        }
        printf(&quot;%d\n&quot;, prim(n));
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>ACM中的期望 概率问题</title>
    <url>/article/csdn/ACM%E4%B8%AD%E7%9A%84%E6%9C%9F%E6%9C%9B_%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46425645" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46425645</a></p>
<p>简易的入门： <a href="http://kicd.blog.163.com/blog/static/126961911200910168335852/" target="_blank" rel="noopener"> http://kicd.blog.163.com/blog/static/126961911200910168335852/
</a><br>大神的总结： <a href="http://blog.csdn.net/woshi250hua/article/details/7912049" target="_blank" rel="noopener"> http://blog.csdn.net/woshi250hua/article/details/7912049
</a><br>全文转自： <a href="http://m.blog.csdn.net/blog/gg_gogoing/43112575" target="_blank" rel="noopener"> http://m.blog.csdn.net/blog/gg_gogoing/43112575
</a><br>bin神专题： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=76505#overview" target="_blank" rel="noopener"> http://acm.hust.edu.cn/vjudge/contest/view.action?cid=76505#overview
</a><br>这些刷完应该就差不多了吧。</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>A*算法</title>
    <url>/article/csdn/A*%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41187115" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41187115</a></p>
<pre><code>把起始格添加到 &quot;开启列表&quot; 
do 
{ 
       寻找开启列表中F值最低的格子, 我们称它为当前格. 
       把它切换到关闭列表. 
       对当前格相邻的8格中的每一个 
          if (它不可通过 || 已经在 &quot;关闭列表&quot; 中) 
          { 
                什么也不做. 
           } 
          if (它不在开启列表中) 
          { 
                把它添加进 &quot;开启列表&quot;, 把当前格作为这一格的父节点, 计算这一格的 FGH 
          if (它已经在开启列表中) 
          { 
                if (用G值为参考检查新的路径是否更好, 更低的G值意味着更好的路径) 
                    { 
                            把这一格的父节点改成当前格, 并且重新计算这一格的 GF 值. 
                    } 
} while( 目标格已经在 &quot;开启列表&quot;, 这时候路径被找到) 
如果开启列表已经空了, 说明路径不存在.

最后从目标格开始, 沿着每一格的父节点移动直到回到起始格, 这就是路径.
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod 1242 斐波那契数列的第N项【矩阵快速幂】</title>
    <url>/article/csdn/51nod_1242_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9A%84%E7%AC%ACN%E9%A1%B9%E3%80%90%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48871469" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48871469</a></p>
<h4><span id="题目链接">题目链接： [</span></h4><p><a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1242" target="_blank" rel="noopener">http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1242</a><br>](<a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1242" target="_blank" rel="noopener">http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1242</a>)</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;

using namespace std;

const int MOD = 1000000009;

struct node
{
    long long m[2][2];
}ans, base;

long long n;

node multi(node a, node b)
{
    node tmp;
    for (int i = 0;i&lt;2;i++)
        for (int j = 0;j&lt;2;j++)
        {
            tmp.m[i][j] = 0;
            for (int k = 0;k&lt;2;k++)
            {
                tmp.m[i][j] += (a.m[i][k] * b.m[k][j]);
                tmp.m[i][j] %= MOD;
            }
        }
    return tmp;
}

long long fast_mod(long long n)// 求矩阵 base 的  n 次幂 
{
    base.m[0][0] = base.m[0][1] = base.m[1][0] = 1;
    base.m[1][1] = 0;
    ans.m[0][0] = ans.m[1][1] = 1;// ans 初始化为单位矩阵
    ans.m[0][1] = ans.m[1][0] = 0;
    while (n)
    {
        if (n &amp; 1) //实现 ans *= t; 其中要先把 ans赋值给 tmp，然后用 ans = tmp * t 
            ans = multi(ans, base);
        base = multi(base, base);
        n &gt;&gt;= 1;
    }
    return ans.m[0][1];
}

int main()
{
    while (scanf(&quot;%lld&quot;, &amp;n) != EOF)
    {
        int ans = fast_mod(n);
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>51nod 1256 乘法逆元</title>
    <url>/article/csdn/51nod_1256_%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48871349" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48871349</a></p>
<h5><span id="题目链接">题目链接： [</span></h5><p><a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1256" target="_blank" rel="noopener">http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1256</a><br>](<a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1256" target="_blank" rel="noopener">http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1256</a>)</p>
<p>水题求逆元。。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;vector&gt;

using namespace std;

long long ext_gcd(long long a, long long b, long long &amp;x, long long &amp;y)
{
    if (a == 0 &amp;&amp; b == 0) return -1;
    if (b == 0)
    {
        x = 1;
        y = 0;
        return a;
    }
    long long d = ext_gcd(b, a%b, y, x);
    y -= a / b*x;
    return d;
}

//求逆元素
// ax=1(mod n)
long long mod_reverse(long long a, long long n)
{
    long long x, y;
    long long d = ext_gcd(a, n, x, y);
    if (d == 1)
        return (x%n + n) % n;
    else
        return -1;
}

int main()
{
    long long a, b;
    while (cin &gt;&gt; a &gt;&gt; b)
    {
        int ans = mod_reverse(a, b);
        cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>ACdream 1099 瑶瑶的第K大</title>
    <url>/article/csdn/ACdream_1099_%E7%91%B6%E7%91%B6%E7%9A%84%E7%AC%ACK%E5%A4%A7.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48789709" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48789709</a></p>
<p>题目链接： <a href="http://acdream.info/problem?pid=1099" target="_blank" rel="noopener"> 点击打开链接 </a></p>
<p>题意：求数组第k大的元素，直接排序会超时的，get到 nth_element 这个函数</p>
<p>nth_element 用法：</p>
<p>nth_element(start, start+n, end)</p>
<p>使第n大元素处于第n位置（从0开始,其位置是下标为n的元素），并且比这个元素小的元素都排在这个元素之前，比这个元素大的元素都排在这个元素之后，但不能保证他们是有序的,原理类似快速排序吧。</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string&gt;
#include &lt;string.h&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;

using namespace std;

int a[5001000];
int n, k;

int main()
{
    while (scanf(&quot;%d%d&quot;,&amp;n,&amp;k)!=EOF)
    {
        for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
        nth_element(a+1,a+1+n-k+1,a+1+n);
        printf(&quot;%d\n&quot;,a[n-k+1]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>ACM小技巧</title>
    <url>/article/csdn/ACM%E5%B0%8F%E6%8A%80%E5%B7%A7.html</url>
    <content><![CDATA[<p>1.一般用C语言节约空间，要用C++库函数或STL时才用C++;<br>cout、cin和printf、scanf最好不要混用。</p>
<p>大数据输入输出时最好不要用cin、cout，防止超时。</p>
<p>2.有时候int型不够用，可以用long long或<strong>int64型(两个下划线</strong>)。</p>
<p>值类型表示值介于 -2^63 ( -9,223,372,036,854,775,808)<br>到2^63-1(+9,223,372,036,854,775,807 )之间的整数。</p>
<p>printf(“%I64d”,a); //__int64 一般VC编译器使用</p>
<p>printf(“%lld”,a); //long long 一般g++编译器使用</p>
<p>3.OJ判断是只看输出结果的。</p>
<p>所以大部分题处理一组数据后可以直接输出，就不需要用数组保存每一个Case的数据。</p>
<p>while(case–)</p>
<p>{scanf(…);</p>
<p>……</p>
<p>printf(…);</p>
<p>}</p>
<p>4.纯字符串用puts()输出。</p>
<p>数据大时最好用scanf()、printf()减少时间。</p>
<p>先用scanf()，再用gets()会读入回车。所以在中间加一个getchar();</p>
<p>scanf(“%c%c”,&amp;c1,&amp;c2)会读入空格；建议用%s读取字符串，取第一个字符。</p>
<p>5.</p>
<p>读到文件的结尾，程序自动结束 <em>**</em></p>
<p>while( ( scanf(  “  %d  ”  , &amp;a) ) != -1 )</p>
<p>while( ( scanf(  “  %d  ”  ,&amp;a) ) != EOF)</p>
<p>while( ( scanf(  “  %d  ”  ,&amp;a) ) == 1 )</p>
<p>while( ~( scanf(  “  %d  ”  ,&amp;a) )  )</p>
<p>读到一个  0  时，程序结束</p>
<p>while( scanf(  “  %d  ”  ,&amp;a) ,a)</p>
<p>读到多个0  时，程序结束</p>
<p>while( scanf(  “  %d%d%d  ”  ,&amp;a,&amp;b,&amp;c),a+b+c ) //a,b,c非负</p>
<p>while( scanf(  “  %d%d%d  ”  ,&amp;a,&amp;b,&amp;c),a|b|c )</p>
<p>6.数组定义int a[10]={0};可以对其全部元素赋值为0；</p>
<p>数组太大不要这样，防止CE。</p>
<p>全局变量，静态变量自动初始化为0；</p>
<p>7.有很多数学题是有规律的，直接推公式或用递归、循环。</p>
<p>8.圆周率=acos(-1.0)<br>自然对数=exp(1.0)</p>
<p>9.如果要乘或除2^n,用位移运算速度快。a&gt;&gt;n;a&lt;&lt;n;</p>
<p>10.定义数组时，数组大小最好比告诉的最大范围大一点。</p>
<p>字符数组大小必须比字符串最大长度大1。</p>
<p>处理字符数组时不要忘了在最后加’/0’或者0。</p>
<p>11.擅用三目运算符</p>
<p>int max(int a,int b)</p>
<p>{return a&gt;b?a:b;</p>
<p>}</p>
<p>int gcd(int m,int n)</p>
<p>{return n?gcd(n,m%n):m;</p>
<p>}</p>
<p>int abs(int a)</p>
<p>{return a&lt;0?-a:a;</p>
<p>}</p>
<p>12.将乘法转换成加法减少时间</p>
<p>log(a*b)=log(a)+log(b)</p>
<p>将乘法转换成除法防止溢出</p>
<p>a/(b*c)=a/b/c</p>
<p>13.排序要求不高时可以用C++的STL模板函数sort(),stable_sort()</p>
<p>int a[n]={…};</p>
<p>sort(a,a+n);</p>
<p>bool cmp(int m,int n)</p>
<p>{return m&gt;n;</p>
<p>}</p>
<p>sort(a,a+n,cmp);</p>
<p>14.有的题数据范围小但是计算量大可以用打表法</p>
<p>先把结果算出来保存在数组里，要用时直接取出来。</p>
<p>15.浮点数比较时最好控制精度</p>
<p>#define eps 1e-6</p>
<p>fabs(a-b)&lt;eps</p>
<p>16.有些字符串与整型的转换函数是非标准的</p>
<p>可以使用sscanf()和sprintf()代替</p>
<p>sscanf(s,”%d”,&amp;n);//从字符串s中读入整数n</p>
<p>sprintf(s,”%d”,n);//将n转换为字符串s</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>二进制</tag>
        <tag>acm</tag>
        <tag>c语言</tag>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ [BeiJing2006]狼抓兔子 【网络流】</title>
    <url>/article/csdn/BZOJ_%5BBeiJing2006%5D%E7%8B%BC%E6%8A%93%E5%85%94%E5%AD%90_%E3%80%90%E7%BD%91%E7%BB%9C%E6%B5%81%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48957759" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48957759</a></p>
<p>题目链接： <a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1001" target="_blank" rel="noopener"> http://www.lydsy.com/JudgeOnline/problem.php?id=1001
</a></p>
<p>就是求最小割 阻止两个兔子窝间联通</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;sstream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string&gt;

using namespace std;

const int MAXN = 1010000;//点数的最大值
const int MAXM = 6001000;//边数的最大值
const int INF = 0x3f3f3f3f;

struct Edge
{
    int to, next, cap, flow;
}edge[MAXM];//注意是MAXM

int tol;
int head[MAXN];
int gap[MAXN], dep[MAXN], pre[MAXN], cur[MAXN];

void init()
{
    tol = 0;
    memset(head, -1, sizeof(head));
}
//加边，单向图三个参数，双向图四个参数
void addedge(int u, int v, int w, int rw = 0)
{
    edge[tol].to = v; edge[tol].cap = w; edge[tol].next = head[u];
    edge[tol].flow = 0; head[u] = tol++;
    edge[tol].to = u; edge[tol].cap = rw; edge[tol].next = head[v];
    edge[tol].flow = 0; head[v] = tol++;
}
//输入参数：起点、终点、点的总数
//点的编号没有影响，只要输入点的总数

int Q[MAXN];

void BFS(int start,int end)
{
    memset(dep, -1, sizeof(dep));
    memset(gap, 0, sizeof(gap));
    gap[0] = 1;
    int front = 0, rear = 0;
    dep[end] = 0;
    Q[rear++] = end;
    while (front != rear)
    {
        int u = Q[front++];
        for (int i = head[u];i != -1;i = edge[i].next)
        {
            int v = edge[i].to;
            if (dep[v] != -1) continue;
            Q[rear++] = v;
            dep[v] = dep[u] + 1;
            gap[dep[v]]++;
        }
    }
}
int S[MAXN];
int sap(int start, int end, int N)
{
    BFS(start, end);
    memcpy(cur, head, sizeof(head));
    int u = start;
    int top = 0;
    int ans = 0;
    while (dep[start] &lt; N)
    {
        if (u == end)
        {
            int Min = INF;
            int inser;
            for (int i = 0; i &lt; top; i++)
                if (Min &gt; edge[S[i]].cap - edge[S[i]].flow)
                {
                    Min = edge[S[i]].cap - edge[S[i]].flow;
                    inser = i;
                }
            for (int i = 0; i &lt; top; i++)
            {
                edge[S[i]].flow += Min;
                edge[S[i] ^ 1].flow -= Min;
            }
            ans += Min;
            top = inser;
            u = edge[S[top] ^ 1].to;
            continue;
        }
        bool flag = false;
        int v;
        for (int i = cur[u]; i != -1; i = edge[i].next)
        {
            v = edge[i].to;
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[v] + 1 == dep[u])
            {
                flag = true;
                cur[u]  = i;
                break;
            }
        }
        if (flag)
        {
            S[top++] = cur[u];
            u = v;
            continue;
        }
        int Min = N;
        for (int i = head[u]; i != -1; i = edge[i].next)
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min)
            {
                Min = dep[edge[i].to];
                cur[u] = i;
            }
        gap[dep[u]]--;
        if (!gap[dep[u]])return ans;
        dep[u] = Min + 1;
        gap[dep[u]]++;
        if (u != start) u = edge[S[--top]^1].to;
    }
    return ans;
}

int n, m;

int main()
{
    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)
    {
        init();
        int w;
        int tmp = 1;

        for(int i=1;i&lt;=n;i++)
        {
            for(int j=1;j&lt;m;j++)
            {
                scanf(&quot;%d&quot;,&amp;w);
                addedge( (i-1)*m+j,(i-1)*m+j+1,w,w);
            }
        }

        for(int i=1;i&lt;n;i++)
        {
            for(int j=1;j&lt;=m;j++)
            {
                scanf(&quot;%d&quot;,&amp;w);
                addedge((i-1)*m+j,(i-1)*m+j+m,w,w);
            }
        }

        for(int i=1;i&lt;n;i++)
        {
            for(int j=1;j&lt;m;j++)
            {
                scanf(&quot;%d&quot;,&amp;w);
                addedge((i-1)*m + j,(i-1)*m + j + m + 1,w,w);
            }
        }
        int ans = sap(1,n*m,n*m);
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>BNU 13288 Bi-shoe and Phi-shoe 【素数筛选】</title>
    <url>/article/csdn/BNU_13288_Bi-shoe_and_Phi-shoe_%E3%80%90%E7%B4%A0%E6%95%B0%E7%AD%9B%E9%80%89%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44156609" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44156609</a></p>
<p>A -  Bi-shoe and Phi-shoe</p>
<hr>
<p><strong>  
</strong></p>
<p>Time Limit:  2000  MS <strong>Memory Limit:</strong> 32768  KB <strong>64bit IO Format:</strong> %lld  &amp;<br>%llu</p>
<p>Submit  <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=70017#status//A/0" target="_blank" rel="noopener"> Status
</a></p>
<p>Description</p>
<p>Bamboo Pole-vault is a massively popular sport in Xzhiland. And Master Phi-<br>shoe is a very popular coach for his success. He needs some bamboos for his<br>students, so he asked his assistant Bi-Shoe to go to the market and buy them.<br>Plenty of Bamboos of all possible integer lengths (yes!) are available in the<br>market. According to Xzhila tradition,</p>
<p>Score of a bamboo = <strong>Φ (bamboo’s length)</strong></p>
<p>(Xzhilans are really fond of number theory). For your information, <strong>Φ (n)</strong> =<br>numbers less than <strong>n</strong> which are relatively prime (having no common divisor<br>other than 1) to <strong>n</strong> . So, score of a bamboo of length 9 is 6 as 1, 2, 4, 5,<br>7, 8 are relatively prime to 9.</p>
<p>The assistant Bi-shoe has to buy one bamboo for each student. As a twist, each<br>pole-vault student of Phi-shoe has a lucky number. Bi-shoe wants to buy<br>bamboos such that each of them gets a bamboo with a score greater than or<br>equal to his/her lucky number. Bi-shoe wants to minimize the total amount of<br>money spent for buying the bamboos. One unit of bamboo costs 1 Xukha. Help<br>him.</p>
<p>Input</p>
<p>Input starts with an integer <strong>T (≤ 100)</strong> , denoting the number of test<br>cases.</p>
<p>Each case starts with a line containing an integer <strong>n (1 ≤ n ≤ 10000)</strong><br>denoting the number of students of Phi-shoe. The next line contains <strong>n</strong><br>space separated integers denoting the lucky numbers for the students. Each<br>lucky number will lie in the range <strong>[1, 10 6  ] </strong> .</p>
<p>Output</p>
<p>For each case, print the case number and the minimum possible money spent for<br>buying the bamboos. See the samples for details.</p>
<p>Sample Input</p>
<p>3</p>
<p>5</p>
<p>1 2 3 4 5</p>
<p>6</p>
<p>10 11 12 13 14 15</p>
<p>2</p>
<p>1 1</p>
<p>Sample Output</p>
<p>Case 1: 22 Xukha</p>
<p>Case 2: 88 Xukha</p>
<p>Case 3: 4 Xukha</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;
#include &lt;iterator&gt;

using namespace std;

const int MAXN = 1000100;
int n, m, t;
int prime[MAXN], ph[MAXN], p[MAXN], q[MAXN];

void solve(int n)
{
    memset(prime,0,sizeof(prime));
    memset(p,0,sizeof(p));
    memset(ph,0,sizeof(ph));
    int t = 0;

    for (int i = 2; i &lt;= n; i++)
    {
        if (p[i] == 0)
            prime[++t] = i;
        for (int j = i * 2; j &lt;= n; j+=i)
        {
            p[j] = 1;
        }
    }
    t = 1;
    for (int i = 1; i &lt;= n; i++)
    {
        while (i &gt;= prime[t])
        {
            t++;
        }
        if (i &lt; prime[t])
            ph[i] = prime[t];
    }
}
/*
int phi[MAXN];

void Phi(int n)
{
    for (int i = 0; i &lt;= n; i++)
        phi[i] = 0;
    phi[1] = 1;
    for (int i = 2; i &lt;= n; i++)
    {
        if (!phi[i])
        {
            for (int j = i; j &lt;= n; j += i)
            {
                if (!phi[j]) phi[j] = j;
                phi[j] = phi[j] / i*(i-1);
            }
        }
    }
}
*/
int main()
{
    int cases = 1;
    solve(1001000);
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        long long ans = 0;
        scanf(&quot;%d&quot;,&amp;n);
        for (int i = 0; i &lt; n; i++)
            scanf(&quot;%d&quot;, &amp;q[i]);

        sort(q,q+n);

        for (int i = 0; i &lt; n; i++)
            ans += ph[q[i]];
        printf(&quot;Case %d: %lld Xukha\n&quot;,cases++,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>BZOJ 1207 [HNOI2004]打鼹鼠</title>
    <url>/article/csdn/BZOJ_1207:_%5BHNOI2004%5D%E6%89%93%E9%BC%B9%E9%BC%A0.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48968621" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48968621</a></p>
<p>题目链接： <a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1207" target="_blank" rel="noopener"> http://www.lydsy.com/JudgeOnline/problem.php?id=1207
</a></p>
<p>动态规划 当前的每步必是由之前的某一步得来的</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;sstream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string&gt;

using namespace std;

int n,m;

struct Node
{
    int x,y;
    int t;
}a[10100];

int f[10010];

int main()
{
    while (scanf(&quot;%d%d&quot;,&amp;n,&amp;m) !=EOF)
    {
        for(int i=1;i&lt;=m;i++)
            {
                f[i]=1;
                scanf(&quot;%d%d%d&quot;,&amp;a[i].t,&amp;a[i].x,&amp;a[i].y);
            }
        int ans = 1;
        for(int i=1;i&lt;=m;i++)
        {
            for(int j=i+1;j&lt;=m;j++)
            {
                if (abs(a[i].x - a[j].x) + abs(a[i].y - a[j].y) &lt;= a[j].t - a[i].t)
                    f[j] = max(f[j],f[i] + 1);
                ans = max(ans, f[j]);
            }
        }
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>bzoj</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ 1050 [HAOI2006]旅行comf</title>
    <url>/article/csdn/BZOJ_1050:_%5BHAOI2006%5D%E6%97%85%E8%A1%8Ccomf.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48976655" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48976655</a></p>
<p>题目链接：1050: [HAOI2006]旅行comf</p>
<p>求起点到终点的一条路径，使得路径最长边与最短边比值最小。<br>边按小到大排序。枚举最小边值依次加边，直至起点终点联通，更新答案。</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;sstream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string&gt;

using namespace std;

struct  Node
{
    int x,y;
    int w;
}a[500010];

bool cmp(Node a,Node b)
{
    return a.w &lt; b.w;
}

int gcd(int a,int b)
{
    if (b == 0) return a;
    else return gcd(b,a%b);
}

int f[10010];
int fi(int x)
{
    if(f[x] == -1) return x;
    else return f[x] = fi(f[x]);
}

void un(int x,int y)
{
    int fx = fi(x);
    int fy = fi(y);
    if (fx != fy)
        f[fx] = fy;
}

int n,m;

int main()
{
    while (scanf(&quot;%d%d&quot;,&amp;n,&amp;m) != EOF)
    {
        int s,t;
        for(int i=1;i&lt;=m;i++)
            scanf(&quot;%d%d%d&quot;,&amp;a[i].x,&amp;a[i].y,&amp;a[i].w);
        scanf(&quot;%d%d&quot;,&amp;s,&amp;t);
        sort(a+1,a+1+m,cmp);

        int ans1,ans2;
        double tmp = 1e8;

        for(int i=1;i&lt;=m;i++)
        {
            memset(f,-1,sizeof(f));
            int ok = 0;
            int MIN = a[i].w;
            int MAX;
            for(int j=i;j&lt;=m;j++)
            {
                MAX = a[j].w;
                un(a[j].x,a[j].y);
                if (fi(s) == fi(t))
                {
                    ok = 1;
                    double tt = (double)(MAX*1.0/MIN);
                    if (tt &lt; tmp)
                    {
                        tmp = tt;
                        ans1 = MAX;
                        ans2 = MIN;
                    }
                    break;
                }
                if (ok) break;
            }
        }
        if (tmp == 1e8) puts(&quot;IMPOSSIBLE&quot;);
        else
        {
            int tt = gcd(ans1,ans2);
            if (ans2 == tt)
                printf(&quot;%d&quot;,ans1/ans2);
            else
                printf(&quot;%d/%d\n&quot;,ans1/tt,ans2/tt);
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>bzoj</tag>
        <tag>排序</tag>
        <tag>联通</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 模板与泛型编程</title>
    <url>/article/csdn/C++_%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47328219" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47328219</a></p>
<p>例子：比较两个值的函数模板</p>
<pre><code>template &lt;typename T&gt;
int compare(const T &amp;t1, const T &amp;t2)
{
    if (t2 &lt; t1) return 1;
    if (t1 &lt; t2) return -1;
    return 0;
}
</code></pre><p>编写泛型代码的两个重要原则：<br>1 模板中函数参数是const的引用<br>2 函数体中条件判断仅适用&lt;比较运算符</p>
<p>模板参数列表中 typename 和 class 没有什么不同。typename更为直观。</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>C++ volatile关键字</title>
    <url>/article/csdn/C++_volatile%E5%85%B3%E9%94%AE%E5%AD%97.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44006713" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44006713</a></p>
<h1><span id="volatile的介绍">volatile的介绍</span></h1><h1><span id="直接处理硬件的程序常常包含该关键字它们的值由程序之外的过程控制">直接处理硬件的程序常常包含该关键字，它们的值由程序之外的过程控制。</span></h1><p>volatile告诉编译器编译不对该对象进行优化，volatile<br>变量是随时可能发生变化的，与volatile变量有关的运算，不要进行编译优化，以免出错，（VC++<br>在产生release版可执行码时会进行编译优化，加volatile关键字的变量有关的运算，将不进行编译优化。）。  </p>
<pre><code>#include &lt;stdio.h&gt;

void main()
{
    volatile int i = 10;
    int a = i;

    printf(&quot;i = %d\n&quot;, a);
    __asm {
        mov dword ptr[ebp - 4], 20h
    }

    int b = i;
    printf(&quot;i = %d\n&quot;, b);
}
</code></pre><p>输出：10,32</p>
<p>volatile的主要作用是：提示编译器该对象的值有可能在编译器未监测的情况下被改变。<br>表示用volatile定义的变量会在程序外被改变,每次都必须从内存中读取，而不能把他放在cache或寄存器中重复使用。</p>
<p>volatile类似于大家所熟知的const也是一个类型修饰符。volatile是给编译器的指示来说明对它所修饰的对象不应该执行优化。volatile的作用就是用来进行多线程编程。在单线程中那就是只能起到限制编译器优化的作用。  </p>
<p>volatile用在如下的几个地方：<br>1) 中断服务程序中修改的供其它程序检测的变量需要加volatile；<br>2) 多任务环境下各任务间共享的标志应该加volatile；<br>3) 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>C++primer 17.4 随机数</title>
    <url>/article/csdn/C++primer_17.4_%E9%9A%8F%E6%9C%BA%E6%95%B0.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/49560641" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/49560641</a></p>
<p>c语言的库函数 rand 生成的随机数为伪随机数。<br><strong>c++提供随机数引擎类和随机数分布类</strong><br>头文件: random</p>
<h3><span id="随机数引擎">随机数引擎：</span></h3><p>随机数引擎的例子：</p>
<pre><code>default_random_engine e;
 for (int i = 1;i &lt;= 10;i++)
    cout &lt;&lt; e() &lt;&lt; endl;//e()对象生成下一个随机数
</code></pre><p>随机数引擎操作</p>
<pre><code>    default_random_engine e;//默认构造函数
    default_random_engine e(100);//100为随机种子
    e.seed(100);//100为随机种子
    cout &lt;&lt; e.min() &lt;&lt; endl;//引擎能生成的最小值
    cout &lt;&lt; e.max() &lt;&lt; endl;//引擎能生成的最大值
</code></pre><h3><span id="分布类型">分布类型：</span></h3><p>为了得到一定范围内的数，使用分布类型的对象：</p>
<pre><code>    uniform_int_distribution&lt;unsigned&gt; u(1, 100);
    default_random_engine e;
    for (int i = 1;i &lt;= 10;i++)
        cout &lt;&lt; u(e) &lt;&lt; endl;
</code></pre><p>为了得到随机序列引擎和分布对象定义为static的：</p>
<pre><code>    static uniform_int_distribution&lt;unsigned&gt; u(1, 100);
    static default_random_engine e;
    for (int i = 1;i &lt;= 10;i++)
        cout &lt;&lt; u(e) &lt;&lt; endl;
</code></pre><p>设置随机数种子：<br>可以使用系统的时间函数</p>
<pre><code>default_random_engine e(time(0));
</code></pre><p>随机初始化的种子。</p>
<h3><span id="其他随机数分布">其他随机数分布</span></h3><h4><span id="生成随机实数">生成随机实数：</span></h4><pre><code>    default_random_engine e(time(0));
    uniform_real_distribution&lt;double&gt; v(0,1);//随机实数的函数

    for (int i = 1;i &lt;= 10;i++)
        cout &lt;&lt; v(e) &lt;&lt; endl;
</code></pre><h4><span id="非均匀分布的随机数">非均匀分布的随机数</span></h4><p>c++支持非均匀分布的随机数，新标准库定义20种分布类型，下面介绍一个正态分布的一个函数：</p>
<h5><span id="normal_distribution">normal_distribution</span></h5><p>例子：</p>
<pre><code>    default_random_engine e(time(0));   
    normal_distribution&lt;&gt; n(4,1.5);//均值为4，标准差1.5
    for (int i = 1;i &lt;= 10;i++)
    {
        int t = n(e);
        for (int j = 1;j &lt;= t;j++)
            cout &lt;&lt; &quot;*&quot;;
        cout &lt;&lt; endl;

    }   
</code></pre><p><img src="https://img-blog.csdn.net/20151101190922482" alt="这里写图片描述"></p>
<h5><span id="bernoulli_distribution-类">bernoulli_distribution 类</span></h5><p>用来随机产生bool值，默认概率为0.5-0.5，可修改：</p>
<pre><code>    default_random_engine e(time(0));
    bernoulli_distribution b;
    cout &lt;&lt; b(e) &lt;&lt; endl;
</code></pre><p>true的概率修改为99%</p>
<pre><code>    default_random_engine e(time(0));
    bernoulli_distribution b(.99);
    cout &lt;&lt; b(e) &lt;&lt; endl;
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>C++primer 17.2 bitset类型</title>
    <url>/article/csdn/C++primer_17.2_bitset%E7%B1%BB%E5%9E%8B.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/49561949" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/49561949</a></p>
<p>bitset类型使得位运算更为容易，定义在头文件bitset中</p>
<h2><span id="定义和初始化bitset">定义和初始化bitset</span></h2><p>定义bitset时需声明包含多少位：</p>
<pre><code>    bitset&lt;32&gt; bits(1u);//定义一个32位第一位为1 其他位为0 的bitset
</code></pre><p>bitset初始化的方法：</p>
<pre><code>    bitset&lt;n&gt; b;  n位均为0
    bitset&lt;n&gt; b(u);  对u的低n位拷贝
    bitset&lt;n&gt; b(s, pos, m, zero, one);  拷贝字符串s的pos位置开始的m个字符，字符串包含zero和one字符
    bitset&lt;n&gt; b(cp, pos, m, zero, one);  拷贝数组cp的pos位置开始的m个字符，字符串包含zero和one字符
</code></pre><p>用unsigned初始化：</p>
<pre><code>    bitset&lt;13&gt; b1(0xbeef);
    bitset&lt;20&gt; b2(0xbeef);
    bitset&lt;128&gt; b3(~0ull);
    cout &lt;&lt; b1 &lt;&lt; endl;
    cout &lt;&lt; b2 &lt;&lt; endl;
    cout &lt;&lt; b3 &lt;&lt; endl;
</code></pre><p><img src="https://img-blog.csdn.net/20151101203213480" alt=""></p>
<p>从一个string初始化bitset：<br><strong><em>注意string的下标习惯与bitset恰好相反。</em> </strong></p>
<pre><code>     string s = &quot;1111111000001010101110&quot;;
    bitset&lt;20&gt; b1(&quot;1100&quot;);
    bitset&lt;20&gt; b2(s,5,4);
    bitset&lt;20&gt; b3(s,s.size()-4);
    cout &lt;&lt; b1 &lt;&lt; endl;
    cout &lt;&lt; b2 &lt;&lt; endl;
    cout &lt;&lt; b3 &lt;&lt; endl;
</code></pre><p><img src="https://img-blog.csdn.net/20151101204209539" alt="这里写图片描述"></p>
<h2><span id="bitset操作">bitset操作</span></h2><p>置位操作即为 1，复位操作为 0</p>
<pre><code>    bitset&lt;32&gt; b; 
    b.any();  是否存在置位的二进制位
    b.all();  是否所有置位的二进制位
    b.none();   是否不存在置位的二进制位
    b.count();  置位的二进制位个数
    b.size();  二进制位数
    b.test(pos);  是否pos置位的二进制置位
    b.set(pos,v);  pos位置置位v
    b.set();  默认set为true
    b.reset(pos);  pos位置复位
    b.reset();  
    b.flip(pos);  改变pos位置的状态
    b.flip();
    b[pos];  
    b.to_string();
    b.to_ullong();
    b.to_ulong();
    os &lt;&lt; b;
    is &gt;&gt; b;
</code></pre><p>提取bitset的值：</p>
<pre><code>    bitset&lt;32&gt; b (&quot;1100&quot;);
    unsigned long long uu = b.to_ullong();
    cout &lt;&lt; uu &lt;&lt; endl;
</code></pre><p><img src="https://img-blog.csdn.net/20151101205104144" alt="这里写图片描述"></p>
<p>bitset 的 IO 运算：<br>输入直至读取的位数达到对应大小，或遇到非法字符，或文件结束。</p>
<pre><code>    bitset&lt;12&gt; b;
    cin &gt;&gt; b;
    cout &lt;&lt; b &lt;&lt; endl;
</code></pre><p><img src="https://img-blog.csdn.net/20151101205331512" alt="这里写图片描述"></p>
<p>bitset的使用：<br>和普通位运算基本一致，不过多了一些操作的方法，就不赘述了。</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>bitset</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/article/csdn/Codeforces_Round_267_(Div._2)_A_B_C.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46384309" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46384309</a></p>
<p>题目链接: <a href="http://codeforces.com/contest/467" target="_blank" rel="noopener"> http://codeforces.com/contest/467 </a><br>A 水<br>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;queue&gt;
#include &lt;set&gt;

using namespace std;

int n;
int p, q;

int main()
{
    while (cin &gt;&gt; n)
    {
        int ans = 0;
        for (int i = 1; i &lt;= n; i++)
        {
            cin &gt;&gt; p &gt;&gt; q;
            if (q - p &gt;= 2) ans++;
        }
        cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}
</code></pre><p>B 暴力一发<br>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int x[10005];

int test(int x)
{
    int ans = 0;
    while (x)
    {
        if (x &amp; 1) ans++;
        x = x &gt;&gt; 1;
    }
    return ans;
}

int main()
{
    int n, m, k;
    while (~scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k))
    {
        m++;
        for (int i = 1; i &lt;= m; i++)
            scanf(&quot;%d&quot;,&amp;x[i]);
        int ans = 0;
        for (int i = 1; i &lt; m; i++)
        {
            if (test(x[i] ^ x[m]) &lt;= k) ans++;
        }
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}
</code></pre><p>C dp ；<br>解法：dp[i][j]表示 （前i个 ，分为j组的时候最优解。<br>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

typedef long long  LOL;

int n, m, k;
LOL p[5010], dp[5010][5010];

int main()
{
    while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; k)
    {
        memset(p,0,sizeof(p));
        memset(dp,0,sizeof(dp));
        for (int i = 1; i &lt;= n; i++)
        {
            cin &gt;&gt; p[i];
            p[i] += p[i-1];
        }
        //dp[i][j]表示   （前i个 ，分为j组的时候最优解
        for (int i = m; i &lt;= n; i++)
            for (int j = 1; j &lt;= k; j++)
            {
                dp[i][j] = max(dp[i-1][j],dp[i-m][j-1] + p[i]-p[i-m]);
            }
        cout &lt;&lt; dp[n][k] &lt;&lt; endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>C C++之回调函数</title>
    <url>/article/csdn/C_C++%E4%B9%8B%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48677835" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48677835</a></p>
<p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p>
<p>函数指针<br>（1）概念：指针是一个变量，是用来指向内存地址的。一个程序运行时，所有和运行相关的物件都是需要加载到内存中，这就决定了程序运行时的任何物件都可以用指针来指向它。函数是存放在内存代码区域内的，它们同样有地址，因此同样可以用指针来存取函数，把这种指向函数入口地址的指针称为函数指针。</p>
<pre><code>void Invoke(char* s)
{
    printf(s);
}
int main()
{
    void (*fp)(char* s);    //声明一个函数指针(fp)        
    fp=Invoke;              //将Invoke函数的入口地址赋值给fp
    fp(&quot;Hello World!\n&quot;);   //函数指针fp实现函数调用
    return 0;
}
</code></pre><p>回调样式例子：</p>
<pre><code>//定义回调函数
void PrintfText() 
{
    printf(&quot;Hello World!\n&quot;);
}

//定义实现回调函数的&quot;调用函数&quot;
void CallPrintfText(void (*callfuct)())
{
    callfuct();
}

//在main函数中实现函数回调
int main(int argc,char* argv[])
{
    CallPrintfText(PrintfText);
    return 0;
}


//定义带参回调函数
void PrintfText(char* s) 
{
    printf(s);
}

//定义实现带参回调函数的&quot;调用函数&quot;
void CallPrintfText(void (*callfuct)(char*),char* s)
{
    callfuct(s);
}

//在main函数中实现带参的函数回调
int main(int argc,char* argv[])
{
    CallPrintfText(PrintfText,&quot;Hello World!\n&quot;);
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/article/csdn/Codeforces_Round_266_(Div._2)_C.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41928881" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41928881</a></p>
<p><a href="http://codeforces.com/contest/466/problem/C" target="_blank" rel="noopener"> http://codeforces.com/contest/466/problem/C
</a></p>
<p>C. Number of Ways</p>
<p>time limit per test</p>
<p>2 seconds</p>
<p>memory limit per test</p>
<p>256 megabytes</p>
<p>input</p>
<p>standard input</p>
<p>output</p>
<p>standard output</p>
<p>You’ve got array  _a_ [1], _a_ [2], …, _a_ [ _n_ ]  , consisting of  _n_<br>integers. Count the number of ways to split all the elements of the array into<br>three contiguous parts so that the sum of elements in each part is the same.</p>
<p>More formally, you need to find the number of such pairs of indices  _i_ , _j_<br>(2 ≤ _i_ ≤ _j_ ≤ _n_ - 1)  , that<br><img src="http://espresso.codeforces.com/669a2f09a3b9e143f54b1f1d9fd6b7dddf403680.png" alt=""><br>.</p>
<p>Input</p>
<p>The first line contains integer  _n_ (1 ≤ _n_ ≤ 5·10  5  )  , showing how many<br>numbers are in the array. The second line contains  _n_ integers  _a_ [1]  ,<br>_a_ [2]  , …,  _a_ [ _n_ ]  (| _a_ [ _i_ ]| ≤  10  9  )  — the elements of<br>array  _a_ .</p>
<p>Output</p>
<p>Print a single integer — the number of ways to split the array into three<br>parts with the same sum.</p>
<p>Sample test(s)</p>
<p>input</p>
<pre><code>5
1 2 3 0 3
</code></pre><p>output</p>
<pre><code>2
</code></pre><p>input</p>
<pre><code>4
0 1 -1 0
</code></pre><p>output</p>
<pre><code>1
</code></pre><p>input</p>
<pre><code>2
4 1
</code></pre><p>output</p>
<pre><code>0







#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt;
#include&lt;malloc.h&gt;

using namespace std;

long long sum[500005];

int main()
{
    sum[0]=0;
    int n;
    while(cin&gt;&gt;n)
    {
        memset(sum, 0, sizeof(sum));
        for(int i=1;i&lt;=n;++i)
        {
            cin&gt;&gt;sum[i];
            sum[i]+=sum[i-1];
        }
        long long aver;
        if(sum[n]==0)
        {
            long long k = 0;
            for (int i = 1; i &lt;= n; ++i)
            {
                if (sum [i] == 0)
                {
                    k++;
                }
            }
            cout &lt;&lt;(k-1)*(k-2)/2 &lt;&lt;endl;
            continue;
        }
        if(sum[n]%3==0 )
        {
            aver=sum[n]/3;
        }
        else
        {
            cout&lt;&lt;0&lt;&lt;endl;
            continue;
        }

        long long pc=0, ss=0;

        for(int i=1;i&lt;=n;++i)
        {
            if (sum[i] == aver)
                pc++;
            if (sum[i] == aver *2)
                ss += pc;
        }
            cout&lt;&lt;ss*pc&lt;&lt;endl;
    }
    return 0;
}
</code></pre><p>赛后懂了。。。</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/article/csdn/Codeforces_Round_277_(Div._2)_A_B.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41262527" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41262527</a></p>
<p><a href="http://codeforces.com/contest/486/problem/A" target="_blank" rel="noopener"> http://codeforces.com/contest/486/problem/A
</a>  </p>
<p>A. Calculating Function</p>
<p>time limit per test</p>
<p>1 second</p>
<p>memory limit per test</p>
<p>256 megabytes</p>
<p>input</p>
<p>standard input</p>
<p>output</p>
<p>standard output</p>
<p>For a positive integer  _n_ let’s define a function  _f_ :</p>
<p>_f_ ( _n_ ) =  - 1 + 2 - 3 + .. + ( - 1)  _n_ _n_</p>
<p>Your task is to calculate  _f_ ( _n_ )  for a given integer  _n_ .</p>
<p>Input</p>
<p>The single line contains the positive integer  _n_ (  1 ≤ _n_ ≤ 10  15  ).</p>
<p>Output</p>
<p>Print  _f_ ( _n_ )  in a single line.</p>
<p>Sample test(s)</p>
<p>input</p>
<pre><code>4
</code></pre><p>output</p>
<pre><code>2
</code></pre><p>input</p>
<pre><code>5
</code></pre><p>output</p>
<pre><code>-3
</code></pre><p>Note</p>
<p>_f_ (4) =  - 1 + 2 - 3 + 4 = 2</p>
<p>_f_ (5) =  - 1 + 2 - 3 + 4 - 5 =  - 3</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;malloc.h&gt;
#include&lt;string.h&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;

using namespace std;

long long n;


int main ()
{
    while (scanf(&quot;%I64d&quot;,&amp;n)!=EOF)
    {
        if (n%2 == 0)
            printf(&quot;%I64d\n&quot;,n/2);
        else
            printf(&quot;%I64d\n&quot;,(n/2+1)*-1);
    }
    return 0;
}
</code></pre><p><a href="http://codeforces.com/contest/486/problem/B" target="_blank" rel="noopener"> http://codeforces.com/contest/486/problem/B
</a>  </p>
<p>B. OR in Matrix</p>
<p>time limit per test</p>
<p>1 second</p>
<p>memory limit per test</p>
<p>256 megabytes</p>
<p>input</p>
<p>standard input</p>
<p>output</p>
<p>standard output</p>
<p>Let’s define logical  _OR_ as an operation on two logical values (i. e. values<br>that belong to the set  {0, 1}  ) that is equal to  1  if either or both of<br>the logical values is set to  1  , otherwise it is  0  . We can define logical<br>_OR_ of three or more logical values in the same manner:</p>
<p><img src="http://espresso.codeforces.com/661f67f4b56b351d145dce2e9a87cd7c5f6a4d64.png" alt=""><br>where<br><img src="http://espresso.codeforces.com/7bcdd7440cc300269a3395fa037d5af6351c3221.png" alt=""><br>is equal to  1  if some  _a_ _i_ = 1  , otherwise it is equal to  0  .</p>
<p>Nam has a matrix  _A_ consisting of  _m_ rows and  _n_ columns. The rows are<br>numbered from  1  to  _m_ , columns are numbered from  1  to  _n_ . Element at<br>row  _i_ (  1 ≤ _i_ ≤ _m_ ) and column  _j_ (  1 ≤ _j_ ≤ _n_ ) is denoted as<br>_A_ _ij_ . All elements of  _A_ are either 0 or 1. From matrix  _A_ , Nam<br>creates another matrix  _B_ of the same size using formula:</p>
<p><img src="http://espresso.codeforces.com/4332dfa4828fa3b9679abe53387834c43c801689.png" alt=""><br>.</p>
<p>(  _B_ _ij_ is  _OR_ of all elements in row  _i_ and column  _j_ of matrix<br>_A_ )</p>
<p>Nam gives you matrix  _B_ and challenges you to guess matrix  _A_ . Although<br>Nam is smart, he could probably make a mistake while calculating matrix  _B_ ,<br>since size of  _A_ can be large.</p>
<p>Input</p>
<p>The first line contains two integer  _m_ and  _n_ (  1 ≤ _m_ , _n_ ≤ 100  ),<br>number of rows and number of columns of matrices respectively.</p>
<p>The next  _m_ lines each contain  _n_ integers separated by spaces describing<br>rows of matrix  _B_ (each element of  _B_ is either  0  or  1  ).</p>
<p>Output</p>
<p>In the first line, print “  NO  “ if Nam has made a mistake when calculating<br>_B_ , otherwise print “  YES  “. If the first line is “  YES  “, then also<br>print  _m_ rows consisting of  _n_ integers representing matrix  _A_ that can<br>produce given matrix  _B_ . If there are several solutions print any one.</p>
<p>Sample test(s)</p>
<p>input</p>
<pre><code>2 2
1 0
0 0
</code></pre><p>output</p>
<pre><code>NO
</code></pre><p>input</p>
<pre><code>2 3
1 1 1
1 1 1
</code></pre><p>output</p>
<pre><code>YES
1 1 1
1 1 1
</code></pre><p>input</p>
<pre><code>2 3
0 1 0
1 1 1
</code></pre><p>output</p>
<pre><code>YES
0 0 0
0 1 0









#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;deque&gt;
#include &lt;vector&gt;
#include &lt;unordered_set&gt;
#include &lt;unordered_map&gt;
#include &lt;set&gt;
#include &lt;valarray&gt;
#include &lt;list&gt;
#include &lt;stack&gt;
#include &lt;array&gt;
#include &lt;iomanip&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;queue&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;


using namespace std;


int A[100][100];
int B[100][100];

int main(int argc, char* argv[])
{
    long long m, n;
    cin &gt;&gt; m &gt;&gt; n;

    for (size_t i = 0; i &lt; m; ++i)
        for (size_t j = 0; j &lt; n; ++j)
            A[i][j] = 1;

    for (size_t i = 0; i &lt; m; ++i)
        for (size_t j = 0; j &lt; n; ++j)
        {
            cin &gt;&gt; B[i][j];

            if (B[i][j] == 0)
            {
                for (size_t k = 0; k &lt; m; ++k)
                    A[k][j] = 0;

                for (size_t k = 0; k &lt; n; ++k)
                    A[i][k] = 0;
            }
        }

    for (size_t i = 0; i &lt; m; ++i)
        for (size_t j = 0; j &lt; n; ++j)
        {
            int a = 0;

            for (size_t k = 0; k &lt; m; ++k)
                a |= A[k][j];

            for (size_t k = 0; k &lt; n; ++k)
                a |= A[i][k];

            if (a != B[i][j])
            {
                cout &lt;&lt; &quot;NO\n&quot;;
                return 0;
            }
        }

    cout &lt;&lt; &quot;YES\n&quot;;
    for (size_t i = 0; i &lt; m; ++i)
    {
        for (size_t j = 0; j &lt; n; ++j)
            cout &lt;&lt; A[i][j] &lt;&lt; &quot; &quot;;
        cout &lt;&lt; endl;
    }

    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/article/csdn/Codeforces_Round_277.5_(Div._2)_C.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41262259" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41262259</a></p>
<p>题目： <a href="http://codeforces.com/contest/489/problem/C" target="_blank" rel="noopener"> http://codeforces.com/contest/489/problem/C
</a></p>
<p>C. Given Length and Sum of Digits…</p>
<p>time limit per test</p>
<p>1 second</p>
<p>memory limit per test</p>
<p>256 megabytes</p>
<p>input</p>
<p>standard input</p>
<p>output</p>
<p>standard output</p>
<p>You have a positive integer  _m_ and a non-negative integer  _s_ . Your task<br>is to find the smallest and the largest of the numbers that have length  _m_<br>and sum of digits  _s_ . The required numbers should be non-negative integers<br>written in the decimal base without leading zeroes.</p>
<p>Input</p>
<p>The single line of the input contains a pair of integers  _m_ ,  _s_ (  1 ≤<br>_m_ ≤ 100, 0 ≤ _s_ ≤ 900  ) — the length and the sum of the digits of the<br>required numbers.</p>
<p>Output</p>
<p>In the output print the pair of the required non-negative integer numbers —<br>first the minimum possible number, then — the maximum possible number. If no<br>numbers satisfying conditions required exist, print the pair of numbers “  -1<br>-1  “ (without the quotes).</p>
<p>Sample test(s)</p>
<p>input</p>
<pre><code>2 15
</code></pre><p>output</p>
<pre><code>69 96
</code></pre><p>input</p>
<pre><code>3 0
</code></pre><p>output</p>
<pre><code>-1 -1


#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;malloc.h&gt;

using namespace std;

int n,m;
int a[110];

int main ()
{
    while (scanf(&quot;%d %d&quot;,&amp;n,&amp;m)!=EOF)
    {
        if ( m == 0 )
        {
            if ( n == 1)
                printf(&quot;0 0\n&quot;);
            else
                printf(&quot;-1 -1\n&quot;);
        }
        else if ( n*9 &lt; m)
            printf(&quot;-1 -1\n&quot;);
        else
        {
            {
                memset(a,0,sizeof(a));
                a[n-1] = 1;
                int ans = m-1;
                for(int i=0 ;ans &amp;&amp; i&lt;n;i++)
                {
                    while (ans != 0 &amp;&amp; a[i]&lt;9)
                    {
                        ans--;
                        a[i]++;
                    }
                }
                for(int i=n-1;i&gt;=0;i--)
                    printf(&quot;%d&quot;,a[i]);
                printf(&quot; &quot;);
            }
            {
                memset(a,0,sizeof(a));
                a[0]= 1 ;
                int ans = m-1;
                for(int i=0;ans &amp;&amp; i&lt;n;i++)
                {
                    while (ans !=0 &amp;&amp; a[i]&lt;9)
                    {
                        ans --;
                        a[i]++;
                    }
                }
                for(int i=0 ;i&lt;n;i++)
                    printf(&quot;%d&quot;,a[i]);
                printf(&quot;\n&quot;);
            }
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/article/csdn/Codeforces_Round_280_(Div._2)_A_B_C.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41673007" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41673007</a></p>
<p><a href="http://codeforces.com/contest/492" target="_blank" rel="noopener"> http://codeforces.com/contest/492 </a></p>
<p>A 水题</p>
<p>A. Vanya and Cubes</p>
<p>time limit per test</p>
<p>1 second</p>
<p>memory limit per test</p>
<p>256 megabytes</p>
<p>input</p>
<p>standard input</p>
<p>output</p>
<p>standard output</p>
<p>Vanya got  _n_ cubes. He decided to build a pyramid from them. Vanya wants to<br>build the pyramid as follows: the top level of the pyramid must consist of  1<br>cube, the second level must consist of  1 + 2 = 3  cubes, the third level must<br>have  1 + 2 + 3 = 6  cubes, and so on. Thus, the  _i_ -th level of the pyramid<br>must have  1 + 2 + … + ( _i_ - 1) + _i_ cubes.</p>
<p>Vanya wants to know what is the maximum height of the pyramid that he can make<br>using the given cubes.</p>
<p>Input</p>
<p>The first line contains integer  _n_ (  1 ≤ _n_ ≤ 10  4  ) — the number of<br>cubes given to Vanya.</p>
<p>Output</p>
<p>Print the maximum possible height of the pyramid in the single line.</p>
<p>Sample test(s)</p>
<p>input</p>
<pre><code>1
</code></pre><p>output</p>
<pre><code>1
</code></pre><p>input</p>
<pre><code>25
</code></pre><p>output</p>
<pre><code>4
</code></pre><p>Note</p>
<p>Illustration to the second sample:</p>
<p><img src="http://espresso.codeforces.com/8689e0e8028c02e92fc5af8b267317c0dce734ce.png" alt=""></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;deque&gt;
#include &lt;vector&gt;
#include &lt;unordered_set&gt;
#include &lt;unordered_map&gt;
#include &lt;set&gt;
#include &lt;valarray&gt;
#include &lt;list&gt;
#include &lt;stack&gt;
#include &lt;array&gt;
#include &lt;iomanip&gt;
#include &lt;map&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;stdio.h&gt;

using namespace std;

int n,m;

int a[1000];

int main ()
{
    a[1] = 1;
    for(int i=1;i&lt;=999;i++)
        a[i] = a[i-1]+i;
    while (cin&gt;&gt;n)
    {
        int i =1;
        int ans = 0;
        while (n-a[i] &gt;=0)
        {
            n-=a[i];
            i++;
            ans++;
        }
        cout&lt;&lt;ans&lt;&lt;endl;
    }
    return 0;
}
</code></pre><p>B 简单贪心</p>
<p>B. Vanya and Lanterns</p>
<p>time limit per test</p>
<p>1 second</p>
<p>memory limit per test</p>
<p>256 megabytes</p>
<p>input</p>
<p>standard input</p>
<p>output</p>
<p>standard output</p>
<p>Vanya walks late at night along a straight street of length  _l_ , lit by  _n_<br>lanterns. Consider the coordinate system with the beginning of the street<br>corresponding to the point  0  , and its end corresponding to the point  _l_ .<br>Then the  _i_ -th lantern is at the point  _a_ _i_ . The lantern lights all<br>points of the street that are at the distance of at most  _d_ from it, where<br>_d_ is some positive number, common for all lanterns.</p>
<p>Vanya wonders: what is the minimum light radius  _d_ should the lanterns have<br>to light the whole street?</p>
<p>Input</p>
<p>The first line contains two integers  _n_ ,  _l_ (  1 ≤ _n_ ≤ 1000  ,  1 ≤ _l_<br>≤ 10  9  ) — the number of lanterns and the length of the street respectively.</p>
<p>The next line contains  _n_ integers  _a_ _i_ (  0 ≤ _a_ _i_ ≤ _l_ ). Multiple<br>lanterns can be located at the same point. The lanterns may be located at the<br>ends of the street.</p>
<p>Output</p>
<p>Print the minimum light radius  _d_ , needed to light the whole street. The<br>answer will be considered correct if its absolute or relative error doesn’t<br>exceed  10  - 9  .</p>
<p>Sample test(s)</p>
<p>input</p>
<pre><code>7 15
15 5 3 7 9 14 0
</code></pre><p>output</p>
<pre><code>2.5000000000
</code></pre><p>input</p>
<pre><code>2 5
2 5
</code></pre><p>output</p>
<pre><code>2.0000000000
</code></pre><p>Note</p>
<p>Consider the second sample. At  _d_ = 2  the first lantern will light the<br>segment  [0, 4]  of the street, and the second lantern will light segment  [3,<br>5]  . Thus, the whole street will be lit.</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;deque&gt;
#include &lt;vector&gt;
#include &lt;unordered_set&gt;
#include &lt;unordered_map&gt;
#include &lt;set&gt;
#include &lt;valarray&gt;
#include &lt;list&gt;
#include &lt;stack&gt;
#include &lt;array&gt;
#include &lt;iomanip&gt;
#include &lt;map&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;stdio.h&gt;

using namespace std;

int n,l;
double a[1010];

int main ()
{
    while (cin&gt;&gt;n&gt;&gt;l)
    {
          for(int i=1;i&lt;=n;i++)
                cin&gt;&gt;a[i];
          sort(a+1,a+1+n);

          double ans = a[1] ;

          for(int i=1;i&lt;=n-1;i++)
          {
              ans = max (ans,(a[i+1]-a[i])*1.0/2);
          }

          ans = max(ans,l-a[n]);

          printf(&quot;%.10lf\n&quot;,ans);
    }
    return 0;
}
</code></pre><p>C 按照bi升序排列 注意不要超时即可</p>
<p>C. Vanya and Exams</p>
<p>time limit per test</p>
<p>1 second</p>
<p>memory limit per test</p>
<p>256 megabytes</p>
<p>input</p>
<p>standard input</p>
<p>output</p>
<p>standard output</p>
<p>Vanya wants to pass  _n_ exams and get the academic scholarship. He will get<br>the scholarship if the average grade mark for all the exams is at least  <em>avg</em><br>. The exam grade cannot exceed  _r_ . Vanya has passed the exams and got grade<br>_a_ _i_ for the  _i_ -th exam. To increase the grade for the  _i_ -th exam by<br>1 point, Vanya must write  _b_ _i_ essays. He can raise the exam grade<br>multiple times.</p>
<p>What is the minimum number of essays that Vanya needs to write to get<br>scholarship?</p>
<p>Input</p>
<p>The first line contains three integers  _n_ ,  _r_ ,  <em>avg</em> (  1 ≤ _n_ ≤ 10  5<br>,  1 ≤ _r_ ≤ 10  9  ,  1 ≤ <em>avg</em> ≤ <em>min</em> ( _r_ , 10  6  )  ) — the number of<br>exams, the maximum grade and the required grade point average, respectively.</p>
<p>Each of the following  _n_ lines contains space-separated integers  _a_ _i_<br>and  _b_ _i_ (  1 ≤ _a_ _i_ ≤ _r_ ,  1 ≤ _b_ _i_ ≤ 10  6  ).</p>
<p>Output</p>
<p>In the first line print the minimum number of essays.</p>
<p>Sample test(s)</p>
<p>input</p>
<pre><code>5 5 4
5 2
4 7
3 1
3 2
2 5
</code></pre><p>output</p>
<pre><code>4
</code></pre><p>input</p>
<pre><code>2 5 4
5 2
5 2
</code></pre><p>output</p>
<pre><code>0
</code></pre><p>Note</p>
<p>In the first sample Vanya can write 2 essays for the 3rd exam to raise his<br>grade by 2 points and 2 essays for the 4th exam to raise his grade by 1 point.</p>
<p>In the second sample, Vanya doesn’t need to write any essays as his general<br>point average already is above average.</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;deque&gt;
#include &lt;vector&gt;
#include &lt;unordered_set&gt;
#include &lt;unordered_map&gt;
#include &lt;set&gt;
#include &lt;valarray&gt;
#include &lt;list&gt;
#include &lt;stack&gt;
#include &lt;array&gt;
#include &lt;iomanip&gt;
#include &lt;map&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;stdio.h&gt;

using namespace std;

int n;
long long r;
long long avg,AVE;

struct q
{
    int a;
    int b;
}p[100010];

bool cmp(q aa,q bb)
{
    return aa.b &lt; bb.b;
}

int main ()
{
    while (cin&gt;&gt;n&gt;&gt;r&gt;&gt;avg)
    {
        AVE= 0;
        for(int i=1;i&lt;=n;i++)
        {
            cin&gt;&gt;p[i].a&gt;&gt;p[i].b;
            AVE+=p[i].a;
        }

        if (AVE &gt;= avg*n)
        {
            cout&lt;&lt;0&lt;&lt;endl;
            return 0;
        }

        sort(p+1,p+1+n,cmp);

        long long  ans = 0;

        int i = 1;
        while ( AVE &lt; avg*n )
        {
            ans += p[i].b * min ( r -p[i].a,n*avg - AVE );

            AVE += min(r -p[i].a,n*avg - AVE);

            i++;
        }

        cout&lt;&lt;ans&lt;&lt;endl;

    }

    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/article/csdn/Codeforces_Round_296_(Div._2)_B._Error_Correct_System.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46379715" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46379715</a></p>
<p>题目链接： <a href="http://codeforces.com/contest/527/problem/B" target="_blank" rel="noopener"> http://codeforces.com/contest/527/problem/B
</a></p>
<p>代码：</p>
<pre><code>#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;

using namespace std;

int p[28][28];
int n;
int num = 0;
string s, t;

int main()
{

    while (cin &gt;&gt; n)
    {
        cin &gt;&gt; s &gt;&gt; t; 
        memset(p, 0, sizeof(p)); num = 0;
        for (int i = 0; i &lt; n; ++i)
        {
            if (s[i] != t[i])
            {
                p[s[i] - &#39;a&#39;][t[i] - &#39;a&#39;] = i + 1;
                num++;
            }
        }
        for (int i = 0; i &lt; 26; ++i)
        {
            for (int j = 0; j &lt; 26; ++j)
            {
                if (p[i][j] &amp;&amp; p[j][i])
                {
                    cout &lt;&lt; (num - 2) &lt;&lt; endl;
                    cout &lt;&lt; p[i][j] &lt;&lt; &quot; &quot; &lt;&lt; p[j][i] &lt;&lt; endl;
                    return 0;
                }
            }
        }
        for (int i = 0; i &lt; 26; ++i)
        {
            for (int j = 0; j &lt; 26; ++j)
            {
                if (p[i][j])
                {
                    for (int k = 0; k &lt; 26; ++k)
                    {
                        if (p[k][i])
                        {
                            cout &lt;&lt; (num - 1) &lt;&lt; endl;
                            cout &lt;&lt; p[i][j] &lt;&lt; &quot; &quot; &lt;&lt; p[k][i] &lt;&lt; endl;
                            return 0;
                        }
                    }
                }
            }
        }
        cout &lt;&lt; num &lt;&lt; endl;
        cout &lt;&lt; &quot;-1 -1&quot; &lt;&lt; endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/article/csdn/Codeforces_Round_283_(Div._2)_A_B.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/42121983" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/42121983</a></p>
<p><a href="http://codeforces.com/contest/496" target="_blank" rel="noopener"> http://codeforces.com/contest/496 </a></p>
<p>A:</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;

using namespace std;

int n;
int p[110];

int main()
{
    while (scanf(&quot;%d&quot;,&amp;n)!=EOF)
    {
        for(int i=1;i&lt;=n;i++)
            scanf(&quot;%d&quot;,&amp;p[i]);

        int ans = 0;
        int q[110];

        for(int i=2;i&lt;=n-1;i++)
        {
            ans = 0;
            int t = p[i];
            p[i] = -1;
            for( int j =1;j&lt;=n-1;j++)
            {
                if (p[j] != -1)
                    ans = max(ans,p[j+1] - p[j]);
                else
                    ans = max(ans,p[j+1] - p[j-1]);
            }

            q[i] = ans;

            p[i] = t;
        }

        ans = 100000;
        for(int i=2;i&lt;=n-1;i++)
            ans = min(ans ,q[i]);

        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre><p>B：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;

using namespace std;

typedef long long LL;

const int MAXN = 1005;

int n;
string s;
string ans;

int main() {
    cin &gt;&gt; n;
    cin &gt;&gt; s;
    ans = s;
    for(int i = 0; i &lt; n; ++i)
    {
        string cur = &quot;0&quot;;
        for(int j = 1; j &lt; n; ++j)
            cur += (char)(&#39;0&#39; + ((int)s[(i + j) % n] - s[i] + 10) % 10);

        //cout&lt;&lt;cur&lt;&lt;endl;
        if (cur &lt; ans) ans = cur;
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/article/csdn/Codeforces_Round_282_(Div._2)_A_B.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/42194077" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/42194077</a></p>
<p><a href="http://codeforces.com/contest/495" target="_blank" rel="noopener"> http://codeforces.com/contest/495 </a>  </p>
<p>A. Digital Counter</p>
<p>time limit per test</p>
<p>1 second</p>
<p>memory limit per test</p>
<p>256 megabytes</p>
<p>input</p>
<p>standard input</p>
<p>output</p>
<p>standard output</p>
<p>Malek lives in an apartment block with  100  floors numbered from  0  to  99<br>. The apartment has an elevator with a digital counter showing the floor that<br>the elevator is currently on. The elevator shows each digit of a number with<br>7  light sticks by turning them on or off. The picture below shows how the<br>elevator shows each digit.</p>
<p><img src="http://espresso.codeforces.com/3e768e277896731a1cac67e7a6b0bdfdf1a2eb4c.png" alt=""></p>
<p>One day when Malek wanted to go from floor  88  to floor  0  using the<br>elevator he noticed that the counter shows number  89  instead of  88  . Then<br>when the elevator started moving the number on the counter changed to  87  .<br>After a little thinking Malek came to the conclusion that there is only one<br>explanation for this: One of the sticks of the counter was broken. Later that<br>day Malek was thinking about the broken stick and suddenly he came up with the<br>following problem.</p>
<p>Suppose the digital counter is showing number  _n_ . Malek calls an integer<br>_x_ (  0 ≤ _x_ ≤ 99  )  good  if it’s possible that the digital counter was<br>supposed to show  _x_ but because of some(possibly none) broken sticks it’s<br>showing  _n_ instead. Malek wants to know number of good integers for a<br>specific  _n_ . So you must write a program that calculates this number.<br>Please note that the counter  always  shows two digits.</p>
<p>Input</p>
<p>The only line of input contains exactly two digits representing number  _n_ (<br>0 ≤ _n_ ≤ 99  ). Note that  _n_ may have a leading zero.</p>
<p>Output</p>
<p>In the only line of the output print the number of good integers.</p>
<p>Sample test(s)</p>
<p>input</p>
<pre><code>89
</code></pre><p>output</p>
<pre><code>2
</code></pre><p>input</p>
<pre><code>00
</code></pre><p>output</p>
<pre><code>4
</code></pre><p>input</p>
<pre><code>73
</code></pre><p>output</p>
<pre><code>15
</code></pre><p>Note</p>
<p>In the first sample the counter may be supposed to show  88  or  89  .</p>
<p>In the second sample the good integers are  00  ,  08  ,  80  and  88  .</p>
<p>In the third sample the good integers are  03, 08, 09, 33, 38, 39, 73, 78, 79,<br>83, 88, 89, 93, 98, 99  .</p>
<p>A 打表 ，开始数错了一个WA了</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt; 
#include&lt;malloc.h&gt; 

using namespace std;

char p[5];

int q[12] = {2,7,2,3,3,4,2,5,1,2};

int main()
{
    while (cin &gt;&gt; p)
    {
        int t = int (p[0] - &#39;0&#39;);
        int tt = int (p[1] - &#39;0&#39;);

        int ans = q[t] * q[tt];

        cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}
</code></pre><p>B. Modular Equations</p>
<p>time limit per test</p>
<p>1 second</p>
<p>memory limit per test</p>
<p>256 megabytes</p>
<p>input</p>
<p>standard input</p>
<p>output</p>
<p>standard output</p>
<p>Last week, Hamed learned about a new type of equations in his math class<br>called Modular Equations. Lets define  _i_ modulo  _j_ as the remainder of<br>division of  _i_ by  _j_ and denote it by<br><img src="http://espresso.codeforces.com/dd2b46f89067e3a9d9987c4263de702dd7518fa7.png" alt=""><br>. A Modular Equation, as Hamed’s teacher described, is an equation of the form<br><img src="http://espresso.codeforces.com/fc4bae676fb9b7279f0b9e6781d3d2d6abf86586.png" alt=""><br>in which  _a_ and  _b_ are two non-negative integers and  _x_ is a variable.<br>We call a positive integer  _x_ for which<br><img src="http://espresso.codeforces.com/fc4bae676fb9b7279f0b9e6781d3d2d6abf86586.png" alt=""><br>a  solution  of our equation.</p>
<p>Hamed didn’t pay much attention to the class since he was watching a movie. He<br>only managed to understand the definitions of these equations.</p>
<p>Now he wants to write his math exercises but since he has no idea how to do<br>that, he asked you for help. He has told you all he knows about Modular<br>Equations and asked you to write a program which given two numbers  _a_ and<br>_b_ determines how many answers the Modular Equation<br><img src="http://espresso.codeforces.com/fc4bae676fb9b7279f0b9e6781d3d2d6abf86586.png" alt=""><br>has.</p>
<p>Input</p>
<p>In the only line of the input two space-separated integers  _a_ and  _b_ (  0<br>≤ _a_ , _b_ ≤ 10  9  ) are given.</p>
<p>Output</p>
<p>If there is an infinite number of answers to our equation, print “infinity”<br>(without the quotes). Otherwise print the number of solutions of the Modular<br>Equation<br><img src="http://espresso.codeforces.com/fc4bae676fb9b7279f0b9e6781d3d2d6abf86586.png" alt=""><br>.</p>
<p>Sample test(s)</p>
<p>input</p>
<pre><code>21 5
</code></pre><p>output</p>
<pre><code>2
</code></pre><p>input</p>
<pre><code>9435152 272
</code></pre><p>output</p>
<pre><code>282
</code></pre><p>input</p>
<pre><code>10 10
</code></pre><p>output</p>
<pre><code>infinity
</code></pre><p>Note</p>
<p>In the first sample the answers of the Modular Equation are 8 and 16 since<br><img src="http://espresso.codeforces.com/6f5ff39ebd209bf990adaf91f4b82f9687097224.png" alt=""></p>
<p>B 优化算法提高效率 以前接触过类似的</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt;
#include&lt;malloc.h&gt;

using namespace std;

int n, m;

int slove(int x ,int y)
{
    int ans = 0;
    for (int i = 1; i*i &lt;= x; i++)
    {
        if (i * i == x)
        {
            if (i &gt; y)
                ans++;
        }
        else if (x % i == 0)
        {
            if (i &gt; y)
            {
                ans++;
            }
            if (x/i &gt; y)
            {
                ans++;
            }
        }
    }
    return ans;
}

int main()
{
    while (cin &gt;&gt; n &gt;&gt; m)
    {
        int ans = 0;
        n -= m;
        if (n == 0)
        {
            cout &lt;&lt; &quot;infinity&quot; &lt;&lt; endl;
            continue;
        }
        else if (n &lt; 0)
        {
            cout &lt;&lt; 0 &lt;&lt; endl;
            continue;
        }
        else 
            cout &lt;&lt; slove (n,m) &lt;&lt; endl;
    }
    return 0; 
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/article/csdn/Codeforces_Round_290_(Div._2)_B._Fox_And_Two_Dots.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43458753" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43458753</a></p>
<p>题目链接 : <a href="http://codeforces.com/contest/510/problem/B" target="_blank" rel="noopener"> http://codeforces.com/contest/510/problem/B
</a></p>
<p>B. Fox And Two Dots</p>
<p>time limit per test</p>
<p>2 seconds</p>
<p>memory limit per test</p>
<p>256 megabytes</p>
<p>input</p>
<p>standard input</p>
<p>output</p>
<p>standard output</p>
<p>Fox Ciel is playing a mobile puzzle game called “Two Dots”. The basic levels<br>are played on a board of size  _n_ × _m_ cells, like this:</p>
<p><img src="http://espresso.codeforces.com/56dcae7c8d1ee32ea083e76eb5cd70ae21b63c24.png" alt=""></p>
<p>Each cell contains a dot that has some color. We will use different uppercase<br>Latin characters to express different colors.</p>
<p>The key of this game is to find a cycle that contain dots of same color.<br>Consider 4 blue dots on the picture forming a circle as an example. Formally,<br>we call a sequence of dots  _d_ 1  , _d_ 2  , …, _d_ _k_ a  cycle  if and<br>only if it meets the following condition:</p>
<ol>
<li>These  _k_ dots are different: if  _i_ ≠ _j_ then  _d_ _i_ is different from  _d_ _j_ . </li>
<li>_k_ is at least 4. </li>
<li>All dots belong to the same color. </li>
<li>For all  1 ≤ _i_ ≤ _k_ - 1  :  _d_ _i_ and  _d_ _i_ + 1  are adjacent. Also,  _d_ _k_ and  _d_ 1  should also be adjacent. Cells  _x_ and  _y_ are called adjacent if they share an edge. </li>
</ol>
<p>Determine if there exists a  cycle  on the field.</p>
<p>Input</p>
<p>The first line contains two integers  _n_ and  _m_ (  2 ≤ _n_ , _m_ ≤ 50  ):<br>the number of rows and columns of the board.</p>
<p>Then  _n_ lines follow, each line contains a string consisting of  _m_<br>characters, expressing colors of dots in each line. Each character is an<br>uppercase Latin letter.</p>
<p>Output</p>
<p>Output “  Yes  “ if there exists a  cycle  , and “  No  “ otherwise.</p>
<p>Sample test(s)</p>
<p>input</p>
<pre><code>3 4
AAAA
ABCA
AAAA
</code></pre><p>output</p>
<pre><code>Yes
</code></pre><p>input</p>
<pre><code>3 4
AAAA
ABCA
AADA
</code></pre><p>output</p>
<pre><code>No
</code></pre><p>input</p>
<pre><code>4 4
YYYR
BYBY
BBBY
BBBY
</code></pre><p>output</p>
<pre><code>Yes
</code></pre><p>input</p>
<pre><code>7 6
AAAAAB
ABBBAB
ABAAAB
ABABBB
ABAAAB
ABBBAB
AAAAAB
</code></pre><p>output</p>
<pre><code>Yes
</code></pre><p>input</p>
<pre><code>2 13
ABCDEFGHIJKLM
NOPQRSTUVWXYZ
</code></pre><p>output</p>
<pre><code>No
</code></pre><p>DFS 判断是否存在环 。</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;string&gt;
#include&lt;sstream&gt;

using namespace std;

int n, m, ok;
char s[100][100];
int vis[100][100];
int dir[4][2] = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };
int is_ok(int x, int y)
{
    if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m)
        return 1;
    return 0;
}

int dfs(int x, int y, int prex, int prey, char c)
{
    vis[x][y] = 1;
    for (int i = 0; i &lt; 4; i++)
    {
        int xx = x + dir[i][0];
        int yy = y + dir[i][1];
        if (xx == prex &amp;&amp; yy == prey) continue;
        if (is_ok(xx, yy) &amp;&amp; s[xx][yy] == c)
        {
            if (vis[xx][yy])
                return 1;
            if (dfs(xx, yy, x, y, c))
                return 1;
        }
    }
    return 0;
}

int main()
{
    while (cin &gt;&gt; n &gt;&gt; m)
    {
        ok = 0; memset(vis, 0, sizeof(vis));
        for (int i = 0; i &lt; n; i++)
            cin &gt;&gt; s[i];

        for (int i = 0; i &lt; n; i++)
            for (int j = 0; j &lt; m; j++)
            {
                if (!vis[i][j])
                    if (dfs(i, j, -1, -1, s[i][j]))
                    {
                        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
                        ok = 1;
                        return 0;
                    }
            }
        if (!ok)
            cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/article/csdn/Codeforces_Round_306_(Div._2)_A_B_C.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46377991" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46377991</a></p>
<p>题目链接： <a href="http://codeforces.com/contest/550" target="_blank" rel="noopener"> http://codeforces.com/contest/550 </a><br>A<br>暴力一发。<br>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;string&gt;
#include &lt;string.h&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

const int MAXN =100010;

char s[MAXN];
int pos1[MAXN];
int pos2[MAXN];

int main()
{
    while (cin&gt;&gt;s)
    {
        int ok1 = 0,ok2 = 0;
        int tmp = 0;
        int len = strlen(s);
        int num1 = 0,num2 = 0;

        for(int i = 0;i &lt; len - 1;i++)
        {
            if (s[i] == &#39;A&#39; &amp;&amp; s[i+1]==&#39;B&#39;)
            {
                ok1 = 1;
                pos1[num1++] = i;
            }
            if (s[i] == &#39;B&#39; &amp;&amp; s[i+1]==&#39;A&#39;)
            {
                ok2 = 1;
                pos2[num2++] = i;
            }
        }
        int ok=0;
        if (ok1 == 1 &amp;&amp; ok2 == 1)
        {
            for(int i=0;i &lt; num1;i++)
            {
                if(ok) break;
                for(int j=0;j &lt; num2;j++)
                {
                    if (abs(pos1[i] - pos2[j]) != 1)
                    {
                        ok=1;
                        break;
                    }
                }
            }
        }
        if (ok) puts(&quot;YES&quot;);
        else puts(&quot;NO&quot;);
    }
    return 0;
}
</code></pre><p>B 再暴力一发</p>
<pre><code>#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int n, l, r, X, a[100];
int ans;

void rec(int x, int sum, int mn, int mx, int cnt) 
{
    if (x == n) 
    {
        if ((cnt &gt;= 2) &amp;&amp; (sum &gt;= l) &amp;&amp; (sum &lt;= r) &amp;&amp; (mx - mn &gt;= X)) ans++;
        return;
    }
    rec(x + 1, sum, mn, mx, cnt);
    rec(x + 1, sum + a[x], min(mn, a[x]), max(mx, a[x]), cnt + 1);
}

int main() {

    while(~scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;l, &amp;r, &amp;X))
    {
        for (int i = 0; i &lt; n; i++) 
            scanf(&quot;%d&quot;, &amp;a[i]);
        rec(0, 0, 1e9, -1e9, 0);
        printf(&quot;%d\n&quot;, ans);
    }
}
</code></pre><p>C 再再暴力一发<br>代码:</p>
<pre><code>#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

char s [1010];

void solve()
{
    int len = strlen(s);
    for(int i=0;i&lt;len;i++)
    {
        if((s[i] - 48) % 8 == 0)
        {
            puts(&quot;YES&quot;);
            printf(&quot;%c\n&quot;,s[i]);
            return;
        }
    }
    for(int i=0;i&lt;len;i++)
    {
        for(int j=i+1;j&lt;len;j++)
        {
            int num = s[i] - 48;
            num = num *10 + s[j]-48;
            if (num % 8 == 0)
            {
                puts(&quot;YES&quot;);
                printf(&quot;%d\n&quot;,num);
                return;
            }
        }
    }
    for(int i=0;i&lt;len;i++)
    {
        if (s[i] != &#39;0&#39;)
            for(int j=i+1;j&lt;len;j++)
                for(int k=j+1;k&lt;len;k++)
                {
                    int num = s[i]-48;
                    num = num*10 + s[j] - 48;
                    num = num*10 + s[k] - 48;
                    if (num % 8 == 0)
                    {
                        puts(&quot;YES&quot;);
                        printf(&quot;%d\n&quot;,num);
                        return ;
                    }

                }

    }
    puts(&quot;NO&quot;);
}

int main()
{
    while (cin&gt;&gt;s)
    {
        int len = strlen(s);
        solve();
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/article/csdn/Codeforces_Round_301_C_(Div._2)_%E3%80%90dfs%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46380465" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46380465</a></p>
<p>题目链接： <a href="http://codeforces.com/contest/540/problem/C" target="_blank" rel="noopener"> http://codeforces.com/contest/540/problem/C
</a></p>
<p>（最近 unhappy！）</p>
<p>题意：初始时候在一个破碎的冰块上，每次只能走到临近的四个未破碎冰块上。未破碎的冰块被踩后变为破碎。且不能在冰块上停留。踩上破碎的冰块就会掉入此坐标。问<br>是否可以在掉进给定的坐标。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;
#include &lt;stdlib.h&gt;

using namespace std;

int n, m, ok;
char p[510][510];
int sx, sy, ex, ey;
int dir[4][2] = { { 1, 0 }, { 0, 1 }, { -1, 0 }, { 0, -1 } };

int check(int x, int y)
{
    if (x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; m) return 0;
    if (p[x][y] == &#39;X&#39;)
    {
        if (x == ex &amp;&amp; y == ey )
            ok = 1;
        return 0;
    }
    return 1;
}

void dfs(int x,int y)
{
    p[x][y] = &#39;X&#39;;
    for (int i = 0; i &lt; 4; i++)
    {
        int xx = x + dir[i][0];
        int yy = y + dir[i][1];
        if (check(xx, yy)) dfs(xx, yy);
    }                                
}

int main()
{
    while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)
    {
        for (int i = 1; i &lt;= n; i++)
            scanf(&quot;%s&quot;,p[i]+1);
        //cout &lt;&lt; endl;
        //for (int i = 1; i &lt;= n; i++)
        //  puts(p[i]+1);
        scanf(&quot;%d%d%d%d&quot;,&amp;sx,&amp;sy,&amp;ex,&amp;ey);
        ok = 0;
        dfs(sx,sy);
        if (ok)
            puts(&quot;YES&quot;);
        else
            puts(&quot;NO&quot;);
    }

    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/article/csdn/Codeforces_Round_311_(Div._2)_B._Pasha_and_Tea%E3%80%90%E4%BA%8C%E5%88%86%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47267583" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47267583</a></p>
<p>B. Pasha and Tea</p>
<p>time limit per test</p>
<p>1 second</p>
<p>memory limit per test</p>
<p>256 megabytes</p>
<p>input</p>
<p>standard input</p>
<p>output</p>
<p>standard output</p>
<p>Pasha decided to invite his friends to a tea party. For that occasion, he has<br>a large teapot with the capacity of  _w_ milliliters and  2 _n_ tea cups, each<br>cup is for one of Pasha’s friends. The  _i_ -th cup can hold at most  _a_ _i_<br>milliliters of water.</p>
<p>It turned out that among Pasha’s friends there are exactly  _n_ boys and<br>exactly  _n_ girls and all of them are going to come to the tea party. To<br>please everyone, Pasha decided to pour the water for the tea as follows:</p>
<ul>
<li>Pasha can boil the teapot exactly once by pouring there at most  _w_ milliliters of water; </li>
<li>Pasha pours the same amount of water to each girl; </li>
<li>Pasha pours the same amount of water to each boy; </li>
<li>if each girl gets  _x_ milliliters of water, then each boy gets  2 _x_ milliliters of water. </li>
</ul>
<p>In the other words, each boy should get two times more water than each girl<br>does.</p>
<p>Pasha is very kind and polite, so he wants to maximize the total amount of the<br>water that he pours to his friends. Your task is to help him and determine the<br>optimum distribution of cups between Pasha’s friends.</p>
<p>Input</p>
<p>The first line of the input contains two integers,  _n_ and  _w_ (  1 ≤ _n_ ≤<br>10  5  ,  1 ≤ _w_ ≤ 10  9  ) — the number of Pasha’s friends that are boys<br>(equal to the number of Pasha’s friends that are girls) and the capacity of<br>Pasha’s teapot in milliliters.</p>
<p>The second line of the input contains the sequence of integers  _a_ _i_ (  1 ≤<br>_a_ _i_ ≤ 10  9  ,  1 ≤ _i_ ≤ 2 _n_ ) — the capacities of Pasha’s tea cups in<br>milliliters.</p>
<p>Output</p>
<p>Print a single real number — the maximum total amount of water in milliliters<br>that Pasha can pour to his friends without violating the given conditions.<br>Your answer will be considered correct if its absolute or relative error<br>doesn’t exceed  10  - 6  .</p>
<p>Sample test(s)</p>
<p>input</p>
<pre><code>2 4
1 1 1 1
</code></pre><p>output</p>
<pre><code>3
</code></pre><p>input</p>
<pre><code>3 18
4 4 4 2 2 2
</code></pre><p>output</p>
<pre><code>18
</code></pre><p>input</p>
<pre><code>1 5
2 3
</code></pre><p>output</p>
<pre><code>4.5
</code></pre><p>二分答案即可</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int n, w;
double p[200010];

int main()

{
    while (cin &gt;&gt; n)
    {
        cin &gt;&gt; w;
        for (int i = 1; i &lt;= n * 2; i++)
            scanf(&quot;%lf&quot;,&amp;p[i]);
        sort(p + 1, p + 1 + 2 * n);
        int t1 = p[1];
        int t2 = p[n + 1];
        double ans;

        if (t2 &gt;= t1 * 2)  //yes
        {
            double left = 0;
            double right = w;
            double mid;
            while (left + 0.000000001 &lt;right)
            {
                mid = (left + right) / 2;
                //n*X + n*X/2 &lt;= mid 
                double x = mid / n / 3;
                if (x &lt;= t1)
                {
                    left = mid;
                    ans = mid;
                }
                else
                    right = mid;
            }
        }
        else
        {
            double left = 0;
            double right = w;
            double mid;
            while (left + 0.000000001 &lt;right)
            {
                mid = (left + right) / 2;
                //n*X + n*X/2 &lt;= mid 
                double x = mid * 2 / n / 3;
                if (x &lt;= t2)
                {
                    left = mid;
                    ans = mid;
                }
                else
                    right = mid;
            }
        }
        printf(&quot;%.8lf\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/article/csdn/Codeforces_Round_303_(Div._2)_A_B_C_D.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46379571" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46379571</a></p>
<p>题目链接： <a href="http://codeforces.com/contest/545" target="_blank" rel="noopener"> http://codeforces.com/contest/545 </a></p>
<p>A：水<br>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;queue&gt;
#include &lt;set&gt;

using namespace std;

int n, ans[110],tmp[21000],num;
int p[110][110];

int main()
{
    while (cin &gt;&gt; n)
    {
        set&lt;int&gt; q; q.clear();
        num = 0;
        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= n; j++)
            {
                scanf(&quot;%d&quot;, &amp;p[i][j]); 
                if (p[i][j] == -1)
                {
                    q.insert(i);
                    q.insert(j);
                }
                else if (p[i][j] == 0)
                {
                    q.insert(i);
                    q.insert(j);
                }
                else if (p[i][j] == 1)
                {
                    tmp[num++] = i;
                    q.insert(j);
                }
                else if (p[i][j] == 2)
                {
                    tmp[num++] = j;
                    q.insert(i);
                }
                else if (p[i][j] == 3)
                {
                    tmp[num++] = i;
                    tmp[num++] = j;
                }
            }
        for (int i = 0; i &lt; num; i++)
            q.erase(tmp[i]);

        set&lt;int&gt; ::iterator it;
        cout &lt;&lt; q.size() &lt;&lt; endl;
        for (it = q.begin(); it != q.end(); it++)
            cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
        cout &lt;&lt; endl;
    }
    return 0;
}
</code></pre><p>B: s ，t 字符不同的位置 ，奇数用s 偶数t，其他位置随意。</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;queue&gt;
#include &lt;set&gt;

using namespace std;

char s[100010],t[100010];
int ans[100010];

int main()
{
    while (cin &gt;&gt; s &gt;&gt; t)
    {
        int len = strlen(s);
        int tmp = 0;
        memset(ans,0,sizeof(ans));
        int num = 0;
        for (int i = 0; i &lt; len; i++)
        {
            if (s[i] != t[i])
            {
                tmp++;
                ans[i] = -1;
            }
        }
        if (tmp % 2 == 1)
            puts(&quot;impossible&quot;);
        else
        {
            for (int i = 0; i &lt; len; i++)
            {
                if (ans[i] == -1)
                {
                    num++;
                    if (num % 2 == 0) printf(&quot;%d&quot;, (s[i] - &#39;0&#39;));
                    else  printf(&quot;%d&quot;, (t[i] - &#39;0&#39;));
                }
                else  printf(&quot;%d&quot;, (s[i] - &#39;0&#39;));
            }
            printf(&quot;\n&quot;);
        }
    }
    return 0;
}
</code></pre><p>C： 贪心直接搞</p>
<p>代码：</p>
<pre><code>#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;

using namespace std;

const int MAXN=100010;
int n;
int dp[10010];

struct node
{
    int x;
    int y;
    int left,right;
}p[MAXN];

bool cmp(node a,node b)
{
    return a.x &lt; b.x;
}

int main()
{
    while (cin&gt;&gt;n)
    {
        for(int i=1;i&lt;=n;i++)
        {
            cin&gt;&gt;p[i].x&gt;&gt;p[i].y;
            p[i].left = p[i].x - p[i].y;
            p[i].right = p[i].x + p[i].y;
        }
        sort(p+1,p+1+n,cmp);
        int ans=0;
        int pos = -2000000000;
        for(int i=1;i&lt;=n;i++)
        {
            if (p[i].x - p[i].y &gt; pos)
            {
                pos = p[i].x;
                ans++;
            }
            else if (i == n || p[i].x + p[i].y &lt; p[i+1].x)
            {
                pos = p[i].x + p[i].y;
                ans++;
            }
            else
                pos = p[i].x;
        }
        cout&lt;&lt;ans&lt;&lt;endl;
    }
    return 0;
}
</code></pre><p>D： 排序直接搞 ，不满足条件直接不选。</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;queue&gt;
#include &lt;set&gt;

using namespace std;

int n;
int p[100010];

int main()
{
    while (cin &gt;&gt; n)
    {
        for (int i = 1; i &lt;= n; i++) cin &gt;&gt; p[i];
        sort(p + 1, p + 1 + n);
        long long tot = p[1];
        int ans = 1;
        for (int i = 2; i &lt;= n; i++)
        {
            if (p[i] &gt;= tot)
            {
                ans++;
                tot += p[i];
            }
        }
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/article/csdn/Codeforces_Round_312_(Div._2)_C.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47103205" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47103205</a></p>
<p>题目链接： <a href="http://codeforces.com/contest/558/problem/C" target="_blank" rel="noopener"> http://codeforces.com/contest/558/problem/C
</a></p>
<p>题意：<br>有n个瓶子，每个瓶子都有相应的水的数量，瓶子的水量可以乘2或者除2，求出最少多少步骤可以使瓶子中的所有水相等。</p>
<p>思路：<br>将所有瓶子可以到达的毫升数及其步数记录起来，得到可以n个瓶子都能到达的毫升数的最小步数。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int n;
int cnt[100010];
int vis[100010];
int step[100010];

int main()
{
    while (scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        memset(step,0,sizeof(step));
        memset(cnt, 0, sizeof(cnt)); 
        memset(vis, 0, sizeof(vis));
        queue &lt;pair&lt;int, int&gt; &gt; q;

        int s;
        for (int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;,&amp;s);
            q.push(make_pair(s,0));

            while (!q.empty())
            {
                int x = q.front().first;
                int y = q.front().second;
                q.pop();
                if (x &gt; 1e5 + 3) continue;
                if (vis[x] == i) continue;
                vis[x] = i;
                cnt[x]++;
                step[x] += y;

                q.push(make_pair(x * 2, y + 1)); 
                q.push(make_pair(x / 2, y + 1));
            }
        };

        int ans = 1e9;
        for(int i = 1; i &lt;= 100005; i++)
        {
            if (cnt[i] == n)
                ans = min(ans, step[i]);
        }
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/article/csdn/Codeforces_Round_313_(Div._2)_ABC.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47014209" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47014209</a></p>
<p>A<br><a href="http://codeforces.com/contest/560/problem/A" target="_blank" rel="noopener"> http://codeforces.com/contest/560/problem/A
</a><br>判断给出的数是否能组成所有自然数。水题</p>
<pre><code>int a[1010];
bool b[1000010];

int main()
{
    int n;
    while (scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        memset(b,false,sizeof(b));
        for (int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;, &amp;a[i]);
            b[a[i]] = true;
        }
        int ans = 0;
        if (b[1] == false) ans = 1;
        else if (b[1]) ans = -1;

        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre><p>B<br><a href="http://codeforces.com/contest/560/problem/B" target="_blank" rel="noopener"> http://codeforces.com/contest/560/problem/B
</a><br>判断一个矩形是否能装下另外两个矩形</p>
<pre><code>int a1, a2, a3, b1, b2, b3;

int main()
{
    while (scanf(&quot;%d%d%d%d%d%d&quot;, &amp;a1, &amp;b1, &amp;a2, &amp;b2, &amp;a3, &amp;b3) != EOF)
    {
        int ok = 0;

        int t1 = max(b2, b3);
        int r1 = max(a2, a3);

        if ((t1 &lt;= a1 &amp;&amp; (a2 + a3) &lt;= b1)) ok = 1;
        if ((t1 &lt;= b1 &amp;&amp; (a2 + a3) &lt;= a1)) ok = 1;
        if ((r1 &lt;= a1 &amp;&amp; (b2 + b3) &lt;= b1)) ok = 1;
        if ((r1 &lt;= b1 &amp;&amp; (b2 + b3) &lt;= a1)) ok = 1;

        int t11 = max(b2, a3);
        int r11 = max(a2, b3);

        if ((r11 &lt;= a1 &amp;&amp; (b2 + a3) &lt;= b1)) ok = 1;
        if ((r11 &lt;= b1 &amp;&amp; (b2 + a3) &lt;= a1)) ok = 1;
        if ((t11 &lt;= a1 &amp;&amp; (a2 + b3) &lt;= b1)) ok = 1;
        if ((t11 &lt;= b1 &amp;&amp; (a2 + b3) &lt;= a1)) ok = 1;

        if (ok) puts(&quot;YES&quot;);
        else puts(&quot;NO&quot;);
    }
    return 0;
}
</code></pre><p>C<br><a href="http://codeforces.com/contest/560/problem/C" target="_blank" rel="noopener"> http://codeforces.com/contest/560/problem/C
</a><br>判断组成六边形需要的三角形个数</p>
<pre><code>int a, b, c, d, e, f;

int main()
{
    while (scanf(&quot;%d%d%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d, &amp;e, &amp;f) != EOF)
    {
        printf(&quot;%d\n&quot;, (a + b + c)*(a + b + c) - (a*a + c*c + e*e));
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/article/csdn/Codeforces_Round_311_(Div._2)_C._Arthur_and_Table.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47273501" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47273501</a></p>
<p>C. Arthur and Table</p>
<p>time limit per test</p>
<p>1 second</p>
<p>memory limit per test</p>
<p>256 megabytes</p>
<p>input</p>
<p>standard input</p>
<p>output</p>
<p>standard output</p>
<p>Arthur has bought a beautiful big table into his new flat. When he came home,<br>Arthur noticed that the new table is unstable.</p>
<p>In total the table Arthur bought has  _n_ legs, the length of the  _i_ -th leg<br>is  _l_ _i_ .</p>
<p>Arthur decided to make the table stable and remove some legs. For each of them<br>Arthur determined number  _d_ _i_ — the amount of energy that he spends to<br>remove the  _i_ -th leg.</p>
<p>A table with  _k_ legs is assumed to be stable if there are more than half<br>legs of the maximum length. For example, to make a table with  5  legs stable,<br>you need to make sure it has at least three (out of these five) legs of the<br>maximum length. Also, a table with one leg is always stable and a table with<br>two legs is stable if and only if they have the same lengths.</p>
<p>Your task is to help Arthur and count the minimum number of energy units<br>Arthur should spend on making the table stable.</p>
<p>Input</p>
<p>The first line of the input contains integer  _n_ (  1 ≤ _n_ ≤ 10  5  ) — the<br>initial number of legs in the table Arthur bought.</p>
<p>The second line of the input contains a sequence of  _n_ integers  _l_ _i_ (<br>1 ≤ _l_ _i_ ≤ 10  5  ), where  _l_ _i_ is equal to the length of the  _i_ -th<br>leg of the table.</p>
<p>The third line of the input contains a sequence of  _n_ integers  _d_ _i_ (  1<br>≤ _d_ _i_ ≤ 200  ), where  _d_ _i_ is the number of energy units that Arthur<br>spends on removing the  _i_ -th leg off the table.</p>
<p>Output</p>
<p>Print a single integer — the minimum number of energy units that Arthur needs<br>to spend in order to make the table stable.</p>
<p>Sample test(s)</p>
<p>input</p>
<pre><code>2
1 5
3 2
</code></pre><p>output</p>
<pre><code>2
</code></pre><p>input</p>
<pre><code>3
2 4 4
1 1 1
</code></pre><p>output</p>
<pre><code>0
</code></pre><p>input</p>
<pre><code>6
2 2 1 1 3 3
4 3 5 5 2 1
</code></pre><p>output</p>
<pre><code>8
</code></pre><p>题意：</p>
<p>给你一张桌子，有n条腿，告诉每条腿的长度（l）以及砍掉这条腿的花费（d），当最长腿的数量超过总数量的1/2，那么合法。问如何使得花费最小达到合法情况。  </p>
<p>解法：</p>
<p>分别枚举以当前长度为最长的长度，砍去所有长度大于它的。删去长度小于它且花费最少的。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

const int MAXN = 100010;

int n;
int cnt[100010];
int val[100010];
int cost[210];

struct node
{
    int L;
    int D;
}a[MAXN], aa[MAXN];

bool cmp1(node a, node b)
{
    if (a.L != b.L)
        return a.L &lt; b.L;
    return a.D &lt; b.D;
}


int main()
{
    while (cin &gt;&gt; n)
    {
        memset(cnt, 0, sizeof(cnt));
        memset(val, 0, sizeof(val));
        memset(cost, 0, sizeof(cost));

        for (int i = 1; i &lt;= n; i++)
        {
            cin &gt;&gt; a[i].L;
            cnt[a[i].L]++;
        }
        for (int i = 1; i &lt;= n; i++)
            cin &gt;&gt; a[i].D;

        sort(a + 1, a + 1 + n, cmp1);

        int sum = 0;
        for (int i = n; i &gt;= 1; i--)
        {
            sum += a[i].D;
            if (a[i].L != a[i - 1].L)
            {
                val[a[i - 1].L] = sum;// 比a[i-1].l 长的桌腿的权值和是多少
            }
        }

        int ans = val[a[1].L];
        cost[a[1].D]++;

        for (int i = 2; i &lt;= n;i++)
        {
            if (a[i].L != a[i - 1].L)
            {

                int tmp = val[a[i].L];
                int num_k = i - cnt[a[i].L];

                if (num_k &gt; 0)
                {
                    for (int k = 1; k &lt;= 200; k++)
                    {
                        if (cost[k])
                        {
                            if (cost[k] &gt;= num_k)
                            {
                                tmp += k * num_k;
                                num_k = 0;
                                break;
                            }
                            else
                            {
                                tmp += k * cost[k];
                                num_k -= cost[k];
                            }
                        }
                    }
                }
                ans = min(ans, tmp);
            }
            cost[a[i].D]++;
        }

        cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/article/csdn/Codeforces_Round_312_(Div._2)_B._Amr_and_The_Large_Array.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47071765" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47071765</a></p>
<p>题目链接： <a href="http://codeforces.com/contest/558/problem/B" target="_blank" rel="noopener"> http://codeforces.com/contest/558/problem/B
</a></p>
<p>题意：给你一组数字。选择一个尽量短的区间，使其包含 数组中出现次数最多的元素的全部元素，求区间起始位置</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int n;
int l[1000010];//记录元素的起始位置
int r[1000010];

int p[1000010];//记录元素
int cnt[1000010];//记录元素出现的次数

int main()
{
    int n;
    while (scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        memset(l, 0, sizeof(l));
        memset(r, 0, sizeof(r));
        memset(cnt, 0, sizeof(cnt));

        int res = 0;
        for (int i = 1;i &lt;= n;i++)
        {
            scanf(&quot;%d&quot;,&amp;p[i]);
            cnt[p[i]] ++;
            if (l[p[i]] == 0)
                l[p[i]] = i;
            r[p[i]] = i;
        }
        int MAX = 0;
        for (int i = 1;i &lt;= n;i++)
            MAX = max(MAX, cnt[p[i]]);

        int t1, t2;
        int tmp = 1e6 + 10;

        for (int i = 1;i &lt;= n;i++)
        {
            if (cnt[p[i]] == MAX)
                if (r[p[i]] - l[p[i]] &lt; tmp)
                {
                    tmp = r[p[i]] - l[p[i]];
                    t1 = l[p[i]];
                    t2 = r[p[i]];
                }
        }
        printf(&quot;%d %d\n&quot;, t1, t2);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/article/csdn/Codeforces_Round_321_(Div._2)_%EF%BC%A1%EF%BC%A2%EF%BC%A3.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48707217" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48707217</a></p>
<p>题目链接： <a href="http://codeforces.com/contest/580" target="_blank" rel="noopener"> http://codeforces.com/contest/580 </a></p>
<p>Ａ　求非递减区间的最大长度，递推即可</p>
<p>Ｂ　按ｍｏｎｅｙ值由大到小排序，求</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;sstream&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;functional&gt;  
#include &lt;vector&gt;
#include &lt;string.h&gt;

using namespace std;

int n, m;
struct Node  
{
    long long val;
    long long fri;
}f[100010];

bool cmp(Node a, Node b)
{
    return a.val &lt; b.val;
}

long long dp[100010];

int main()
{
    while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))
    {
        memset(dp,0,sizeof(dp));
        for (int i = 1;i &lt;= n;i++)
            scanf(&quot;%lld%lld&quot;, &amp;f[i].val, &amp;f[i].fri);

        sort(f + 1, f + 1 + n, cmp);

        long long ans = 0;
        long long tmp = 0;
        int pos = 1;
        for (int i = 1;i &lt;= n;i++)
        {
            if (i != 1) tmp -= f[i - 1].fri;
            while (pos &lt;= n &amp;&amp; f[pos].val - f[i].val &lt; m)
            {
                tmp += f[pos++].fri;
            }
            ans = max(ans, tmp);
        }
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}
</code></pre><p>Ｃ　由根节点进行ＤＦＳ遍历，遍历过程记录答案。</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/article/csdn/Codeforces_Round_333_(Div._2)_C._The_Two_Routes.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/50086655" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/50086655</a></p>
<p>题目链接： <a href="http://codeforces.com/contest/602/problem/C" target="_blank" rel="noopener"> http://codeforces.com/contest/602/problem/C
</a></p>
<p>题意：给你一个完全图，edge是铁路或公路，火车只走铁路，汽车只公路。求使得火车汽车都从１到达n点所需的最短时间，并且两车途中不得同时到达同一点（除了n点）。</p>
<p>解法：由于是完全图，一定有火车或汽车直接由１到n 。求另一车的最短路径即可。</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;string&gt;
#include &lt;string.h&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int MAXV = 4010;
const int inf = 10000000;

int map[MAXV][MAXV];
int d[MAXV];
bool vis[MAXV];
int n,m;

void dijkstra(int s)
{
    for(int i=1;i&lt;=n;i++)
    {
        vis[i] = false;
        d[i] = map[s][i];
    }
    d[1] = 0;
    while (1)
    {
        int min=inf,v = -1;
        for(int i=1;i&lt;=n;i++)
            if(!vis[i] &amp;&amp; d[i]&lt;min)
            {
                v=i;
                min=d[i];
            }
        if(v == -1)
            break;
        vis[v]=1;
        for(int i=1;i&lt;=n;i++)
            if(!vis[i] &amp;&amp; d[i] &gt; d[v] + map[v][i])
                d[i]=map[v][i]+d[v];
    }
}

int m1[510][510];
int m2[510][510];
int ans1,ans2;

int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=n;j++)
            {
                if (i!=j)
                    m1[i][j] = m2[i][j] = inf;
                else
                    m1[i][j] = m2[i][j] = 0;
            }

    int u,v;
    for(int i=1;i&lt;=m;i++)
    {
        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
        m1[u][v] = m1[v][u] = 1;
    }

    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=n;j++)
    {
        if (m1[i][j] == inf)
                m2[i][j] = m2[j][i] = 1;
    }

    ans1 = ans2 = -1;
    int ans = 1;

    if (m1[1][n] == 1)
    {
        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;=n;j++)
            map[i][j] = m2[i][j];
        dijkstra(1);
        if (d[n] == inf) ans = -1;
        else ans = d[n];
    }
    else
    {
        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;=n;j++)
            map[i][j] = m1[i][j];
        dijkstra(1);
        if (d[n] == inf) ans = -1;
        else ans = d[n];
    }

    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/article/csdn/Codeforces_Round_316_(Div._2).html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47796031" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47796031</a></p>
<p>A <a href="http://codeforces.com/contest/570/problem/A" target="_blank" rel="noopener"> http://codeforces.com/contest/570/problem/A
</a><br>简单题</p>
<pre><code>int n, m;

long long  cnt[1000];

struct node
{
    long long nb;
    long long sum;
}res[1000],ans[1000];

bool cmp(node a, node b)
{
    if (a.sum != b.sum)
        return a.sum &gt; b.sum;
    else
        return a.nb &lt; b.nb;
}

bool cmp2(int a, int b)
{

    return a &gt; b;
}



int main()
{
    while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))
    {
        memset(ans, 0, sizeof(ans));
        memset(cnt, 0, sizeof(cnt));

        long long t;
        for (int i = 1; i &lt;= m; i++)
        {
            memset(res, 0, sizeof(res));
            for (int j = 1; j &lt;= n; j++)
            {
                scanf(&quot;%lld&quot;,&amp;t);
                res[j].sum += t;
                res[j].nb = j;
            }
            sort(res + 1, res + 1 + n, cmp);
            cnt[res[1].nb]++;
        }
        long long  MAX = -1;
        for (int i = 0; i &lt;= n; i++)
            MAX = max(MAX, cnt[i]);
        for (int i = 0; i &lt;= n; i++)
        {
            if (cnt[i] == MAX)
            {
                printf(&quot;%d\n&quot;, i);
                break;
            }
        }
    }
    return 0;
}
</code></pre><p>B <a href="http://codeforces.com/contest/570/problem/B" target="_blank" rel="noopener"> http://codeforces.com/contest/570/problem/B
</a><br>简单题</p>
<pre><code>int n, m;

int main()
{
    while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))
    {
        if (n == 1 &amp;&amp; m == 1)
        {
            printf(&quot;1\n&quot;);
            continue;
        }
        int ans = n / 2;
        if (ans &gt;= m) ans = m+1;
        else ans = m - 1;
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre><p>C <a href="http://codeforces.com/contest/570/problem/C" target="_blank" rel="noopener"> http://codeforces.com/contest/570/problem/C
</a><br>思路见代码</p>
<pre><code>int n, m;
char s[300010];

int main()
{
    while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))
    {
        scanf(&quot;%s&quot;, s+1);
        int pos;
        char c[10];
        int ans = 0;
        for (int i = 1; i &lt; n; i++) if (s[i] == &#39;.&#39; &amp;&amp; s[i + 1] == &#39;.&#39;) ans++;
        while (m--)
        {
            scanf(&quot;%d%s&quot;, &amp;pos, c);
            if (pos &gt; 1 &amp;&amp; s[pos] == &#39;.&#39; &amp;&amp; s[pos - 1] == &#39;.&#39;) ans--;
            if (pos + 1 &lt;= n &amp;&amp; s[pos] == &#39;.&#39; &amp;&amp; s[pos + 1] == &#39;.&#39;) ans--;
            s[pos] = c[0];
            if (pos &gt; 1 &amp;&amp; s[pos] == &#39;.&#39; &amp;&amp; s[pos - 1] == &#39;.&#39;) ans++;
            if (pos + 1 &lt;= n &amp;&amp; s[pos] == &#39;.&#39; &amp;&amp; s[pos + 1] == &#39;.&#39;) ans++;
            printf(&quot;%d\n&quot;,ans);
        }
    }
    return 0;
}
</code></pre><p>D <a href="http://codeforces.com/contest/570/problem/D" target="_blank" rel="noopener"> http://codeforces.com/contest/570/problem/D
</a><br>代码TLE了。。。之后改</p>
<pre><code>int n, m;
int deep[500010];
int fa[500010];
char s[500010];
char ss[30] = {&#39;a&#39;,&#39;q&#39;,&#39;w&#39;,&#39;e&#39;,&#39;r&#39;,&#39;t&#39;,&#39;y&#39;,&#39;u&#39;,&#39;i&#39;,&#39;o&#39;,&#39;p&#39;,&#39;a&#39;,&#39;s&#39;,&#39;d&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;,&#39;j&#39;,&#39;k&#39;,&#39;l&#39;,&#39;z&#39;,&#39;x&#39;,&#39;c&#39;,&#39;v&#39;,&#39;b&#39;,&#39;n&#39;,&#39;m&#39;};
map&lt;char, int&gt;mp;
vector&lt;int&gt; g[500010];

void dfs(int x,int d)
{
    if (deep[x] == d)
        mp[s[x]]++;
    for (int i = 0; i &lt; g[x].size(); i++)
    {
        if (fa[g[x][i]] == x)
            dfs(g[x][i], d);
    }
}

int main()
{
    while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))
    {
        memset(fa, -1, sizeof(fa));
        for (int i = 1; i &lt;= n; i++) g[i].clear();
        fa[1] = 1;
        deep[1] = 1;
        int max_deep = 1;

        int tmp;
        for (int i = 2; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;, &amp;tmp);
            g[tmp].push_back(i);
            fa[i] = tmp;
            deep[i] = deep[fa[i]] + 1;
            max_deep = max(max_deep, deep[i]);
        }
        scanf(&quot;%s&quot;, s + 1);
        int a, b;
        while (m--)
        {
            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
            if (b &gt; max_deep)
            {
                puts(&quot;Yes&quot;);
                continue;
            }
            if (deep[a] &gt; deep[b])
            {
                puts(&quot;Yes&quot;);
                continue;
            }

            mp.clear();
            dfs(a, b);
            int cnt = 0;
            for (int i = 1; i &lt;= 26; i++)
            {
                if (mp[ss[i]] % 2 == 1) cnt++;
                if (cnt &gt; 1) break;
            }
            //cout &lt;&lt; &quot;  ***  &quot; &lt;&lt; str &lt;&lt; endl;
            if (cnt &gt; 1) puts(&quot;No&quot;);
            else puts(&quot;Yes&quot;);
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>struct</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/article/csdn/Codeforces_Round_334_(Div._2).html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/50152401" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/50152401</a></p>
<p><a href="http://codeforces.com/contest/604" target="_blank" rel="noopener"> http://codeforces.com/contest/604 </a></p>
<p>Ａ：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;bitset&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;
#include &lt;map&gt;
#include &lt;set&gt;

using namespace std;

int m[6];
int w[6];
int hs,hu;
int a[10] = {0,500, 1000, 1500, 2000, 2500};

int main()
{
    cin&gt;&gt;m[1]&gt;&gt;m[2]&gt;&gt;m[3]&gt;&gt;m[4]&gt;&gt;m[5];
    cin&gt;&gt;w[1]&gt;&gt;w[2]&gt;&gt;w[3]&gt;&gt;w[4]&gt;&gt;w[5];
    cin&gt;&gt;hs&gt;&gt;hu;
    int ans =0;
    for(int i=1;i&lt;=5;i++)
        ans += max(a[i]/10*3,a[i] - a[i]/250*m[i] - 50*w[i]);

    ans += 100*hs;
    ans += -50*hu;
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
</code></pre><p>Ｂ：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

int n, k;
long long a[100010];

int main()
{
    while (cin &gt;&gt; n &gt;&gt; k)
    {
        for (int i = 1;i &lt;= n;i++)
            cin &gt;&gt; a[i];

        long long ans = a[n];

        int num = n - k;

        for (int i = 1;i &lt;= num;i++)
        {
            ans = max(ans, a[i] + a[2 * num - i + 1]);
        }

        cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}
</code></pre><p>Ｃ：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

int n;
char s[100010];

int main()
{
    while (cin &gt;&gt; n)
    {
        cin &gt;&gt; s;

        int pos = 0;
        int len = strlen(s);
        int cnt1 = 0, cnt2 = 0;

        while (pos &lt; len)
        {
            if (s[pos] == s[pos + 1])
            {
                cnt2++;
            }
            else
            {
                cnt1++;
            }
            pos++;
        }

        //cout &lt;&lt; cnt1 &lt;&lt; &quot; &quot; &lt;&lt; cnt2 &lt;&lt; endl;

        int ans = cnt1 + min(2, cnt2);

        cout &lt;&lt; ans &lt;&lt; endl;

    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/article/csdn/Codeforces_Round_346_(Div._2)_ABCDE.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/51051053" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/51051053</a></p>
<p>题目： <a href="http://codeforces.com/contest/659/problems" target="_blank" rel="noopener"> http://codeforces.com/contest/659/problems
</a><br>A:</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int n, a, b;

int main()
{
    while (cin &gt;&gt; n &gt;&gt; a &gt;&gt; b)
    {
        int ans;
        ans = (a + b + n * 1000) % (n);
        if (ans == 0) ans = n;
        cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}
</code></pre><p>B:</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

vector &lt;pair&lt;int, string&gt;&gt; a[10010];


int n, m;
int main()
{
    while (cin &gt;&gt; n &gt;&gt; m)
    {

        string tmp;
        int num, val;
        for (int i = 1;i &lt;= n;i++)
        {
            cin &gt;&gt; tmp &gt;&gt; num &gt;&gt; val;
            num--;
            val = -val;
            a[num].push_back(make_pair(val, tmp));
        }


        for (int i = 0;i &lt; m;i++)
        {

            sort(a[i].begin(), a[i].end());
            if (a[i].size() &gt; 2 &amp;&amp; a[i][1].first == a[i][2].first) 
                puts(&quot;?&quot;);
            else
                cout &lt;&lt; a[i][0].second &lt;&lt;&quot; &quot;&lt;&lt; a[i][1].second &lt;&lt; endl;
        }
    }
    return 0;
}
</code></pre><p>C:</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;set&gt;

using namespace std;

int n, m;
set&lt;int&gt; S;
vector&lt;int&gt; ans;

int main()
{
    while (cin &gt;&gt; n &gt;&gt; m)
    {
        ans.clear();
        S.clear();
        set&lt;int&gt;::iterator pos;
        vector&lt;int&gt;::iterator it;

        int tmp;
        for (int i = 1;i &lt;= n;i++)
        {
            cin &gt;&gt; tmp;
            S.insert(tmp);
        }

        tmp = 1;
        while (m)
        {
            if (m &lt; tmp) break;
            if (S.count(tmp) == 0)
            {
                m -= tmp;
                ans.push_back(tmp);
                S.insert(tmp);
                tmp++;
            }
            else
                tmp++;
        }
        cout &lt;&lt; ans.size() &lt;&lt; endl;
        for (it = ans.begin();it != ans.end();it++)
            cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
        cout &lt;&lt; endl;
    }
    return 0;
}
</code></pre><p>D:</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;set&gt;

using namespace std;

int n;

struct
{
    int x, y;
}a[1010];

int main()
{
    while (scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        memset(b, 0, sizeof(b));

        for (int i = 0;i &lt;= n;i++)
        {
            scanf(&quot;%d %d&quot;, &amp;a[i].x, &amp;a[i].y);
        }

        int ans = 0;
        for (int i = 0;i &lt; n;i++)
        {
            int t1 = i + 1;
            int t2 = i + 2;
            if (t2 == n + 1) t2 = 0;

            if (a[i].x &lt; a[i + 1].x &amp;&amp; a[i].y == a[i + 1].y)//右
            {
                if (a[t1].x == a[t2].x &amp;&amp; a[t1].y &lt; a[t2].y)//↑
                    ans++;
            }
            else if (a[i].x &gt; a[i + 1].x &amp;&amp; a[i].y == a[i + 1].y)//左
            {
                if (a[t1].x == a[t2].x &amp;&amp; a[t1].y &gt; a[t2].y)//下
                    ans++;
            }
            else if (a[i].x == a[i + 1].x &amp;&amp; a[i].y &lt; a[i + 1].y)//上
            {
                if (a[t1].x &gt; a[t2].x &amp;&amp; a[t1].y == a[t2].y)//左
                    ans++;
            }
            else if (a[i].x == a[i + 1].x &amp;&amp; a[i].y &gt; a[i + 1].y)//下
            {
                if (a[t1].x &lt; a[t2].x &amp;&amp; a[t1].y == a[t2].y)//右
                    ans++;
            }
        }
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}
</code></pre><p>E:</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;set&gt;

using namespace std;

const int MAXN = 200010;

vector&lt;int&gt; g[MAXN];

int n, m, nnode, nedge;
int vis[MAXN];

void dfs(int u)
{
    vis[u] = 1;
    nnode++;
    for (int i = 0;i &lt; g[u].size();i++)
    {
        int v = g[u][i];
        nedge++;
        if (!vis[v])
            dfs(v);
    }

}

int main()
{
    while (scanf(&quot;%d %d&quot;, &amp;n, &amp;m) != EOF)
    {
        memset(vis, 0, sizeof vis);
        for (int i = 0;i &lt;= n;i++)
            g[i].clear();
        int u, v;
        for (int i = 1;i &lt;= m;i++)
        {
            scanf(&quot;%d %d&quot;, &amp;u, &amp;v);
            g[u].push_back(v);
            g[v].push_back(u);
        }

        int ans = 0;
        for (int i = 1;i &lt;= n;i++)
        {
            if (!vis[i])
            {
                nnode = nedge = 0;
                dfs(i);
                if (nedge / 2 == nnode - 1)
                    ans++;
            }
        }

        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Divideing Jewels【dfs或DP】</title>
    <url>/article/csdn/Divideing_Jewels%E3%80%90dfs%E6%88%96DP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44496867" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44496867</a></p>
<p>Divideing Jewels<br>Time Limit: 1 Sec Memory Limit: 128 MB<br>Submit: 164 Solved: 22<br>[Submit][Status][Web Board]<br>Description<br>Mary and Rose own a collection of jewells. They want to split the collection<br>among themselves so that both receive an equal share of the jewels. This would<br>be easy if all the jewels had the same value, because then they could just<br>split the collection in half. But unfortunately, some of the jewels are<br>larger, or more beautiful than others. So, Mary and Rose start by assigning a<br>value, a natural number between one and ten, to each jewel. Now they want to<br>divide the jewels so that each of them gets the same total value.<br>Unfortunately, they realize that it might be impossible to divide the jewels<br>in this way (even if the total value of all jewels is even). For example, if<br>there are one jewel of value 1, one of value 3 and two of value 4, then they<br>cannot be split into sets of equal value. So, they ask you to write a program<br>that checks whether there is a fair partition of the jewels.</p>
<p>Input<br>Each line in the input file describes one collection of jewels to be divided.<br>The lines contain ten non-negative integers n1 , … , n10 , where ni is the<br>number of jewels of value i. The maximum total number of jewells will be</p>
<ol start="10000">
<li>The last line of the input file will be “0 0 0 0 0 0 0 0 0 0”; do not process<br>this line.</li>
</ol>
<p>Output<br>For each collection, output “#k:”, where k is the number of the test case, and<br>then either “Can be divided.” or “Can’t be divided.”.<br>Output a blank line after each test case（Except the last case）.</p>
<pre><code>Sample Input
1 0 1 2 0 0 0 0 2 0
1 0 0 0 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0
Sample Output

#1:Can&#39;t be divided.
#2:Can be divided.
</code></pre><p>dp:</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;iostream&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;ctype.h&gt;  
#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;stack&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;sstream&gt;  
#include &lt;time.h&gt;  
#include &lt;malloc.h&gt;  

using namespace std;

const int MAXN = 100000;

int p[MAXN],dp[MAXN];

int vis[MAXN], tmp, ave;

int main()
{
    int cases = 1;
    while (1)
    {
        memset(vis, 0, sizeof(vis));
        int ok = 0;
        int sum = 0;
        for (int i = 1; i &lt;= 10; i++)
        {
            scanf(&quot;%d&quot;,&amp;p[i]);
            sum += i * p[i];
            if (p[i] != 0) ok = 1;
        }
        p[0] = 0;

        if (!ok) break;
        if (cases != 1) printf(&quot;\n&quot;);

        if (sum % 2 != 0)
        {
            printf(&quot;#%d:Can&#39;t be divided.\n&quot;, cases++);
            continue;
        }
        else
        {
            ave = sum / 2;
            memset(dp, -1, sizeof(dp));

            dp[0] = 0;

            for (int i = 0; i &lt;= 10; i++)
            {
                for (int j = 0; j &lt;= ave; j++)
                {
                    if (dp[j] &gt;= 0)
                        dp[j] = p[i];
                    else if (j &lt; i || dp[j - i] &lt;= 0)
                    {
                        dp[j] = -1;
                    }
                    else
                    {
                        dp[j] = dp[j - i] - 1;
                    }
                }
            }

            if (dp[ave]&gt;=0)
                printf(&quot;#%d:Can be divided.\n&quot;, cases++);
            else
                printf(&quot;#%d:Can&#39;t be divided.\n&quot;, cases++);
        }
    }
    return 0;
}
</code></pre><p>dfs:</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;iostream&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;ctype.h&gt;  
#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;stack&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;sstream&gt;  
#include &lt;time.h&gt;  
#include &lt;malloc.h&gt;  

using namespace std;

const int MAXN = 1000000;

int p[MAXN];

int val[MAXN], tmp, ave;

int dfs(int sum,int num)
{
    if (sum == 0) return 1;
    if (sum &lt; 0 || (sum&gt;0 &amp;&amp; num == 0)) return 0;
    if (dfs(sum - val[num], num - 1)) return 1;
    dfs(sum,num-1);
}

int main()
{
    int cases = 1;
    while (1)
    {
        int sum = 0;
        int len = 1;
        for (int i = 1; i &lt;= 10; i++)
        {
            scanf(&quot;%d&quot;, &amp;p[i]);
                sum += i * p[i];
            for (int j = 0; j &lt; p[i]; j++)
                val[len++] = i;
        }

        if (sum==0) break;
        if (cases != 1) printf(&quot;\n&quot;);

        if (sum % 2 != 0)
        {
            printf(&quot;#%d:Can&#39;t be divided.\n&quot;, cases++);
            continue;
        }
        if (dfs(sum/2,len-1))
            printf(&quot;#%d:Can be divided.\n&quot;, cases++);
        else
            printf(&quot;#%d:Can&#39;t be divided.\n&quot;, cases++);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>DP经典5题 【DP】</title>
    <url>/article/csdn/DP%E7%BB%8F%E5%85%B85%E9%A2%98_%E3%80%90DP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46383371" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46383371</a></p>
<p>1.最大子段和</p>
<p>给定n个整数的序列{ N1, N2, …, Nn }，其任意连续子序列可表示为{ Ni, Ni+1, …, Nj }，其中 1 &lt;= i &lt;= j &lt;=<br>K。最大连续子序列是所有连续子序中元素和最大的一个， 例如给定序列{ -2, 11, -4, 13, -5, -2 }，其最大连续子序列为{ 11, -4,<br>13 }，最大和为20。</p>
<pre><code>int n, a[100];
int b = 0, ans = -1e9;
void solve()
{
    for (int i = 0; i &lt; n; i++)
    {
        if (b &gt; 0) b += a[i];
        else b = a[i];
        ans = max(ans, b);
    }
}
</code></pre><p>2.数塔问题</p>
<p>要求从顶层走到底层，若每一步只能走到相邻的结点，则经过的结点的数字之和最大是多少？</p>
<p>自下而上进行状态转移。</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;algorithm&gt;  
#include &lt;string.h&gt;  
#include &lt;string&gt;  
#include &lt;sstream&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;malloc.h&gt;  

using namespace std;  

int dp[510][510];  

int main ()  
{  
    int n;  
    cin&gt;&gt;n;  

        memset (dp,0,sizeof(dp));  
        for (int i=1;i&lt;=n;i++)  
            for (int j=1;j&lt;=i;j++)  
            cin&gt;&gt;dp[i][j];  

        for (int i=n-1;i&gt;=1;i--)  
        {  
            for (int j=1;j&lt;=i;j++)  
                dp[i][j]+=max (dp[i+1][j],dp[i+1][j+1]);  
        }  
        cout&lt;&lt;dp[1][1]&lt;&lt;endl;  

    return 0;  
}
</code></pre><p>3.最长上升子序列</p>
<p>给你一个数组p[MAXN],求最长上升子序列长度（不要和字串搞混）。</p>
<pre><code>#include&lt;stdio.h&gt;  
#include&lt;iostream&gt;  
#include&lt;math.h&gt;  
#include&lt;stdlib.h&gt;  
#include&lt;ctype.h&gt;  
#include&lt;algorithm&gt;  
#include&lt;vector&gt;  
#include&lt;string&gt;  
#include&lt;queue&gt;  
#include&lt;stack&gt;  
#include&lt;set&gt;  
#include&lt;map&gt;  

using namespace std;  

int n,p[1010],dp[1010];  

int main()  
{  
    while (scanf(&quot;%d&quot;, &amp;n) != EOF)  
    {  
        for (int i = 1; i &lt;= n; i++)  
            scanf(&quot;%d&quot;,&amp;p[i]);  

        for (int i = 1; i &lt;= n; i++)  
        {  
            dp[i] = 1;  
            for (int j = 1; j &lt; i; j++)  
            {  
                if (p[i] &gt; p[j])  
                    dp[i] = max(dp[i],dp[j] + 1);  
            }  
        }  
        int ans = -1;  
        for (int i = 1; i &lt;= n; i++)  
            ans = max(ans,dp[i]);  
        printf(&quot;%d\n&quot;,ans);  
    }  
    return 0;  
}
</code></pre><p>4.最长公共子序列(LCS)<br>两个数组s[100],t[100];</p>
<p>状态转移方程:</p>
<p>if (s[i+1]==t[j+1]) dp[i+1][j+1] = max(dp[i][j]+1,dp[i][j+1],dp[i+1][j])</p>
<p>else dp[i+1][j+1] = max(dp[i][j+1],dp[i+1][j])</p>
<pre><code>int s[100], t[100], n, m;
int dp[110][110];
void solve()
{
    for (int i = 0; i &lt; n; i++)
        for (int j = 0; j &lt; m; j++)
        {
            if (s[i] == t[j])
                dp[i + 1][j + 1] = max(dp[i][j] + 1, max(dp[i][j + 1], dp[i + 1][j]));
            else
                dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);
        }
    int ans = dp[n][m];
}
</code></pre><p>5.01背包问题</p>
<p>有编号分别为a,b,c,d,e的五件物品，它们的重量分别是2,2,6,5,4，它们的价值分别是6,3,5,4,6，现在给你个承重为10的背包，如何让背包里装入的物品具有最大的价值总和？</p>
<pre><code>#include&lt;stdlib.h&gt;  
#include&lt;ctype.h&gt;  
#include&lt;algorithm&gt;  
#include&lt;vector&gt;  
#include&lt;string&gt;  
#include&lt;queue&gt;  
#include&lt;stack&gt;  
#include&lt;set&gt;  
#include&lt;map&gt;  
#include &lt;string&gt;  
#include &lt;sstream&gt;  

using namespace std;

int main()
{
    int t;
    scanf(&quot;%d&quot;, &amp;t);
    int a[1000], c[1000], dp[10000];
    while (t--)
    {
        int n, v;
        scanf(&quot;%d%d&quot;, &amp;n, &amp;v);

        for (int i = 0; i&lt;n; i++)
            scanf(&quot;%d&quot;, &amp;a[i]);
        for (int i = 0; i&lt;n; i++)
            scanf(&quot;%d&quot;, &amp;c[i]);

        memset(dp, 0, sizeof(dp));

        for (int i = 0; i&lt;n; i++)
            for (int j = v; j &gt;= 0; j--)
            {
                if (j - c[i] &gt;= 0)
                    dp[j] = max(dp[j], dp[j - c[i]] + a[i]);
            }
        printf(&quot;%d\n&quot;, dp[v]);
    }
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/article/csdn/Codeforces_Round_340_(Div._2)_A_B_C_D.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/50573943" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/50573943</a></p>
<p><a href="http://codeforces.com/contest/617" target="_blank" rel="noopener"> http://codeforces.com/contest/617 </a><br>A<br>尽量选择数值较大的</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string&gt;
#include &lt;string.h&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;set&gt;

using namespace std;

int main()
{
    int x;
    while (cin&gt;&gt;x)
    {
        int cnt = 0;
        while (x &gt;= 5)
        {
            x -= 5;
            cnt++;
        }
        while (x &gt;= 4)
        {
            x -= 4;
            cnt++;
        }
        while (x &gt;= 3)
        {
            x -= 3;
            cnt++;
        }
        while (x &gt;= 2)
        {
            x -= 2;
            cnt++;
        }
        while (x &gt;= 1)
        {
            x -= 1;
            cnt++;
        }
        cout &lt;&lt; cnt &lt;&lt; endl;
    }
    return 0;
}
</code></pre><p>B<br>乘法计数原理</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string&gt;
#include &lt;string.h&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;set&gt;

using namespace std;

int n;
int a[110];
long long  b[110];


int main()
{
    while (scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        int ok = 0;
        for (int i = 1;i &lt;= n;i++)
        {
            scanf(&quot;%d&quot;, &amp;a[i]);
            if (a[i] == 1)
                ok = 1;
        }
        if ((n == 1 &amp;&amp; a[1] == 0) || !ok)
        {
            printf(&quot;0\n&quot;);
            continue;
        }

        memset(b, 1, sizeof(b));

        int len = 0;
        int c1 = 0;
        int cnt = 0;

        for (int i = 1;i &lt;= n;i++)
        {
            if (a[i] == 1)
                c1++;
            else if (a[i] == 0 &amp;&amp; c1 != 0)
                cnt++;

            if (c1 &gt; 1 &amp;&amp; a[i] == 1)
            {
                b[len++] = cnt + 1;
                cnt = 0;
            }

        }

        long long ans = 1;
        for (int i = 0;i &lt; len;i++)
            ans *= b[i];

        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}
</code></pre><p>C<br>按与水池1距离大到小模拟</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string&gt;
#include &lt;string.h&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;set&gt;

using namespace std;

struct Point
{
    Point() {}
    __int64 x, y;
}p[10],q[2010];

bool cmp(Point a,Point b)
{
    __int64 t1 = (a.x - p[0].x) * (a.x - p[0].x) + (a.y - p[0].y) * (a.y - p[0].y);
    __int64 t2 = (b.x - p[0].x) * (b.x - p[0].x) + (b.y - p[0].y) * (b.y - p[0].y);
    __int64 t3 = (a.x - p[1].x) * (a.x - p[1].x) + (a.y - p[1].y) * (a.y - p[1].y);
    __int64 t4 = (b.x - p[1].x) * (b.x - p[1].x) + (b.y - p[1].y) * (b.y - p[1].y);
    if (t1 == t2)
        return t3 &gt; t4;
    else
        return t1 &gt; t2;
}  

int main()
{
    int n;
    while (scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        for (int i = 0;i &lt; 2;i++)
            scanf(&quot;%I64d %I64d&quot;, &amp;p[i].x, &amp;p[i].y);

        for (int i = 0;i &lt; n;i++)
            scanf(&quot;%I64d %I64d&quot;, &amp;q[i].x, &amp;q[i].y);

        sort(q, q + n, cmp);

        __int64 ans = 1e18, MAX = 0;
        for (int i = 0;i &lt; n;i++)
        {
            ans = min(ans, MAX + (q[i].x - p[0].x) * (q[i].x - p[0].x) + (q[i].y - p[0].y)*(q[i].y - p[0].y));
            MAX = max(MAX, (q[i].x - p[1].x) * (q[i].x - p[1].x) +(q[i].y - p[1].y)*(q[i].y - p[1].y));
        }
        ans = min(ans, MAX);
        printf(&quot;%I64d\n&quot; ,ans);
    }
    return 0;
}
</code></pre><p>D<br>三点一线 - 1<br>两点一线 另一点不在两点之间区域 - 2<br>其他 - 3</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string&gt;
#include &lt;string.h&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;set&gt;

using namespace std;

int x1, x2, x3, y11, y2, y3;

bool is_two(int x1, int y1, int x2, int y2, int x3, int y3)
{
    if (x1 == x2)
    {
        if (y3 &lt;= min(y1, y2) || y3 &gt;= max(y1, y2))
            return true;
        return false;
    }
    if (x1 == x3)
    {
        if (y2 &lt;= min(y1, y3) || y2 &gt;= max(y1, y3))
            return true;
        return false;
    }
    if (x3 == x2)
    {
        if (y1 &lt;= min(y3, y2) || y1 &gt;=max(y3, y2))
            return true;
        return false;
    }

    if (y1 == y2)
    {
        if (x3 &lt;= min(x1, x2) || x3 &gt;= max(x1, x2))
            return true;
        return false;
    }
    if (y1 == y3)
    {
        if (x2 &lt;= min(x1, x3) || x2 &gt;= max(x3, x1))
            return true;
        return false;
    }
    if (y3 == y2)
    {
        if (x1 &lt;= min(x3, x2) || x1 &gt;= max(x3, x2))
            return true;
        return false;
    }

    return false;
}

int main()
{
    while (cin &gt;&gt; x1 &gt;&gt; y11 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; x3 &gt;&gt; y3)
    {
        int ans;
        if (x1 == x2 &amp;&amp; x1 == x3)
            ans = 1;
        else if (y11 == y2 &amp;&amp; y2 == y3)
            ans = 1;
        else if (is_two(x1, y11, x2, y2, x3, y3))
        {
            ans = 2;
        }
        else
            ans = 3;
        cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>C语言：位异或运算符^</title>
    <url>/article/csdn/C%E8%AF%AD%E8%A8%80%EF%BC%9A%E4%BD%8D%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6%5E.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40650683" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40650683</a></p>
<p>C语言：位异或运算符^</p>
<p>位运算符家族中，最常用的，某过于异或运算符。</p>
<p>异或运算符是指： 参与运算的两个值，如果两个相应位相同，则结果为0，否则为1。即：0^0=0， 1^0=1， 0^1=1， 1^1=0</p>
<p>例如：10100001^00010001=10110000</p>
<p>0^0=0,0^1=1    可理解为： 0异或任何数，其结果=任何数</p>
<p>1^0=1,1^1=0    可理解为： 1异或任何数，其结果=任何数取反<br>任何数异或自己，等于把自己置0</p>
<p>1)按位异或可以用来使某些特定的位翻转，如对数10100001的第1位和第2位翻转，可以将数与00000110进行按位异或运算。<br>10100001^00000110=10100111</p>
<p>用十六进制表示： 0xA1 ^ 0x06 = 0xA7</p>
<p>(2)通过按位异或运算，可以实现两个值的交换，而不必使用临时变量。例如交换两个整数a，b的值，可通过下列语句实现：</p>
<p>a=10100001,   b=00000110</p>
<p>a=a^b； 　　//a=10100111</p>
<p>b=b^a； 　　//b=10100001</p>
<p>a=a^b； 　　//a=00000110</p>
<p>(3)异或运算符的特点是：数a两次异或同一个数b（a=a^b^b）仍然为原值a.</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>FZU 2150 求双搜最优解</title>
    <url>/article/csdn/FZU_2150_%E6%B1%82%E5%8F%8C%E6%90%9C%E6%9C%80%E4%BC%98%E8%A7%A3.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/42298181" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/42298181</a></p>
<p><a href="http://acm.fzu.edu.cn/problem.php?pid=2150" target="_blank" rel="noopener"> http://acm.fzu.edu.cn/problem.php?pid=2150
</a></p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt;
#include&lt;malloc.h&gt;

using namespace std;

int t, n, m;
char b[15][15];
int dir[4][2] = { { -1, 0 }, { 1, 0 }, { 0, 1 }, { 0, -1 } };
int vis[15][15];
int check(int x, int y)
{
    if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m)
        return 1;
    return 0;
}
struct node
{
    int x;
    int y;
    int t;
}q[150];

queue&lt;node&gt; de;
int step = 0;

int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    int c = 1;
    while (t--)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        for (int i = 0; i &lt; n; i++)
            scanf(&quot;%s&quot;,b[i]);

        int num = 0;
        for (int i = 0; i &lt; n; i++)
            for (int j = 0; j &lt; m; j++)
            {
                if (b[i][j] == &#39;#&#39;)
                {
                    q[num].x = i;
                    q[num++].y = j;
                }
            }

        int ans = 0x3f3f3f3f;
        if (num == 2)
            ans = 0;
        else 
        for (int i = 0; i &lt; num; i++)
        {
            for (int j = i; j &lt; num; j++)
            {
                int sx = q[i].x;
                int sy = q[i].y;
                int ex = q[j].x;
                int ey = q[j].y;
                {

                    while (!de.empty()) de.pop();

                    node qq, qqq;
                    qq.x = sx; qq.y = sy; qq.t = 0;
                    qqq.x = ex; qqq.y = ey; qqq.t = 0;

                    de.push(qq);
                    de.push(qqq);
                    memset(vis,0,sizeof(vis));

                    vis[sx][sy] = vis[ex][ey] = 1;

                    step = 0;

                    /////////////////
                    while (!de.empty())
                    {
                        node qq = de.front();
                        de.pop();
                            step = qq.t;
                        for (int i = 0; i &lt; 4; i++)
                        {
                            int x = qq.x + dir[i][0];
                            int y = qq.y + dir[i][1];

                            if (!check(x, y) || vis[x][y] || b[x][y] == &#39;.&#39;)
                                continue;
                            node qqq;
                            qqq.x = x;
                            qqq.y = y;
                            qqq.t = qq.t + 1;
                            vis[x][y] = 1;
                            de.push(qqq);
                        }
                    }
                    ////////////////
                    int ok = 1;

                    for (int i = 0; i &lt; n; i++)
                    {
                        for (int j = 0; j &lt; m; j++)
                        {
                            if (vis[i][j] == 0 &amp;&amp; b[i][j] == &#39;#&#39;)
                            {
                                ok = 0;
                                break;
                            }
                        }
                    }

                    if (ok)
                    {
                        ans = min(ans, step);
                    }
                }
            }
        }
        if (ans == 0x3f3f3f3f)
            ans = -1;
        printf(&quot;Case %d: %d\n&quot;,c++,ans);
    }
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Goldbach`s Conjecture 【素数线性筛法】</title>
    <url>/article/csdn/Goldbach%60s_Conjecture_%E3%80%90%E7%B4%A0%E6%95%B0%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B3%95%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44163723" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44163723</a></p>
<p>Goldbach`s Conjecture</p>
<p><strong>Time Limit:</strong> 2000  MS <strong>Memory Limit:</strong> 32768  KB <strong>64bit IO Format:</strong> %lld<br>&amp; %llu</p>
<p>Submit  <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=70017#status//F/0" target="_blank" rel="noopener"> Status
</a></p>
<p>Description</p>
<p>Goldbach’s conjecture is one of the oldest unsolved problems in number theory<br>and in all of mathematics. It states:</p>
<p>Every even integer, greater than 2, can be expressed as the sum of two primes<br>[1].</p>
<p>Now your task is to check whether this conjecture holds for integers up to<br><strong>10 7  </strong> .</p>
<p>Input</p>
<p>Input starts with an integer <strong>T (≤ 300)</strong> , denoting the number of test<br>cases.</p>
<p>Each case starts with a line containing an integer <strong>n (4 ≤ n ≤ 10 7  , n is<br>even) </strong> .</p>
<p>Output</p>
<p>For each case, print the case number and the number of ways you can express<br><strong>n</strong> as sum of two primes. To be more specific, we want to find the number of<br><strong>(a, b)</strong> where</p>
<p>1)      Both <strong>a</strong> and <strong>b</strong> are prime</p>
<p>2) <strong>a + b = n</strong></p>
<p>3) <strong>a ≤ b</strong></p>
<p>Sample Input</p>
<p>2</p>
<p>6</p>
<p>4</p>
<p>Sample Output</p>
<p>Case 1: 1</p>
<p>Case 2: 1</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;
#include &lt;iterator&gt;

using namespace std;

int t;
const int MAXN = 10000010;

bool com[MAXN];
int primes, prime[MAXN/10];//数组不必开的太大

void solve(int n)
{
    primes = 0;
    memset(com,false,sizeof(com));
    com[0] = com[1] = true;
    for (int i = 2; i &lt;= n; ++i)
    {
        if (!com[i])
        {
            prime[++primes] = i;
        }
        for (int j = 1; j &lt;= primes &amp;&amp; i*prime[j] &lt;= n; ++j)
        {
            com[i*prime[j]] = true;
            if (!(i % prime[j]))
                break;
        }
    }
}

int main()
{
    solve(10000000);
    int t, cases = 1, n;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%d&quot;, &amp;n);


        int ans = 0;
        for (int i = 1; prime[i] * 2 &lt;= n; i++)//效率高
        {
            if (!com[n - prime[i]])
                ans++;
        }
        printf(&quot;Case %d: %d\n&quot;, cases++, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>HDU-1421</title>
    <url>/article/csdn/HDU-1421.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40900153" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40900153</a></p>
<p>题目传送门： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1421" target="_blank" rel="noopener"> hdu1421 </a></p>
<p>解题思路：</p>
<p>一道DP题</p>
<p>给定n个物品，每个物品有重量，<br>从中选出m对，使得这m对物品重量差的平方和最小。<br>疲劳度：m对物品重量差的平方和<br>分析与解题思路<br>先对n中物品的重量排序<br>令dp[i][j]表示前i个物品中选j对的最小疲劳度。<br>则dp[i][j]可能含有第i个物品(这种情况下,第i种物品一定是和第i-1个物品配对)，<br>则dp[i][j]=dp[i-2][j-1]+(val[i]-val[i-1])<em>(val[i]-val[i-1])<br>dp[i][j]的j对也可能不含有第i个物品，此时有<br>dp[i][j]=dp[i-1][j]<br>状态转移方程<br>dp[i][j]=min{dp[i-2][j-1]+(val[i]-val[i-1])</em>(val[i]-val[i-1]),dp[i-1][j]</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;malloc.h&gt;
#include&lt;string.h&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;

using namespace std;

int n,k;
long long  dp[2005][1005];
long long  p[2005];

long long  min (long long  a ,long long  b )
{
    return a&lt;b?a:b;
}

int cmp(const void* a,const void* b)  
{  
  return *(int*)a-*(int*)b;  
}  

int main()
{
    while (scanf (&quot;%d%d&quot;,&amp;n,&amp;k) != EOF)
    {
        for (int i =1 ;i&lt;=n;i++)
            scanf (&quot;%I64d&quot;,&amp;p[i]);

        qsort (p+1,n,sizeof (p[0]),cmp);

        for (int i =1 ;i&lt;=n;i++)
            for (int j=1 ;j&lt;=k;j++)
            {
                dp[i][j]=2147483646 ;
            }

        for (int i = 2 ;i&lt;=n;i++ )
        {
            for (int j=1 ;j*2&lt;=i;j++)
            {
                dp[i][j] = min ( dp[i-1][j],dp[i-2][j-1] + (p[i]-p[i-1])*(p[i]-p[i-1]) );
            }

        }
        printf(&quot;%I64d\n&quot;,dp[n][k]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1429</title>
    <url>/article/csdn/HDU_1429.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/42062533" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/42062533</a></p>
<p>终于过了这道题  </p>
<p>做的第一道位压缩</p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1429" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1429
</a>  </p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;malloc.h&gt;

using namespace std;

int n, m, t;

int ans,num;

char s[22];

int sx, sy;

int dir[4][2] = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };//四个方向

int vis[22][22][1025];

struct Q
{
    int x;
    int y;
    char ele;
    int step;
    int nkeys;
}p[22][22];

int check(int x, int y)
{
    if (x&gt;=0 &amp;&amp; x&lt;n &amp;&amp; y&gt;=0 &amp;&amp; y&lt;m)
        return 1;
    else
        return 0;
}

void bfs()
{
    memset(vis,0,sizeof(vis));
    queue &lt;Q&gt; q;
    Q qq, qqq;
    p[sx][sy].step = 0;
    p[sx][sy].nkeys = 0;

    vis[sx][sy][p[sx][sy].nkeys] = 1;

    q.push(p[sx][sy]);

    while (!q.empty())
    {
        qq = q.front();
        q.pop();

        if (p[qq.x][qq.y].ele == &#39;^&#39; &amp;&amp; qq.step &lt; t)
        {
            printf(&quot;%d\n&quot;,qq.step);
            return ;
        }
        else if ( p[qq.x][qq.y].ele == &#39;^&#39; &amp;&amp; qq.step &gt;= t )
        {
            printf(&quot;-1\n&quot;);
            return ;
        }

        for (int i = 0; i &lt; 4;i++)
        {
            int x = qq.x+dir[i][0];
            int y = qq.y+dir[i][1];

            qqq = qq;
            qqq.x = x;
            qqq.y = y;

            if ( check(qqq.x, qqq.y)  &amp;&amp;  p[qqq.x][qqq.y].ele != &#39;*&#39;  &amp;&amp;  !vis[qqq.x][qqq.y][qqq.nkeys])
            {
                if (p[qqq.x][qqq.y].ele &gt;= &#39;a&#39; &amp;&amp; p[qqq.x][qqq.y].ele &lt;= &#39;j&#39; )
                {
                    int key = 1 &lt;&lt; (p[qqq.x][qqq.y].ele - &#39;a&#39;);

                    qqq.nkeys |= key;//拾取钥匙
                    if (!vis[qqq.x][qqq.y][qqq.nkeys])
                    {
                        qqq.step += 1;
                        vis[qqq.x][qqq.y][qqq.nkeys] = 1;
                        q.push(qqq);
                    }
                }
                else if (p[qqq.x][qqq.y].ele &gt;= &#39;A&#39; &amp;&amp; p[qqq.x][qqq.y].ele &lt;= &#39;J&#39; )
                {
                    int key = 1 &lt;&lt; (p[qqq.x][qqq.y].ele - &#39;A&#39;);

                    if ( (qqq.nkeys &amp; key) )//检查手头是否有该门的钥匙
                    {
                        qqq.step += 1;
                        vis[qqq.x][qqq.y][qqq.nkeys] = 1;
                        q.push(qqq);
                    }
                }
                else 
                {
                    qqq.step += 1;
                    vis[qqq.x][qqq.y][qqq.nkeys] = 1;
                        q.push(qqq);
                }
            }
        }
    }
    printf(&quot;-1\n&quot;);
    return;
}

int main()
{
    while (scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;t) != EOF)
    {
        num = 0;
        sx = sy = 0;
        for (int i = 0; i &lt; n; i++)
        {
            scanf(&quot;%s&quot;,s);
            for (int j = 0; j &lt; m; j++)
            {
                p[i][j].ele = s[j];
                p[i][j].step = 0 ;
                p[i][j].nkeys = 0 ;
                p[i][j].x = i;
                p[i][j].y = j;

                if (p[i][j].ele == &#39;@&#39;)
                {
                    sx = i;
                    sy = j;
                }
            }
        }

        bfs();

    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-5112-A Curious Matt （2014ACM ICPC北京赛区现场赛A题！）</title>
    <url>/article/csdn/HDU-5112-A_Curious_Matt_%EF%BC%882014ACM_ICPC%E5%8C%97%E4%BA%AC%E8%B5%9B%E5%8C%BA%E7%8E%B0%E5%9C%BA%E8%B5%9BA%E9%A2%98%EF%BC%81%EF%BC%89.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41685097" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41685097</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5112" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5112
</a></p>
<p>排序之后计算就好 开始用cin超时了</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt;
#include&lt;malloc.h&gt;
#include&lt;stdexcept&gt;

using namespace std;

struct q
{
    int t ;
    int dis;
}p[10005];

int t ;
int n;

bool cmp (q a,q b)
{
    return a.t &lt; b.t;
}

int k=1;

int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%d&quot;,&amp;n);
        for(int i=1;i&lt;=n;i++)
            scanf(&quot;%d %d&quot;,&amp;p[i].t,&amp;p[i].dis);
        sort(p+1,p+1+n,cmp);

        double ans = (p[2].dis - p[1].dis) * 1.0 / ( p[2].t - p[1].t);

        for(int i=3;i&lt;=n;i++)
        {
            ans = max (ans ,double ( abs( (p[i].dis-p[i-1].dis) )*1.0 / (p[i].t - p[i-1].t) ) );
        }
        printf(&quot;Case #%d: %.2lf\n&quot;,k++,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
        <tag>icpc</tag>
      </tags>
  </entry>
  <entry>
    <title>Hopcroft-Carp算法模板【二分图匹配】</title>
    <url>/article/csdn/Hopcroft-Carp%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E3%80%90%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46507499" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46507499</a></p>
<p>模板：//hdu 2063</p>
<p>Hopcroft-Carp 时间复杂度为 O(sqrt(V)<em>E)；<br>而匈牙利算法为 O(V</em>E)；</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

const int N = 1005;
const int INF = 1 &lt;&lt; 28;

int g[N][N];
int Mx[N];
int My[N];
int dx[N];
int dy[N];
bool used[N];

int Nx, Ny, dis;

bool searchP()
{
    dis = INF;
    int i, v, u;
    std::queue&lt;int&gt; Q;

    memset(dx, -1, sizeof(dx));
    memset(dy, -1, sizeof(dy));
    for (i = 0; i&lt;Nx; i++)
    {
        if (Mx[i] == -1)
        {
            Q.push(i);
            dx[i] = 0;
        }
    }
    while (!Q.empty())
    {
        u = Q.front();
        Q.pop();
        if (dx[u]&gt;dis) break;
        for (v = 0; v&lt;Ny; v++)
        {
            if (g[u][v] &amp;&amp; dy[v] == -1)
            {
                dy[v] = dx[u] + 1;
                if (My[v] == -1) dis = dy[v];
                else
                {
                    dx[My[v]] = dy[v] + 1;
                    Q.push(My[v]);
                }
            }
        }
    }
    return dis != INF;
}

bool DFS(int u)
{
    int v;
    for (v = 0; v&lt;Ny; v++)
    {
        if (g[u][v] &amp;&amp; !used[v] &amp;&amp; dy[v] == dx[u] + 1)
        {
            used[v] = true;
            if (My[v] != -1 &amp;&amp; dy[v] == dis) continue;
            if (My[v] == -1 || DFS(My[v]))
            {
                My[v] = u;
                Mx[u] = v;
                return true;
            }
        }
    }
    return false;
}

int Hungary()
{
    int u;
    int ret = 0;
    memset(Mx, -1, sizeof(Mx));
    memset(My, -1, sizeof(My));
    while (searchP())
    {
        memset(used, false, sizeof(used));
        for (u = 0; u&lt;Nx; u++)
            if (Mx[u] == -1 &amp;&amp; DFS(u))  ret++;
    }
    return ret;
}

int main()
{
    int k, u, v;
    while (~scanf(&quot;%d&quot;, &amp;k) ,k)
    {
        scanf(&quot;%d%d&quot;, &amp;Nx, &amp;Ny);
        memset(g, 0, sizeof(g));
        Ny = Nx&gt;Ny ? Nx : Ny;
        while (k--)
        {
            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
            u--; v--;
            g[u][v] = 1;
        }
        int ans = Hungary();
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>HDU 2896 病毒侵袭 【AC自动机】</title>
    <url>/article/csdn/HDU_2896_%E7%97%85%E6%AF%92%E4%BE%B5%E8%A2%AD_%E3%80%90AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46383457" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46383457</a></p>
<p>病毒侵袭<br>Time Limit:1000MS Memory Limit:32768KB 64bit IO Format:%I64d &amp; %I64u</p>
<p>Submit Status<br>Description</p>
<p>当太阳的光辉逐渐被月亮遮蔽，世界失去了光明，大地迎来最黑暗的时刻。。。。在这样的时刻，人们却异常兴奋――我们能在有生之年看到500年一遇的世界奇观，那是多么幸福的事儿啊~~<br>但网路上总有那么些网站，开始借着民众的好奇心，打着介绍日食的旗号，大肆传播病毒。小t不幸成为受害者之一。小t如此生气，他决定要把世界上所有带病毒的网站都找出来。当然，谁都知道这是不可能的。小t却执意要完成这不能的任务，他说：“子子孙孙无穷匮也！”（愚公后继有人了）。<br>万事开头难，小t收集了好多病毒的特征码，又收集了一批诡异网站的源码，他想知道这些网站中哪些是有病毒的，又是带了怎样的病毒呢？顺便还想知道他到底收集了多少带病毒的网站。这时候他却不知道何从下手了。所以想请大家帮帮忙。小t又是个急性子哦，所以解决问题越快越好哦~~<br>Input</p>
<p>第一行，一个整数N（1&lt;=N&lt;=500），表示病毒特征码的个数。<br>接下来N行，每行表示一个病毒特征码，特征码字符串长度在20―200之间。<br>每个病毒都有一个编号，依此为1―N。<br>不同编号的病毒特征码不会相同。<br>在这之后一行，有一个整数M（1&lt;=M&lt;=1000），表示网站数。<br>接下来M行，每行表示一个网站源码，源码字符串长度在7000―10000之间。<br>每个网站都有一个编号，依此为1―M。<br>以上字符串中字符都是ASCII码可见字符（不包括回车）。<br>Output</p>
<p>依次按如下格式输出按网站编号从小到大输出，带病毒的网站编号和包含病毒编号，每行一个含毒网站信息。<br>web 网站编号: 病毒编号 病毒编号 …<br>冒号后有一个空格，病毒编号按从小到大排列，两个病毒编号之间用一个空格隔开，如果一个网站包含病毒，病毒数不会超过3个。<br>最后一行输出统计信息，如下格式<br>total: 带病毒网站数<br>冒号后有一个空格。<br>Sample Input</p>
<p>3 aaa bbb ccc 2 aaabbbccc bbaacc<br>Sample Output</p>
<p>web 1: 1 2 3 total: 1</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;cstdio&gt;  
#include &lt;cstring&gt;  
#include &lt;algorithm&gt;  
#include &lt;string&gt;  
#include &lt;queue&gt;  

using namespace std;

struct Trie
{
    int next[500010][128], fail[500010];
    int end[500010];//Trie树使用

    int root, L;
    int newnode()
    {
        for (int i = 0; i &lt; 128; i++)
            next[L][i] = -1;
        end[L++] = -1;
        return L - 1;
    }
    void init()//初始化
    {
        L = 0;
        root = newnode();
    }
    void insert(char buf[],int id)
    {
        int len = strlen(buf);
        int now = root;
        for (int i = 0; i &lt; len; i++)
        {
            if (next[now][buf[i]] == -1)
                next[now][buf[i]] = newnode();
            now = next[now][buf[i]];
        }
        end[now] = id;//Trie树根节点
    }
    void build()
    {
        queue&lt;int&gt;Q;
        fail[root] = root;
        for (int i = 0; i &lt;128; i++)
            if (next[root][i] == -1)
                next[root][i] = root;
            else
            {
                fail[next[root][i]] = root;
                Q.push(next[root][i]);
            }
        while (!Q.empty())
        {
            int now = Q.front();
            Q.pop();
            for (int i = 0; i &lt; 128; i++)
                if (next[now][i] == -1)
                    next[now][i] = next[fail[now]][i];
                else
                {
                    fail[next[now][i]] = next[fail[now]][i];
                    Q.push(next[now][i]);
                }
        }
    }
    bool used[1010];
    int query(char buf[],int n,int id)
    {
        int len = strlen(buf);
        int now = root;
        memset(used, false, sizeof(used)); 
        int ok = 0;

        for (int i = 0; i &lt; len; i++)
        {
            now = next[now][buf[i]];
            int temp = now;
            while (temp != root)
            {
                if (end[temp] != -1)
                {
                    used[end[temp]] = true;
                    ok = 1;
                }
                temp = fail[temp];
            }
        }
        if (!ok)
            return 0;
        printf(&quot;web %d:&quot;,id);
        for (int i = 1; i &lt;= n; i++)
            if (used[i]) printf(&quot; %d&quot;,i);
        printf(&quot;\n&quot;);
        return 1;
    }

}ac;

char buf[1000010];
int n, m;

int main()
{
    while (scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        ac.init();
        for (int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%s&quot;, buf);
            ac.insert(buf,i);
        }
        ac.build();
        int ans = 0;
        scanf(&quot;%d&quot;,&amp;m);
        for (int i = 1; i &lt;= m; i++)
        {
            scanf(&quot;%s&quot;, buf);
            if (ac.query(buf,n,i))
                ans++;
        }

        printf(&quot;total: %d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>HDU 3790 最短路径问题 【求花费最少的最短路径】</title>
    <url>/article/csdn/HDU_3790_%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98_%E3%80%90%E6%B1%82%E8%8A%B1%E8%B4%B9%E6%9C%80%E5%B0%91%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46383493" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46383493</a></p>
<p>最短路径问题<br>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 15413 Accepted Submission(s): 4658</p>
<p>Problem Description<br>给你n个点，m条无向边，每条边都有长度d和花费p，给你起点s终点t，要求输出起点到终点的最短距离及其花费，如果最短距离有多条路线，则输出花费最少的。</p>
<p>Input<br>输入n,m，点的编号是1~n,然后是m行，每行4个数 a,b,d,p，表示a和b之间有一条边，且其长度为d，花费为p。最后一行是两个数<br>s,t;起点s，终点。n和m为0时输入结束。<br>(1</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;iostream&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;ctype.h&gt;  
#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;stack&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;sstream&gt;  
#include &lt;time.h&gt;  
#include &lt;malloc.h&gt;  

using namespace std;

/*
邻接矩阵的dij求最短路径
源点beg 到其他点最短路径
*/
const int MAXN = 1010;
const int INF = 1e9;

bool vis[MAXN];
int pre[MAXN];

//beg 起点
void dijkstra(int cost[][MAXN], int lowcost[], int n, int beg,int val[][MAXN],int lowval[])
{
    memset(vis,false,sizeof(vis));
    for (int i = 1; i &lt;= n; i++)
    {
        lowcost[i] = cost[beg][i];
        lowval[i] = val[beg][i];
    }
    lowcost[beg] = 0;
    lowval[beg] = 0;
    vis[beg] = true;
    for (int j = 1; j &lt; n; j++)
    {
        int k = -1;
        int MIN = INF;
        for (int i = 1; i &lt;= n; i++)
            if (!vis[i] &amp;&amp; lowcost[i] &lt; MIN)
            {
                MIN = lowcost[i];
                k = i;
            }
        if (k == -1) break;
        vis[k] = true;
        for (int i = 1; i &lt;= n; i++)
        {
            if (!vis[i] &amp;&amp; lowcost[k] + cost[k][i] &lt; lowcost[i])
            {
                lowcost[i] = lowcost[k] + cost[k][i];
                lowval[i] = lowval[k] + val[k][i];
            }
            else if (!vis[i] &amp;&amp; lowcost[k] + cost[k][i] == lowcost[i])
            {
                lowval[i] = min(lowval[i],lowval[k] + val[k][i]);
            }
        }
    }
}

int n, m;
int a, b, c, d;
int s, t;
int p[MAXN][MAXN];
int val[MAXN][MAXN];
int lowcost[MAXN];
int lowval[MAXN];

int main()
{
    while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)
    {
        if (n == 0 &amp;&amp; m == 0)
            break;
        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= n; j++)
            {
                if (i != j)
                {
                    p[i][j] = INF;
                    val[i][j] = INF;
                }
                else
                {
                    p[i][j] = 0;
                    val[i][j] = 0;
                }
            }
        for (int i = 0; i &lt; m; i++)
        {
            scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d);
            {
                if (p[a][b] &gt; c)
                {
                    p[a][b] = p[b][a] = c;
                    val[a][b] = val[b][a] = d;
                }
                else if (p[a][b] == c &amp;&amp; val[a][b] &gt; d)
                    val[a][b] = val[b][a] = d;
            }
        }
        scanf(&quot;%d%d&quot;,&amp;s,&amp;t);
        dijkstra(p,lowcost,n,s,val,lowval);
        printf(&quot;%d %d\n&quot;, lowcost[t],lowval[t]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>INT ,LONG , LONG LONG类型的范围</title>
    <url>/article/csdn/INT_,LONG_,_LONG_LONG%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%8C%83%E5%9B%B4.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46383183" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46383183</a></p>
<p>输出：</p>
<p>unsigned int 0～4294967295 %u</p>
<p>int 2147483648～2147483647 %d</p>
<p>unsigned long 0～4294967295 %lu</p>
<p>long 2147483648～2147483647 %ld</p>
<p>long long的最大值：9223372036854775807 %lld</p>
<p>long long的最小值：-9223372036854775808 ~</p>
<p>unsigned long long的最大值：18446744073709551615 %llu</p>
<p>__int64的最大值：9223372036854775807 ~</p>
<p>__int64的最小值：-9223372036854775808 ~</p>
<p>unsigned __int64的最大值：18446744073709551615 ~</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>long</tag>
        <tag>输出</tag>
        <tag>int</tag>
      </tags>
  </entry>
  <entry>
    <title>IO复用 select Demo</title>
    <url>/article/csdn/IO%E5%A4%8D%E7%94%A8_select_Demo.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44834185" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44834185</a></p>
<p>1 等待键盘输入，输出读入的字节数和读入的内容</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    char buffer[11111];
    int result,nread;
    fd_set inputs, testfds;
    struct timeval timeout;

    FD_ZERO(&amp;inputs);
    FD_SET(0,&amp;inputs);

    while (true)
    {
        testfds = inputs;
        timeout.tv_sec = 2;
        timeout.tv_usec = 5000;

        result = select(FD_SETSIZE,&amp;testfds,(fd_set *)0,(fd_set *)0,&amp;timeout);
        switch(result)
        {
            case 0:
                printf(&quot;timeout\n&quot;);
                break;
            case -1:
                perror(&quot;select&quot;);
                break;
            default:
                if (FD_ISSET(0,&amp;testfds))
                {
                    ioctl(0, FIONREAD, &amp;nread);
                    if (nread == 0)
                    {
                        printf(&quot;done\n&quot;);
                        exit(0);
                    }
                    nread = read(0,buffer,nread);
                    buffer[nread] = 0;
                    printf(&quot;read %d from keyboard: %s\n&quot;,nread,buffer);
                }
                break;
        }
    }

    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Java-单例设计模式（基础）</title>
    <url>/article/csdn/Java-%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/49493577" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/49493577</a></p>
<h3><span id="设计模式">设计模式</span></h3><p>对问题的行之有效的解决方法，其实它是一种思想。不要固化。</p>
<h4><span id="1单例设计模式">1，单例设计模式。</span></h4><pre><code>解决的问题：
保证一个类在内存中的对象唯一性。
</code></pre><p>必须对于多个程序使用同一配置信息对象时，就该保证对象唯一性。<br>如何保证对象唯一性？<br>1），不可以让其他程序用new创建对象。<br>2），在该类中，创建一个本类实例。<br>3），对外提供方法让其他程序获取该对象。<br>步骤：<br>1），私有化该类构造函数。<br>2），通过new在本类中创建一个本类对象。<br>3），定义一个共有方法，将创建的对象返回。</p>
<p>代码例子：</p>
<pre><code>class Single
{
    private static Single s = new Single();

    private Single (){}

    public static Single get()
    {
        return s;
    }
}

public class mfcheer 
{   
    public static void main(String[] args) 
    {
        Single s1 = Single.get();//可控
        Single s2 = Single.get();
        System.out.println(s1==s2);//返回true
        // Single sss = Single.s; 不可控
    }
}


//类加载时，无对象，get方法调用时才创建对象
//延迟加载形式
//懒汉式 ： 用到时才创建对象
//存在的问题：多线程时可能存在安全隐患

class Single
{
    private static Single s = null;

    private Single (){}

    public static Single get()
    {
        if (s == null)
            s = new Single();
        return s;
    }
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Java-高精度</title>
    <url>/article/csdn/Java-%E9%AB%98%E7%B2%BE%E5%BA%A6.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/50512377" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/50512377</a></p>
<p>1002<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1002" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1002
</a></p>
<pre><code>import java.io.*;
import java.util.Scanner;
import java.math.BigInteger;

public class Main
{    
    public static void main(String[] args) 
    {
         Scanner cin = new Scanner(System.in);
         while (cin.hasNextInt())
         {
             BigInteger a,b,c;
             int t;
             t = cin.nextInt();
             for(int i=1;i&lt;=t;i++)
             {
                 a = cin.nextBigInteger();
                 b = cin.nextBigInteger();
                 c = a.add(b);
                 System.out.println(&quot;Case &quot;+ i +&quot;:&quot;);
                 System.out.println(a+&quot; + &quot;+b+&quot; = &quot;+c);
                 if(i&lt;t) System.out.println(&quot;&quot;);
             }
         }
    }
}
</code></pre><p>1042<br><a href="http://acm.hdu.edu.cn/submit.php?pid=1042" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/submit.php?pid=1042
</a></p>
<pre><code>import java.io.*;
import java.util.Scanner;
import java.math.BigInteger;

public class Main
{   
    public static void main(String[] args) 
    {
         Scanner cin = new Scanner(System.in);
         while (cin.hasNextInt())
         {
            int t;
            t = cin.nextInt();
            BigInteger sum = BigInteger.ONE;
            for(int i=1;i&lt;=t;i++)
                sum = sum.multiply(BigInteger.valueOf(i));
            System.out.println(sum);
         }
    }
}
</code></pre><p>1047<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1047" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1047
</a></p>
<pre><code>import java.io.*;
import java.util.Scanner;
import java.math.BigInteger;

public class Main
{    
    public static void main(String[] args) 
    {
         Scanner cin = new Scanner(System.in);
         while (cin.hasNextInt())
         {
            int t;
            BigInteger sum,tmp;
            t = cin.nextInt();
            for(int i=1;i&lt;=t;i++)
            {
                sum = BigInteger.ZERO;
                boolean ok = true;
                while (ok)
                {
                    tmp = cin.nextBigInteger();
                    if (tmp.compareTo(BigInteger.ZERO) == 0)
                        ok= false;
                    sum = sum.add(tmp);
                }
                System.out.println(sum.toString());
                if (i &lt; t) System.out.println(&quot;&quot;);
            }
         }
    }
}
</code></pre><p>1063<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1063" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1063
</a></p>
<pre><code>import java.io.*;
import java.util.Scanner;
import java.math.BigInteger;
import java.math.BigDecimal;  

public class Main
{    
    public static void main(String[] args) 
    {
         Scanner cin = new Scanner(System.in);
         while (cin.hasNextBigDecimal())
         {
            BigDecimal r, ans;
            int n;
            r = cin.nextBigDecimal();
            n = cin.nextInt();

            ans = BigDecimal.ONE;
            for(int i=1;i&lt;=n;i++)
            {
                ans = ans.multiply(r);
            }
            ans = ans.stripTrailingZeros();
            String str = ans.toPlainString();
            if (str.startsWith(&quot;0.&quot;))
                str = str.substring(1);
            System.out.println(str);
         }
    }
}
</code></pre><p>1316<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1316" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1316
</a></p>
<pre><code>import java.io.*;
import java.util.Scanner;
import java.math.BigInteger;
import java.math.BigDecimal;  

public class Main
{   
    public static void main(String[] args) 
    {
         Scanner cin = new Scanner(System.in);

         BigInteger f[] = new BigInteger [505];
         f[1] = new BigInteger(&quot;1&quot;);
         f[2] = new BigInteger(&quot;2&quot;);
         for(int i=3;i&lt;=500;i++)
             f[i] = f[i-1].add(f[i-2]);

         while (cin.hasNextBigInteger())
         {
            BigInteger a, b;
            a = cin.nextBigInteger();
            b = cin.nextBigInteger();

            if (a.compareTo(BigInteger.ZERO) == 0 &amp;&amp; b.compareTo(BigInteger.ZERO) == 0)
                break;

            int ans = 0;
            for(int i=1;i&lt;=500;i++)
            {
                if (a.compareTo(f[i]) &lt;= 0 &amp;&amp; b.compareTo(f[i]) &gt;= 0)
                    ans++;
                if(b.compareTo(f[i]) &lt; 0) 
                    break;
            }
            System.out.println(ans);
         }
    }
}
</code></pre><p>1715<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1715" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1715
</a></p>
<pre><code>import java.io.*;
import java.util.Scanner;
import java.math.BigInteger;
import java.math.BigDecimal;  

public class Main
{    
    public static void main(String[] args) 
    {
         Scanner cin = new Scanner(System.in);

         BigInteger f[] = new BigInteger [10010];
         f[1] = new BigInteger(&quot;1&quot;);
         f[2] = new BigInteger(&quot;1&quot;);

         for(int i=3;i&lt;=1005;i++)
             f[i] = f[i-1].add(f[i-2]);

         while (cin.hasNextInt())
         {
            int t,id;
            t = cin.nextInt();
            for(int i=1;i&lt;=t;i++)
            {
                id = cin.nextInt();
                System.out.println(f[id]);
            }
         }
    }
}
</code></pre><p>1753<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1753" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1753
</a></p>
<pre><code>import java.io.*;
import java.util.Scanner;
import java.math.BigInteger;
import java.math.BigDecimal;  

public class Main
{   
    public static void main(String[] args) 
    {
         Scanner cin = new Scanner(System.in);

         BigDecimal a,b,c;

         while (cin.hasNextBigDecimal())
         {
            a = cin.nextBigDecimal();
            b = cin.nextBigDecimal();

            c = a.add(b);
            c = c.stripTrailingZeros();
            String str = c.toPlainString();
               if (str.startsWith(&quot;0.&quot;))
                   str = str.substring(1);
            System.out.println(str);
         }
    }
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Java - 继承（基础）</title>
    <url>/article/csdn/Java_-_%E7%BB%A7%E6%89%BF%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/49474241" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/49474241</a></p>
<h3><span id="继承">继承：</span></h3><p>增强代码复用性，使类和类之间产生关系，为多肽提供前提。<br>extends 关键字<br>使用类的继承时，查看体系顶层类，了解功能，创建子类对象完善功能的使用。</p>
<h4><span id="什么时候用继承">什么时候用继承？</span></h4><p>类与类之间存在所属关系，定义继承。比如xx（狗）是yy（犬科动物）的一种。</p>
<h4><span id="java支持单继承对c多继承进行改良支持多重继承">java支持单继承，对c++多继承进行改良，支持多重继承。</span></h4><p>单继承 ：一个子类只能有一个父类。</p>
<pre><code>class C extends A
{

}
</code></pre><p>多继承 ：一个子类可以有多个父类。(java不允许，进行改良)<br>不直接支持愿意，会产生调用不确定性。</p>
<p>多重继承：比如B继承C，A继承B。</p>
<h4><span id="子父类变量间的关系">子父类变量间的关系</span></h4><p>成员特点体现：<br>1 , 成员变量<br>若变量同名，则优先调用子类中变量。<br>同名时，用super区分父类。<br>和this用法相似。<br>this：代表本类对象引用<br>super：代表父类空间<br>子类不能直接访问父类私有变量内容。</p>
<p>2，成员函数<br>若函数同名，则优先调用子类中函数。这种现象称为覆盖操作。<br>函数两个特性：<br>1） 重载：同一类中<br>2） 覆盖：子类中<br>覆盖注意事项：<br>1），覆盖时，子类权限必须大于等于父类权限才可以引发覆盖。<br>public &gt;无&gt; private<br>2），static方法只能被static覆盖。</p>
<p>3，构造函数<br>子类构造对象时，访问子类构造函数时，父类也运行了。<br>子类构造函数第一行有隐式语句，super()，调用父类的（空参数）构造函数。<br>子类所以构造函数都会调用父类的空参数构造函数。<br><img src="https://img-blog.csdn.net/20151029170805357" alt="这里写图片描述"><br>小例子：</p>
<pre><code>package if_i_can_do;
import java.util.*;

class Person
{
    String name;
    int age;
    int num = 5;
    private int money = 1000000;
    void speak0()
    {
        System.out.println(&quot;peo!&quot;);
    }
}

class Student extends Person
{
    private int num = 4;
    Student(){}
    void speak()
    {
        System.out.println(&quot;stu!&quot;);
        System.out.println(num + &quot;   &quot; + num);//若变量同名，则优先调用子类中变量。
        System.out.println(this.num + &quot;   &quot; + super.num);//同名时，用super区分父类。
        //System.out.println(super.money); error:子类不能直接访问父类私有变量内容。
    }
}

class Worker extends Person
{
    Worker(){}
    void speak0()
    {
        System.out.println(&quot;66666!&quot;);
    }
    void speak()
    {
        System.out.println(&quot;work!&quot;);
    }
}


public class mfcheer 
{
     public static void main(String[] args) 
     {
         Student s1 = new Student();
         s1.speak0();
         s1.speak();

         Worker w1 = new Worker();
         w1.speak0();
         w1.speak();
     }  

}
</code></pre><p>运行结果：</p>
<p><img src="https://img-blog.csdn.net/20151028210126027" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>继承</tag>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title>Java编程思想 - 第6章、访问权限控制</title>
    <url>/article/csdn/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3_-_%E7%AC%AC6%E7%AB%A0%E3%80%81%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/49488911" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/49488911</a></p>
<h3><span id="本章主要知识点是访问权限">本章主要知识点是访问权限:</span></h3><p>public &gt; protected &gt; (无关键词) &gt; private</p>
<p>1，</p>
<h4><span id="杂碎的知识点">杂碎的知识点：</span></h4><p>包内含有一组类，它们在单一的名字空间下被组织到了一起。<br>import关键字用于导入类。<br>例子：</p>
<pre><code>import java.util.ArrayList;

public class mfcheer 
{
     public static void main(String[] args) 
     {
         ArrayList list = new java.util.ArrayList();
     }
}
</code></pre><p>导入所有类只需使用 <code>import java.util.*;</code></p>
<p>代码组织：<br>关键字 package 在文件起始位置处，这样写</p>
<pre><code>package access；
</code></pre><p>表示你在声明该编译单元是名为access的类库的一部分。</p>
<p>Java解释器运行过程：<br>首先找出环境变量CLASSPATH，CLASSPATH包含一个或多个目录，用于查找.class文件根目录。从根目录开始产生一个路径名称，得到的路径与CLASSPATH各个不同项目链接，解释器就会在目录中查找与你所创建的类名称相关的.class文件。</p>
<p>2，</p>
<h4><span id="java访问权限修饰词">Java访问权限修饰词：</span></h4><pre><code>    public：import之后包内包外可以使用
    protected：继承访问权限，只有子类可以访问。同时，protected也提供包访问权限
    包访问权限：（类前面没有权限修饰符）一个包的代码可以访问本包内所有代码，但是本包对外界成员是透明的、不可见的
    private：除本类外包内包外均无法访问
</code></pre><p>封装的原因：<br>1），设定客户端程序员可以使用和不适用的界限，建立内部机制。<br>2），将接口和具体实现分离。便于重构。</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LA 3126 - Taxi Cab Scheme【DAG最小路径覆盖】</title>
    <url>/article/csdn/LA_3126_-_Taxi_Cab_Scheme%E3%80%90DAG%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48296579" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48296579</a></p>
<h4><span id="题目链接">题目链接： [</span></h4><p><a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1127" target="_blank" rel="noopener">https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1127</a><br>](<a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1127" target="_blank" rel="noopener">https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1127</a>)</p>
<p>DAG最小路径覆盖 = 点数 - 最大匹配数。</p>
<p>代码:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int n;
int p[510][510];
int book[510];
int match[510];
bool vis[510];

bool dfs(int u)
{
    for (int i = 1; i &lt;= n; i++)
    {
        if (book[i] == 0 &amp;&amp; p[u][i] == 1)
        {
            book[i] = 1;
            if (match[i] == 0 || dfs(match[i]))
            {
                match[i] = u;
                return true;
            }
        }
    }
    return false;
}

struct node
{
    int x1, y1, x2, y2;
    int st, ed;
}taxi[510];

int get_dis(node a, node b)
{
    return abs(a.x2 - b.x1) + abs(a.y2 - b.y1);
}

int main()
{
    int t;
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    {
        memset(p, 0, sizeof(p));
        memset(match, 0, sizeof(match));
        memset(vis, false, sizeof(vis));

        scanf(&quot;%d&quot;, &amp;n);
        int a, b, c, d, e, f;
        char s[10];
        for (int i = 1;i &lt;= n;i++)
        {
            scanf(&quot;%s %d %d %d %d&quot;, s, &amp;c, &amp;d, &amp;e, &amp;f);
            a = (s[0] - &#39;0&#39;) * 10 + (s[1] - &#39;0&#39;);
            b = (s[3] - &#39;0&#39;) * 10 + (s[4] - &#39;0&#39;);
        //  printf(&quot;        %d %d %d %d %d %d\n&quot;, a, b, c, d, e, f);
            taxi[i].st = a * 60 + b;
            taxi[i].ed = taxi[i].st + abs(c - e) + abs(d - f);
            taxi[i].x1 = c;
            taxi[i].y1 = d;
            taxi[i].x2 = e;
            taxi[i].y2 = f;
        }

        for (int i = 1;i &lt;= n;i++)
            for (int j = 1;j &lt;= n;j++)
            {
                if (taxi[i].ed + get_dis(taxi[i],taxi[j]) &lt; taxi[j].st)
                    p[i][j] = 1;
            }
        int ans = 0;
        for (int i = 1; i &lt;= n; i++)
        {
            memset(book, 0, sizeof(book));
            if (dfs(i))
                ans++;
        }
        printf(&quot;%d\n&quot;, n - ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Java编程思想 - 第7章、复用类</title>
    <url>/article/csdn/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3_-_%E7%AC%AC7%E7%AB%A0%E3%80%81%E5%A4%8D%E7%94%A8%E7%B1%BB.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/49490127" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/49490127</a></p>
<h3><span id="代码的复用">代码的复用</span></h3><pre><code>has a: 组合
is a: 继承
中庸之道:代理
</code></pre><h4><span id="1组合继承代理">1，组合，继承，代理</span></h4><p>为了继承，一般的规则是将所有的数据成员都设置为private，而将所有的方法都设置为public。这样，当不同的包下的类继承该类时，就可以获得该类所有的方法，和包内、包外没有区别。如果不加修饰符，就是限制包内访问，那么包外继承的时候，只能获得public修饰的方法，这样内外的方法不一致，就会出现问题了。当然，特殊情况需要特殊考虑。</p>
<p>try和finally语句：<br>关键字try表示，下面的块，是所谓的保护区，意味着总要被特殊处理。其中一项特殊处理就是try块无论如何退出，保护区后的finally子句中的代码都会执行。</p>
<pre><code>try{
 }
finally {
}
</code></pre><p>protected关键字：<br>对于类用户而而言，protected是privated的，而对于其导出类或同一个包中的类来说是有访问权限的。</p>
<p>向上转型：<br>“新类是现有类的一种类型”<br>由导出类转换为基类，是安全的。</p>
<h4><span id="2final-关键字">2，final 关键字</span></h4><p>表示这是无法改变的。<br>用处：<br>1），永不改变的编译时变量<br>2），运行时初始化的值，不希望它被改变。<br>对final变量定义时，必须对其赋值。<br>一个既是static又是final的域只占一段不能改变的存储空间，惯例用大写字母加下划线分隔单词。</p>
<p>空白final：可以通过在定义处或者在构造函数中初始化，而在构造函数中初始化可以使不同对象的对象拥有不同的值（比如身份证号，唯一且不能改变）。这样就保证final数据在使用前被初始化且无法改变的特征。</p>
<p>final参数：java可在参数列表中以声明的方式将参数指明为final，意味着你无法在方法中更改参数引用所指的对象。</p>
<p>final类：表明了你不打算继承该类，而且也不允许别人这样做。你对该类的设计并不需要改变，或者是处于安全的考虑，你不希望它有子类。</p>
<p>使用final原因：<br>1），将方法锁定。<br>2），效率。</p>
<p>类中的private方法都隐式的指定为final。</p>
<h4><span id="3初始化">3，初始化</span></h4><pre><code>    在执行xx.main的时候，因为main是static方法，就触发了该类的加载（因为Java采用了动态加载技术，只有使用的时候才会被加载）。于是Java解释器调用类加载器在CLASSPATH中找xx.class，如果xx继承自aa，那么编译器注意到xx有一个基类aa（通过extends得到），就开始加载基类，不管你是否打算产生一个该基类的对象（因为需要将该类加载进内存，有其子必有其父是也）。如果该基类继承自其它类，就会以此类推。
    根基类中的static初始化会被执行，然后是第二个基类，以此类推（如果没有调用new，到这里就结束了）
    如果使用new创建对象，就会在堆上为该对象分配足够的存储空间
    存储空间先清空，然后进行默认初始化，基本类型给默认值，引用类型给null。其实这一块是通过将对象内存设为二进制零值一举生成的，说成两个过程是便于理解，本质是分配内存的同时进行设置默认值
    从根基类开始，执行每个类定义处的域初始化
    从根基类的构造器开始执行，一直到底
</code></pre><h3><span id="总结">总结：</span></h3><p>组合和继承相比，更加灵活。优先选择组合，而非继承，除非必要。</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LA 3231 Fair Share 【二分+最大流】</title>
    <url>/article/csdn/LA_3231_Fair_Share_%E3%80%90%E4%BA%8C%E5%88%86+%E6%9C%80%E5%A4%A7%E6%B5%81%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48271969" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48271969</a></p>
<h4><span id="题目链接">题目链接： [</span></h4><p><a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1232" target="_blank" rel="noopener">https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1232</a><br>](<a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1232" target="_blank" rel="noopener">https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1232</a>)</p>
<p>题意：最小化网络流边中流量的最大值。二分流量求值</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;sstream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;string&gt;

using namespace std;

const int MAXN = 101000;//点数的最大值
const int MAXM = 400100;//边数的最大值
const int INF = 0x3f3f3f3f;

struct Edge
{
    int to, next, cap, flow;
}edge[MAXM];//注意是MAXM

int tol;
int head[MAXN];
int gap[MAXN], dep[MAXN], pre[MAXN], cur[MAXN];

void init()
{
    tol = 0;
    memset(head, -1, sizeof(head));
}
//加边，单向图三个参数，双向图四个参数
void addedge(int u, int v, int w, int rw = 0)
{
    edge[tol].to = v; edge[tol].cap = w; edge[tol].next = head[u];
    edge[tol].flow = 0; head[u] = tol++;
    edge[tol].to = u; edge[tol].cap = rw; edge[tol].next = head[v];
    edge[tol].flow = 0; head[v] = tol++;
}
//输入参数：起点、终点、点的总数
//点的编号没有影响，只要输入点的总数

int Q[MAXN];

void BFS(int start,int end)
{
    memset(dep, -1, sizeof(dep));
    memset(gap, 0, sizeof(gap));
    gap[0] = 1;
    int front = 0, rear = 0;
    dep[end] = 0;
    Q[rear++] = end;
    while (front != rear)
    {
        int u = Q[front++];
        for (int i = head[u];i != -1;i = edge[i].next)
        {
            int v = edge[i].to;
            if (dep[v] != -1) continue;
            Q[rear++] = v;
            dep[v] = dep[u] + 1;
            gap[dep[v]]++;
        }
    }
}
int S[MAXN];
int sap(int start, int end, int N)
{
    BFS(start, end);
    memcpy(cur, head, sizeof(head));
    int u = start;
    int top = 0;
    int ans = 0;
    while (dep[start] &lt; N)
    {
        if (u == end)
        {
            int Min = INF;
            int inser;
            for (int i = 0; i &lt; top; i++)
                if (Min &gt; edge[S[i]].cap - edge[S[i]].flow)
                {
                    Min = edge[S[i]].cap - edge[S[i]].flow;
                    inser = i;
                }
            for (int i = 0; i &lt; top; i++)
            {
                edge[S[i]].flow += Min;
                edge[S[i] ^ 1].flow -= Min;
            }
            ans += Min;
            top = inser;
            u = edge[S[top] ^ 1].to;
            continue;
        }
        bool flag = false;
        int v;
        for (int i = cur[u]; i != -1; i = edge[i].next)
        {
            v = edge[i].to;
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[v] + 1 == dep[u])
            {
                flag = true;
                cur[u]  = i;
                break;
            }
        }
        if (flag)
        {
            S[top++] = cur[u];
            u = v;
            continue;
        }
        int Min = N;
        for (int i = head[u]; i != -1; i = edge[i].next)
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min)
            {
                Min = dep[edge[i].to];
                cur[u] = i;
            }
        gap[dep[u]]--;
        if (!gap[dep[u]])return ans;
        dep[u] = Min + 1;
        gap[dep[u]]++;
        if (u != start) u = edge[S[--top]^1].to;
    }
    return ans;
}

int n, m;

struct node
{
    int x, y;
}a[MAXM];

int main()
{
    int T;
    scanf(&quot;%d&quot;,&amp;T);
    while (T--)
    {
        scanf(&quot;%d%d&quot;, &amp;m, &amp;n);
        for (int i = 1;i &lt;= n;i++) scanf(&quot;%d%d&quot;, &amp;a[i].x, &amp;a[i].y);

        int ans = 1e9;
        int left = 1, right = n;

        while (left &lt;= right)
        {
            int mid = (left + right) / 2;
            init();

            for (int i = 1;i &lt;= n;i++)
            {
                addedge(0, i, 1);
                addedge(i, a[i].x + n, 1);
                addedge(i, a[i].y + n, 1);
            }
            for (int i = 1;i &lt;= m;i++)
            {
                addedge(i + n, n + m + 1, mid);
            }
            int tmp = sap(0, n + m + 1, n + m + 2);
            if (tmp == n)
            {
                ans = min(ans, mid);
                right = mid - 1;
            }
            else left = mid + 1;
        }
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Jzzhu and Sequences 【矩阵快速幂】</title>
    <url>/article/csdn/Jzzhu_and_Sequences_%E3%80%90%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44562509" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44562509</a></p>
<p>Jzzhu and Sequences<br>Time Limit:1000MS Memory Limit:262144KB 64bit IO Format:%I64d &amp; %I64u<br>Submit</p>
<p>Status<br>Description<br>Jzzhu has invented a kind of sequences, they meet the following property:</p>
<p><img src="https://img-blog.csdn.net/20150323164556402" alt="这里写图片描述"><br>You are given x and y, please calculate fn modulo 1000000007(109 + 7).</p>
<p>Input<br>The first line contains two integers x and y(|x|, |y| ≤ 109). The second line<br>contains a single integer n(1 ≤ n ≤ 2·109).</p>
<p>Output<br>Output a single integer representing fn modulo 1000000007(109 + 7).</p>
<p>Sample Input<br>Input<br>2 3<br>3<br>Output<br>1<br>Input<br>0 -1<br>2<br>Output<br>1000000006<br>Hint<br>In the first sample, f2 = f1 + f3, 3 = 2 + f3, f3 = 1.</p>
<p>In the second sample, f2 =  - 1;  - 1 modulo (109 + 7) equals (109 + 6).</p>
<p>构造矩阵 <img src="https://img-blog.csdn.net/20150323121929167" alt="这里写图片描述"> 之后套模板即可；</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;

using namespace std;

const long long MOD = 1000000007;

struct node
{
    long long m[2][2];
}ans,base;
long long a,b;
int n;

node multi(node a,node b)
{
    node tmp;
    for(int i=0;i&lt;2;i++)
        for(int j=0;j&lt;2;j++)
    {
        tmp.m[i][j] = 0;
        for(int k=0;k&lt;2;k++)
        {
            tmp.m[i][j] = ((tmp.m[i][j] + a.m[i][k] * b.m[k][j]) % MOD + MOD)%MOD;
        }
    }
    return tmp;
}

void fast_mod(int n)// 求矩阵 base 的  n 次幂
{
    base.m[0][0] = 0;base.m[0][1] = 1;
    base.m[1][0] = -1;base.m[1][1] = 1;
    ans.m[0][0] = ans.m[1][1] = 1;// ans 初始化为单位矩阵
    ans.m[0][1] = ans.m[1][0] = 0;
    while (n)
    {
        if (n&amp;1) //实现 ans *= t; 其中要先把 ans赋值给 tmp，然后用 ans = tmp * t
            ans = multi(ans,base);
        base = multi(base,base);
        n&gt;&gt;=1;
    }
}

int main()
{
    while (scanf(&quot;%lld %lld %d&quot;,&amp;a,&amp;b,&amp;n)!=EOF)
    {
        if (n==1)
        {
            printf(&quot;%lld\n&quot;,(a%MOD + MOD)%MOD);
            continue;
        }
        if (n==2)
        {
            printf(&quot;%lld\n&quot;,(b%MOD + MOD)%MOD);
            continue;
        }
        fast_mod(n-2);
        long long anss = (((ans.m[1][0]*a+ans.m[1][1]*b) % MOD) + MOD) % MOD;
        printf(&quot;%lld\n&quot;,anss);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>K-means聚类算法</title>
    <url>/article/csdn/K-means%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/50958963" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/50958963</a></p>
<p>K-means算法是一种无监督的机器学习算法。无监督学习即事先不知道要寻找的内容。全自动分类，将相似对象归到同一个簇中。用户预先给的K个簇，每个簇通过“质心”来描述。</p>
<p>伪代码：</p>
<pre><code>创建K个点作为起始质心（一般随机选择）
任意一个点所属簇的结果发生改变时
    对数据集中每个点
        对每个质心
            计算数据与质心间的距离
        将数据划分到与它最近的簇
    对于每个簇，重新计算质心（所有点的均值）
</code></pre><p>求距离的方法，欧氏距离。</p>
<p>聚类效果的度量。一般计算SEE（误差平方和），SEE越小表示数据点越接近他们的质心。</p>
<p>一般误差原因：k的选取。</p>
<p>改进: 二分 K-均值算法<br>首先将所有点作为一个簇，然后将该簇一分为二。之后选择一个簇继续划分，选择哪个取决于是否可以最大程度降低SEE的值。直到取得合适的K值为止。</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>LA 3415 - Guardian of Decency【最大独立集】</title>
    <url>/article/csdn/LA_3415_-_Guardian_of_Decency%E3%80%90%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48297763" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48297763</a></p>
<h4><span id="题目">题目： [</span></h4><p><a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1416" target="_blank" rel="noopener">https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1416</a><br>](<a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1416" target="_blank" rel="noopener">https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1416</a>)</p>
<p>最大独立集 = 点数 - 最大匹配数</p>
<p>解法：按男女分类，不满足4条任何条件的建边，求最大匹配。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int n, n1, n2;
int p[510][510];
int book[510];
int match[510];
bool vis[510];

bool dfs(int u)
{
    for (int i = 1; i &lt;= n2; i++)
    {
        if (book[i] == 0 &amp;&amp; p[u][i] == 1)
        {
            book[i] = 1;
            if (match[i] == 0 || dfs(match[i]))
            {
                match[i] = u;
                return true;
            }
        }
    }
    return false;
}

struct node
{
    char music[110];
    char sports[110];
    char sex[10];
    int high;
}stu[510],boy[510], girl[510];

int main()
{
    int t;
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    {
        memset(p, 0, sizeof(p));
        memset(match, 0, sizeof(match));
        memset(vis, false, sizeof(vis));
        n1 = 0, n2 = 0;

        scanf(&quot;%d&quot;, &amp;n);
        for (int i = 1;i &lt;= n;i++)
        {
            scanf(&quot;%d%s%s%s&quot;, &amp;stu[i].high, stu[i].sex, stu[i].music, stu[i].sports);
            if (stu[i].sex[0] == &#39;M&#39;)
            {
                n1++;
                boy[n1].high = stu[i].high;
                strcpy(boy[n1].music,stu[i].music);
                strcpy(boy[n1].sports, stu[i].sports);
            }
            else
            {
                n2++;
                girl[n2].high = stu[i].high;
                strcpy(girl[n2].music, stu[i].music);
                strcpy(girl[n2].sports, stu[i].sports);
            }

        }

        for (int i = 1;i &lt;= n1;i++)
        {
            for (int j = 1;j &lt;= n2;j++)
            {
                if (!(abs(boy[i].high - girl[j].high) &gt; 40 || strcmp(boy[i].sports, girl[j].sports) == 0 || strcmp(boy[i].music, girl[j].music) != 0))
                    p[i][j] = 1;
            }
        }

        int ans = 0;
        for (int i = 1; i &lt;= n1; i++)
        {
            memset(book, 0, sizeof(book));
            if (dfs(i))
                ans++;
        }
        printf(&quot;%d\n&quot;, n - ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LIGHTOJ 1002 – COUNTRY ROADS 【求最大边最小的路径】</title>
    <url>/article/csdn/LIGHTOJ_1002_%E2%80%93_COUNTRY_ROADS_%E3%80%90%E6%B1%82%E6%9C%80%E5%A4%A7%E8%BE%B9%E6%9C%80%E5%B0%8F%E7%9A%84%E8%B7%AF%E5%BE%84%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46383209" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46383209</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1002" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1002
</a></p>
<p>dij简单变形；</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;     
#include&lt;iostream&gt;     
#include&lt;math.h&gt;     
#include&lt;stdlib.h&gt;     
#include&lt;ctype.h&gt;     
#include&lt;algorithm&gt;     
#include&lt;vector&gt;     
#include&lt;string.h&gt;     
#include&lt;stack&gt;     
#include&lt;set&gt;        
#include&lt;sstream&gt;     
#include&lt;time.h&gt;     
#include&lt;utility&gt;     
#include&lt;malloc.h&gt;     
#include&lt;stdexcept&gt;     
#include&lt;iomanip&gt;     
#include&lt;iterator&gt;     

using namespace std;

int t, cases = 1;
int n, m, f;

const int MAXN = 510;
const int INF = 10000000;
int map[MAXN][MAXN];
int a, b, c;
bool vis[MAXN];
int lowcost[MAXN];

void dijkstra(int cost[][MAXN], int lowcost[], int n, int beg)
{
    for (int i = 0; i &lt; n; i++)
    {
        vis[i] = false;
        lowcost[i] = cost[beg][i];
    }
    lowcost[beg] = 0;
    vis[beg] = true;
    for (int j = 0; j &lt; n; j++)
    {
        int k = -1;
        int MIN = INF;
        for (int i = 0; i &lt; n; i++)
            if (!vis[i] &amp;&amp; lowcost[i] &lt; MIN)
            {
                MIN = lowcost[i];
                k = i;
            }
        if (k == -1) break;
        vis[k] = true;

        for (int i = 0; i &lt; n; i++)
        {
            if (!vis[i] &amp;&amp; max(lowcost[k] , cost[k][i]) &lt; lowcost[i])
            {
                lowcost[i] = max(lowcost[k], cost[k][i]);

            }
        }
    }
}

int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
        for (int i = 0; i &lt;= n; i++)
            for (int j = 0; j &lt;= n; j++)
            {
                if (i == j)
                    map[i][i] = 0;
                else
                    map[i][j] = map[j][i] = INF;
            }
        for (int i = 1; i &lt;= m; i++)
        {
            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
            if (map[a][b] &gt; c)
            map[a][b] = map[b][a] = c;
        }
        scanf(&quot;%d&quot;,&amp;f);
        dijkstra(map, lowcost, n, f);
        /*for (int k = 0; k &lt; n; k++)
            for (int i = 0; i &lt; n; i++)
                for (int j = 0; j &lt; n; j++)
                {
                    if (max(map[i][k], map[k][j]) &lt; map[i][j])
                        map[i][j] = max(map[i][k], map[k][j]);
                }
        */
        printf(&quot;Case %d:\n&quot;,cases++);
        for (int i = 0; i &lt; n; i++)
        {
            if (lowcost[i] != INF)
                printf(&quot;%d\n&quot;, lowcost[i]);
            else
                puts(&quot;Impossible&quot;);
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LA 3708 GRAVEYARD</title>
    <url>/article/csdn/LA_3708_GRAVEYARD.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46383433" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46383433</a></p>
<p>题意：</p>
<p>在一个具有n个等距建筑的圆形中插入m个，使得保持等距，求最短移动距离；</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;cstdio&gt;  
#include &lt;cstring&gt;  
#include &lt;algorithm&gt;  
#include &lt;string&gt;  
#include &lt;queue&gt;  

using namespace std;

int n, m;
double tol = 10000;

int main()
{
    while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)
    {
        double ans = 0;
        for (int i = 1; i &lt; n; i++)
        {
            double pos = (double)i / n*(n + m);
            ans += fabs(pos- floor(pos+0.5) )/ (n + m);
        }
        printf(&quot;%.4lf\n&quot;,ans*tol);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LIGHTOJ 1005 – ROOKS</title>
    <url>/article/csdn/LIGHTOJ_1005_%E2%80%93_ROOKS.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46383215" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46383215</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1005" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1005
</a></p>
<p>代码：</p>
<pre><code>//先在n行中选出k行，C(n,k)，再在n列中选出k列随便放A(n,k)，答案为C(n,k)*A(n,k)
#include&lt;stdio.h&gt;     
#include&lt;iostream&gt;     
#include&lt;math.h&gt;     
#include&lt;stdlib.h&gt;     
#include&lt;ctype.h&gt;     
#include&lt;algorithm&gt;     
#include&lt;vector&gt;     
#include&lt;string.h&gt;     
#include&lt;stack&gt;     
#include&lt;set&gt;     
#include&lt;map&gt;     
#include&lt;sstream&gt;     
#include&lt;time.h&gt;     
#include&lt;utility&gt;     
#include&lt;malloc.h&gt;     
#include&lt;stdexcept&gt;     
#include&lt;iomanip&gt;     
#include&lt;iterator&gt;     

using namespace std;

int t;
int n, k;

long long a[35][35], c[35][35];

void solve()
{
    for (int i = 1; i &lt;= 30; i++)
    {
        c[i][0] = c[i][i] = 1;
        for (int j = 1; j &lt; i; j++)
        {
            c[i][j] = c[i - 1][j - 1] + c[i - 1][j];
        }
    }
    for (int i = 0; i &lt;= 30; i++)
    {
        a[i][0] = 1;
        a[i][1] = i;
        for (int j = 2; j &lt;= i; j++)
            a[i][j] = a[i][j - 1] * (long long)(i - j + 1);
    }
}

int main()
{
    int cases = 1; 
    scanf(&quot;%d&quot;,&amp;t);
    solve();
    while (t--)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
        printf(&quot;Case %d: &quot;, cases++);
        long long ans = 0 ;
        if (k &gt; n)  { printf(&quot;0\n&quot;); continue; }
        ans = a[n][k] * c[n][k];
        printf(&quot;%lld\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LA 3989 - Ladies&#39; Choice【稳定婚姻问题】</title>
    <url>/article/csdn/LA_3989_-_Ladies&#39;_Choice%E3%80%90%E7%A8%B3%E5%AE%9A%E5%A9%9A%E5%A7%BB%E9%97%AE%E9%A2%98%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48393453" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48393453</a></p>
<h4><span id="稳定婚姻学习资料">稳定婚姻学习资料：</span></h4><p><a href="http://www.matrix67.com/blog/?s=%E7%A8%B3%E5%AE%9A%E5%A9%9A%E5%A7%BB" target="_blank" rel="noopener"> http://www.matrix67.com/blog/?s=%E7%A8%B3%E5%AE%9A%E5%A9%9A%E5%A7%BB
</a><br><a href="http://www.programmer.com.cn/12001/" target="_blank" rel="noopener"> http://www.programmer.com.cn/12001/ </a></p>
<h4><span id="题目链接">题目链接： [</span></h4><p><a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1990" target="_blank" rel="noopener">https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1990</a><br>](<a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1990" target="_blank" rel="noopener">https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1990</a>)</p>
<p>题意：稳定婚姻</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;  
#include &lt;ctype.h&gt;  
#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;stack&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string&gt;  
#include &lt;sstream&gt;  
#include &lt;malloc.h&gt;

using namespace std;

const int MAXN = 1010;
int pref[MAXN][MAXN], order[MAXN][MAXN], Next[MAXN];
int future_husband[MAXN], future_wife[MAXN];
queue&lt;int&gt; q;

void engage(int man, int woman)
{
    int m = future_husband[woman];
    if (m)
    {
        future_wife[m] = 0;
        q.push(m);
    }
    future_wife[man] = woman;
    future_husband[woman] = man;
}

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        while (!q.empty()) q.pop();
        int  n;
        scanf(&quot;%d&quot;, &amp;n);
        for (int i = 1;i &lt;= n;i++)
        {
            for (int j = 1;j &lt;= n;j++)
                scanf(&quot;%d&quot;,&amp;pref[i][j]);
            Next[i] = 1;
            future_wife[i] = 0;
            q.push(i);
        }
        for (int i = 1;i &lt;= n;i++)
        {
            for (int j = 1;j &lt;= n;j++)
            {
                int x;
                scanf(&quot;%d&quot;, &amp;x);
                order[i][x] = j;
            }
            future_husband[i] = 0;
        }
        while (!q.empty())
        {
            int man = q.front();q.pop();
            int woman = pref[man][Next[man]++];
            if (!future_husband[woman])
                engage(man, woman);
            else if (order[woman][man] &lt; order[woman][future_husband[woman]])
                engage(man, woman);
            else q.push(man);
        }
        for (int i = 1;i &lt;= n;i++)
            printf(&quot;%d\n&quot;, future_wife[i]);
        if (t) printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LIGHTOJ 1029 – CIVIL AND EVIL ENGINEER 【PRIM】</title>
    <url>/article/csdn/LIGHTOJ_1029_%E2%80%93_CIVIL_AND_EVIL_ENGINEER_%E3%80%90PRIM%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46383157" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46383157</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1029" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1029
</a></p>
<p>根据给出的条件，求最大和最小生成树的平均值。</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;queue&gt;

using namespace std;

const int inf = 100000000;
int n, a, b, c;
int maxp[110][110];
int minp[110][110];

int dis[110], v[110];
int prim(int map[][110],int n)
{
    memset(v, 0, sizeof(v));
    int min, sum = 0;
    for (int i = 0; i &lt;= n; i++)
        dis[i] = map[0][i];
    v[0] = 1;
    for (int i = 1; i &lt;= n; i++)
    {
        int k = 0;
        min = inf;
        for (int j = 0; j &lt;= n; j++)
            if (!v[j] &amp;&amp; min&gt;dis[j])
            {
                k = j;
                min = dis[j];
            }
        sum += min;
        v[k] = 1;
        for (int j = 0; j &lt;= n; j++)
            if (!v[j] &amp;&amp; dis[j]&gt;map[k][j])
                dis[j] = map[k][j];
    }
    return sum;
}

int primmax(int map[][110], int n)
{
    memset(v, 0, sizeof(v));
    int min, sum = 0;
    for (int i = 0; i &lt;= n; i++)
        dis[i] = map[0][i];
    v[0] = 1;
    for (int i = 1; i &lt;= n; i++)
    {
        int k = 0;
        min = -1;
        for (int j = 0; j &lt;= n; j++)
            if (!v[j] &amp;&amp; min&lt;dis[j])
            {
                k = j;
                min = dis[j];
            }
        sum += min;
        v[k] = 1;
        for (int j = 0; j &lt;= n; j++)
            if (!v[j] &amp;&amp; dis[j]&lt;map[k][j])
                dis[j] = map[k][j];
    }
    return sum;
}

void init(int n)
{
    for (int i = 0; i &lt;= n; i++)
        for (int j = 0; j &lt;= n; j++)
        {
            if (i == j)
            {
                maxp[i][j] = maxp[j][i] = minp[i][j] = minp[j][i] = 0;
            }
            else
            {
                maxp[i][j] = maxp[j][i] = -1;
                minp[i][j] = minp[j][i] = inf;
            }
        }
}

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    for (int k = 1; k &lt;= t; k++)
    {
        scanf(&quot;%d&quot;, &amp;n);
        init(n);
        while (scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c) != EOF)
        {
            if (a == 0 &amp;&amp; b == 0 &amp;&amp; c == 0)
                break;
            if (minp[a][b] &gt; c)
            {
                minp[a][b] = minp[b][a] = c;
            }
            if (maxp[a][b] &lt; c)
            {
                maxp[a][b] = maxp[b][a] = c;
            }
        }

        int ans1 = primmax(maxp, n);
        int ans2 = prim(minp, n);
        int ans = ans1 + ans2;
        if (!(ans%2))
            printf(&quot;Case %d: %d\n&quot;, k, ans/2);
        else 
            printf(&quot;Case %d: %d%c%d\n&quot;, k, ans,&#39;/&#39;,2);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LIGHTOJ 1174 – COMMANDOS 【FLOYD】</title>
    <url>/article/csdn/LIGHTOJ_1174_%E2%80%93_COMMANDOS_%E3%80%90FLOYD%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46383163" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46383163</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1174" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1174
</a></p>
<p>题意：很多人从起点出发走过所有城市后，在终点汇聚所需的最短时间。</p>
<p>利用floyd。</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;queue&gt;

using namespace std;

const int inf = 10000000;
int t;
int p[110][110];
int n, m;

void init(int n)
{
    for (int i = 0; i &lt;= n; i++)
    {
        p[i][i] = 0;
        for (int j = i + 1; j &lt;= n; j++)
            p[i][j] = p[j][i] = inf;
    }
}

void floyd(int n)
{
    for (int k = 0; k &lt; n; k++)
        for (int i = 0; i &lt; n; i++)
            for (int j = 0; j &lt; n; j++)
            {
                if (p[i][k] + p[k][j] &lt; p[i][j] &amp;&amp; p[i][k]!=inf &amp;&amp; p[k][j] !=inf)
                    p[i][j] = p[i][k] + p[k][j];
            }
}

int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    int a, b, c;
    for (int k = 1; k &lt;= t; k++)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m); 
        init(n);
        while (m--)
        {
            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
            p[a][b] = p[b][a] = 1;
        }
        floyd(n);
        int s, e;
        scanf(&quot;%d%d&quot;,&amp;s,&amp;e);
        int ans = -inf;
        for (int i = 0; i &lt; n; i++)
        {
            if (p[s][i] != inf &amp;&amp; p[i][e] != inf)
                ans = max(ans,p[s][i] + p[i][e]);
        }
        printf(&quot;Case %d: %d\n&quot;, k, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LIGHTOJ 1007 – MATHEMATICALLY HARD【欧拉函数】</title>
    <url>/article/csdn/LIGHTOJ_1007_%E2%80%93_MATHEMATICALLY_HARD%E3%80%90%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46383193" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46383193</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1007" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1007
</a></p>
<p>题意：打表欧拉函数即可；</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;    
#include&lt;iostream&gt;    
#include&lt;math.h&gt;    
#include&lt;stdlib.h&gt;    
#include&lt;ctype.h&gt;    
#include&lt;algorithm&gt;    
#include&lt;vector&gt;    
#include&lt;string.h&gt;    
#include&lt;stack&gt;    
#include&lt;set&gt;    
#include&lt;map&gt;    
#include&lt;sstream&gt;    
#include&lt;time.h&gt;    
#include&lt;utility&gt;    
#include&lt;malloc.h&gt;    
#include&lt;stdexcept&gt;    
#include&lt;iomanip&gt;    
#include&lt;iterator&gt;    

using namespace std;

const int MAXN = 5000010; 

int t;
int from, ed;
bool com[MAXN];
int primes, prime[MAXN];
unsigned long long phi[MAXN];

void init(int n)
{

    phi[1] = 0;
    for (int i = 2; i &lt;= n; ++i)
    {
        if (!com[i])
        {
            prime[primes++] = i;
            phi[i] = i - 1;
        }
        for (int j = 0; j &lt; primes &amp;&amp; i*prime[j] &lt;= n; ++j)
        {
            com[i*prime[j]] = true;
            if (i % prime[j])
                phi[i*prime[j]] = phi[i] * (prime[j] - 1);
            else
            {
                phi[i*prime[j]] = phi[i] * prime[j]; break;
            }
        }
    }

    phi[2] *= phi[2];
    for (int i = 3; i &lt;= n; i++)
        phi[i] = phi[i - 1] + phi[i] * phi[i];
}

int main()
{
    init(5000005);
    scanf(&quot;%d&quot;,&amp;t);
    for (int i = 1; i &lt;= t; i++)
    {
        scanf(&quot;%d%d&quot;,&amp;from,&amp;ed);
        printf(&quot;Case %d: %llu\n&quot;,i,phi[ed] - phi[from-1]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LIGHTOJ 1019 – BRUSH (V) 【最短路】</title>
    <url>/article/csdn/LIGHTOJ_1019_%E2%80%93_BRUSH_(V)_%E3%80%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46383205" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46383205</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1019" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1019
</a></p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;     
#include&lt;iostream&gt;     
#include&lt;math.h&gt;     
#include&lt;stdlib.h&gt;     
#include&lt;ctype.h&gt;     
#include&lt;algorithm&gt;     
#include&lt;vector&gt;     
#include&lt;string.h&gt;     
#include&lt;stack&gt;     
#include&lt;set&gt;        
#include&lt;sstream&gt;     
#include&lt;time.h&gt;     
#include&lt;utility&gt;     
#include&lt;malloc.h&gt;     
#include&lt;stdexcept&gt;     
#include&lt;iomanip&gt;     
#include&lt;iterator&gt;     

using namespace std;

int t, cases = 1;
int n, m, f;
const int MAXN = 110;
const int INF = 10000000;
int map[MAXN][MAXN];
int a, b, c;
bool vis[MAXN];
int lowcost[MAXN];

void dijkstra(int cost[][MAXN], int lowcost[], int n, int beg)
{
    for (int i = 0; i &lt; n; i++)
    {
        vis[i] = false;
        lowcost[i] = cost[beg][i];
    }
    lowcost[beg] = 0;
    vis[beg] = true;
    for (int j = 0; j &lt; n; j++)
    {
        int k = -1;
        int MIN = INF;
        for (int i = 0; i &lt; n; i++)
            if (!vis[i] &amp;&amp; lowcost[i] &lt; MIN)
            {
                MIN = lowcost[i];
                k = i;
            }
        if (k == -1) break;
        vis[k] = true;

        for (int i = 0; i &lt; n; i++)
        {
            if (!vis[i] &amp;&amp; lowcost[k] + cost[k][i] &lt; lowcost[i])
            {
                lowcost[i] = lowcost[k] + cost[k][i];
            }
        }
    }
}

int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        getchar();
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
        for (int i = 0; i &lt; n; i++)
            for (int j = 0; j &lt; n; j++)
            {
                if (i == j) map[i][i] = 0;
                else map[i][j] = map[j][i] = INF;
            }
        while (m--)
        {
            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
            if (map[a-1][b-1] &gt; c)
            map[a-1][b-1] = map[b-1][a-1] = c;
        }
        dijkstra(map, lowcost, n, 0);
        printf(&quot;Case %d: &quot;,cases++);
        if (lowcost[n - 1] != INF) printf(&quot;%d\n&quot;,lowcost[n-1]);
        else puts(&quot;Impossible&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LIGHTOJ 1255-SUBSTRING FREQUENCY 【KMP】</title>
    <url>/article/csdn/LIGHTOJ_1255-SUBSTRING_FREQUENCY_%E3%80%90KMP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46383175" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46383175</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1255" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1255
</a></p>
<p>题意：求母串中包含子串的个数，可重叠。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;iostream&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;ctype.h&gt;  
#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;stack&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;sstream&gt;  
#include &lt;time.h&gt;  
#include &lt;malloc.h&gt;  

using namespace std;

void get_next(char x[], int m, int Next[])
{
    int i, j;
    j = Next[0] = -1;
    i = 0;
    while (i &lt; m)
    {
        while (-1 != j &amp;&amp; x[i] != x[j]) j = Next[j];
        Next[++i] = ++j;
    }
}

int Next[1001000];
long long KMP(char x[], int m, char y[], int n)//x模式串 y主串
{
    int i, j;
    long long ans = 0;
    i = j = 0;
    get_next(x, m, Next);
    while (i &lt; n)
    {
        while (-1 != j &amp;&amp; y[i] != x[j])
            j = Next[j];
        i++; j++;
        if (j &gt;= m)
        {
            ans++;
            j = Next[j];
        }
    }
    return ans;
}
char a[1000100], b[1000100];

int main()
{
    int t, num;
    scanf(&quot;%d&quot;, &amp;t);
    for (int i = 1; i &lt;= t; i++)
    {
        printf(&quot;Case %d: &quot;, i);
        scanf(&quot;%s&quot;, a);
        int n = strlen(a);
        scanf(&quot;%s&quot;, b);
        int m = strlen(b);
        printf(&quot;%lld\n&quot;, KMP(b, m, a, n));

    }
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LIGHTOJ 1258 – MAKING HUGE PALINDROMES 【KMP】</title>
    <url>/article/csdn/LIGHTOJ_1258_%E2%80%93_MAKING_HUGE_PALINDROMES_%E3%80%90KMP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46383167" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46383167</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1258" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1258
</a></p>
<p>题意：为了使原串变为回文串，可任意添加字符，求变为回文串之后字符的长度。</p>
<p>解法：求字符串与其反串的最大公共长度len，则最后回文字符串的长度为:原串长度*2-len;</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;iostream&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;ctype.h&gt;  
#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;stack&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;sstream&gt;  
#include &lt;time.h&gt;  
#include &lt;malloc.h&gt;  

using namespace std;
#define LL  long long

void get_next(char x[], LL m, LL Next[])
{
    LL i, j;
    j = Next[0] = -1;
    i = 0;
    while (i &lt; m)
    {
        while (-1 != j &amp;&amp; x[i] != x[j]) j = Next[j];
        Next[++i] = ++j;
    }
}

LL Next[1001000];
long long KMP(char x[], LL m, char y[], LL n)//x模式串 y主串 
{
    LL i, j, ans = 0;
    i = j = 0;
    get_next(x, m, Next);
    while (i &lt; m &amp;&amp; j &lt; n)
    {
        if (j ==-1 || x[j] == y[i])
        {
            i++;
            j++;
        }
        else
            j = Next[j];
    }
    return n + m - j;
}
char a[1000100], b[1000100];

int main()
{
    LL t;
    scanf(&quot;%lld&quot;,&amp;t);
    for (LL i = 1; i &lt;= t;i++)
    { 
        scanf(&quot;%s&quot;, a);
        LL n = strlen(a);

        for (LL k = 0; k &lt; n; k++)
            b[n - k -1] = a[k];
        long long tmp = KMP(b, n, a, n);
        printf(&quot;Case %lld: &quot;,i);
        printf(&quot;%lld\n&quot;,tmp);
    }
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode 151. Reverse Words in a String</title>
    <url>/article/csdn/Leetcode_151._Reverse_Words_in_a_String.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/51228879" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/51228879</a></p>
<p>题目： <a href="https://leetcode.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener"> https://leetcode.com/problems/reverse-words-in-a-string/
</a></p>
<p>代码：</p>
<pre><code>class Solution 
{
public:
    void reverseWords(string &amp;s)
    {
        string ans;
        ans.clear();
        for (int i = 0;i != s.size() / 2;i++)
            swap(s[i], s[s.size() - i - 1]);
        string tmp;

        for (int i = 0;i &lt; s.size();i++)
        {
            if (s[i] != &#39; &#39;)
                tmp.push_back(s[i]);

            else if (tmp.size() != 0)
            {
                for (int j = 0;j != tmp.size() / 2;j++)
                    swap(tmp[j], tmp[tmp.size() - j - 1]);
                if (ans.size() != 0)
                    ans.append(&quot; &quot;);
                ans += tmp;
                tmp.clear();
            }
        }

        if (tmp.size() != 0)
        {
            if (ans.size() != 0)
                ans.append(&quot; &quot;);
            for (int j = 0;j != tmp.size() / 2;j++)
                swap(tmp[j], tmp[tmp.size() - j - 1]);
            ans += tmp;
        }
        s.clear();
        s = ans;
    }
};
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 2. Add Two Numbers</title>
    <url>/article/csdn/LeetCode_2._Add_Two_Numbers.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/50861890" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/50861890</a></p>
<p>题目： <a href="https://leetcode.com/problems/add-two-numbers/" target="_blank" rel="noopener"> https://leetcode.com/problems/add-two-numbers/
</a></p>
<pre><code>class Solution
{
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2)
    {
        if (l1 == NULL) return l2;
        if (l2 == NULL) return l1;

        ListNode *l3, *ans;
        l3 = (ListNode*)malloc(sizeof(ListNode));
        l3 = NULL;
        ans = NULL;

        int s = 0;

        while (l1 != NULL &amp;&amp; l2 != NULL)
        {
            int sum = l1-&gt;val + l2-&gt;val;
            l1 = l1-&gt;next;
            l2 = l2-&gt;next;

            ListNode *tmp;
            tmp = (ListNode*)malloc(sizeof(ListNode));
            tmp-&gt;next = NULL;
            tmp-&gt;val = (sum + s) % 10;
            s = (sum + s) / 10;

            if (ans == NULL)
            {
                ans = l3 = tmp;
            }
            else
            {
                l3-&gt;next = tmp;
                l3 = l3-&gt;next;
            }
        }

        while (l1 != NULL)
        {
            int sum = l1-&gt;val;
            l1 = l1-&gt;next;

            ListNode *tmp;
            tmp = (ListNode*)malloc(sizeof(ListNode));
            tmp-&gt;next = NULL;
            tmp-&gt;val = (sum + s) % 10;
            s = (sum + s) / 10;

            l3-&gt;next = tmp;
            l3 = l3-&gt;next;
        }

        while (l2 != NULL)
        {
            int sum = l2-&gt;val;
            l2 = l2-&gt;next;

            ListNode *tmp;
            tmp = (ListNode*)malloc(sizeof(ListNode));
            tmp-&gt;next = NULL;
            tmp-&gt;val = (sum + s) % 10;
            s = (sum + s) / 10;

            l3-&gt;next = tmp;
            l3 = l3-&gt;next;
        }

        if (s != 0)
        {
            ListNode *tmp;
            tmp = (ListNode*)malloc(sizeof(ListNode));
            tmp-&gt;next = NULL;
            tmp-&gt;val = s;
            s = 0;
            l3-&gt;next = tmp;
            l3 = l3-&gt;next;
        }
        return ans;
    }
};
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ 1004 - Monkey Banana Problem 【DP】</title>
    <url>/article/csdn/LightOJ_1004_-_Monkey_Banana_Problem_%E3%80%90DP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46442033" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46442033</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1004" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1004
</a><br>题意：两个数塔相接，求最大的路径和。<br>解法：简单ＤＰ。<br>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int t, n;
int dp[220][220];
int p[220][220];

int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    for (int ca = 1; ca &lt;= t;ca++)
    {
        scanf(&quot;%d&quot;,&amp;n);
        int tmp = n - 1;
        int tmp2 = n - 1;

        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= i; j++)
                scanf(&quot;%d&quot;,&amp;p[i][j]);
        for (int i = n + 1; i &lt;= 2 * n - 1; i++)
            for (int j = 1; j &lt;= 2 * n - i; j++)
                scanf(&quot;%d&quot;, &amp;p[i][j]);

        memset(dp,0,sizeof(dp));

        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= i; j++)
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + p[i][j];

        for (int i = n + 1; i &lt;= 2 * n - 1; i++)
            for (int j = 1; j &lt;= 2 * n - i; j++)
                dp[i][j] = max(dp[i-1][j],dp[i-1][j+1])+p[i][j];

        printf(&quot;Case %d: %d\n&quot;,ca,dp[2*n - 1][1]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ 1011 Marriage Ceremonies【状压DP】</title>
    <url>/article/csdn/LightOJ_1011_Marriage_Ceremonies%E3%80%90%E7%8A%B6%E5%8E%8BDP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46380573" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46380573</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1011" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1011
</a></p>
<p>状态压缩DP；</p>
<p>dp[i][j] 表示在前i行man，状态j时的最大解。若j的第k位是1，则表示选择了第k个woman，否则表示没选择第k个woman。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

using namespace std;

const int MAXN = 17;
int t;
int n,p[MAXN][MAXN];
int dp[MAXN][(1&lt;&lt;MAXN)];

int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    for(int cases =1;cases&lt;=t;cases++)
    {
        scanf(&quot;%d&quot;,&amp;n);
        for(int i=0;i&lt;n;i++)
            for(int j=0;j&lt;n;j++)
                scanf(&quot;%d&quot;,&amp;p[i][j]);
        memset(dp,0,sizeof(dp));
        int len = (1&lt;&lt;n);
        for(int i=0;i&lt;n;i++) dp[0][1&lt;&lt;i] = p[0][i];
        for(int i=1;i&lt;n;i++)
            {
                for(int j=0;j&lt;n;j++)
                {   
                    for(int k=0;k&lt;len;k++)
                    {
                        if(!dp[i-1][k] || (1&lt;&lt;j)&amp;k) continue;//k未选择过 或 jk都已经选择过
                        //也就是保证： k选择过 且 j没有被选择过
                        dp[i][(1&lt;&lt;j)|k] = max(dp[i][(1&lt;&lt;j)|k],dp[i-1][k] + p[i][j]);
                    }
                }
            }
        printf(&quot;Case %d: %d\n&quot;,cases,dp[n-1][len-1]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ 1003 - Drunk【拓扑排序】</title>
    <url>/article/csdn/LightOJ_1003_-_Drunk%E3%80%90%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48456565" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48456565</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1003" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1003
</a></p>
<p>拓扑排序判圈 ，若存在元素不在拓扑序中，则存在圈。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;malloc.h&gt;
#include &lt;functional&gt;

using namespace std;

char a[15], b[15];
map&lt;string, int&gt; mp;
int m, n, in[10010], tot;

struct Edge
{
    int to, next;
}edge[10010];

int head[10010];

void addedge(int u, int v)
{
    edge[tot].to = v;
    edge[tot].next = head[u];
    head[u] = tot++;
}

void init()
{
    tot = 0;
    memset(head, -1, sizeof(head));
    memset(in, 0, sizeof(in));
    mp.clear();
    n = 0;
}

int main()
{
    int t, cases = 1;
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    {
        scanf(&quot;%d&quot;, &amp;m);
        init();

        for (int i = 1;i &lt;= m;i++)
        {
            scanf(&quot;%s %s&quot;, a, b);
            if (mp.find(a) == mp.end()) mp[a] = ++n;
            if (mp.find(b) == mp.end()) mp[b] = ++n;

            in[mp[b]]++;
            addedge(mp[a], mp[b]);
        }

        int cnt = n;

        queue&lt;int&gt; que; while (!que.empty()) que.pop();
        for (int i = 1;i &lt;= n;i++) if (in[i] == 0) que.push(i);
        while (!que.empty())
        {
            int tmp = que.front();que.pop();
            cnt--;
            for (int i = head[tmp];i != -1;i = edge[i].next)
            {
                int v = edge[i].to;
                in[v]--;
                if (in[v] == 0) que.push(v);
            }
        }

        if (!cnt) printf(&quot;Case %d: Yes\n&quot;, cases++);
        else printf(&quot;Case %d: No\n&quot;, cases++);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ 1025 - The Specials Menu【区间DP】</title>
    <url>/article/csdn/LightOJ_1025_-_The_Specials_Menu%E3%80%90%E5%8C%BA%E9%97%B4DP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/50782578" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/50782578</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1025" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1025
</a></p>
<p>题意：给你一个字符串，可以删除任意多个字符使之组成回文串，问你最多有多少种方法。</p>
<p>思路：<br>dp[i][j]表示i到j组成回文串的方法数目。<br>首先初始化dp[i][j] = 1，就是不删除任何字符的方法。</p>
<p>若s[i] != s[i]<br>dp[i][j] = dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]<br>表示删除i 和删除j的方法数和，因为两种方法重复了i+1 到j-1，所以再减去。</p>
<p>若s[i] == s[j]<br>dp[i][j] = （dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]）+（dp[i+1][j-1] + 1)<br>后面的括号dp[i+1][j-1]表示按照原方案忽略i,j的方法数目，+1表示把[i+1]到[j-1] 全部删除的方法。</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;

using namespace std;

char s[100];

long long dp[100][100];

int main()
{
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    for (int t = 1;t &lt;= T;t++)
    {
        memset(dp, 0, sizeof(dp));
        scanf(&quot;%s&quot;, s);
        int len = strlen(s);

        for (int i = 0;i &lt; len;i++)
            dp[i][i] = 1;

        for (int p = 1;p &lt;= len;p++)
        {
            for (int i = 0;i + p &lt; len;i++)
            {
                int j = i + p;

                if (s[i] == s[j])
                    dp[i][j] = (dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]) + (dp[i+1][j-1] + 1);
                else
                    dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1];
            }
        }
        printf(&quot;Case %d: %lld\n&quot;, t, dp[0][len-1]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>lightoj</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ 1030 Discovering Gold【概率】</title>
    <url>/article/csdn/LightOJ_1030_Discovering_Gold%E3%80%90%E6%A6%82%E7%8E%87%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46417221" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46417221</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1030" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1030
</a><br>题意：基础概率题。<br>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;vector&gt;  
#include &lt;string&gt;  
#include &lt;algorithm&gt;  
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;fstream&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;math.h&gt;

using namespace std;

double dp[1010];

int main()
{
    int i, j, t, n, ca = 0;
    cin &gt;&gt; t;
    while (t--)
    {
        memset(dp, 0,sizeof(dp));
        cin &gt;&gt; n;
        for (int i = 1; i &lt;= n;i++)
            scanf(&quot;%lf&quot;, &amp;dp[i]);

        for (int i = n-1; i &gt;= 1; i--)
            for (int j = 1; j &lt;= 6; j++)
                dp[i] += dp[i+j] / min(6, n - i);
        printf(&quot;Case %d: %.6lf\n&quot;, ++ca, dp[1]);

    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ 1033 - Generating Palindromes 【区间DP】</title>
    <url>/article/csdn/LightOJ_1033_-_Generating_Palindromes_%E3%80%90%E5%8C%BA%E9%97%B4DP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46442917" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46442917</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1033" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1033
</a><br>题意：至少添加几个字符，能使得给定的串变为回文串。<br>解法：枚举起点终点，进行ＤＰ；<br>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int t;
char s[1010];
int dp[1010][1010]; 

int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    for (int ca = 1; ca &lt;= t;ca++)
    {
        memset(dp,0,sizeof(dp));
        scanf(&quot;%s&quot;,s+1);
        int n = strlen(s+1);

        for (int i = n; i &gt;= 1; i--)
            for (int j = i+1; j &lt;= n; j++)
            {
                if (s[i] == s[j])
                    dp[i][j] = dp[i + 1][j - 1];
                else
                    dp[i][j] = min(dp[i+1][j],dp[i][j-1]) + 1;
            }
        printf(&quot;Case %d: %d\n&quot;,ca,dp[1][n]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ 1038 - Race to 1 Again 【DP】</title>
    <url>/article/csdn/LightOJ_1038_-_Race_to_1_Again_%E3%80%90DP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46431179" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46431179</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1038" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1038
</a><br>题意：题目很短，不叙述了。<br>解法：dp<br>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int t, n;
double dp[100010];

int main()
{
    memset(dp, 0, sizeof(dp));
    dp[1] = 0;
    dp[2] = 2.0;
    double tmp;
    for (int i = 3; i &lt;= 100010; i++)
    {
        tmp = 0;
        dp[i] = 0;
        for (int j = 1; j*j &lt;= i; j++)
        {
            if (i % j == 0)
            {
                dp[i] += dp[j];
                tmp+=1;
                if (j != i / j &amp;&amp; j != 1)
                {
                    dp[i] += dp[i / j];
                    tmp += 1;
                }
            }
        }
        dp[i] = (dp[i]  + tmp + 1) / tmp;
    }
    scanf(&quot;%d&quot;,&amp;t);
    for (int ca = 1; ca &lt;= t; ca++)
    {
        scanf(&quot;%d&quot;,&amp;n);
        printf(&quot;Case %d: %.6lf\n&quot;,ca,dp[n]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ 1017 - Brush (III)【一般DP】</title>
    <url>/article/csdn/LightOJ_1017_-_Brush_(III)%E3%80%90%E4%B8%80%E8%88%ACDP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/49016009" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/49016009</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1017" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1017
</a></p>
<p>题意：<br>给你一把刷子，每次最多刷w宽的区域，给你n个点的间距，最多刷k次，问你最多能刷到几个点。</p>
<p>解法：<br>按坐标排序。<br>dp[i][j] 表示刷到i用j次最优解，用num[i]记录i位置最多能刷多少个。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

using namespace std;

int n, w, k;
int dp[110][110];

struct Node
{
    int x;
    int y;
}a[100010];

bool cmp(Node a, Node b)
{
    return a.y &lt; b.y;
}

int num[110];

int main()
{
    int t, cases = 1;
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    {
        memset(num, 0, sizeof(num));
        scanf(&quot;%d%d%d&quot;, &amp;n, &amp;w, &amp;k);
        for (int i = 1;i &lt;= n;i++)
            scanf(&quot;%d%d&quot;, &amp;a[i].x, &amp;a[i].y);
        sort(a + 1, a + 1 + n, cmp);

        for (int i = 1;i &lt;= n;i++)
        {
            int tmp = 0;
            for (int j = 1;j &lt;= i;j++)
            {
                if ((long long)(a[i].y - a[j].y) &lt;= w)
                    tmp++;
            }
            num[i] = tmp;
        }
        memset(dp, 0, sizeof(dp));

        for (int i = 1;i &lt;= n;i++)
            for (int j = 1;j &lt;= k;j++)
            {
                dp[i][j] = 1;
                if (i &lt; num[i])
                    dp[i][j] = num[i];
                else
                    dp[i][j] = max(dp[i - 1][j], dp[i-num[i]][j-1] + num[i]);
            }
        printf(&quot;Case %d: %d\n&quot;, cases++, dp[n][k]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ 1031 - Easy Game【区间dp】</title>
    <url>/article/csdn/LightOJ_1031_-_Easy_Game%E3%80%90%E5%8C%BA%E9%97%B4dp%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/50760717" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/50760717</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1031" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1031
</a></p>
<p>题意:<br>给一个序列，两个人轮流在序列的两边取任意个数的number，但每次只能从选定的那一边取，问取得数字的和的较大者比较小者多多少？</p>
<p>思路：<br>dp[i][j]表示i-j区间的最优解，然后枚举区间。</p>
<p>代码：</p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

using namespace std;

int n;
int a[110], sum[110];
int dp[110][110];

int main()
{
    int t, cases = 1;
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    {
        memset(a, 0, sizeof(a));
        memset(dp, 0, sizeof(dp));
        memset(sum, 0, sizeof(sum));

        scanf(&quot;%d&quot;, &amp;n);
        for (int i = 1;i &lt;= n;i++)
        {
            scanf(&quot;%d&quot;, &amp;a[i]);
            sum[i] = sum[i - 1] + a[i];
            dp[i][i] = a[i];
        }

        for (int p = 1;p &lt;= n;p++)
        {
            for (int i = 1;i &lt;= n - p;i++)
            {
                int j = i + p;
                dp[i][j] = sum[j] - sum[i - 1];
                for (int k = i;k &lt; j;k++)
                {
                    int tmp = max(sum[k] - sum[i-1] - dp[k+1][j], sum[j] - sum[k] - dp[i][k]);
                    dp[i][j] = max(dp[i][j], tmp);
                }
            }
        }

        printf(&quot;Case %d: %d\n&quot;, cases++, dp[1][n]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ 1034 - Hit the Light Switches【强连通最小点基】</title>
    <url>/article/csdn/LightOJ_1034_-_Hit_the_Light_Switches%E3%80%90%E5%BC%BA%E8%BF%9E%E9%80%9A%E6%9C%80%E5%B0%8F%E7%82%B9%E5%9F%BA%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48445943" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48445943</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1034" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1034
</a></p>
<p>题意：有向图，选择尽量少的点，从这些点出发，使得所有点都被到达过。</p>
<p>思路：首先，进行强连通缩点。然后每个强连通间按照拓扑排序的思想建边。入度为0的强连通的个数即为答案。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;malloc.h&gt;
#include &lt;functional&gt;

using namespace std;

const int MAXN = 20010;
const int MAXM = 500100;

struct Edge
{
    int to, next;
}edge[MAXM];

int head[MAXM], tot;
int Low[MAXN], Dfn[MAXN], Stack[MAXN], Belong[MAXN];//Belong的值为 1 ~ scc
int Index, top;
int scc;//强连通个数
bool Instack[MAXN];
int num[MAXN];//各个强连通包含的点的个数

void addedge(int u, int v)
{
    edge[tot].to = v;
    edge[tot].next = head[u];
    head[u] = tot++;
}

void Tarjan(int u)
{
    int v;
    Low[u] = Dfn[u] = ++Index;
    Stack[top++] = u;
    Instack[u] = true;
    for (int i = head[u]; i != -1; i = edge[i].next)
    {
        v = edge[i].to;
        if (!Dfn[v])
        {
            Tarjan(v);
            if (Low[u] &gt; Low[v])
                Low[u] = Low[v];
        }
        else if (Instack[v] &amp;&amp; Low[u] &gt; Dfn[v])
            Low[u] = Dfn[v];
    }
    if (Low[u] == Dfn[u])
    {
        scc++;
        do
        {
            v = Stack[--top];
            Instack[v] = false;
            Belong[v] = scc;
            num[scc]++;
        } while (v != u);
    }
}

void solve(int N)
{
    memset(Dfn, 0, sizeof(Dfn));
    memset(Instack, false, sizeof(Instack));
    memset(num, 0, sizeof(num));
    Index = scc = top = 0;
    for (int i = 1; i &lt;= N; i++)
    {
        if (!Dfn[i])
            Tarjan(i);
    }
}

void init()
{
    tot = 0;
    memset(head, -1, sizeof(head));
}

int n, m;
int in[100010];

int main()
{
    int t, cases = 1;
    scanf(&quot;%d&quot;, &amp;t);

    while (t--)
    {
        init();
        memset(in, 0, sizeof(in));

        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        int u, v;
        for (int i = 1;i &lt;= m;i++)
        {
            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
            addedge(u, v);
        }
        solve(n);
        for (int u = 1;u &lt;= n;u++)
        {
            for (int j = head[u];j != -1;j = edge[j].next)
            {
                int v = edge[j].to;
                int t1 = Belong[u];
                int t2 = Belong[v];
                if (t1 != t2)
                    in[t2]++;
            }
        }

        int ans = 0;
        for (int i = 1;i &lt;= scc;i++)
            if (in[i] == 0) ans++;
        printf(&quot;Case %d: %d\n&quot;, cases++, ans);

    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ 1040 – Donation 【Prim】</title>
    <url>/article/csdn/LightOJ_1040_%E2%80%93_Donation_%E3%80%90Prim%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46380521" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46380521</a></p>
<p>题目连接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1040" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1040
</a></p>
<p>题意也不说了。</p>
<p>水题</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;
#include &lt;set&gt;

using namespace std;

const int MAXN = 55;
const int inf = 100000000;

int p[MAXN][MAXN];
int n;

int dis[MAXN], v[MAXN];
int prim(int map[][55], int n)
{
    memset(v, 0, sizeof(v));
    int min, sum = 0;
    for (int i = 0; i &lt; n; i++)
        dis[i] = map[0][i];
    v[0] = 1;
    for (int i = 1; i &lt; n; i++)
    {
        int k = -1;
        min = inf;
        for (int j = 0; j &lt; n; j++)
            if (!v[j] &amp;&amp; min&gt;dis[j])
            {
                k = j;
                min = dis[j];
            }
        if (k == -1)
            return - 1;
        sum += min;
        v[k] = 1;
        for (int j = 0; j &lt; n; j++)
            if (!v[j] &amp;&amp; dis[j]&gt;map[k][j])
                dis[j] = map[k][j];
    }
    return sum;
}

void init()
{
    for (int i = 0; i &lt; n; i++)
    {
        for (int j = 0; j &lt; n; j++)
        {
            if (i != j &amp;&amp; p[i][j] == 0 &amp;&amp; p[j][i] == 0)
            {
                p[i][j] = p[j][i] = inf;
            }
        }
    }
}

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    for (int cases = 1; cases &lt;= t; cases++)
    {
        int ans = 0;
        memset(p,0,sizeof(p));
        scanf(&quot;%d&quot;,&amp;n);
        for (int i = 0; i &lt; n; i++)
            for (int j = 0; j &lt; n; j++)
            {
                scanf(&quot;%d&quot;,&amp;p[i][j]);
                ans += p[i][j];
                if (i == j)
                    p[i][i] = 0;
                if (i!=j &amp;&amp; p[i][j] == 0)
                {
                    p[i][j] = p[j][i];
                }
                else if (i != j &amp;&amp; p[j][i] != 0 &amp;&amp; p[i][j]!=0)
                {
                    p[i][j] = p[j][i] = min(p[i][j], p[j][i]);
                }
                else if (i != j &amp;&amp; p[j][i] == 0)
                {
                    p[j][i] = p[i][j];
                }
            }
        init();
        int tmp = prim(p, n);
        ans -= tmp;
        if (tmp!=-1)
            printf(&quot;Case %d: %d\n&quot;,cases,ans);
        else
            printf(&quot;Case %d: -1\n&quot;, cases);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ 1048 - Conquering Keokradong 【二分】</title>
    <url>/article/csdn/LightOJ_1048_-_Conquering_Keokradong_%E3%80%90%E4%BA%8C%E5%88%86%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47045557" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47045557</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1048" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1048
</a></p>
<p>题意：有N 个数，将它们按顺序分成M份，M&lt;=min(N,300)。使得每一份的和的最大值最小。有很多中情况，这些情况中第一天、第二天……的和最大的情况。</p>
<p>思路 ： 二分最大的和，得到一个数mid。判断是否符合条件。</p>
<p>代码：（不能AC 实在是找不出来了，先放着）</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int a[1010];
int t;
int n, k;
int tmp;
int sum[1010];
int ans;
int g[1010];

int is_ok(int x)
{
    int res;
    int num = 0;
    int pos = 0;

    for (int i = 1; i &lt;= n; i++)
        if (sum[i] - sum[i - 1] &gt; x) return 0;

    for (int i = 1; i &lt;= n; i++)
    {
        if (sum[i] -sum[pos] == x  || (i == n &amp;&amp; sum[i] -sum[pos] &lt;= x) || (i != n &amp;&amp; sum[i+1] - sum[pos] &gt; x))
        {
            if (i != n) num++;
            pos = i;
        }
    }
    if (num &lt;= k) return 1;
    else return 0;
}

void get_ans()
{
    int res;
    int now = 1;

    int remain = n - k -1;
    while (now &lt;= n)
    {
        int pos = now - 1;
        int tmp = sum[now] - sum[now-1];
        now++;
        if (remain != 0)
        {
            for (; now &lt;= n; now++)
            {
                if (sum[now] - sum[pos] &lt;= ans)
                    tmp = sum[now] - sum[pos], remain --; 
                else 
                {
                    printf(&quot;%d\n&quot;,tmp);
                    break;
                }
            }
            if (remain == 0)
            {
                printf(&quot;%d\n&quot;,tmp);
                now++;
                break;
            }

        }
        else
        {
            printf(&quot;%d\n&quot;, tmp);
        }

    }
}

int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    int cases = 1;
    while (t--)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
        n++;

        int tot = 0;
        memset(sum,0,sizeof(sum));

        for (int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;, &amp;a[i]);
            sum[i] = sum[i - 1] + a[i];
            tot += a[i];
        }

        int left = 1;
        int right = tot;
        int mid;

        while (left &lt;= right)
        {
            mid = (left + right) / 2;
            if (is_ok(mid))
            {
                ans = mid;
                right = mid - 1;
            }
            else 
                left = mid + 1;
        }

        printf(&quot;Case %d: &quot;, cases++);
        printf(&quot;%d\n&quot;, ans);
        get_ans();
    }
    return 0; 
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ 1047 - Neighbor House 【DP】</title>
    <url>/article/csdn/LightOJ_1047_-_Neighbor_House_%E3%80%90DP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46454809" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46454809</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1047" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1047
</a><br>题意：求(p[i][j])上下相邻的 j 不能相同的数塔的最小和。<br>解法：看代码！<br>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;bitset&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;
#include &lt;map&gt;
#include &lt;set&gt;

using namespace std;

int t;
int n;
int p[25][5];
int dp[25][25];
int pos[25];

int main()
{
    cin &gt;&gt; t;
    for (int ca = 1; ca &lt;= t; ca++)
    {
        memset(dp,0,sizeof(dp));
        cin &gt;&gt; n;
        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= 3; j++)
                cin &gt;&gt; p[i][j];

        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= 3; j++)
            {
                if (j == 1)
                    dp[i][j] = min(dp[i - 1][2], dp[i - 1][3]) + p[i][j];
                if (j == 2)
                    dp[i][j] = min(dp[i - 1][1], dp[i - 1][3]) + p[i][j];
                if (j == 3)
                    dp[i][j] = min(dp[i - 1][2], dp[i - 1][1]) + p[i][j];
            }

        cout &lt;&lt; &quot;Case &quot; &lt;&lt; ca &lt;&lt; &quot;: &quot; &lt;&lt; min(dp[n][1] ,min(dp[n][2],dp[n][3]))&lt;&lt; endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ 1044 - Palindrome Partitioning【dp】</title>
    <url>/article/csdn/LightOJ_1044_-_Palindrome_Partitioning%E3%80%90dp%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/50768226" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/50768226</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1044" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1044
</a></p>
<p>题意：给你一个字符串，问最少分为几个回文串？</p>
<p>思路：dp[i]表示从开头到位置 i 的最优解，若[j,i]是回文串，则dp[i] = min(dp[i],dp[j-1] +1)</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;

using namespace std;

char s[1010];
int dp[1010];

bool is_ok(char a[], int L, int R)
{
    while (L &lt;= R)
    {
        if (a[L] != a[R])
        {
            return false;
        }
        L++;
        R--;
    }

    return true;
}

int main()
{
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    for (int t = 1;t &lt;= T;t++)
    {
        memset(dp, 0, sizeof(dp));

        scanf(&quot;%s&quot;, s + 1);
        int len = strlen(s+1);

        for (int i = 1;i &lt;= len;i++)
        {
            dp[i] = 1010;
            for (int j = 1;j &lt;= i;j++)
            {
                if (is_ok(s, j, i))
                {
                    if (j == 1)
                        dp[i] = 1;
                    else
                        dp[i] = min(dp[i], dp[j - 1] + 1);
                }
            }
        }

        printf(&quot;Case %d: %d\n&quot;, t, dp[len]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ 1050 - Marbles【概率】</title>
    <url>/article/csdn/LightOJ_1050_-_Marbles%E3%80%90%E6%A6%82%E7%8E%87%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/50783145" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/50783145</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1050" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1050
</a></p>
<p>题意就不解释了</p>
<p>思路：<br>dp[i][j]表示i个红球j个蓝球的获胜概率。<br>初始化：dp[0][i] = 1 没有红球全是蓝球则获胜概率是1<br>转移：dp[i][j] = 我取得红球的概率<em>dp[i-1][j-1] + 我取得蓝球的概率</em>dp[i][j-2]</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;

using namespace std;

double dp[1010][1010];

int R, B;

void init()
{
    memset(dp, 0, sizeof(dp));
    for (int i = 0;i &lt;= 500;i++)
        dp[0][i] = 1;

    for (int i = 1;i &lt;= 500;i++)
        for (int j = 2;j &lt;= 500;j++)
            dp[i][j] = (double)i / (i + j) * dp[i - 1][j - 1] + (double)j / (i + j) * dp[i][j - 2];
}

int main()
{
    init();
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    for (int t = 1;t &lt;= T;t++)
    {
        scanf(&quot;%d %d&quot;, &amp;R, &amp;B);
        printf(&quot;Case %d: %.8lf\n&quot;, t, dp[R][B]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>lightoj</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ 1074 – Extended Traffic 【SPFA判负环】</title>
    <url>/article/csdn/LightOJ_1074_%E2%80%93_Extended_Traffic_%E3%80%90SPFA%E5%88%A4%E8%B4%9F%E7%8E%AF%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46380581" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46380581</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1074" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1074
</a></p>
<p>给你一个有向图，求原点1到给定询问点的最短距离是多少，由于可能存在负环，不能用dij,如果点在负环中，则无解，dfs判环。</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;vector&gt;
#include &lt;malloc.h&gt;

using namespace std;

int t;
int n,m,a,b;
int p[21000];

const int MAXN = 41000;
const int INF = 0x3f3f3f3f;

struct Edge
{
    int v;
    int cost;
    Edge(int _v=0,int _cost=0)
    {
        v = _v;
        cost = _cost;
    }
};
vector&lt;Edge&gt; E[MAXN];

void addedge(int u,int v,int cost)
{
    E[u].push_back(Edge(v,cost));
}

bool vis[MAXN];
int cnt[MAXN];
int dist[MAXN];

///////判断负环
int cir[MAXN];
void dfs(int u)
{
    cir[u]=true;
    for(int i=0;i&lt;E[u].size();i++)
    {
        if (!cir[E[u][i].v])
            dfs(E[u][i].v);
    }
}
////////////////
void SPFA(int start,int n)
{
    memset(vis,false,sizeof(vis));
    for(int i=1;i&lt;=n;i++) dist[i]= INF;
    vis[start] = true;
    dist[start] = 0;
    queue&lt;int&gt; que;
    while (!que.empty()) que.pop();
    que.push(start);
    memset(cnt,0,sizeof(cnt));
    cnt[start] =1;

    memset(cir,false,sizeof(cir));
    while (!que.empty())
    {
        int u = que.front();que.pop();
        vis[u]=false;
        for(int i=0;i&lt;E[u].size();i++)
        {
            int v = E[u][i].v;
            if (cir[v]) continue;
            if (dist[v]&gt;dist[u] + E[u][i].cost)
            {
                dist[v]=dist[u] + E[u][i].cost;
                if (!vis[v])
                {
                    vis[v] = true;
                    que.push(v);
                    cnt[v]++;
                    if (cnt[v] &gt; n)
                        dfs(v);
                }
            }
        }
    }
}

int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    for(int cases=1;cases&lt;=t;cases++)
    {
        scanf(&quot;%d&quot;,&amp;n);
        for(int i=1;i&lt;=n;i++)
            {
                scanf(&quot;%d&quot;,&amp;p[i]);
                E[i].clear();
            }
        scanf(&quot;%d&quot;,&amp;m);
        while (m--)
        {
            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
            addedge(a,b,(p[b]-p[a])*(p[b]-p[a])*(p[b]-p[a]));
        }
        SPFA(1,n);
        printf(&quot;Case %d:\n&quot;,cases);
        scanf(&quot;%d&quot;,&amp;m);
        while (m--)
        {
            scanf(&quot;%d&quot;,&amp;b);
            if(cir[b] || dist[b] &lt; 3 || dist[b] == INF)
                printf(&quot;?\n&quot;);
            else
                printf(&quot;%d\n&quot;,dist[b]);
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ 1067 - Combinations【Lucas定理】</title>
    <url>/article/csdn/LightOJ_1067_-_Combinations%E3%80%90Lucas%E5%AE%9A%E7%90%86%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/50883535" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/50883535</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1067" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1067
</a></p>
<p>题意： 组合数求模，Lucas定理</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;algorithm&gt;  
#include &lt;string.h&gt;    
#include &lt;iostream&gt;

using namespace std;

const long long MOD = 1000003;

long long pow(long long a, long long b, long long c)
{
    long long tmp = 1;
    while (b)
    {
        if (b &amp; 1) tmp = (tmp*a) % c;
        a = (a*a) % c;
        b &gt;&gt;= 1;
    }
    return tmp;
}

long long fac[1000005];

void get_fac(long long p)
{
    fac[0] = 1;
    for (int i = 1;i &lt;= p;i++)
        fac[i] = (fac[i - 1] * i) % p;
}

long long Lucas(long long n, long long m, long long p)
{
    long long tmp = 1;
    while (n &amp;&amp; m)
    {
        long long a = n%p, b = m%p;
        if (a &lt; b) return 0;
        tmp = (tmp * fac[a] * pow(fac[b] * fac[a - b] % p, p - 2, p)) % p;

        n /= p;
        m /= p;
    }
    return tmp;
}

int n, m;

int main()
{
    get_fac(MOD);
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    for (int t = 1;t &lt;= T;t++)
    {
        scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
        int ans = Lucas(n, m, MOD);
        printf(&quot;Case %d: %d\n&quot;, t, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ 1072 - Calm Down 【二分】</title>
    <url>/article/csdn/LightOJ_1072_-_Calm_Down_%E3%80%90%E4%BA%8C%E5%88%86%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48041909" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48041909</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1072" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1072
</a></p>
<p>解法：考虑角度的关系 二分r</p>
<p>代码:</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;sstream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  

using namespace std;

const double PI = acos(-1);

double R;
int n;

bool is_ok(double mid)
{
    double y = R - mid;
    double tmp = asin(mid/y);
    int tn = (PI / tmp);
    if (tn &gt;= n) return true;
    else return false;
}

int main()
{
    int cases = 1;
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%lf %d&quot;, &amp;R, &amp;n);
        double left = 0, right = R;

        while (right - left &gt; 1e-8)
        {
            double mid = (left + right) / 2;
            if (is_ok(mid)) left = mid;
            else right = mid;
        }
        printf(&quot;Case %d: %.8lf\n&quot;, cases++, right);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ 1082 - Array Queries【线段树最值】</title>
    <url>/article/csdn/LightOJ_1082_-_Array_Queries%E3%80%90%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%9C%80%E5%80%BC%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/49027647" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/49027647</a></p>
<p>题目链接：<br><a href="http://www.lightoj.com/volume_showproblem.php?problem=1082" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1082
</a></p>
<p>一水~</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;vector&gt;

#define Mid(a,b) ( a+((b-a)&gt;&gt;1))
#define ll(x) (x&lt;&lt;1)
#define rr(x) (x&lt;&lt;1|1)

const int N = 1001000;

using namespace std;

int t, n, m;

int a[N];

struct node
{
    int left;
    int right;
    int sum;
    int mid() { return Mid(left, right); }
};

struct segtree
{
    node tree[N * 4];

    void buildtree(int left, int right, int ind)
    {
        tree[ind].left = left;
        tree[ind].right = right;
        tree[ind].sum = 0;

        if (left == right)
            tree[ind].sum = a[left];
        else
        {
            int mid = tree[ind].mid();
            buildtree(left, mid, ll(ind));
            buildtree(mid + 1, right, rr(ind));
            tree[ind].sum = min(tree[ll(ind)].sum, tree[rr(ind)].sum);
        }
    }

    int query(int st, int ed, int ind)
    {
        int left = tree[ind].left;
        int right = tree[ind].right;

        if (st &lt;= left &amp;&amp; right &lt;= ed)
            return tree[ind].sum;
        else
        {
            int mid = tree[ind].mid();
            int ans = 1e6;
            if (st &lt;= mid)
                ans = min(query(st, ed, ll(ind)),ans);
            if (ed &gt; mid)
                ans = min(ans,query(st, ed, rr(ind)));
            return ans;
        }
    }
}seg;

int main()
{
    int t,cases=1;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        printf(&quot;Case %d:\n&quot;,cases++);
        scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
        memset(a,0,sizeof(a));
        for (int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;, &amp;a[i]);
        }
        seg.buildtree(1, n, 1);
        for(int i=0;i&lt;m;i++)
        {
            int c, d;
            scanf(&quot;%d %d&quot;, &amp;c, &amp;d);
            printf(&quot;%d\n&quot;, seg.query(c, d, 1));
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>lightoj</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ 1094 - Farthest Nodes in a Tree【树的直径】</title>
    <url>/article/csdn/LightOJ_1094_-_Farthest_Nodes_in_a_Tree%E3%80%90%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48708631" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48708631</a></p>
<p>树的直径：假设 s-t这条路径为树的直径，或者称为树上的最长路<br>现有结论，从任意一点u出发搜到的最远的点一定是s、t中的一点，然后在从这个最远点开始搜，就可以搜到另一个最长路的端点。即用两遍搜索就可以找出树的最长路。</p>
<p>题目链接：<br><a href="http://www.lightoj.com/volume_showproblem.php?problem=1094" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1094
</a></p>
<p>题意：树的节点间，路径间边的权值和最大是多少</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;sstream&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;functional&gt;  
#include &lt;vector&gt;
#include &lt;string.h&gt;

using namespace std;

int n, m;
vector&lt;pair &lt;int, int&gt; &gt; g[30100];
bool vis[30100];
int in[30010], weight[30010], dis[30010];
int ans, pos;

void bfs(int u)
{
    queue&lt;int&gt; que;
    while (!que.empty()) que.pop();
    que.push(u);
    dis[u] = 0;
    vis[u] = true;
    int tmp = 0;

    while (!que.empty())
    {
        int v = que.front();
        que.pop();
        for (int i = 0;i &lt; g[v].size();i++)
        {
            int t = g[v][i].first;
            int w = g[v][i].second;
            if (!vis[t])
            {
                vis[t] = true;
                dis[t] = dis[v] + w;
                if (dis[t] &gt; tmp)
                {
                    tmp = dis[t];
                    pos = t;
                }
                que.push(t);
            }
        }

    }
}

void dfs(int u, int sum)
{
    vis[u] = true;
    ans = max(ans, sum);
    for (int i = 0;i &lt; g[u].size();i++)
    {
        int v = g[u][i].first;
        int w = g[u][i].second;
        if (!vis[v]) dfs(v, sum + w);
    }
}

int main()
{
    int t, cases = 1;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        memset(dis, 0, sizeof(dis));
        scanf(&quot;%d&quot;, &amp;n);
        int u, v, w;
        for (int i = 0;i &lt;= n;i++) g[i].clear();
        for (int i = 1;i &lt; n;i ++ )
        {
            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
            g[u].push_back(make_pair(v, w));
            g[v].push_back(make_pair(u, w));
        }

        memset(vis, false, sizeof(vis));
        bfs(0);
        ans = 0;
        memset(vis, false, sizeof(vis));
        dfs(pos, 0);

        printf(&quot;Case %d: %d\n&quot;,cases++, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>lightoj</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ 1149 - Factors and Multiples【二分图最大匹配】</title>
    <url>/article/csdn/LightOJ_1149_-_Factors_and_Multiples%E3%80%90%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48008797" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48008797</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1149" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1149
</a></p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;sstream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  

using namespace std;

int n, m;
int p[1000][1000];
int book[1000];
int match[1000];

int dfs(int u)
{
    int i;
    for (i = 1;i &lt;= m;i++)
    {
        if (book[i] == 0 &amp;&amp; p[u][i] == 1)
        {
            book[i] = 1;
            if (match[i] == 0 || dfs(match[i]))
            {
                match[i] = u;
                return 1;
            }
        }
    }
    return 0;
}

int a[110], b[110];

int main()
{
    int t;
    int cases = 1;
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    {
        scanf(&quot;%d&quot;,&amp;n);
        for (int i = 1;i &lt;= n;i++) scanf(&quot;%d&quot;, &amp;a[i]);

        scanf(&quot;%d&quot;, &amp;m);
        for (int i = 1;i &lt;= m;i++) scanf(&quot;%d&quot;, &amp;b[i]);

        int ans = 0;
        memset(match, 0, sizeof(match));
        memset(p, 0, sizeof(p));

        for (int i = 1;i &lt;= n;i++)
            for (int j = 1;j &lt;= m;j++)
                if (b[j] % a[i] == 0) p[i][j] = 1;

        for (int i = 1;i &lt;= n;i++)
        {
            memset(book, 0, sizeof(book));
            if (dfs(i))
                ans++;
        }
        printf(&quot;Case %d: %d\n&quot;, cases++, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>lightoj</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ 1079 - Just another Robbery 【背包问题】</title>
    <url>/article/csdn/LightOJ_1079_-_Just_another_Robbery_%E3%80%90%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/50767746" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/50767746</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1079" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1079
</a></p>
<p>题意：<br>给你一些银行的存储金钱的数目及被抓的概率，若被抓总概率不超过p的话，问不被抓的条件下最多可以抢多少钱？</p>
<p>思路：<br>对于一个银行，可以抢或者不抢，于是想到了背包。</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;

using namespace std;

double p;
int n;

int a[110];
double b[110];
double dp[11000];


int main()
{
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    for (int t = 1;t &lt;= T;t++)
    {
        memset(dp, 0, sizeof(dp));

        scanf(&quot;%lf%d&quot;, &amp;p, &amp;n);

        int sum = 0;
        for (int i = 1;i &lt;= n;i++)
        {
            scanf(&quot;%d%lf&quot;, &amp;a[i], &amp;b[i]);
            sum += a[i];
        }

        dp[0] = 1;

        for (int i = 1;i &lt;= n;i++)
        {
            for (int j = sum;j &gt;= a[i];j--)
            {
                dp[j] = max(dp[j], dp[j - a[i]] * (1 - b[i]));              
            }
        }

        int ans = 0;
        for (int i = 0;i &lt;= sum;i++)
        {
            if (1 - dp[i] &lt; p)
            ans = max(i, ans);
        }

        printf(&quot;Case %d: %d\n&quot;, t, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ 1153 - Internet Bandwidth【最大流】</title>
    <url>/article/csdn/LightOJ_1153_-_Internet_Bandwidth%E3%80%90%E6%9C%80%E5%A4%A7%E6%B5%81%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48139363" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48139363</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1153" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1153
</a></p>
<p>注意自环</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;sstream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  

using namespace std;

const int MAXN = 10100;//点数的最大值
const int MAXM = 4000100;//边数的最大值
const int INF = 0x3f3f3f3f;
struct Edge
{
    int to, next, cap, flow;
}edge[MAXM];//注意是MAXM
int tol;
int head[MAXN];
int gap[MAXN], dep[MAXN], pre[MAXN], cur[MAXN];
void init()
{
    tol = 0;
    memset(head, -1, sizeof(head));
}
//加边，单向图三个参数，双向图四个参数
void addedge(int u, int v, int w, int rw = 0)
{
    edge[tol].to = v; edge[tol].cap = w; edge[tol].next = head[u];
    edge[tol].flow = 0; head[u] = tol++;
    edge[tol].to = u; edge[tol].cap = rw; edge[tol].next = head[v];
    edge[tol].flow = 0; head[v] = tol++;
}
//输入参数：起点、终点、点的总数
//点的编号没有影响，只要输入点的总数
int sap(int start, int end, int N)
{
    memset(gap, 0, sizeof(gap));
    memset(dep, 0, sizeof(dep));
    memcpy(cur, head, sizeof(head));
    int u = start;
    pre[u] = -1;
    gap[0] = N;
    int ans = 0;
    while (dep[start] &lt; N)
    {
        if (u == end)
        {
            int Min = INF;
            for (int i = pre[u]; i != -1; i = pre[edge[i ^ 1].to])
                if (Min &gt; edge[i].cap - edge[i].flow)
                    Min = edge[i].cap - edge[i].flow;
            for (int i = pre[u]; i != -1; i = pre[edge[i ^ 1].to])
            {
                edge[i].flow += Min;
                edge[i ^ 1].flow -= Min;
            }
            u = start;
            ans += Min;
            continue;
        }
        bool flag = false;
        int v;
        for (int i = cur[u]; i != -1; i = edge[i].next)
        {
            v = edge[i].to;
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[v] + 1 == dep[u])
            {
                flag = true;
                cur[u] = pre[v] = i;
                break;
            }
        }
        if (flag)
        {
            u = v;
            continue;
        }
        int Min = N;
        for (int i = head[u]; i != -1; i = edge[i].next)
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min)
            {
                Min = dep[edge[i].to];
                cur[u] = i;
            }
        gap[dep[u]]--;
        if (!gap[dep[u]])return ans;
        dep[u] = Min + 1;
        gap[dep[u]]++;
        if (u != start) u = edge[pre[u] ^ 1].to;
    }
    return ans;
}

int m, n, s, t;
int a, b, c;

int main()
{
    int T, cases = 1;
    scanf(&quot;%d&quot;, &amp;T);
    while (T--)
    {
        init();
        scanf(&quot;%d&quot;, &amp;n);
        scanf(&quot;%d%d%d&quot;, &amp;s, &amp;t, &amp;m);
        while (m--)
        {
            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
            if (a != b)
            {
                addedge(a, b, c, c);
            }
        }
        int ans = sap(s, t, n);
        printf(&quot;Case %d: %d\n&quot;, cases++, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ 1104 - Birthday Paradox【概率】</title>
    <url>/article/csdn/LightOJ_1104_-_Birthday_Paradox%E3%80%90%E6%A6%82%E7%8E%87%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46455747" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46455747</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1104" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1104
</a><br>题意：生日驳论，求最小满足条件的人数<br>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;bitset&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;
#include &lt;map&gt;
#include &lt;set&gt;

using namespace std;

int t;
int n;
int dp[100010];

int main()
{
    cin &gt;&gt; t;
    for (int ca = 1; ca &lt;= t; ca++)
    {
        memset(dp,0,sizeof(dp));
        cin &gt;&gt; n;
        cout &lt;&lt; &quot;Case &quot; &lt;&lt; ca &lt;&lt; &quot;: &quot;;
        if (n == 1)
            cout &lt;&lt; 1 &lt;&lt; endl;
        else
        {
            double ans = 1.0;
            int i;
            for ( i = 1; i &lt;= n; i++)
            {
                ans *= ((n - i)*1.0 / n);
                if (ans &lt;= 0.5)
                    break;
            }
            cout &lt;&lt; i &lt;&lt; endl;
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ 1152 - Hiding Gold【二分图】</title>
    <url>/article/csdn/LightOJ_1152_-_Hiding_Gold%E3%80%90%E4%BA%8C%E5%88%86%E5%9B%BE%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48032295" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48032295</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1152" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1152
</a></p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;sstream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  

using namespace std;

int n, m;
int p[1010][1010];
int book[1010];
int match[1010];

int dfs(int u)
{
    for (int v = 0; v &lt; n*m; v++)
    {
        if (book[v] == 0 &amp;&amp; p[u][v] == 1)
        {
            book[v] = 1;
            if (match[v] == 0 || dfs(match[v]))
            {
                match[v] = u;
                return 1;
            }
        }
    }
    return 0;
}

char s[110][110];
int dir[][2] = { {1,0},{-1,0},{0,1},{0,-1} };
int is_ok(int x, int y)
{
    if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m) return 1;
    return 0 ;
}

int main()
{
    int t;
    int cases = 1;
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        for (int i = 0; i &lt; n; i++) scanf(&quot;%s&quot;, s[i]);

        int ans = 0;
        memset(match, 0, sizeof(match));
        memset(p, 0, sizeof(p));

        int sum = 0;
        for (int i = 0;i &lt; n;i++)
            for (int j = 0;j &lt; m;j++)
            {
                if (s[i][j] == &#39;*&#39;)
                {
                    sum++;
                    for (int k = 0;k &lt; 4;k++)
                    {
                        int x = i + dir[k][0];
                        int y = j + dir[k][1];
                        if (is_ok(x, y) &amp;&amp; s[x][y] == &#39;*&#39;)
                            p[i*m + j][x*m + y] = 1;
                    }
                }
            }


        for (int i = 0; i &lt; n*m; i++)
        {
            memset(book, 0, sizeof(book));
            if (dfs(i))
                ans++;
        }
        printf(&quot;Case %d: %d\n&quot;, cases++, sum - ans / 2);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>lightoj</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ 1176 - Getting a T-shirt【最大流】</title>
    <url>/article/csdn/LightOJ_1176_-_Getting_a_T-shirt%E3%80%90%E6%9C%80%E5%A4%A7%E6%B5%81%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48167669" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48167669</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1176" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1176
</a></p>
<p>建图：源点向人，人向6*n个衣服，衣服向汇点，容量均为1。</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;sstream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;string&gt;

using namespace std;

const int MAXN = 1010;//点数的最大值
const int MAXM = 400100;//边数的最大值
const int INF = 0x3f3f3f3f;

struct Edge
{
    int to, next, cap, flow;
}edge[MAXM];//注意是MAXM

int tol;
int head[MAXN];
int gap[MAXN], dep[MAXN], pre[MAXN], cur[MAXN];

void init()
{
    tol = 0;
    memset(head, -1, sizeof(head));
}
//加边，单向图三个参数，双向图四个参数
void addedge(int u, int v, int w, int rw = 0)
{
    edge[tol].to = v; edge[tol].cap = w; edge[tol].next = head[u];
    edge[tol].flow = 0; head[u] = tol++;
    edge[tol].to = u; edge[tol].cap = rw; edge[tol].next = head[v];
    edge[tol].flow = 0; head[v] = tol++;
}
//输入参数：起点、终点、点的总数
//点的编号没有影响，只要输入点的总数
int sap(int start, int end, int N)
{
    memset(gap, 0, sizeof(gap));
    memset(dep, 0, sizeof(dep));
    memcpy(cur, head, sizeof(head));
    int u = start;
    pre[u] = -1;
    gap[0] = N;
    int ans = 0;
    while (dep[start] &lt; N)
    {
        if (u == end)
        {
            int Min = INF;
            for (int i = pre[u]; i != -1; i = pre[edge[i ^ 1].to])
                if (Min &gt; edge[i].cap - edge[i].flow)
                    Min = edge[i].cap - edge[i].flow;
            for (int i = pre[u]; i != -1; i = pre[edge[i ^ 1].to])
            {
                edge[i].flow += Min;
                edge[i ^ 1].flow -= Min;
            }
            u = start;
            ans += Min;
            continue;
        }
        bool flag = false;
        int v;
        for (int i = cur[u]; i != -1; i = edge[i].next)
        {
            v = edge[i].to;
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[v] + 1 == dep[u])
            {
                flag = true;
                cur[u] = pre[v] = i;
                break;
            }
        }
        if (flag)
        {
            u = v;
            continue;
        }
        int Min = N;
        for (int i = head[u]; i != -1; i = edge[i].next)
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min)
            {
                Min = dep[edge[i].to];
                cur[u] = i;
            }
        gap[dep[u]]--;
        if (!gap[dep[u]])return ans;
        dep[u] = Min + 1;
        gap[dep[u]]++;
        if (u != start) u = edge[pre[u] ^ 1].to;
    }
    return ans;
}

int m, n, ans;
string a, b;

map&lt;string, int&gt; Mp;

int main()
{
    Mp.clear();
    Mp.insert(make_pair(&quot;XXL&quot;, 1));
    Mp.insert(make_pair(&quot;XL&quot;, 2));
    Mp.insert(make_pair(&quot;L&quot;, 3));
    Mp.insert(make_pair(&quot;M&quot;, 4));
    Mp.insert(make_pair(&quot;S&quot;, 5));
    Mp.insert(make_pair(&quot;XS&quot;, 6));

    int T, cases = 1;
    cin &gt;&gt; T;
    while (T--)
    {
        init();
        cin &gt;&gt; n &gt;&gt; m;


        for (int i = 1;i &lt;= m;i++) addedge(0, i, 1);

        for (int i = m + 1;i &lt;= m + 6 * n;i++) addedge(i, m + 6 * n + 1, 1);

        for (int i = 1;i &lt;= m;i++)
        {
            cin &gt;&gt; a &gt;&gt; b;
            int t1 = Mp[a];
            int t2 = Mp[b];
            for (int j = 0;j &lt; n;j++)
            {
                addedge(i, m + j * 6 + t1, 1);
                addedge(i, m + j * 6 + t2, 1);
            }
        }
        ans = sap(0, 6 * n + m + 1, 6 * n + m + 2);
        printf(&quot;Case %d: &quot;, cases++);
        if (ans == m) puts(&quot;YES&quot;);
        else puts(&quot;NO&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ 1201 - A Perfect Murder【二分图最大独立集】</title>
    <url>/article/csdn/LightOJ_1201_-_A_Perfect_Murder%E3%80%90%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48010113" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48010113</a></p>
<p>链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1201" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1201
</a></p>
<p>最大独立集= 顶点数- 最大匹配</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;sstream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  

using namespace std;

int n, m;
int p[1010][1010];
int book[1010];
int match[1010];

int dfs(int u)
{
    int i;
    for (i = 1;i &lt;= n;i++)
    {
        if (book[i] == 0 &amp;&amp; p[u][i] == 1)
        {
            book[i] = 1;
            if (match[i] == 0 || dfs(match[i]))
            {
                match[i] = u;
                return 1;
            }
        }
    }
    return 0;
}


int main()
{
    int t;
    int cases = 1;
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    {
        int ans = 0;
        memset(match, 0, sizeof(match));
        memset(p, 0, sizeof(p));

        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        int a, b;
        while (m--)
        {
            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
            p[a][b] = p[b][a] = 1;

        }

        for (int i = 1;i &lt;= n;i++)
        {
            memset(book, 0, sizeof(book));
            if (dfs(i))
                ans++;
        }
        printf(&quot;Case %d: %d\n&quot;, cases++,n - ans/2);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ 1184 - Marriage Media 【二分图最大匹配】</title>
    <url>/article/csdn/LightOJ_1184_-_Marriage_Media_%E3%80%90%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48020829" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48020829</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1184" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1184
</a></p>
<p>根据一些要求建图即可</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;sstream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  

using namespace std;

int n, m;
int p[1000][1000];
int book[1000];
int match[1000];

int dfs(int u)
{
    int i;
    for (i = 1; i &lt;= m; i++)
    {
        if (book[i] == 0 &amp;&amp; p[u][i] == 1)
        {
            book[i] = 1;
            if (match[i] == 0 || dfs(match[i]))
            {
                match[i] = u;
                return 1;
            }
        }
    }
    return 0;
}


struct peo
{
    int hig;
    int age;
    int ok;
}a[110], b[110];

int main()
{
    int t;
    int cases = 1;
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);

        for (int i = 1; i &lt;= n; i++) scanf(&quot;%d%d%d&quot;, &amp;a[i].hig, &amp;a[i].age, &amp;a[i].ok);
        for (int i = 1; i &lt;= m; i++) scanf(&quot;%d%d%d&quot;, &amp;b[i].hig, &amp;b[i].age, &amp;b[i].ok);

        int ans = 0;
        memset(match, 0, sizeof(match));
        memset(p, 0, sizeof(p));

        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= m; j++)
            {
                if (a[i].ok == b[j].ok &amp;&amp; abs(a[i].hig - b[j].hig) &lt;= 12 &amp;&amp; abs(a[i].age - b[j].age) &lt;= 5)
                p[i][j] = 1;
            }

        for (int i = 1; i &lt;= n; i++)
        {
            memset(book, 0, sizeof(book));
            if (dfs(i))
                ans++;
        }
        printf(&quot;Case %d: %d\n&quot;, cases++, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>lightoj</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ 1155 - Power Transmission【拆点网络流】</title>
    <url>/article/csdn/LightOJ_1155_-_Power_Transmission%E3%80%90%E6%8B%86%E7%82%B9%E7%BD%91%E7%BB%9C%E6%B5%81%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48165021" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48165021</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1155" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1155
</a></p>
<p>1~N每个点有容量限制，这样就把每个点拆开，容量为限制的容量。</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;sstream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  

using namespace std;

const int MAXN = 1010;//点数的最大值
const int MAXM = 400100;//边数的最大值
const int INF = 0x3f3f3f3f;

struct Edge
{
    int to, next, cap, flow;
}edge[MAXM];//注意是MAXM

int tol;
int head[MAXN];
int gap[MAXN], dep[MAXN], pre[MAXN], cur[MAXN];

void init()
{
    tol = 0;
    memset(head, -1, sizeof(head));
}
//加边，单向图三个参数，双向图四个参数
void addedge(int u, int v, int w, int rw = 0)
{
    edge[tol].to = v; edge[tol].cap = w; edge[tol].next = head[u];
    edge[tol].flow = 0; head[u] = tol++;
    edge[tol].to = u; edge[tol].cap = rw; edge[tol].next = head[v];
    edge[tol].flow = 0; head[v] = tol++;
}
//输入参数：起点、终点、点的总数
//点的编号没有影响，只要输入点的总数
int sap(int start, int end, int N)
{
    memset(gap, 0, sizeof(gap));
    memset(dep, 0, sizeof(dep));
    memcpy(cur, head, sizeof(head));
    int u = start;
    pre[u] = -1;
    gap[0] = N;
    int ans = 0;
    while (dep[start] &lt; N)
    {
        if (u == end)
        {
            int Min = INF;
            for (int i = pre[u]; i != -1; i = pre[edge[i ^ 1].to])
                if (Min &gt; edge[i].cap - edge[i].flow)
                    Min = edge[i].cap - edge[i].flow;
            for (int i = pre[u]; i != -1; i = pre[edge[i ^ 1].to])
            {
                edge[i].flow += Min;
                edge[i ^ 1].flow -= Min;
            }
            u = start;
            ans += Min;
            continue;
        }
        bool flag = false;
        int v;
        for (int i = cur[u]; i != -1; i = edge[i].next)
        {
            v = edge[i].to;
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[v] + 1 == dep[u])
            {
                flag = true;
                cur[u] = pre[v] = i;
                break;
            }
        }
        if (flag)
        {
            u = v;
            continue;
        }
        int Min = N;
        for (int i = head[u]; i != -1; i = edge[i].next)
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min)
            {
                Min = dep[edge[i].to];
                cur[u] = i;
            }
        gap[dep[u]]--;
        if (!gap[dep[u]])return ans;
        dep[u] = Min + 1;
        gap[dep[u]]++;
        if (u != start) u = edge[pre[u] ^ 1].to;
    }
    return ans;
}

int m, n, s, t;
int a, b, c;

int store[110];

int main()
{
    int T, cases = 1;
    scanf(&quot;%d&quot;, &amp;T);
    while (T--)
    {
        init();
        scanf(&quot;%d&quot;, &amp;n);
        for (int i = 1;i &lt;= n;i++) scanf(&quot;%d&quot;, &amp;store[i]);
        for (int i = 1;i &lt;= n;i++) addedge(i, i + n, store[i]);

        scanf(&quot;%d&quot;, &amp;m);
        while (m--)
        {
            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
            addedge(a + n, b, c);
        }
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        while (a--)
        {
            scanf(&quot;%d&quot;, &amp;c);
            addedge(0, c, 11111);
        }
        while (b--)
        {
            scanf(&quot;%d&quot;, &amp;c);
            addedge(c + n, 2 * n+1, 11111);
        }
        int ans = sap(0, 2 * n + 1, 2 * n + 2);
        printf(&quot;Case %d: %d\n&quot;, cases++, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>lightoj</tag>
        <tag>网络</tag>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ 1177 - Angry Programmer【最大流最小割】</title>
    <url>/article/csdn/LightOJ_1177_-_Angry_Programmer%E3%80%90%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48182521" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48182521</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1177" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1177
</a></p>
<p>题意为求最小割。由最小割最大流定理 ：最小割 ==》最大流</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;sstream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;string&gt;

using namespace std;

const int MAXN = 1010;//点数的最大值
const int MAXM = 400100;//边数的最大值
const int INF = 0x3f3f3f3f;

struct Edge
{
    int to, next, cap, flow;
}edge[MAXM];//注意是MAXM

int tol;
int head[MAXN];
int gap[MAXN], dep[MAXN], pre[MAXN], cur[MAXN];

void init()
{
    tol = 0;
    memset(head, -1, sizeof(head));
}
//加边，单向图三个参数，双向图四个参数
void addedge(int u, int v, int w, int rw = 0)
{
    edge[tol].to = v; edge[tol].cap = w; edge[tol].next = head[u];
    edge[tol].flow = 0; head[u] = tol++;
    edge[tol].to = u; edge[tol].cap = rw; edge[tol].next = head[v];
    edge[tol].flow = 0; head[v] = tol++;
}
//输入参数：起点、终点、点的总数
//点的编号没有影响，只要输入点的总数
int sap(int start, int end, int N)
{
    memset(gap, 0, sizeof(gap));
    memset(dep, 0, sizeof(dep));
    memcpy(cur, head, sizeof(head));
    int u = start;
    pre[u] = -1;
    gap[0] = N;
    int ans = 0;
    while (dep[start] &lt; N)
    {
        if (u == end)
        {
            int Min = INF;
            for (int i = pre[u]; i != -1; i = pre[edge[i ^ 1].to])
                if (Min &gt; edge[i].cap - edge[i].flow)
                    Min = edge[i].cap - edge[i].flow;
            for (int i = pre[u]; i != -1; i = pre[edge[i ^ 1].to])
            {
                edge[i].flow += Min;
                edge[i ^ 1].flow -= Min;
            }
            u = start;
            ans += Min;
            continue;
        }
        bool flag = false;
        int v;
        for (int i = cur[u]; i != -1; i = edge[i].next)
        {
            v = edge[i].to;
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[v] + 1 == dep[u])
            {
                flag = true;
                cur[u] = pre[v] = i;
                break;
            }
        }
        if (flag)
        {
            u = v;
            continue;
        }
        int Min = N;
        for (int i = head[u]; i != -1; i = edge[i].next)
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min)
            {
                Min = dep[edge[i].to];
                cur[u] = i;
            }
        gap[dep[u]]--;
        if (!gap[dep[u]])return ans;
        dep[u] = Min + 1;
        gap[dep[u]]++;
        if (u != start) u = edge[pre[u] ^ 1].to;
    }
    return ans;
}

int n, m;
int cost[100];

int main()
{
    int t, cases = 1;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        init();
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        for (int i = 2;i &lt; n;i++) scanf(&quot;%d&quot;, &amp;cost[i]);
        for (int i = 2;i &lt; n;i++) addedge(i, i + n, cost[i]);

        addedge(1, n + 1, 100000000);
        addedge(n, n*n, 100000000);

        int a, b, c;
        while (m--)
        {
            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
            addedge(a + n, b, c);
            addedge(b + n, a, c);
        }
        int ans = sap(1, n, n * 2);
        printf(&quot;Case %d: %d\n&quot;, cases++, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>lightoj</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ 1209 - Strange Voting 【二分图匹配】</title>
    <url>/article/csdn/LightOJ_1209_-_Strange_Voting_%E3%80%90%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48116281" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48116281</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1209" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1209
</a></p>
<p>解法：想了几种方法 ，都是错的，遂看了别人的。get正确姿势。按投票男女分类，关系矛盾的连边。</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;sstream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  

using namespace std;

int n, m, q;
int p[510][510];
int book[510];
int match[510];

int dfs(int u)
{
    for (int v = 1; v &lt;= m; v++)
    {
        if (book[v] == 0 &amp;&amp; p[u][v] == 1)
        {
            book[v] = 1;
            if (match[v] == 0 || dfs(match[v]))
            {
                match[v] = u;
                return 1;
            }
        }
    }
    return 0;
}

char a[10], b[10];

struct node
{
    int u, v;
}t1[510], t2[510];

int main()
{
    int t;
    int cases = 1;
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    {
        scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q);

        n = m = 0;
        memset(match, 0, sizeof(match));
        memset(p, 0, sizeof(p));

        for (int i = 1; i &lt;= q; i++)
        {
            scanf(&quot;%s %s&quot;,a,b);
            if (a[0] == &#39;M&#39;)
            {
                n++;
                sscanf(a, &quot;%*c%d&quot;, &amp;t1[n].u);
                sscanf(b, &quot;%*c%d&quot;, &amp;t1[n].v);
            }
            else
            {
                m++;
                sscanf(a, &quot;%*c%d&quot;, &amp;t2[m].u);
                sscanf(b, &quot;%*c%d&quot;, &amp;t2[m].v);
            }
        }

        for (int i = 1; i &lt;= n; i++)
            for (int j = 1;j &lt;= m;j++)
            {
                if (t1[i].u == t2[j].v || t1[i].v == t2[j].u)
                    p[i][j] = 1;
            }

        int ans = 0;
        for (int i = 1; i &lt;= n; i++)
        {
            memset(book, 0, sizeof(book));
            if (dfs(i))
                ans++;
        }
        printf(&quot;Case %d: %d\n&quot;, cases++, q - ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>lightoj</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ 1231 - Coin Change (I) 【DP】</title>
    <url>/article/csdn/LightOJ_1231_-_Coin_Change_(I)_%E3%80%90DP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46509255" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46509255</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1231" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1231
</a><br>题意：多重部分和的解法有几种。<br>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int n, k;
int val[110],num[110];
int dp[110][1100];

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    for (int ca = 1; ca &lt;= t; ca++)
    {
        scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
        for (int i = 0; i &lt; n; i++)
            scanf(&quot;%d&quot;,&amp;val[i]);
        for (int i = 0; i &lt; n; i++)
            scanf(&quot;%d&quot;, &amp;num[i]);

        memset(dp,0,sizeof(dp));
        dp[0][0] = 1;

        for (int i = 0; i &lt; n; i++)
            for (int j = 0; j &lt;= k; j++)
                for (int p = 0; p &lt;= num[i] &amp;&amp; p*val[i] &lt;= j; p++)
                    dp[i + 1][j] = (dp[i + 1][j] + dp[i][j - p*val[i]]) % 100000007;
        printf(&quot;Case %d: %d\n&quot;,ca,dp[n][k]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ 1210 - Efficient Traffic System【强连通图】</title>
    <url>/article/csdn/LightOJ_1210_-_Efficient_Traffic_System%E3%80%90%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%9B%BE%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48457237" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48457237</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1210" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1210
</a></p>
<p>题意：<br>加多少条边，使得整个图变得强连通。<br>使用Tarjan进行缩点，得到一个SCC图、<br>这个图有多少个入度为0的，多少个出度为0的。<br>假设有n个入度为0，m个出度为0<br>那么答案是max(n,m)</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;sstream&gt;
#include &lt;time.h&gt;

using namespace std;

const int MAXN = 200100;
const int MAXM = 500100;

struct Edge
{
    int to, next;
}edge[MAXM];

int head[MAXM], tot;
int Low[MAXN], Dfn[MAXN], Stack[MAXN], Belong[MAXN];//Belong的值为 1 ~ scc
int Index, top;
int scc;//强连通个数
bool Instack[MAXN];
int num[MAXN];//各个强连通包含的点的个数

void addedge(int u, int v)
{
    edge[tot].to = v;
    edge[tot].next = head[u];
    head[u] = tot++;
}

void Tarjan(int u)
{
    int v;
    Low[u] = Dfn[u] = ++Index;
    Stack[top++] = u;
    Instack[u] = true;
    for (int i = head[u]; i != -1; i = edge[i].next)
    {
        v = edge[i].to;
        if (!Dfn[v])
        {
            Tarjan(v);
            if (Low[u] &gt; Low[v])
                Low[u] = Low[v];
        }
        else if (Instack[v] &amp;&amp; Low[u] &gt; Dfn[v])
            Low[u] = Dfn[v];
    }
    if (Low[u] == Dfn[u])
    {
        scc++;
        do
        {
            v = Stack[--top];
            Instack[v] = false;
            Belong[v] = scc;
            num[scc]++;
        } while (v != u);
    }
}

int in[MAXN], out[MAXN];
int cases = 1;

void solve(int N)
{
    memset(Dfn, 0, sizeof(Dfn));
    memset(Instack, false, sizeof(Instack));
    memset(num, 0, sizeof(num));
    Index = scc = top = 0;
    for (int i = 1; i &lt;= N; i++)
    {
        if (!Dfn[i])
            Tarjan(i);
    }
    printf(&quot;Case %d: &quot;,cases++);

    if (scc == 1)
    {
        printf(&quot;0\n&quot;);
        return;
    }
    for (int i = 1; i &lt;= scc; i++)
        in[i] = out[i] = 0;
    for (int u = 1; u &lt;= N; u++)
    {
        for (int i = head[u]; i != -1; i = edge[i].next)
        {
            int v = edge[i].to;
            if (Belong[u] != Belong[v])
            {
                in[Belong[v]]++;
                out[Belong[u]]++;
            }
        }
    }
    int ans1 = 0, ans2 = 0;
    for (int i = 1; i &lt;= scc; i++)
    {
        if (in[i] == 0) ans1++;
        if (out[i] == 0) ans2++;
    }
    printf(&quot;%d\n&quot;, max(ans1, ans2));
}

void init()
{
    tot = 0;
    memset(head, -1, sizeof(head));
}

int main()
{
    int n, t, m;
    int u, v;
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    {
        init();
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        for (int i = 1; i &lt;= m; i++)
        {
            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
            {
                addedge(u, v);
            }
        }
        solve(n);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>lightoj</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ 1341 - Aladdin and the Flying Carpet【合数分解】</title>
    <url>/article/csdn/LightOJ_1341_-_Aladdin_and_the_Flying_Carpet%E3%80%90%E5%90%88%E6%95%B0%E5%88%86%E8%A7%A3%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46535889" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46535889</a></p>
<p>题目链接： <a href="http://lightoj.com/volume_showproblem.php?problem=1341" target="_blank" rel="noopener"> http://lightoj.com/volume_showproblem.php?problem=1341
</a></p>
<p>题意：<br>给出整数 a 和 b ，求区间[b, a] 内的 a 的约数对的个数，a 的约数对（比如[2, 3] 与 [3, 2] 为同一对）。</p>
<p>解法：<br>主要利用公式:<br>一个整数ｎ可以表示为若干素数乘积：　n = p1^a1 <em> p2^a2</em>…<em>pm^am;<br>则 n 的正因数的个数可以表示为： num = (a1+1) _</em>(a2+1)…_ (am+1);</p>
<p>代码：</p>
<pre><code> #include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

long long n, m;

const int MAXN = 1000010;

bool notprime[MAXN];//值为false表示素数，值为true表示非素数
int prime[MAXN + 1];

void getPrime()
{
    memset(notprime, false, sizeof(notprime));
    notprime[0] = notprime[1] = true;
    memset(prime, 0, sizeof(prime));
    for (int i = 2; i &lt;= MAXN; i++)
    {
        if (!notprime[i])prime[++prime[0]] = i;
        for (int j = 1; j &lt;= prime[0] &amp;&amp; prime[j] &lt;= MAXN / i; j++)
        {
            notprime[prime[j] * i] = true;
            if (i%prime[j] == 0) break;
        }
    }
}

int getFactors()
{
    int ans = 1;
    int fatCnt = 0;
    long long tmp = n;
    if (n / m &lt; m) return 0;
    for (int i = 1; prime[i] &lt;= tmp / prime[i]; i++)
    {
        int c = 0;
        while (tmp%prime[i] == 0)
        {
            c++;
            tmp /= prime[i];
        }
        ans *= (c + 1);
    }
    if (tmp &gt; 1)
        ans &lt;&lt;= 1;
    ans &gt;&gt;= 1;
    for (int i = 1; i &lt; m; i++)
        if (n % i == 0)
            ans--;

    return ans;
}

int main()
{
    getPrime();
    int t;
    scanf(&quot;%d&quot;, &amp;t);
    for (int cases = 1; cases &lt;= t; cases++)
    {
        scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);
        printf(&quot;Case %d: %d\n&quot;, cases, getFactors());
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ 1422 Halloween Costumes 【区间DP】</title>
    <url>/article/csdn/LightOJ_1422_Halloween_Costumes_%E3%80%90%E5%8C%BA%E9%97%B4DP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46540437" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46540437</a></p>
<p>题目链接： <a href="http://lightoj.com/volume_showproblem.php?problem=1422" target="_blank" rel="noopener"> http://lightoj.com/volume_showproblem.php?problem=1422
</a></p>
<p>解法：dp[i][j]=min(1+dp[i+1][j],dp[i+1][k-1]+dp[k][j])</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int c[110];
int t, n;
int dp[110][110];

int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    for (int ca = 1; ca &lt;= t; ca++)
    {
        scanf(&quot;%d&quot;,&amp;n);
        for (int i = 1; i &lt;= n; i++)
            scanf(&quot;%d&quot;,&amp;c[i]);

        memset(dp,0,sizeof(dp));
        for (int i = 1; i &lt;= n; i++)
            for (int j = i; j &lt;= n; j++)
                dp[i][j] = j - i + 1;

        for (int i = n-1; i &gt;= 1; i--)
            for (int j = i + 1; j &lt;= n; j++)
            {
                dp[i][j] = dp[i+1][j] + 1;//表示第i个的衣服在后面没有利用了
                for (int k = i+1; k &lt;= j; k++)
                    if (c[i] == c[k])//用同一件衣服
                        dp[i][j] = min(dp[i][j],dp[i+1][k-1] + dp[k][j]);
            }

        printf(&quot;Case %d: %d\n&quot;,ca,dp[1][n]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ 1232 - Coin Change (II) 【完全背包】</title>
    <url>/article/csdn/LightOJ_1232_-_Coin_Change_(II)_%E3%80%90%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46515569" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46515569</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1232" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1232
</a><br>题意：每个物品价值为val[i] (&gt;=1)，每个物品有k种，组成价值为k的方案数。完全背包。<br>解法：完全背包计数。<br>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int n, k;
int val[110];
int dp[10100];

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    for (int ca = 1; ca &lt;= t; ca++)
    {
        scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
        for (int i = 0; i &lt; n; i++)
            scanf(&quot;%d&quot;,&amp;val[i]);

        //  完全背包计数

        memset(dp,0,sizeof(dp));
        dp[0] = 1;
        for (int i = 0; i &lt; n; i++)
            for (int j = val[i]; j &lt;= k; j++)
               dp[j] = (dp[j] + dp[j-val[i]]) % 100000007;

        printf(&quot;Case %d: %d\n&quot;,ca,dp[k]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ 1403 - Air Raid【二分匹配】</title>
    <url>/article/csdn/LightOJ_1403_-_Air_Raid%E3%80%90%E4%BA%8C%E5%88%86%E5%8C%B9%E9%85%8D%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48020945" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48020945</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1403" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1403
</a></p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;sstream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  

using namespace std;

int n, m;
int p[1010][1010];
int book[1010];
int match[1010];
vector&lt;int&gt; g[1010];

int dfs(int u)
{
    int i;
    for (i = 0; i &lt; g[u].size(); i++)
    {
        int v = g[u][i];
        if (book[v] == 0 &amp;&amp; p[u][v] == 1)
        {
            book[v] = 1;
            if (match[v] == 0 || dfs(match[v]))
            {
                match[v] = u;
                return 1;
            }
        }
    }
    return 0;
}

int main()
{
    int t;
    int cases = 1;
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        for (int i = 0; i &lt;= n; i++) g[i].clear();

        int ans = 0;
        memset(match, 0, sizeof(match));
        memset(p, 0, sizeof(p));

        int a, b;
        while (m--)
        {
            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
            p[a][b] = 1;
            g[a].push_back(b);
        }

        for (int i = 1; i &lt;= n; i++)
        {
            memset(book, 0, sizeof(book));
            if (dfs(i))
                ans++;
        }
        printf(&quot;Case %d: %d\n&quot;, cases++, n - ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>lightoj</tag>
        <tag>air</tag>
        <tag>raid</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ 1380 – Teleport 【最小树形图】</title>
    <url>/article/csdn/LightOJ_1380_%E2%80%93_Teleport_%E3%80%90%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/45046821" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/45046821</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1380" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1380
</a></p>
<p>最小树形图也就是有向图的最小生成树。普通的prim无法求解。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;queue&gt;

using namespace std;

const int INF = 0x3f3f3f3f;
const int MAXN = 1010;
const int MAXM = 400100;

struct Edge
{
    int u, v, cost;
};
Edge edge[MAXM];
int pre[MAXN], id[MAXN], visit[MAXN], in[MAXN];
int zhuliu(int root, int n, int m, Edge edge[])
{
    int res = 0, u, v;
    while (1)
    {
        for (int i = 0; i &lt; n; i++)
            in[i] = INF;
        for (int i = 0; i &lt; m; i++)
            if (edge[i].u != edge[i].v &amp;&amp; edge[i].cost &lt; in[edge[i].v])
            {
                pre[edge[i].v] = edge[i].u;
                in[edge[i].v] = edge[i].cost;
            }
        for (int i = 0; i &lt; n; i++)
            if (i != root &amp;&amp; in[i] == INF)
                return -1;
        int tn = 0;
        memset(id, -1, sizeof(id));
        memset(visit, -1, sizeof(visit));
        in[root] = 0;
        for (int i = 0; i &lt; n; i++)
        {
            res += in[i];
            v = i;
            while (visit[v] != i &amp;&amp; id[v] == -1 &amp;&amp; v != root)
            {
                visit[v] = i;
                v = pre[v];
            }
            if (v != root &amp;&amp; id[v] == -1)
            {
                for (int u = pre[v]; u != v; u = pre[u])
                    id[u] = tn;
                id[v] = tn++;
            }
        }
        if (tn == 0)break;
        for (int i = 0; i &lt; n; i++)
            if (id[i] == -1)
                id[i] = tn++;
        for (int i = 0; i &lt; m;)
        {
            v = edge[i].v;
            edge[i].u = id[edge[i].u];
            edge[i].v = id[edge[i].v];
            if (edge[i].u != edge[i].v)
                edge[i++].cost -= in[v];
            else
                swap(edge[i], edge[--m]);
        }
        n = tn;
        root = id[root];
    }
    return res;
}
int g[MAXN][MAXN];


int a[100];
int sum[100];

void init(int n)
{
    for (int i = 0; i &lt;= n; i++)
        for (int j = 0; j &lt;= n; j++)
        {
            if (i == j)
                g[i][j] = 0;
            else
                g[i][j] = g[j][i] = INF;
        }
}

int main()
{
    int t, n, m, k,a,b,c;
    scanf(&quot;%lld&quot;,&amp;t);
    for (int kk = 1; kk &lt;= t; kk++)
    {
        scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);
        init(n);
        while (m--)
        {
            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
            if (g[a][b] &gt; c)
                g[a][b] =  c;
        }
        int L = 0;
        for (int i = 0; i &lt; n; i++)
            for (int j = 0; j &lt;= n; j++)
            {
                if (g[i][j] &lt; INF)
                {
                    edge[L].u = i;
                    edge[L].v = j;
                    edge[L++].cost = g[i][j];
                }
            }
        int ans = zhuliu(k,n,L,edge);
        if (ans != -1)
            printf(&quot;Case %d: %d\n&quot;, kk, ans);
        else 
            printf(&quot;Case %d: impossible\n&quot;, kk);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ 1400 - Employment【稳定婚姻问题】</title>
    <url>/article/csdn/LightOJ_1400_-_Employment%E3%80%90%E7%A8%B3%E5%AE%9A%E5%A9%9A%E5%A7%BB%E9%97%AE%E9%A2%98%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48393509" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48393509</a></p>
<p>题目连接: <a href="http://www.lightoj.com/volume_showproblem.php?problem=1400" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1400
</a></p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;  
#include &lt;ctype.h&gt;  
#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;stack&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string&gt;  
#include &lt;sstream&gt;  
#include &lt;malloc.h&gt;

using namespace std;

const int MAXN = 1010;
int pref[MAXN][MAXN], order[MAXN][MAXN], Next[MAXN];
int future_husband[MAXN], future_wife[MAXN];
queue&lt;int&gt; q;

void engage(int man, int woman)
{
    int m = future_husband[woman];
    if (m)
    {
        future_wife[m] = 0;
        q.push(m);
    }
    future_wife[man] = woman;
    future_husband[woman] = man;
}

int main()
{
    int t, cases = 1;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        while (!q.empty()) q.pop();
        memset(future_husband, 0, sizeof(future_husband));
        memset(future_wife, 0, sizeof(future_wife));
        memset(Next, 0, sizeof(Next));

        int  n;
        scanf(&quot;%d&quot;, &amp;n);
        for (int i = 1;i &lt;= n;i++)
        {
            for (int j = 1;j &lt;= n;j++)
            {
                int x;
                scanf(&quot;%d&quot;, &amp;x);
                pref[i][j] = x - n;
            }
            Next[i] = 1;
            q.push(i);
        }

        for (int i = 1;i &lt;= n;i++)
        {
            for (int j = 1;j &lt;= n;j++)
            {
                int x;
                scanf(&quot;%d&quot;, &amp;x);
                order[i][x] = j;
            }
        }
        while (!q.empty())
        {
            int man = q.front();q.pop();
            int woman = pref[man][Next[man]++];
            if (!future_husband[woman])
                engage(man, woman);
            else if (order[woman][man] &lt; order[woman][future_husband[woman]])
                engage(man, woman);
            else q.push(man);
        }
        printf(&quot;Case %d:&quot;, cases++);
        for (int i = 1;i &lt;= n;i++)
            printf(&quot; (%d %d)&quot;, i,future_wife[i] + n);
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Light oj 1245  【数学题】</title>
    <url>/article/csdn/Light_oj_1245_%E3%80%90%E6%95%B0%E5%AD%A6%E9%A2%98%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44159345" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44159345</a></p>
<p>1245 - Harmonic Number (II)</p>
<p><a href="http://www.lightoj.com/volume_submit.php?problem=1245" target="_blank" rel="noopener"> <img src="http://www.lightoj.com/images/submit1.png" alt="">
</a> |  <a href="http://www.lightoj.com/volume_showproblem.php?problem=1245&amp;language=english&amp;type=pdf" target="_blank" rel="noopener"> PDF (English)
</a><br>|  <a href="http://www.lightoj.com/volume_problemstat.php?problem=1245" target="_blank" rel="noopener"> Statistics </a><br>|  <a href="http://www.lightoj.com/forum_showproblem.php?problem=1245" target="_blank" rel="noopener"> Forum </a><br>—|—|—|—  </p>
<table>
<thead>
<tr>
<th>Time Limit:  3 second(s)</th>
<th>Memory Limit:  32 MB  </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>I was trying to solve problem <strong>‘1234 - Harmonic Number’</strong> , I wrote the<br>following code</p>
<p>long  long  H  (  int  n  )  {<br>long  long  res  =  0  ;<br>for  (  int  i  =  1  ;  i  &lt;=  n  ;  i  ++  )<br>res  =  res  +  n  /  i  ;<br>return  res  ;<br>}</p>
<p>Yes, my error was that I was using the integer divisions only. However, you<br>are given <strong>n</strong> , you have to find <strong>H(n)</strong> as in my code.</p>
<h1><span id="input">Input</span></h1><p>Input starts with an integer <strong>T (≤ 1000)</strong> , denoting the number of test<br>cases.</p>
<p>Each case starts with a line containing an integer <strong>n (1 ≤ n &lt; 2  31  ) </strong> .</p>
<h1><span id="output">Output</span></h1><p>For each case, print the case number and <strong>H(n)</strong> calculated by the code.</p>
<h1><span id="sample-input">Sample Input</span></h1><p>|</p>
<h1><span id="output-for-sample-input">Output for Sample Input</span></h1><p>—|—  </p>
<p>11</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>2147483647</p>
<p>|</p>
<p>Case 1: 1</p>
<p>Case 2: 3</p>
<p>Case 3: 5</p>
<p>Case 4: 8</p>
<p>Case 5: 10</p>
<p>Case 6: 14</p>
<p>Case 7: 16</p>
<p>Case 8: 20</p>
<p>Case 9: 23</p>
<p>Case 10: 27</p>
<p>Case 11: 46475828386  </p>
<p>运算到sqrt（n）</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;
#include &lt;iterator&gt;

using namespace std;

int t,cases = 1;
int n;
long long ans;

long long solve(long long  n)
{
    long long res = 0;
    for (int i = 1; i &lt;= sqrt(n); i++)
    {
        res += n / i;
        if (n / i &gt; n / (i + 1))
            res += (n / i - n / (i + 1))*i;
    }
    if ((long long)sqrt(n) == n/(long long)sqrt(n))
        res -= (int)sqrt(n);
    return res;
}

int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%d&quot;,&amp;n);
        ans = solve(n);
        printf(&quot;Case %d: %lld\n&quot;,cases++,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ 1433 - Minimum Arc Distance</title>
    <url>/article/csdn/LightOJ_1433_-_Minimum_Arc_Distance.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/49496939" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/49496939</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1433" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1433
</a></p>
<p>题意：给你圆心坐标及圆上的两点坐标，求两点距离。<br>求对应的圆心角度再求距离。水~</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;cmath&gt;
#include &lt;string&gt;
#include &lt;string.h&gt;

using namespace std;

int main()
{
    double x0, y0, x1, y1, x2, y2;
    int t, cases1 = 1;
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    {
        scanf(&quot;%lf%lf%lf%lf%lf%lf&quot;, &amp;x0, &amp;y0, &amp;x1, &amp;y1, &amp;x2, &amp;y2);
        printf(&quot;Case %d: &quot;, cases1++);
        double dis1 = sqrt((x1 - x0)*(x1 - x0) + (y1 - y0)*(y1 - y0));
        double dis2 = sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2));

        double tmp = asinf(dis2*1.0 / 2 / dis1);

        double l = 2.0 *dis1;

        double ans = (tmp) * l;
        printf(&quot;%.6lf\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ Math_Basic Math 专题</title>
    <url>/article/csdn/LightOJ_Math_Basic_Math_%E4%B8%93%E9%A2%98.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46380503" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46380503</a></p>
<p>挖个坑。开始板刷lightoj.</p>
<p>1354 <a href="http://www.lightoj.com/volume_showproblem.php?problem=1354" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1354
</a></p>
<p>2进制与十进制是否相等。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;vector&gt;

using namespace std;

const int MAXN = 101000;

typedef long long LL;

int cases;
char s[MAXN];
LL a, b, c, d, e, num;
char r;

int main()
{
    scanf(&quot;%d&quot;, &amp;cases);
    for (int i = 1; i &lt;= cases; i++)
    {
        scanf(&quot;%lld%c%lld%c%lld%c%lld&quot;, &amp;a, &amp;r, &amp;b, &amp;r, &amp;c, &amp;r, &amp;d);

        scanf(&quot;%s&quot;, s);
        int ok = 1;
        ///////////// a
        e = 0;
        num = 0;
        for (int i = 7; i &gt;= 0; i--)
        {
            if (s[i] == &#39;1&#39;)
                e += pow(2, num);
            num++;
        }
        if (e != a) ok = 0;
        //////////////// b
        e = 0;
        num = 0;
        for (int i = 16; i &gt;= 9; i--)
        {
            if (s[i] == &#39;1&#39;)
                e += pow(2, num);
            num++;
        }
        if (e != b) ok = 0;
        ///////////// c
        e = 0;
        num = 0;
        for (int i = 25; i &gt;= 18; i--)
        {
            if (s[i] == &#39;1&#39;)
                e += pow(2, num);
            num++;
        }
        if (e != c) ok = 0;
        /////////// d
        e = 0;
        num = 0;
        for (int i = 34; i &gt;= 27; i--)
        {
            if (s[i] == &#39;1&#39;)
                e += pow(2, num);
            num++;
        }
        if (e != d) ok = 0;

        printf(&quot;Case %d: &quot;, i);
        if (ok) puts(&quot;Yes&quot;);
        else puts(&quot;No&quot;);
    }
    return 0;
}
</code></pre><p>1214 <a href="http://www.lightoj.com/volume_showproblem.php?problem=1214" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1214
</a></p>
<p>问一个大数是否能被另一个数整除。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

using namespace std;

int cases;
int ok;
long long b;

string s;

int main()
{
    scanf(&quot;%d&quot;, &amp;cases); 
    for (int i = 1; i &lt;= cases; i++)
    {
        cin &gt;&gt; s;
        scanf(&quot;%lld&quot;,&amp;b);

        long long sum = 0;
        for (int i = 0; i &lt; s.size(); i++)
        {
            if (s[i] == &#39;-&#39;) continue;
            sum = (sum * 10 + s[i]-&#39;0&#39;) % b;
        }

        printf(&quot;Case %d: &quot;, i);
        if (!sum) puts(&quot;divisible&quot;);
        else puts(&quot;not divisible&quot;);
    }
    return 0;
}
</code></pre><p>1116 <a href="http://www.lightoj.com/volume_showproblem.php?problem=1116" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1116
</a></p>
<p>问n是否可以分解为一个奇数和一个偶数的乘积<br>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;

using namespace std;

typedef long long LL;

LL n, m;
LL ans;
int cases;

int main()
{
    scanf(&quot;%d&quot;, &amp;cases);
    for (int i = 1; i &lt;= cases; i++)
    {
        scanf(&quot;%lld&quot;, &amp;n);
        printf(&quot;Case %d: &quot;, i);
        LL tmp = 1;

        while (n % 2 == 0)
        {
            n /= 2;
            tmp *= 2;
        }
        if (n % 2 == 1 &amp;&amp; tmp != 1)
            printf(&quot;%lld %lld\n&quot;, n, tmp);
        else
            puts(&quot;Impossible&quot;);
    }
    return 0;
}
</code></pre><p>1294 <a href="http://www.lightoj.com/volume_showproblem.php?problem=1294" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1294
</a></p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;

using namespace std;

typedef long long LL;

LL n, m;
LL ans;
int cases;

int main()
{
    cin &gt;&gt; cases;
    for (int i = 1; i &lt;= cases;i++)
    {
        cin &gt;&gt; n &gt;&gt; m;
        int t = n / m / 2;
        ans = t*m*m;
        cout &lt;&lt; &quot;Case &quot; &lt;&lt; i &lt;&lt; &quot;: &quot;;
        cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}
</code></pre><p>1214<br><a href="http://lightoj.com/volume_showproblem.php?problem=1214" target="_blank" rel="noopener"> http://lightoj.com/volume_showproblem.php?problem=1214
</a><br>判断大数是否能整除</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int t;
char s[10000000];
long long n;

int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    int cases = 1;
    while (t--)
    {
        scanf(&quot;%s %lld&quot;,s,&amp;n);

        printf(&quot;Case %d: &quot;,cases++);
        long long ans = 0;
        int len = strlen(s);
        for (int i = 0; i &lt; len; i++)
        {
            if (s[i] == &#39;-&#39;) continue;
            ans = (ans * 10 + s[i] - &#39;0&#39;) % n;
        }
        if (ans == 0)
            puts(&quot;divisible&quot;);
        else
            puts(&quot;not divisible&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>代码</tag>
        <tag>十进制</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOj 1027 A Dangerous Maze【概率】</title>
    <url>/article/csdn/LightOj_1027_A_Dangerous_Maze%E3%80%90%E6%A6%82%E7%8E%87%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46372409" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46372409</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1027" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1027
</a></p>
<p>题意：<br>你面前有n个门，每个对应一个数字，若为正xi，代表xi分钟后你会从它走出迷宫，负数则说明你会在-xi分钟后回到出发点且失去记忆。求出去的时间的期望。</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;string&gt;
#include &lt;string.h&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

const int MAXN = 10000;
int t ,n;
int p[MAXN];

long long gcd (long long a,long long b)
{
    if (b == 0) return a;
    else return gcd (b,a%b);
}

int main()
{
    cin&gt;&gt;t;
    for(int cases=1;cases&lt;=t;cases++)
    {
        cin&gt;&gt;n;
        int num = 0;
        long long  sum  =0;
        for(int i=1;i&lt;=n;i++)
        {
            cin&gt;&gt;p[i];      
            if (p[i] &gt; 0) num++;
            sum += abs(p[i]);
        }
        int tmp = gcd(sum,num);
        num = num/tmp;
        sum = sum/tmp;
        cout&lt;&lt;&quot;Case &quot;&lt;&lt;cases&lt;&lt;&quot;: &quot;;
        if (num!=0) cout&lt;&lt; sum &lt;&lt;&quot;/&quot;&lt;&lt; num &lt;&lt;endl;
        else cout&lt;&lt;&quot;inf&quot;&lt;&lt;endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Lightoj 1062 - Crossed Ladders【二分】</title>
    <url>/article/csdn/Lightoj_1062_-_Crossed_Ladders%E3%80%90%E4%BA%8C%E5%88%86%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47045881" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47045881</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1062" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1062
</a></p>
<p>题意： 两个梯子靠墙放，一个长度是x一个长度是y，它们交点到地面的距离是c。求这两个梯子底部的距离。</p>
<p>思路：二分底部的距离t，往计算t’ ，根据t和t’的大小关系更新上下界即可。<br>设宽为mid，那么可以求得<br>c/sqrt( y^2 - mid^2 ) + c/sqrt( x^2 - mid ^2 ) = 1</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

double x, y, c;

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    int cases = 1;
    while (t--)
    {
        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;

        double left = 0, right = min(x, y);
        double mid;

        while (left + 0.0000000000001 &lt;= right)
        {
            mid = (left + right) / 2;
            double t1 = sqrt(x*x - mid*mid);
            double t2 = sqrt(y*y - mid*mid);
            double tmp = c / t1 + c / t2;
            if (tmp &gt;= 1) right = mid;
            else left = mid;
        }

        printf(&quot;Case %d: &quot;, cases++);
        printf(&quot;%.8lf\n&quot;,right);
    }
    return 0; 
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Lightoj 1043 - Triangle Partitioning【二分】</title>
    <url>/article/csdn/Lightoj_1043_-_Triangle_Partitioning%E3%80%90%E4%BA%8C%E5%88%86%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47027441" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47027441</a></p>
<p>题目链接： <a href="http://lightoj.com/volume_showproblem.php?problem=1043" target="_blank" rel="noopener"> http://lightoj.com/volume_showproblem.php?problem=1043
</a></p>
<p>题意：一个三角形ABC，DE//BC，已知三角形ADE和四边形BDEC的面积的比，求AD的长度。</p>
<p>解法：二分AD边即可</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int main()
{
    int t; int cases = 1;

    double a, b, c, ratio;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; ratio;

        double s = a*b;
        double ans;

        ratio = ratio / (ratio + 1.0);

        double left = 0, right = a;
        double mid;

        while (left + 0.000000001&lt;= right)
        {
            mid = (left + right) / 2.0;
            ans = mid * b * (mid / a);
            ans /= s;

            if (ans &gt;= ratio) right = mid;
            else left = mid;
        }

        printf(&quot;Case %d: &quot;, cases++);
        printf(&quot;%.9lf\n&quot;, right);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Lightoj 1088 - Points in Segments 【二分】</title>
    <url>/article/csdn/Lightoj_1088_-_Points_in_Segments_%E3%80%90%E4%BA%8C%E5%88%86%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47046355" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47046355</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1088" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1088
</a></p>
<p>题意： 有一维的n个点和q条线段。询问每条线段上的点有多少个；</p>
<p>思路：寻找这些点中对于每条线段的上下界即可。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int n, q;
int a[100010];
int x, y;
int ok;

int query(int t,int &amp;ok)
{
    ok = 0;
    int left = 1;
    int right = n;
    int mid;
    while (left &lt;= right)
    {
        int mid = (left + right) / 2;
        if (a[mid] &gt;= t)
        {
            if (a[mid] == t)
                ok = 1;
            right = mid - 1;
        }
        else
            left = mid + 1;
    }
    return left;
}

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    int cases = 1;
    while (t--)
    {
        scanf(&quot;%d%d&quot;,&amp;n,&amp;q);
        for (int i = 1; i &lt;= n; i++)
            scanf(&quot;%d&quot;,&amp;a[i]);
        printf(&quot;Case %d:\n&quot;, cases++);
        while (q--)
        {
            scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
            int ok1 = 0, ok2 = 0, tmp = 0;
            int t1 = query(x,ok1);
            int t2 = query(y,ok2);
            if (ok2) tmp = 1;
            //printf(&quot;      %d %d\n&quot;,t1,t2);
            printf(&quot;%d\n&quot;, t2 - t1 + tmp);
        }
    }
    return 0; 
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Lightoj 1122 - Digit Count 【DP】</title>
    <url>/article/csdn/Lightoj_1122_-_Digit_Count_%E3%80%90DP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47082191" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47082191</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1122" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1122
</a></p>
<p>题意：给你m个数，选取n个数组成一个整数，使得整数各位的最大数与最小数的差小于2。问有几种选法？</p>
<p>解法：ＤＰ。ｄｐ［ｉ］［ｊ］表示以ｊ结尾的ｉ位整数的解法数目。<br>答案即为ｓｕｍ（ｄｐ［ｎ］［ｋ］　（１＜＝ｋ＜＝９，且ｋ在集合Ｓ中）　）</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int n, m;
int p[15];
int dp[15][15];

int main()
{
    int t;
    int cases = 1;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        memset(dp, 0, sizeof(dp));
        memset(p, 0, sizeof(p));

        scanf(&quot;%d%d&quot;, &amp;m, &amp;n);
        int x;
        for (int i = 1;i &lt;= m;i++)
        {
            scanf(&quot;%d&quot;, &amp;x);
            p[x] = 1;
        }

        for (int i = 1;i &lt;= 9;i++)
        {
            if (p[i])
                dp[1][i] = 1;
        }

        for (int i = 2;i &lt;= n;i++)
            for (int j = 1;j &lt;= 9;j++)
            {
                if (p[j]) dp[i][j] = 0;

                for (int k = 1;k &lt;= 9;k++)
                {
                    if (abs(k - j) &lt;= 2 &amp;&amp; p[k])
                        dp[i][j] += dp[i-1][k];
                }
            }

        int ans = 0;
        for (int i = 1;i &lt;= 9;i++)
            if (p[i]) ans += dp[n][i];

        printf(&quot;Case %d: %d\n&quot;, cases++, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Lightoj 1127 - Funny Knapsack 【二分】</title>
    <url>/article/csdn/Lightoj_1127_-_Funny_Knapsack_%E3%80%90%E4%BA%8C%E5%88%86%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47053287" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47053287</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1127" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1127
</a></p>
<p>题意：有n个物体（n&lt;30）和一个容量为W的容器，问将容器不装满的放置物品的方式有多少种。</p>
<p>思路 ：<br>状态压缩+二分。将前n/2个物体看做一个整体，将剩下的看做一个整体。1&lt;&lt;(n/2)个状态代表前一半的物品使用情况，然后求出每一种状态的总的体积。排序。对于后面的那一半也是。答案只需枚举一半然后在另一半中找和W差的下界即可。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int n;
long long w;
long long a[1000000];
long long s1[1000000];
long long s2[1000000];

int main()
{
    int t;
    scanf(&quot;%d&quot;, &amp;t);
    int cases = 1;
    while (t--)
    {
        memset(s1, 0, sizeof(s1));
        memset(s2, 0, sizeof(s2));
        memset(a, 0, sizeof(a));

        scanf(&quot;%d %lld&quot;, &amp;n, &amp;w);
        for (int i = 0; i &lt; n; i++)
            scanf(&quot;%lld&quot;, &amp;a[i]);

        int t1 = n &gt;&gt; 1;
        int t2 = n - t1;
        int r1 = 1 &lt;&lt; t1;
        int r2 = 1 &lt;&lt; t2;

        for (int i = 0; i &lt; r1; i++)
            for (int j = 0; j &lt; t1; j++)
            {
                if (i &amp;(1 &lt;&lt; j))
                    s1[i] += a[j];
            }

        for (int i = 0; i &lt; r2; i++)
            for (int j = 0; j &lt; t2; j++)
            {
                if (i &amp;(1 &lt;&lt; j))
                    s2[i] += a[t1 + j];
            }

        sort(s2, s2 + r2 );

        long long ans = 0;
        for (int i = 0; i &lt; r1; i++)
        {
            if (w - s1[i] &gt;= 0)
                ans += upper_bound(s2, s2 + r2, w - s1[i]) - s2;
        }
        printf(&quot;Case %d: %lld\n&quot;, cases++, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 进程控制</title>
    <url>/article/csdn/Linux_%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/51377261" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/51377261</a></p>
<h2><span id="进程">进程</span></h2><h3><span id="1-进程创建">1 进程创建</span></h3><p>fork()函数创建子进程。<br>“调用一次，返回两次”</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    pid_t pid;
    if ((pid = fork())&lt;0)
    {
        printf(&quot;error\n&quot;);
        exit(0);
    }
    else if (pid == 0)
    {
        printf(&quot;in fork\n&quot;);
    }
    else
    {
        printf(&quot;father\n&quot;);
    }
    return 0;
}
</code></pre><p>代码打印结果为：<br>father<br>in fork</p>
<p>vfork()函数，与父进程共享地址空间，使用vfork时父进程会被堵塞，使用_exit()退出子进程。</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    pid_t pid;
    int var = 5;
    printf(&quot;process id %ld\n&quot;,(long)getpid());
    if ((pid = vfork())&lt;0)
    {
        printf(&quot;error\n&quot;);
        return 1;
    }
    else if (pid == 0)
    {
        var++;
        printf(&quot;in fork\n&quot;);
        _exit(0);
    }
    else
    {
        printf(&quot;father\n&quot;);
        return 0;
    }
    return 0;
}
</code></pre><p>运行结果:<br><img src="https://img-blog.csdn.net/20160511185155550" alt="这里写图片描述"></p>
<p>execve()函数创建子进程，在另外一个文件执行。</p>
<p>new.cpp文件</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int main()
{
    puts(&quot;hello&quot;);
    return 0;
}
</code></pre><p>A.cpp</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;

extern char **environ;

int main(int argc,char *argv[])
{
    pid_t pid;
    if ((pid =fork()) &lt; 0)
    {
        puts(&quot;error!\n&quot;);
    }
    if (pid == 0)
        execve(&quot;new&quot;,argv,environ);
    else
        puts(&quot;ok&quot;);
    return 0;
}
</code></pre><p>执行A.cpp运行结果：<br><img src="https://img-blog.csdn.net/20160511193906349" alt="这里写图片描述"></p>
<h3><span id="2-进程等待">2 进程等待</span></h3><p>wait()函数，挂起父进程，等待子进程运行结束。</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/wait.h&gt;

void exit_s(int status)
{
    if (WIFEXITED(status))
        printf(&quot;normal exit,status = %d\n&quot;,WEXITSTATUS(status));
    else
        printf(&quot;single exit!,status = %d\n&quot;,WTERMSIG(status));
}

int main(void)
{
    pid_t pid,pid1;
    int status;
    if ((pid = fork()) &lt; 0)
    {
        puts(&quot;error&quot;);
        exit(0);
    }   
    else if (pid == 0)
    {
        printf(&quot;child process\n&quot;);
        exit(2);
    }
    else
    {
        printf(&quot;father process\nwait error!\n&quot;);
        exit(1);
    }
    exit_s(status);

    if ((pid = fork()) &lt; 0)
    {
        puts(&quot;error&quot;);
        exit(1);
    }   
    else if (pid == 0)
    {
        printf(&quot;child process\n&quot;);
        pid1 = getpid();
        kill(pid1,14);
        exit(2);
    }
    if (wait(&amp;status) != pid)
    {
        printf(&quot;father process\nwait error!\n&quot;);
        exit(0);
    }
    exit_s(status);
    exit(0);
}
</code></pre><p>运行结果：<br><img src="https://img-blog.csdn.net/20160511201407005" alt="这里写图片描述"></p>
<h3><span id="3-进程结束">3 进程结束</span></h3><p>exit和_exit<br>区别：exit退出时释放占用的资源及清空缓冲区。_exit则不具备这个功能。</p>
<h3><span id="4-进程组">4 进程组</span></h3><p>setpgid创建新的进程组</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/wait.h&gt;

int main(void)
{
    int a;
    pid_t pgid,pid;

    pid = getpid();
    pgid = getpgrp();
    a = setpgid(pid,pgid);
    printf(&quot;a = %d , pid = %d ，pgid = %d \n&quot;,a,pid,pgid);
    return 0;
}
</code></pre><p>运行结果：<br><img src="https://img-blog.csdn.net/20160511203737575" alt="这里写图片描述"></p>
<h3><span id="5-时间片的分配">5 时间片的分配</span></h3><p>进程优先级：</p>
<p>头文件</p>
<pre><code>#include &lt;sched.h&gt;
</code></pre><p>setpriority()和getpriority()设置和获取线程的优先级。</p>
<h3><span id="6-进程的操作">6 进程的操作</span></h3><pre><code>getpid()进程id
getppid()父进程id
getuid()用户id
geteuid()有效用户id
getgid()用户组id
getegid()有效用户组id
setuid()设置用户标识
setgid()设置用户组标识


#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;sched.h&gt;
#include &lt;pthread.h&gt;

int main(void)
{
    int a1,a2;
    a1 = setuid(0);
    a2 = setgid(100);
    printf(&quot;a1 = %d  a2 = %d\n&quot;,a1,a2);
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Linux基本网络命令</title>
    <url>/article/csdn/Linux%E5%9F%BA%E6%9C%AC%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/49913859" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/49913859</a></p>
<h2><span id="ping">ping</span></h2><p>ping发送ECHO_REQUEST包到你指定的地址。这样你可以很方便确认你的电脑和Internet或是一个指定的IP地址是不是通的。使用 -c<br>开关，可以指定发送ECHO_REQUEST包的个数。</p>
<h2><span id="whois">whois</span></h2><p>whois命令输出指定站点的whois记录，可以查看到更多如谁注册和持有这个站点这样的信息。</p>
<h2><span id="ifconfig">ifconfig</span></h2><p>ifconfig用于输出网络接口配置、调优和debug的各种选项。可以快捷地查看IP地址和其它网络接口的信息。键入ifconfig查看所有启用的网络接口的状态，包括它们的名字。可以指定网络接口的名字来只显示这一个接口的信息。</p>
<h2><span id="ifdown-amp-ifup">ifdown &amp; ifup</span></h2><p>ifdown和ifup命令和运行ifconfig up，ifconfig<br>down的功能一样。给定网络接口的名字可以只禁用或启用这一个接口。需要root权限，所以在Ubuntu上需要使用sudo来运行。</p>
<h2><span id="route">route</span></h2><p>可以使用route命令来配置并查看内核路由表的配置情况。<br>例如：<br>（1） 添加到主机的路由。  </p>
<p>#route add –host 192.168.1.2 dev eth0:0  </p>
<p>#route add –host 10.20.30.148 gw 10.20.30.40<br>（2） 添加到网络的路由。  </p>
<p>#route add –net 10.20.30.40 netmask 255.255.255.248 eth0  </p>
<p>#route add –net 10.20.30.48 netmask 255.255.255.248 gw 10.20.30.41  </p>
<p>#route add –net 192.168.1.0/24 eth1<br>（3） 添加默认网关。  </p>
<p>#route add default gw 192.168.1.1<br>（4） 查看内核路由表的配置。  </p>
<p>#route<br>（5）删除路由。  </p>
<p>#route del –host 192.168.1.2 dev eth0:0  </p>
<p>#route del –host 10.20.30.148 gw 10.20.30.40  </p>
<p>#route del –net 10.20.30.40 netmask 255.255.255.248 eth0  </p>
<p>#route del –net 10.20.30.48 netmask 255.255.255.248 gw 10.20.30.41  </p>
<p>#route del –net 192.168.1.0/24 eth1  </p>
<p>#route del default gw 192.168.1.1<br>对于1和2两点可使用下面的语句实现：<br>Ifconfig eth0 172.16.19.71 netmask 255.255.255.0<br>Route 0.0.0.0 gw 172.16.19.254<br>Service network restart</p>
<h2><span id="traceroute">traceroute</span></h2><p>可以使用traceroute命令显示数据包到达目的主机所经过的路由。<br>例如：  </p>
<p>#traceroute <a href="http://www.sina.com.cn/" target="_blank" rel="noopener"> http://www.sina.com.cn/ </a></p>
<h2><span id="hostname">hostname</span></h2><p>可以使用hostname命令来更改主机名。例如；  </p>
<p>#hostname myhost</p>
<h2><span id="host">host</span></h2><p>host命令用来做DNS查询。如果命令参数是域名，命令会输出关联的IP；如果命令参数是IP，命令则输出关联的域名。</p>
<h2><span id="netstat">netstat</span></h2><p>可以使用netstat命令来显示网络状态信息。<br>例如：<br>（1） 显示网络接口状态信息。  </p>
<p>#netstat –i<br>（2） 显示所有监控中的服务器的Socket和正使用Socket的程序信息。  </p>
<p>#netstat –lpe<br>（3） 显示内核路由表信息。  </p>
<p>#netstat –r  </p>
<p>#netstat –nr<br>（4） 显示TCP/UDP传输协议的连接状态。  </p>
<p>#netstat –t  </p>
<p>#netstat –u</p>
<h2><span id="arp">arp</span></h2><p>可以使用arp命令来配置并查看arp缓存。例如：<br>（1） 查看arp缓存。  </p>
<p>#arp<br>（2） 添加一个IP地址和MAC地址的对应记录。  </p>
<p>#arp –s 192.168.33.15 00:60:08:27:CE:B2<br>（3） 删除一个IP地址和MAC地址的对应缓存记录。  </p>
<p>#arp –d192.168.33.15</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Lightoj 1235 - Coin Change (IV) 【二分】</title>
    <url>/article/csdn/Lightoj_1235_-_Coin_Change_(IV)_%E3%80%90%E4%BA%8C%E5%88%86%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47054731" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47054731</a></p>
<p>题目链接： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1235" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1235
</a></p>
<p>题意： 有N个硬币（N&lt;=18），问能否在每个硬币使用不超过两次的情况下支付正好K的面额。</p>
<p>思路 ：<br>dfs构造出用这些硬币用前一半能支付的所有费用和后一半能支付的所有费用。之后排序，枚举前一半的每个面值在第二个里面二分寻找即可。（或者用set保存）。</p>
<p>代码：（set）</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int n;
int num1, num2;
long long w;
long long a[1000000];

set &lt;long long&gt;s1;
set &lt;long long&gt;s2;


void dfs1(long long sum, int x, int num)
{
    if (x == num1)
    {
        s1.insert(sum);
        return;
    }
    for (int i = 0; i &lt;= 2; i++)
        dfs1(sum + a[x] * i,x + 1, num + 1);
}

void dfs2(long long sum,int x, int num)
{
    if (x == n)
    {
        s2.insert(sum);
        return;
    }
    for (int i = 0; i &lt;= 2; i++)
        dfs2(sum + a[x] * i, x + 1, num + 1);
}



int main()
{
    int t;
    scanf(&quot;%d&quot;, &amp;t);
    int cases = 1;
    while (t--)
    {
        s1.clear();
        s2.clear();
        memset(a, 0, sizeof(a));

        scanf(&quot;%d %lld&quot;, &amp;n, &amp;w);

        for (int i = 0; i &lt; n; i++)
            scanf(&quot;%lld&quot;, &amp;a[i]);

        num1 = n &gt;&gt; 1;
        num2 = n - num1;

        dfs1(0, 0, num1);
        dfs2(0, num1, n);

        int ok = 0;

        set &lt;long long&gt; ::iterator it;
        for (it = s1.begin(); it != s1.end(); it++)
        {
            int tmp = *it;
            //cout &lt;&lt; tmp &lt;&lt; endl;
            if (s2.count(w-tmp) != 0)
            {
                ok = 1;
                break;
            }
        }

        if (ok) printf(&quot;Case %d: Yes\n&quot;, cases++);
        else printf(&quot;Case %d: No\n&quot;, cases++);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 进程间通信</title>
    <url>/article/csdn/Linux_%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/51383792" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/51383792</a></p>
<p>linux下进程间通信的几种主要手段简介：<br>1 管道（Pipe）及有名管道（named<br>pipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；<br>2<br>信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）；<br>3 报文（Message）队列（消息队列）：消息队列是消息的链接表，包括Posix消息队列system<br>V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。<br>4<br>共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。<br>5 信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。<br>6<br>套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System<br>V的变种都支持套接字。</p>
<h3><span id="1-pipe管道">1 pipe管道</span></h3><p>子进程写，父进程读。<br>pipe(fd[2])<br>fd[1]写，fd[0]读</p>
<pre><code>#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define MAXSIZE 100

int main() 
{   
    int fd[2],pid,line;
    char message[100];
    if (pipe(fd) == -1)
    {
        printf(&quot;create failed!\n&quot;);
        return 1;
    }
    else if ((pid =fork()) &lt; 0)
    {
        printf(&quot;child process failed\n!&quot;);
        return 1;
    }
    else if (pid == 0)
    {
        close(fd[0]);
        printf(&quot;child send!\n&quot;);
        write(fd[1],&quot;hello father!&quot;,14);
    }
    else
    {
        close(fd[1]);
        printf(&quot;father receive!\n&quot;);
        line = read(fd[0],message,MAXSIZE);
        write(STDOUT_FILENO,message,line);
        printf(&quot;\n&quot;);

        _exit(0);
    }
    return 0;
}
</code></pre><p>运行结果：<br><img src="https://img-blog.csdn.net/20160512125301427" alt="这里写图片描述"></p>
<h3><span id="2-命名管道">2 命名管道：</span></h3><p>mkfifo(“路径名”,文件权限)</p>
<pre><code>#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

#define FIFO &quot;/home/fifo&quot;

int main() 
{   
    int fd,pid,line;
    char r_msg[BUFSIZ];

    if ((pid = mkfifo(FIFO,0777)) == -1)
    {
        printf(&quot;fifo failed\n!&quot;);
        return 1;
    }
    else 
        printf(&quot;create success!&quot;);
    fd = open(FIFO,O_RDWR);
    if(fd == -1)
    {
        printf(&quot;fifo failed!\n&quot;);
        return 1;
    }
    if(write(fd,&quot;hello world&quot;,12) == -1)
    {
        perror(&quot;write error&quot;);
        return 1;
    }
    else 
        printf(&quot;write success!\n&quot;);

    if(read(fd,r_msg,BUFSIZ) == -1)
    {
        perror(&quot;read error&quot;);
        return 1;
    }
    else 
        printf(&quot;receive data id %s !\n&quot;,r_msg);
    close(fd);

    return 0;
}
</code></pre><p>运行结果：<br><img src="https://img-blog.csdn.net/20160512131756717" alt="这里写图片描述"></p>
<h3><span id="3-共享内存">3 共享内存</span></h3><p>shmget() 函数创建共享内存<br>shmat() 函数将共享内存添加到进程地址中<br>shmdt() 进程退出共享内存<br>shmctl() 对内存区域的操作</p>
<pre><code>#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/shm.h&gt;


int main() 
{   
    int shmid;
    int proj_id;
    key_t key;
    int size;
    char *addr;
    pid_t pid;
    key = IPC_PRIVATE;

    shmid = shmget(key,1024,IPC_CREAT|0660);
    if (shmid == -1)
    {
        perror(&quot;create share memory failed&quot;);
        return 1;
    }

    addr = (char *)shmat(shmid,NULL,0);
    if (addr == (char *)(-1))
    {
        perror(&quot;error!!!&quot;);
        return 1;
    }
    printf(&quot;share memory address %s\n&quot;,addr);

    strcpy(addr,&quot;welcome to mfcheer&quot;);

    pid = fork();

    if (pid == -1)
    {
        printf(&quot;error!\n&quot;);
        return 1;
    }
    else if (pid == 0)
    {
        printf(&quot;chind process string is %s\n&quot;,addr);
        _exit(0);
    }
    else 
    {
        printf(&quot;parent process string is %s\n&quot;,addr);
        if(shmdt (addr) == -1)
        {
            printf(&quot;release failed!\n&quot;);
            return 1;
        }
        if (shmctl(shmid,IPC_RMID,NULL) == -1)
        {
            printf(&quot;erroe!\n&quot;);
            return 1;
        }
    }

    return 0;
}
</code></pre><p>运行结果：<br><img src="https://img-blog.csdn.net/20160512140557925" alt="这里写图片描述"></p>
<h3><span id="4-信号量">4 信号量</span></h3><p>semget() 创建信号量<br>semop() 信号量操作<br>semctl() 信号量的控制</p>
<h3><span id="5-消息队列">5 消息队列</span></h3>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Linux生产者消费者模型--基于线程条件变量</title>
    <url>/article/csdn/Linux%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B--%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/52521087" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/52521087</a></p>
<h2><span id="生产者消费者模型">生产者消费者模型</span></h2><p>生产者和消费者之间用中间类似一个队列一样的东西串起来。这个队列可以想像成一个存放产品的“仓库”，生产者只需要关心这个“仓库”，并不需要关心具体的消费者，对于生产者而言甚至都不知道有这些消费者存在。对于消费者而言他也不需要关心具体的生产者，到底有多少生产者也不是他关心的事情，他只要关心这个“仓库”中还有没有东西。这种模型是一种松耦合模型。</p>
<h2><span id="c代码">C代码：</span></h2><pre><code>#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;

#define BUFFER_SIZE 4
#define OVER -1

struct producers
{
    int buffer[BUFFER_SIZE];
    pthread_mutex_t lock;
    int readpos,writepos;
    pthread_cond_t notempty;
    pthread_cond_t notfull;
};

void init(struct producers *b)
{
    pthread_mutex_init(&amp;b-&gt;lock,NULL);
    pthread_cond_init(&amp;b-&gt;notempty,NULL);
    pthread_cond_init(&amp;b-&gt;notfull,NULL);
    b-&gt;readpos = 0;
    b-&gt;writepos = 0;
}


void put(struct producers *b, int data)
{
    pthread_mutex_lock(&amp;b-&gt;lock);
    while ((b-&gt;writepos + 1)%BUFFER_SIZE == b-&gt;readpos)
    {
        pthread_cond_wait(&amp;b-&gt;notfull,&amp;b-&gt;lock);
    }
    b-&gt;buffer[b-&gt;writepos] = data;
    b-&gt;writepos++;
    if(b-&gt;writepos &gt;= BUFFER_SIZE)
        b-&gt;writepos = 0;
    pthread_cond_signal(&amp;b-&gt;notempty);
    pthread_mutex_unlock(&amp;b-&gt;lock);
}

int get(struct producers *b)
{
    int data;
    pthread_mutex_lock(&amp;b-&gt;lock);
    while (b-&gt;writepos == b-&gt;readpos)
    {
        pthread_cond_wait(&amp;b-&gt;notempty,&amp;b-&gt;lock);
    }
    data = b-&gt;buffer[b-&gt;readpos];
    b-&gt;readpos++;
    if(b-&gt;readpos &gt;= BUFFER_SIZE)
        b-&gt;readpos = 0;
    pthread_cond_signal(&amp;b-&gt;notfull);
    pthread_mutex_unlock(&amp;b-&gt;lock);

    return data;
}

struct producers buffer;

void *producer(void *data)
{
    int n;
    for(n=0;n&lt;10;n++)
    {
        printf(&quot;Producer: %d--\n&quot;,n);
        put(&amp;buffer,n);
    }
    put(&amp;buffer,OVER);
}

void *consumer(void *data)
{
    int d;
    while (1)
    {
        d = get(&amp;buffer);
        if (d == OVER)
            break;
        printf(&quot;Consumer: %d--\n&quot;,d);
    }
}

int main()
{
    pthread_t tha,thb;
    void *retval;

    init(&amp;buffer);

    pthread_create(&amp;tha,NULL,producer,0);
    pthread_create(&amp;thb,NULL,consumer,0);

    pthread_join(tha,&amp;retval);
    pthread_join(thb,&amp;retval);

    return 0;
}
</code></pre><h2><span id="pthread-api">pthread API:</span></h2><p>数据类型<br>pthread_t：线程句柄<br>pthread_attr_t：线程属性<br>线程操纵函数（简介起见，省略参数）<br>pthread_create()：创建一个线程<br>pthread_exit()：终止当前线程<br>pthread_cancel()：中断另外一个线程的运行<br>pthread_join()：阻塞当前的线程，直到另外一个线程运行结束<br>pthread_attr_init()：初始化线程的属性<br>pthread_attr_setdetachstate()：设置脱离状态的属性（决定这个线程在终止时是否可以被结合）<br>pthread_attr_getdetachstate()：获取脱离状态的属性<br>pthread_attr_destroy()：删除线程的属性<br>pthread_kill()：向线程发送一个信号</p>
<p>同步函数<br>用于 mutex 和条件变量<br>pthread_mutex_init() 初始化互斥锁<br>pthread_mutex_destroy() 删除互斥锁<br>pthread_mutex_lock()：占有互斥锁（阻塞操作）<br>pthread_mutex_trylock()：试图占有互斥锁（不阻塞操作）。当互斥锁空闲时将占有该锁；否则立即返回<br>pthread_mutex_unlock(): 释放互斥锁<br>pthread_cond_init()：初始化条件变量<br>pthread_cond_destroy()：销毁条件变量<br>pthread_cond_wait(): 等待条件变量的特殊条件发生<br>pthread_cond_signal(): 唤醒第一个调用pthread_cond_wait()而进入睡眠的线程<br>Thread-local storage（或者以Pthreads术语，称作 线程特有数据）:<br>pthread_key_create(): 分配用于标识进程中线程特定数据的键<br>pthread_setspecific(): 为指定线程特定数据键设置线程特定绑定<br>pthread_getspecific(): 获取调用线程的键绑定，并将该绑定存储在 value 指向的位置中<br>pthread_key_delete(): 销毁现有线程特定数据键</p>
<p>与一起工作的工具函数<br>pthread_equal(): 对两个线程的线程标识号进行比较<br>pthread_detach(): 分离线程<br>pthread_self(): 查询线程自身线程标识号</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Never Say Never</title>
    <url>/article/csdn/Never_Say_Never.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43084463" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43084463</a></p>
<p>See I never thought that I could walk through fire</p>
<p>I never thought that I could take the burn</p>
<p>I never had the strength to take it higher</p>
<p>Until I reached the point of no return</p>
<p>And there’s just no turning back</p>
<p>When your hearts under attack</p>
<p>Gonna give everything I have</p>
<p>It’s my destiny  </p>
<p>I will never say never! (I will fight)</p>
<p>I will fight till forever! (make it right)</p>
<p>Whenever you knock me down</p>
<p>I will not stay on the ground</p>
<p>Pick it up</p>
<p>Pick it up</p>
<p>Pick it up</p>
<p>Pick it up up up</p>
<p>And never say never （and never say never ，and never say never ，and never say<br>never）</p>
<p>I never thought that I could feel this power</p>
<p>I never thought that I could feel this free</p>
<p>I’m strong enough to climb the highest tower</p>
<p>And I’m fast enough to run across the sea</p>
<p>And there’s just no turning back</p>
<p>When your hearts under attack</p>
<p>Gonna give everything I have</p>
<p>It’s my destiny</p>
<p>I will never say never! (I will fight)</p>
<p>I will fight till forever! (make it right)</p>
<p>Whenever you knock me down</p>
<p>I will not stay on the ground</p>
<p>Pick it up</p>
<p>Pick it up</p>
<p>Pick it up</p>
<p>Pick it up up up</p>
<p>And never say never</p>
<p>Here we go!</p>
<p>Guess who?</p>
<p>JSmith and Jb!</p>
<p>I gotcha lil bro</p>
<p>I can handle him</p>
<p>Hold up, aight?</p>
<p>I can handle him</p>
<p>Now he’s bigger than me</p>
<p>Taller than me</p>
<p>And he’s older than me</p>
<p>And stronger than me</p>
<p>And his arms a little bit longer than me</p>
<p>But he ain’t on a JB song with me!</p>
<p>I be trying a chill</p>
<p>They be trying to side with the thrill</p>
<p>No pun intended, was raised by the power of Will</p>
<p>Like Luke with the force, when push comes to shove</p>
<p>Like Cobe with the 4th, ice water with blood</p>
<p>I gotta be the best, and yes</p>
<p>We’re the flyest</p>
<p>Like David and Goliath</p>
<p>I conquered the giant</p>
<p>So now I got the world in my hand</p>
<p>I was born from two stars</p>
<p>So the moon’s where I land</p>
<p>I will never say never!(I will fight)</p>
<p>I will fight till forever!(make it right)</p>
<p>Whenever you knock me down</p>
<p>I will not stay on the ground</p>
<p>Pick it up</p>
<p>Pick it up</p>
<p>Pick it up</p>
<p>Pick it up, up, up</p>
<p>And never say never</p>
<p>I will never say never!(I will fight)</p>
<p>I will fight till forever!(make it right)</p>
<p>Whenever you knock me down</p>
<p>I will not stay on the ground</p>
<p>Pick it up</p>
<p>Pick it up</p>
<p>Pick it up</p>
<p>Pick it up, up, up</p>
<p>And never say never</p>
<p>Never say never</p>
<p>Never say never</p>
<p>Never say never</p>
<p>Never say never</p>
<p>Never say never</p>
<p>And never say never</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Nagle算法</title>
    <url>/article/csdn/Nagle%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/52104848" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/52104848</a></p>
<p>纳格算法是以减少数据包发送量来增进TCP/IP网络的性能。它是由约翰．纳格任职于Ford Aerospace时命名。</p>
<p>纳格的文件描述了他所谓的“小数据包问题”－某个应用程序不断地提交小单位的数据，且某些常只占1字节大小。因为TCP数据包具有40字节的标头信息（TCP与IPv4各占20字节），这导致了41字节大小的数据包只有1字节的可用信息，造成庞大的浪费。这种状况常常发生于Telnet工作阶段－大部分的键盘操作会产生1字节的数据并马上提交。更糟的是，在慢速的网络连接下，这类的数据包会大量地在同一时点传输，造成壅塞碰撞（Congestion<br>Collapse）。</p>
<p>纳格算法的工作方式是合并（coalescing）一定数量的输出数据后一次提交。特别的是，只要有已提交的数据包尚未确认，发送者会持续缓冲数据包，直到累积一定数量的数据才提交。</p>
<p>算法过程：</p>
<pre><code>if有新資料要傳送
   if訊窗大小&gt;= MSS and可傳送的資料&gt;= MSS
     立刻傳送完整MSS大小的segment
   else
    if管線中有尚未確認的資料
      在下一個確認（ACK）封包收到前，將資料排進緩衝區佇列
    else
      立即傳送資料
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Merkle-Hellman背包密码算法</title>
    <url>/article/csdn/Merkle-Hellman%E8%83%8C%E5%8C%85%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/49434947" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/49434947</a></p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;cmath&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;time.h&gt;

using namespace std;

long long gcd(long long a, long long b)
{
    if (b == 0) return a;
    else return gcd(b, a%b);
}

long long ext_gcd(long long a, long long b, long long &amp;x, long long &amp;y)
{
    if (a == 0 &amp;&amp; b == 0) return -1;
    if (b == 0)
    {
        x = 1;
        y = 0;
        return a;
    }
    long long d = ext_gcd(b, a%b, y, x);
    y -= a / b*x;
    return d;
}

long long mod_reverse(long long a, long long n)
{
    long long x, y;
    long long d = ext_gcd(a, n, x, y);
    if (d == 1)
        return (x%n + n) % n;
    else
        return -1;
}

struct Hellman
{
    int n;
    int a[100010];
    int b[100010];
    int c[100010];
    void solve()
    {
        cout &lt;&lt; &quot;*******************************&quot; &lt;&lt; endl;
        printf(&quot;本数据假定递增序列（1,3,5,10）\nM=20，W=7\n明文为13的加密解秘过程\n&quot;);
        cout &lt;&lt; &quot;*******************************&quot; &lt;&lt; endl&lt;&lt;endl&lt;&lt;endl;

        //scanf(&quot;%d&quot;, &amp;n);//输入长度n
        int sum = 0;
        int pos = 1;
        n = 4;

        //随机生成超递增序列
        /*
        while (1)
        {
            srand(time(NULL));
            int tmp = rand() % 1000;
            if (tmp &gt; sum)
            {
                a[pos++] = tmp;//私钥
                sum += tmp;
            }
            if (pos == n + 1) break;
        }
        */

        sum = 19;
        a[1] = 1;
        a[2] = 3;
        a[3] = 5;
        a[4] = 10;

        //随机生成M W
        int M = double(rand() / RAND_MAX)* (sum + 1001 - sum + 1) + sum + 1;
        int W = M - 1;
        /*
        while (gcd(M, W) != 1)
        {
            srand(time(0));
            int aa = 1;
            int bb = M - 1;
            W = rand() / RAND_MAX * (bb - aa) + aa;
        }
        */

        M = 20;
        W = 7;

        //公钥
        for (int i = 1;i &lt;= n;i++)
        {
            b[i] = W * a[i] % M;
        }

        ///////取明文
        cout &lt;&lt; &quot;请输入明文：&quot; &lt;&lt; endl;
        int clear;
        scanf(&quot;%d&quot;, &amp;clear);
        int len = 1;
        int num[100010];
        int tmp = clear;
        cout &lt;&lt; &quot;加密：&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;start&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;..............&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;end&quot; &lt;&lt; endl;
        //获得比特流
        while (tmp)
        {
            if (tmp &amp; 1)
                num[len++] = 1;
            else
                num[len++] = 0;
            tmp &gt;&gt;= 1;
        }


        //加密c
        int c = 0;
        for (int i = 1;i &lt; len;i++)
            c += num[len - i] * b[i];

        cout &lt;&lt; &quot;加密得到的数字c为：&quot; &lt;&lt; endl;
            cout &lt;&lt; c &lt;&lt; endl;

        //int d = mod_reverse(W, M) * c % M;
        int d = 3;
        c = c*d%M;
        cout &lt;&lt; &quot;加密得到的转换的c为：&quot; &lt;&lt; endl;
        cout &lt;&lt; c &lt;&lt; endl;
        int ans[10010];
        memset(ans, 0, sizeof(ans));

        for (int i = n;i &gt;= 1;i--)
        {
            if (c &gt;= a[i])
            {
                ans[i] = 1;
                c = c - a[i];
            }
        }
        cout &lt;&lt; &quot;解密：&quot;&lt;&lt; endl;
        int tt = 0;
        for (int i = 1;i &lt;= n;i++)
        {
            printf(&quot;%d&quot;, ans[i]);
            if (ans[i]) tt += pow(2,n-i);
        }
        cout &lt;&lt; &quot;----&quot; &lt;&lt; tt &lt;&lt; endl;
    }
}hellman;

int main()
{
    hellman.solve();
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj 1006 生理周期 【中国剩余定理】</title>
    <url>/article/csdn/POJ_1006_%E7%94%9F%E7%90%86%E5%91%A8%E6%9C%9F_%E3%80%90%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44678667" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44678667</a></p>
<p>生理周期<br>Time Limit: 1000MS Memory Limit: 10000K<br>Total Submissions: 117999 Accepted: 37040<br>Description</p>
<p>人生来就有三个生理周期，分别为体力、感情和智力周期，它们的周期长度为23天、28天和33天。每一个周期中有一天是高峰。在高峰这天，人会在相应的方面表现出色。例如，智力周期的高峰，人会思维敏捷，精力容易高度集中。因为三个周期的周长不同，所以通常三个周期的高峰不会落在同一天。对于每个人，我们想知道何时三个高峰落在同一天。对于每个周期，我们会给出从当前年份的第一天开始，到出现高峰的天数（不一定是第一次高峰出现的时间）。你的任务是给定一个从当年第一天开始数的天数，输出从给定时间开始（不包括给定时间）下一次三个高峰落在同一天的时间（距给定时间的天数）。例如：给定时间为10，下次出现三个高峰同天的时间是12，则输出2（注意这里不是3）。<br>Input</p>
<p>输入四个整数：p, e, i和d。 p, e, i分别表示体力、情感和智力高峰出现的时间（时间从当年的第一天开始计算）。d 是给定的时间，可能小于p, e,<br>或 i。 所有给定时间是非负的并且小于365, 所求的时间小于21252。</p>
<p>当p = e = i = d = -1时，输入数据结束。<br>Output</p>
<p>从给定时间起，下一次三个高峰同天的时间（距离给定时间的天数）。</p>
<p>采用以下格式：<br>Case 1: the next triple peak occurs in 1234 days.</p>
<p>注意：即使结果是1天，也使用复数形式“days”。<br>Sample Input</p>
<p>0 0 0 0<br>0 0 0 100<br>5 20 34 325<br>4 5 6 7<br>283 102 23 320<br>203 301 203 40<br>-1 -1 -1 -1<br>Sample Output</p>
<p>Case 1: the next triple peak occurs in 21252 days.<br>Case 2: the next triple peak occurs in 21152 days.<br>Case 3: the next triple peak occurs in 19575 days.<br>Case 4: the next triple peak occurs in 16994 days.<br>Case 5: the next triple peak occurs in 8910 days.<br>Case 6: the next triple peak occurs in 10789 days.<br>Source</p>
<p>East Central North America 1999</p>
<p>裸的中国剩余定理</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;

using namespace std;

int p, e, i, d;

long long ext_gcd(long long a, long long b, long long &amp;x, long long &amp;y)
{
    if (a == 0 &amp;&amp; b == 0) return -1;
    if (b == 0)
    {
        x = 1;
        y = 0;
        return a;
    }
    long long d = ext_gcd(b, a%b, y, x);
    y -= a / b*x;
    return d;
}

//求逆元素
// ax=1(mod n)
long long mod_reverse(long long a, long long n)
{
    long long x, y;
    long long d = ext_gcd(a, n, x, y);
    if (d == 1)
        return (x%n + n) % n;
    else
        return -1;
}

int cases = 1;

int main()
{
    while (cin &gt;&gt; p &gt;&gt; e &gt;&gt; i &gt;&gt; d)
    {
        if (p == -1 &amp;&amp; e == -1 &amp;&amp; i == -1 &amp;&amp; d == -1)
            return 0;
        int d1 = p * 33 * 28 * mod_reverse(33 * 28, 23);
        int d2 = e * 23 * 33 * mod_reverse(23 * 33, 28);
        int d3 = i * 23 * 28 * mod_reverse(23 * 28, 33);
        int ans = ((d1 + d2 + d3 - d) % (23 * 28 * 33) + (23 * 28 * 33)) % (23 * 28 * 33);
        if (ans == 0) ans = (23 * 28 * 33);
        printf(&quot;Case %d: the next triple peak occurs in %d days.\n&quot;,cases++,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>POJ 1679 THE UNIQUE MST 【次小生成树】</title>
    <url>/article/csdn/POJ_1679_THE_UNIQUE_MST_%E3%80%90%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46383467" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46383467</a></p>
<p>The Unique MST<br>Time Limit: 1000MS Memory Limit: 10000K<br>Total Submissions: 22098 Accepted: 7847<br>Description</p>
<p>Given a connected undirected graph, tell if its minimum spanning tree is<br>unique.<br>Definition 1 (Spanning Tree): Consider a connected, undirected graph G = (V,<br>E). A spanning tree of G is a subgraph of G, say T = (V’, E’), with the<br>following properties:<br>1. V’ = V.<br>2. T is connected and acyclic.</p>
<p>Definition 2 (Minimum Spanning Tree): Consider an edge-weighted, connected,<br>undirected graph G = (V, E). The minimum spanning tree T = (V, E’) of G is the<br>spanning tree that has the smallest total cost. The total cost of T means the<br>sum of the weights on all the edges in E’.</p>
<p>Input</p>
<p>The first line contains a single integer t (1 &lt;= t &lt;= 20), the number of test<br>cases. Each case represents a graph. It begins with a line containing two<br>integers n and m (1 &lt;= n &lt;= 100), the number of nodes and edges. Each of the<br>following m lines contains a triple (xi, yi, wi), indicating that xi and yi<br>are connected by an edge with weight = wi. For any two nodes, there is at most<br>one edge connecting them.<br>Output</p>
<p>For each input, if the MST is unique, print the total cost of it, or otherwise<br>print the string ‘Not Unique!’.<br>Sample Input</p>
<p>2<br>3 3<br>1 2 1<br>2 3 2<br>3 1 3<br>4 4<br>1 2 2<br>2 3 2<br>3 4 2<br>4 1 2<br>Sample Output</p>
<p>3<br>Not Unique!<br>Source</p>
<p>POJ Monthly–2004.06.27 srbga@POJ<br>代码：</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;iostream&gt;  
#include &lt;string.h&gt;  
#include &lt;algorithm&gt;  
#include &lt;math.h&gt;  
#include &lt;stack&gt;  
#include &lt;queue&gt;  
#include &lt;set&gt;  

using namespace std;  
#define INF 10000000  

/* 
 * 次小生成树 
 * 求最小生成树时，用数组Max[i][j]来表示MST中i到j最大边权 
 * 求完后，直接枚举所有不在MST中的边，替换掉最大边权的边，更新答案 
 * 点的编号从1开始 
 */  
const int MAXN=110;  
bool vis[MAXN];  
int lowc[MAXN];  
int pre[MAXN];//记录前驱节点  
int Max[MAXN][MAXN];//Max[i][j]表示在最小生成树中从i到j的路径中的最大边权  
bool used[MAXN][MAXN];//是否是最小生成树的边  

int Prim(int cost[][MAXN],int n)  
{  
    int ans=0;  
    memset(vis,false,sizeof(vis));  
    memset(Max,0,sizeof(Max));  
    memset(used,false,sizeof(used));  
    memset(lowc,0,sizeof(lowc));  

    for(int i=1;i&lt;=n;i++)  
    {  
        lowc[i]=cost[1][i];  
        pre[i]=1;  
    }  
    lowc[1]=0;  
    vis[1]=true;  
    pre[1]=-1;   

    for(int i=1;i&lt;n;i++)  
    {  
        int minc=INF;  
        int p=-1;  
        for(int j=1;j&lt;=n;j++)  
            if(!vis[j] &amp;&amp; minc &gt; lowc[j])  
            {  
                minc = lowc[j];  
                p = j;  
            }  
        if(minc==INF)  
            return -1;  

        ans += minc;  
        vis[p]=true;  
        used[p][pre[p]]=used[pre[p]][p]=true;  

        for(int j=1;j&lt;=n;j++)  
        {  
            if(vis[j])  
                Max[j][p]=Max[p][j]=max(Max[j][pre[p]],lowc[p]);  

            if(!vis[j]&amp;&amp;lowc[j]&gt;cost[p][j])  
            {  
                lowc[j]=cost[p][j];  
                pre[j]=p;  
            }  
        }  
    }  
    return ans;  
}  
int ans;  
int smst(int cost[][MAXN],int n)//求次小生成树  
{  
    int Min=INF;  
    for(int i=1;i&lt;=n;i++)  
        for(int j=i+1;j&lt;=n;j++)  
            if(cost[i][j]!=INF &amp;&amp; !used[i][j])  
            {  
                Min=min(Min,ans+cost[i][j]-Max[i][j]);  
            }  
    if(Min==INF)  
        return -1;//不存在  
    return Min;  
}  
int cost[MAXN][MAXN];  
int main()  
{  
    int T;  
    int n,m;  
    scanf(&quot;%d&quot;,&amp;T);  
    while(T--)  
    {  
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);  
        int u,v,w;  
        for(int i=1;i&lt;=n;i++)  
            for(int j=1;j&lt;=n;j++)  
            {  
                if(i==j)  
                    cost[i][j]=0;  
                else  
                    cost[i][j]=INF;  
            }  
        while(m--)  
        {  
            scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);  
            if (cost[u][v] &gt; w)  
                cost[u][v]=cost[v][u]=w;  
        }  

        ans=Prim(cost,n);  
        if(ans==smst(cost,n))  
            printf(&quot;Not Unique!\n&quot;);//次小生成树和最小生成树一样大  
        else  
            printf(&quot;%d\n&quot;,ans);  
    }  
    return 0;  
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>POJ 2785 4 VALUES WHOSE SUM IS 0 【折半枚举】</title>
    <url>/article/csdn/POJ_2785_4_VALUES_WHOSE_SUM_IS_0_%E3%80%90%E6%8A%98%E5%8D%8A%E6%9E%9A%E4%B8%BE%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46383417" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46383417</a></p>
<p>Description</p>
<p>The SUM problem can be formulated as follows: given four lists A, B, C, D of<br>integer values, compute how many quadruplet (a, b, c, d ) ∈ A x B x C x D are<br>such that a + b + c + d = 0 . In the following, we assume that all lists have<br>the same size n .<br>Input</p>
<p>The first line of the input file contains the size of the lists n (this value<br>can be as large as 4000). We then have n lines containing four integer values<br>(with absolute value as large as 228 ) that belong respectively to A, B, C and<br>D .<br>Output</p>
<p>For each input file, your program has to write the number quadruplets whose<br>sum is zero.<br>Sample Input</p>
<p>6<br>-45 22 42 -16<br>-41 -27 56 30<br>-36 53 -37 77<br>-36 30 -75 -46<br>26 -38 -10 62<br>-32 -54 -6 45<br>Sample Output</p>
<p>5<br>Hint</p>
<p>Sample Explanation: Indeed, the sum of the five following quadruplets is zero:<br>(-45, -27, 42, 30), (26, 30, -10, -46), (-32, 22, 56, -46),(-32, 30, -75, 77),<br>(-32, -54, 56, 30).<br>折半枚举时间复杂度O(n^2logn)</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;string.h&gt;
#include &lt;functional&gt;

using namespace std;

int a[4444],b[4444],c[4444],d[4444];
int p [4444 * 4444];

int main()
{
    int n ;
    while (scanf(&quot;%d&quot;,&amp;n)!=EOF)
    {
        for (int i=0;i&lt;n;i++)
            scanf (&quot;%d%d%d%d&quot;,&amp;a[i],&amp;b[i],&amp;c[i],&amp;d[i]);

        for (int i=0;i&lt;n;i++)
            for (int j=0;j&lt;n;j++)
        {
            p[i*n+j] = a[i] + b[j] ;
        }

        sort (p,p+n*n);
        long long  ans = 0;
        for (int i=0;i&lt;n;i++)
            for (int j=0;j&lt;n;j++)
        {
            int cd = -1*(c[i] + d[j]);
            ans += (upper_bound(p,p+n*n ,cd) - lower_bound(p,p+n*n,cd));
        }
        printf(&quot;%I64d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>POJ 2112 Optimal Milking【二分+最大流】</title>
    <url>/article/csdn/POJ_2112_Optimal_Milking%E3%80%90%E4%BA%8C%E5%88%86+%E6%9C%80%E5%A4%A7%E6%B5%81%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48323489" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48323489</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=2112" target="_blank" rel="noopener"> http://poj.org/problem?id=2112 </a></p>
<p>最小化最大流量边。<br>建图：源点向机器建边，容量为m，牛向汇点建边，容量1，机器与牛之间建边（若符合条件），容量1。</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;sstream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;string&gt;

using namespace std;

const int MAXN = 101000;//点数的最大值
const int MAXM = 400100;//边数的最大值
const int INF = 0x3f3f3f3f;

struct Edge
{
    int to, next, cap, flow;
}edge[MAXM];//注意是MAXM

int tol;
int head[MAXN];
int gap[MAXN], dep[MAXN], pre[MAXN], cur[MAXN];

void init()
{
    tol = 0;
    memset(head, -1, sizeof(head));
}
//加边，单向图三个参数，双向图四个参数
void addedge(int u, int v, int w, int rw = 0)
{
    edge[tol].to = v; edge[tol].cap = w; edge[tol].next = head[u];
    edge[tol].flow = 0; head[u] = tol++;
    edge[tol].to = u; edge[tol].cap = rw; edge[tol].next = head[v];
    edge[tol].flow = 0; head[v] = tol++;
}
//输入参数：起点、终点、点的总数
//点的编号没有影响，只要输入点的总数

int Q[MAXN];

void BFS(int start, int end)
{
    memset(dep, -1, sizeof(dep));
    memset(gap, 0, sizeof(gap));
    gap[0] = 1;
    int front = 0, rear = 0;
    dep[end] = 0;
    Q[rear++] = end;
    while (front != rear)
    {
        int u = Q[front++];
        for (int i = head[u];i != -1;i = edge[i].next)
        {
            int v = edge[i].to;
            if (dep[v] != -1) continue;
            Q[rear++] = v;
            dep[v] = dep[u] + 1;
            gap[dep[v]]++;
        }
    }
}
int S[MAXN];
int sap(int start, int end, int N)
{
    BFS(start, end);
    memcpy(cur, head, sizeof(head));
    int u = start;
    int top = 0;
    int ans = 0;
    while (dep[start] &lt; N)
    {
        if (u == end)
        {
            int Min = INF;
            int inser;
            for (int i = 0; i &lt; top; i++)
                if (Min &gt; edge[S[i]].cap - edge[S[i]].flow)
                {
                    Min = edge[S[i]].cap - edge[S[i]].flow;
                    inser = i;
                }
            for (int i = 0; i &lt; top; i++)
            {
                edge[S[i]].flow += Min;
                edge[S[i] ^ 1].flow -= Min;
            }
            ans += Min;
            top = inser;
            u = edge[S[top] ^ 1].to;
            continue;
        }
        bool flag = false;
        int v;
        for (int i = cur[u]; i != -1; i = edge[i].next)
        {
            v = edge[i].to;
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[v] + 1 == dep[u])
            {
                flag = true;
                cur[u] = i;
                break;
            }
        }
        if (flag)
        {
            S[top++] = cur[u];
            u = v;
            continue;
        }
        int Min = N;
        for (int i = head[u]; i != -1; i = edge[i].next)
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min)
            {
                Min = dep[edge[i].to];
                cur[u] = i;
            }
        gap[dep[u]]--;
        if (!gap[dep[u]])return ans;
        dep[u] = Min + 1;
        gap[dep[u]]++;
        if (u != start) u = edge[S[--top] ^ 1].to;
    }
    return ans;
}

int k, c, m;
int a[2345][2345];

int main()
{
    while (~scanf(&quot;%d%d%d&quot;, &amp;k, &amp;c, &amp;m))
    {
        memset(a, 0, sizeof(a));
        int n = k + c;
        for (int i = 1;i &lt;= n;i++)
            for (int j = 1;j &lt;= n;j++)
            {
                scanf(&quot;%d&quot;, &amp;a[i][j]);
                if (a[i][j] == 0) a[i][j] = 1e6;
            }

        //预处理最短距离
        for (int p = 1;p &lt;= n;p++)
            for (int i = 1;i &lt;= n;i++)
                for (int j = 1;j &lt;= n;j++)
                    a[i][j] = min(a[i][j], a[i][p] + a[p][j]);

        int left = 0, right = 1000000;
        int ans = 1000000;

        while (left &lt;= right)
        {
            init();
            for (int i = 1;i &lt;= k;i++)
                addedge(0, i, m);
            for (int i = k + 1;i &lt;= k + c;i++)
                addedge(i, k + c + 1, 1);

            int mid = (left + right) / 2;
            for (int i = 1;i &lt;= k;i++)
                for (int j = k + 1;j &lt;= n;j++)
                {
                    if (a[i][j] &lt;= mid)
                        addedge(i, j, 1);
                }

            if (sap(0, k + c + 1, k + c + 2) == c)
            {
                right = mid - 1;
                ans = min(mid, ans);
            }
            else
                left = mid + 1;
        }
        printf(&quot;%d\n&quot;, ans);
    }   
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>POJ 1273 DRAINAGE DITCHES【最大流】</title>
    <url>/article/csdn/POJ_1273_DRAINAGE_DITCHES%E3%80%90%E6%9C%80%E5%A4%A7%E6%B5%81%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46383243" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46383243</a></p>
<p>模板题。<br>Description</p>
<p>Every time it rains on Farmer John’s fields, a pond forms over Bessie’s<br>favorite clover patch. This means that the clover is covered by water for<br>awhile and takes quite a long time to regrow. Thus, Farmer John has built a<br>set of drainage ditches so that Bessie’s clover patch is never covered in<br>water. Instead, the water is drained to a nearby stream. Being an ace<br>engineer, Farmer John has also installed regulators at the beginning of each<br>ditch, so he can control at what rate water flows into that ditch.<br>Farmer John knows not only how many gallons of water each ditch can transport<br>per minute but also the exact layout of the ditches, which feed out of the<br>pond and into each other and stream in a potentially complex network.<br>Given all this information, determine the maximum rate at which water can be<br>transported out of the pond and into the stream. For any given ditch, water<br>flows in only one direction, but there might be a way that water can flow in a<br>circle.<br>Input</p>
<p>The input includes several cases. For each case, the first line contains two<br>space-separated integers, N (0 &lt;= N &lt;= 200) and M (2 &lt;= M &lt;= 200). N is the<br>number of ditches that Farmer John has dug. M is the number of intersections<br>points for those ditches. Intersection 1 is the pond. Intersection point M is<br>the stream. Each of the following N lines contains three integers, Si, Ei, and<br>Ci. Si and Ei (1 &lt;= Si, Ei &lt;= M) designate the intersections between which<br>this ditch flows. Water will flow through this ditch from Si to Ei. Ci (0 &lt;=<br>Ci &lt;= 10,000,000) is the maximum rate at which water will flow through the<br>ditch.<br>Output</p>
<p>For each case, output a single integer, the maximum rate at which water may<br>emptied from the pond.<br>Sample Input</p>
<p>5 4<br>1 2 40<br>1 4 20<br>2 4 20<br>2 3 30<br>3 4 10<br>Sample Output</p>
<p>50</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;  
#include &lt;ctype.h&gt;  
#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;stack&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string&gt;  
#include &lt;sstream&gt;  
#include &lt;malloc.h&gt;

using namespace std;
const int MAXN = 1010;//点数的最大值
const int MAXM = 400010;//边数的最大值
const int INF = 0x3f3f3f3f;
struct Edge
{
    int to, next, cap, flow;
}edge[MAXM];//注意是MAXM
int tol;
int head[MAXN];
int gap[MAXN], dep[MAXN], pre[MAXN], cur[MAXN];
void init()
{
    tol = 0;
    memset(head, -1, sizeof(head));
}
//加边，单向图三个参数，双向图四个参数
void addedge(int u, int v, int w, int rw = 0)
{
    edge[tol].to = v; edge[tol].cap = w; edge[tol].next = head[u];
    edge[tol].flow = 0; head[u] = tol++;
    edge[tol].to = u; edge[tol].cap = rw; edge[tol].next = head[v];
    edge[tol].flow = 0; head[v] = tol++;
}
//输入参数：起点、终点、点的总数
//点的编号没有影响，只要输入点的总数
int sap(int start, int end, int N)
{
    memset(gap, 0, sizeof(gap));
    memset(dep, 0, sizeof(dep));
    memcpy(cur, head, sizeof(head));
    int u = start;
    pre[u] = -1;
    gap[0] = N;
    int ans = 0;
    while (dep[start] &lt; N)
    {
        if (u == end)
        {
            int Min = INF;
            for (int i = pre[u]; i != -1; i = pre[edge[i ^ 1].to])
                if (Min &gt; edge[i].cap - edge[i].flow)
                    Min = edge[i].cap - edge[i].flow;
            for (int i = pre[u]; i != -1; i = pre[edge[i ^ 1].to])
            {
                edge[i].flow += Min;
                edge[i ^ 1].flow -= Min;
            }
            u = start;
            ans += Min;
            continue;
        }
        bool flag = false;
        int v;
        for (int i = cur[u]; i != -1; i = edge[i].next)
        {
            v = edge[i].to;
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[v] + 1 == dep[u])
            {
                flag = true;
                cur[u] = pre[v] = i;
                break;
            }
        }
        if (flag)
        {
            u = v;
            continue;
        }
        int Min = N;
        for (int i = head[u]; i != -1; i = edge[i].next)
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min)
            {
                Min = dep[edge[i].to];
                cur[u] = i;
            }
        gap[dep[u]]--;
        if (!gap[dep[u]])return ans;
        dep[u] = Min + 1;
        gap[dep[u]]++;
        if (u != start) u = edge[pre[u] ^ 1].to;
    }
    return ans;
}

int m, n;
int a, b, c;

int main()
{
    while (scanf(&quot;%d%d&quot;, &amp;m, &amp;n) != EOF)
    {
        init();
        while (m--)
        {
            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
            addedge(a - 1, b - 1, c);
        }
        int ans = sap(0,n-1,n);
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>RC4加密算法</title>
    <url>/article/csdn/RC4%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48769443" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48769443</a></p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;map&gt;
#include &lt;algorithm&gt;

using namespace std;

int S[300];
int T[300];
int K[300];

int main()
{
    int len;
    scanf(&quot;%d&quot;, &amp;len);
    for (int i = 0;i &lt; len;i++) scanf(&quot;%d&quot;,&amp;K[i]);
    for (int i = 0;i &lt;= 255;i++)
    {
        S[i] = i;
        T[i] = K[i%len];
    }
    int j = 0;
    for (int i = 0;i &lt;= 255;i++)
    {
        j = (j + S[i] + T[i]) % 256;
        swap(S[i], S[j]);
    }

    int clear_text[300];
    int cnt;
    scanf(&quot;%d&quot;, &amp;cnt);
    for (int i = 0;i &lt; cnt;i++) scanf(&quot;%d&quot;, &amp;clear_text[i]);
    int tmp[300];
    int num = 0;

    int i = 0;
    j = 0;
    while (1)
    {
        i = (i + 1) % 256;
        j = (j + S[i]) % 256;
        swap(S[i], S[j]);
        int t = (S[i] + S[j]) % 256;
        tmp[num++] = S[t];
        if (num == cnt) break;
    }
    int ans[300];
    for (int i = 0;i &lt; strlen(clear_text);i++)
        ans[i] = (tmp[i] ^ clear_text[i]);
    for (int i = 0;i &lt; strlen(clear_text);i++) cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;;cout &lt;&lt; endl;
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis内存回收:LRU算法</title>
    <url>/article/csdn/Redis%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6:LRU%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/49999467" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/49999467</a></p>
<h2><span id="lru算法最近最久未使用算法">LRU算法(最近最久未使用算法)</span></h2><p>LRU算法作为内存管理的一种有效算法,其含义是在内存有限的情况下，当内存容量不足时，为了保证程序的运行，这时就不得不淘汰内存中的一些对象，释放这些对象占用的空间，那么选择淘汰哪些对象呢？LRU算法就提供了一种策略，告诉我们选择最近一段时间内，最久未使用的对象将其淘汰，至于为什么要选择最久未使用的，可以想想，最近一段时间内使用的东西，我们是不是可能一会又要用到呢~，而很长一段时间内都没有使用过的东西，也许永远都不会再使用</p>
<p>在操作系统中LRU算法淘汰的不是内存中的对象，而是页,当内存中数据不足时，通过LRU算法，选择一页(一般是4KB)将其交换到虚拟内存区(Swap区)</p>
<h2><span id="lru算法演示">LRU算法演示</span></h2><p><img src="https://img-blog.csdn.net/20160911155045785" alt="这里写图片描述"></p>
<p>算法实现应该采用怎样的数据结构</p>
<p>队列,FIFO，LRU算法最为精典的实现，HashMap+Double LinkedList，时间复杂度为O(1)</p>
<pre><code>struct Node
{
    Node(int _key,int _value){key = _key;value = _value;pre = next = NULL;}
    int key;
    int value;
    Node*pre;
    Node*next;
};
class LRUCache{
public:
    // @param capacity, an integer
    LRUCache(int capacity) {
        // write your code here
        this-&gt;capacity = capacity;
        size = 0;
        head = NULL;
        tail = NULL;
    }

    // @return an integer
    int get(int key) {
        // write your code here
        if(m.find(key)==m.end())
        {
            return -1;
        }
        else
        {
            Node* n = m[key];
            int ret = n-&gt;value;
            if(head!=n)
            {
                if(n==tail)
                    tail = tail-&gt;pre;
                Node*pre = n-&gt;pre;
                if(n-&gt;next!=NULL)
                    n-&gt;next-&gt;pre = pre;
                pre-&gt;next = n-&gt;next;
                n-&gt;next = head;
                head-&gt;pre = n;
                head = n;
            }
            return ret;
        }
    }

    // @param key, an integer
    // @param value, an integer
    // @return nothing
    void set(int key, int value) {
        // write your code here
        if(head==NULL)
        {
            head = new Node(key,value);
            tail = head;
            size++;
            m[key] = head;
            return;
        }
        if(m.find(key)==m.end())
        {
            Node*n = new Node(key,value);
            n-&gt;next = head;
            head-&gt;pre = n;
            head = n;
            m[key] = n;
            size++;
        }
        else
        {
            Node*n = m[key];
            if(head!=n)
            {
                if(n==tail)
                    tail = tail-&gt;pre;
                Node*pre = n-&gt;pre;
                pre-&gt;next = n-&gt;next;
                if(n-&gt;next!=NULL)
                    n-&gt;next-&gt;pre = pre;
                n-&gt;next = head;
                head-&gt;pre = n;
                head = n;
                m[key] = n;
            }
            head-&gt;value = value;
        }
        if(size&gt;capacity)
        {
            Node*todel = tail;
            int keyToDel = todel-&gt;key;
            tail = tail-&gt;pre;
            tail-&gt;next = NULL;
            delete todel;
            m.erase(m.find(keyToDel));
            size--;
        }

    }

    private:
        int capacity;
        int size;
        Node*head;
        Node*tail;
        unordered_map&lt;int,Node*&gt; m;
};
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>redis</tag>
        <tag>内存</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>RDB和AOF持久化</title>
    <url>/article/csdn/RDB%E5%92%8CAOF%E6%8C%81%E4%B9%85%E5%8C%96.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/52567049" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/52567049</a></p>
<h1><span id="rdb持久化">RDB持久化</span></h1><p>直接保存数据库的键值对。是二进制文件存储。指定的时间间隔内生成数据集的时间点快照</p>
<h2><span id="两个命令">两个命令:</span></h2><p>1 SAVE 会阻塞进程<br>2 BGSAVE 创建子进程处理文件，不会阻塞。父进程继续处理client请求，子进程负责将内存内容写入到临时文件。由于os的写时复制机制（copy on<br>write)父子进程会共享相同的物理页面，当父进程处理写请求时os会为父进程要修改的页面创建副本，而不是写共享的页面。所以子进程的地址空间内的数<br>据是fork时刻整个数据库的一个快照。</p>
<p>redis可以设置自动性间隔保存<br>如:save 300 10<br>表明服务器300秒内至少调用10次，会自动调用BGSAVE命令</p>
<p>rdb文件结构：<br>redis-db_version-databases-EOF-check_sum</p>
<h2><span id="优势">优势</span></h2><p>一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这样非常方便进行备份。比如你可能打算没1天归档一些数据。<br>方便备份，我们可以很容易的将一个一个RDB文件移动到其他的存储介质上<br>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。<br>RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork<br>出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。</p>
<h2><span id="劣势">劣势</span></h2><p>如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB<br>文件的频率， 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。<br>在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。<br>每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， fork()<br>可能会非常耗时，造成服务器在某某毫秒内停止处理客户端； 如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然<br>AOF 重写也需要进行 fork() ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。</p>
<h1><span id="aof持久化">AOF持久化</span></h1><p>redis会将每一个收到的写命令都通过write函数追加到文件中(默认是 appendonly.aof)。<br>当redis重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。当然由于os会在内核中缓存<br>write做的修改，所以可能不是立即写到磁盘上。这样aof方式的持久化也还是有可能会丢失部分修改。不过我们可以通过配置文件告诉redis我们想要<br>通过fsync函数强制os写入到磁盘的时机。有三种方式如下（默认是：每秒fsync一次）</p>
<p>如果：appendonly yes //启用aof持久化方式，则redis优先使用aof<br>appendfsync 选项直接决定AOF持久化的效率与安全性。<br>appendfsync - always每次都把缓冲区的内容写入AOF文件。<br>appendfsync - everysec每秒都把缓冲区的内容写入AOF文件。</p>
<p>aof保存的是服务器的写命令。</p>
<p>aof重写优化</p>
<h2><span id="优势">优势</span></h2><p>使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 fsync 策略，比如无 fsync<br>，每秒钟一次 fsync ，或者每次执行写入命令时 fsync 。 AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis<br>仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。</p>
<p>AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 seek ，<br>即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， redis-check-aof 工具也可以轻易地修复这种问题。<br>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。<br>整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的<br>AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</p>
<p>AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂，<br>对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要<br>AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到<br>FLUSHALL 执行之前的状态。</p>
<h2><span id="劣势">劣势</span></h2><p>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</p>
<p>根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让<br>AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。</p>
<p>AOF 在过去曾经发生过这样的 bug ： 因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。 （举个例子，阻塞命令<br>BRPOPLPUSH 就曾经引起过这样的 bug 。） 测试套件里为这种情况添加了测试： 它们会自动生成随机的、复杂的数据集，<br>并通过重新载入这些数据来确保一切正常。 虽然这种 bug 在 AOF 文件中并不常见， 但是对比来说， RDB 几乎是不可能出现这种 bug 的。</p>
<h1><span id="抉择">抉择</span></h1><p>一般来说， 如果想达到高要求的数据安全性， 应该同时使用两种持久化功能。<br>如果你可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>SWAR算法：计算Hamming Weight</title>
    <url>/article/csdn/SWAR%E7%AE%97%E6%B3%95%EF%BC%9A%E8%AE%A1%E7%AE%97Hamming_Weight.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/52491045" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/52491045</a></p>
<h2><span id="hamming-weight">Hamming Weight</span></h2><p>即汉明重量，指的是一个位数组中非0二进制位的数量。<br>比如a[] = {1,0,1,0,0,1,1,0}统计非0数目为4。</p>
<p>比较常规的方法，按位统计，算法复杂度O（n）。<br>redis里实现用到了两种算法：</p>
<p>1 查表法 比如<br>0000 0001 ： 1<br>0110 0001 ： 3<br>……<br>1111 1111 ： 8</p>
<h2><span id="swar算法">SWAR算法</span></h2><p>代码：</p>
<pre><code>// 计算32位二进制的汉明重量
int32_t swar(int32_t i)
{    
    i = (i &amp; 0x55555555) + ((i &gt;&gt; 1) &amp; 0x55555555);
    i = (i &amp; 0x33333333) + ((i &gt;&gt; 2) &amp; 0x33333333);
    i = (i &amp; 0x0F0F0F0F) + ((i &gt;&gt; 4) &amp; 0x0F0F0F0F);
    i = (i * (0x01010101) &gt;&gt; 24);
    return i
}
</code></pre><p>第一步：<br>计算出来的值i的二进制可以按每2个二进制位为一组进行分组，各组的十进制表示的就是该组的汉明重量。</p>
<p>第二步：<br>计算出来的值i的二进制可以按每4个二进制位为一组进行分组，各组的十进制表示的就是该组的汉明重量。</p>
<p>第三步：<br>计算出来的值i的二进制可以按每8个二进制位为一组进行分组，各组的十进制表示的就是该组的汉明重量。</p>
<p>第四步：<br>i *<br>(0x01010101)计算出汉明重量并记录在二进制的高八位，&gt;&gt;24语句则通过右移运算，将汉明重量移到最低八位，最后二进制对应的的十进制数就是汉明重量。</p>
<p>算法时间复杂度是O（1）的。</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Rabin数字签名  Lamport 一次签名</title>
    <url>/article/csdn/Rabin%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D_Lamport_%E4%B8%80%E6%AC%A1%E7%AD%BE%E5%90%8D.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/49720821" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/49720821</a></p>
<p>Rabin数字签名 代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;time.h&gt;
#include&lt;iostream&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;
#include&lt;algorithm&gt;
#include&lt;random&gt;

using namespace std;

const int S = 10;

long long mult_mod(long long a, long long b, long long c)
{
    a %= c;
    b %= c;
    long long ret = 0;
    while (b)
    {
        if (b &amp; 1) { ret += a; ret %= c; }
        a &lt;&lt;= 1;
        if (a &gt;= c)a %= c;
        b &gt;&gt;= 1;
    }
    return ret;
}

//计算 ret =  x^n %c
long long pow_mod(long long x, long long n, long long mod)//x^n%c
{
    if (n == 1)return x%mod;
    x %= mod;
    long long tmp = x;
    long long ret = 1;
    while (n)
    {
        if (n &amp; 1) ret = mult_mod(ret, tmp, mod);
        tmp = mult_mod(tmp, tmp, mod);
        n &gt;&gt;= 1;
    }
    return ret;
}

bool check(long long a, long long n, long long x, long long t)
{
    long long ret = pow_mod(a, x, n);
    long long last = ret;
    for (int i = 1; i &lt;= t; i++)
    {
        ret = mult_mod(ret, ret, n);
        if (ret == 1 &amp;&amp; last != 1 &amp;&amp; last != n - 1) return true;//合数
        last = ret;
    }
    if (ret != 1) return true;
    return false;
}

bool Miller_Rabin(long long n)//Miller_Rabin算法判断素数
{
    if (n&lt;2)return false;
    if (n == 2)return true;
    if ((n &amp; 1) == 0) return false;//偶数
    long long x = n - 1;
    long long t = 0;
    while ((x &amp; 1) == 0) { x &gt;&gt;= 1; t++; }
    for (int i = 0; i&lt;S; i++)
    {
        long long a = rand() % (n - 1) + 1;
        if (check(a, n, x, t))
            return false;//合数
    }
    return true;
}

long long gcd(long long a, long long b)
{
    if (a == 0)return 1;
    if (a&lt;0) return gcd(-a, b);
    while (b)
    {
        long long t = a%b;
        a = b;
        b = t;
    }
    return a;
}

bool Legendre(int a, int p)
{
    int tmp = pow(a, (p - 1) / 2);
    if (tmp % p == 1)
        return true;
    else
        return false;
}

int main()
{
    cout &lt;&lt; &quot;*******************************************&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;测试数据假定 p = 7 q = 11 ，进行签名和验证&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;*******************************************&quot; &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl;
    static uniform_int_distribution&lt;unsigned&gt; u(1000000, 1000000000);
    static default_random_engine e(time(0));
    long long p = 6, q = 6;

    //随机产生素数p q
    while (!Miller_Rabin(p))
        p = u(e);
    while (!Miller_Rabin(q))
        q = u(e);

    //cout &lt;&lt; p &lt;&lt; &quot; &quot; &lt;&lt; q &lt;&lt; endl;
    long long n = p*q;
    cout &lt;&lt; &quot;素数p,q生成完毕！&quot; &lt;&lt; endl;
    p = 7;
    q = 11;

    //签名生成
    cout &lt;&lt; &quot;请输入 m 进行签名:&quot; &lt;&lt; endl;
    long long m;
    cin &gt;&gt; m;

    if (!(Legendre(m, p) &amp;&amp; Legendre(m, q)))
    {
        while (!(Legendre(m, p) &amp;&amp; Legendre(m, q)))
            m = m - 1;
    }

    long long s = ((long long)sqrt(m)) % n; 

    //签名验证
    cout &lt;&lt; &quot;请输入s进行签名验证:&quot; &lt;&lt; endl;
    int ss;
    cin &gt;&gt; ss;
    if (m == ss*ss%n)
        cout &lt;&lt; &quot;true 验证成功！&quot; &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;false 验证失败！&quot; &lt;&lt; endl;

    return 0;
}
</code></pre><p>Lamport 一次签名：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;cmath&gt;
#include &lt;string&gt;

using namespace std;

int quickpow(int m, int n, int k)
{
    int  b = 1;
    while (n &gt; 0)
    {
        if (n &amp; 1)
            b = (b*m) % k;
        n = n &gt;&gt; 1;
        m = (m*m) % k;
    }
    return b;
}

int main()
{
    int n, MOD;
    cin &gt;&gt; n &gt;&gt; MOD;

    int y10, y11, y20, y21, y30, y31;
    cin&gt;&gt;y10&gt;&gt;y11&gt;&gt;y20&gt;&gt;y21&gt;&gt;y30&gt;&gt;y31;

    int z10, z11, z20, z21, z30, z31;
    //
    z10 = quickpow(n, y10, MOD);
    z11 = quickpow(n, y11, MOD);
    z20 = quickpow(n, y20, MOD);
    z21 = quickpow(n, y21, MOD);
    z30 = quickpow(n, y30, MOD);
    z31 = quickpow(n, y31, MOD);
    //

    string cl;
    cin &gt;&gt; cl;
    int len = cl.size();
    int Sign[100];

    if (cl[0] == &#39;0&#39;)
        Sign[0] = y30;
    else 
        Sign[0] = y31;
    if (cl[1] == &#39;0&#39;)
        Sign[1] = y20;
    else
        Sign[1] = y21;
    if (cl[2] == &#39;0&#39;)
        Sign[2] = y10;
    else
        Sign[2] = y11;


    int Sign_ans[100];

    for (int i = 0; i &lt; 3; i++)
    {
        Sign_ans[i] = quickpow(n, Sign[2-i],MOD);
        cout &lt;&lt; Sign_ans[i] &lt;&lt; endl;
    }


    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Redis主从同步</title>
    <url>/article/csdn/Redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/50554347" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/50554347</a></p>
<h1><span id="全量同步">全量同步</span></h1><p>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下：<br>1）从服务器连接主服务器，发送SYNC命令；<br>2）主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令；<br>3）主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；<br>4）从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；<br>5）主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；<br>6）从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</p>
<h1><span id="增量同步">增量同步</span></h1><p>Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。<br>增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令</p>
<h1><span id="redis主从同步策略">Redis主从同步策略</span></h1><p>主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis<br>策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>服务器</tag>
        <tag>数据</tag>
      </tags>
  </entry>
  <entry>
    <title>STL 之 pair 和map</title>
    <url>/article/csdn/STL_%E4%B9%8B_pair_%E5%92%8Cmap.html</url>
    <content><![CDATA[<p>STL的<utility>头文件中描述了一个非常简单的模板类pair，用来表示一个二元组或元素对，并提供了大小比较的比较运算符模板函数。</utility></p>
<p>pair模板类需要两个参数：首元素的数据类型和尾元素的数据类型。pair模板类对象有两个成员：first和second，分别表示首元素和尾元素。</p>
<p>在<utility>中已经定义了pair上的六个比较运算符：&lt;、&gt;、&lt;=、&gt;=、==、!=，其规则是先比较first，first相等时再比较second，这符合大多数应用的逻辑。当然，也可以通过重载这几个运算符来重新指定自己的比较逻辑。</utility></p>
<ul>
<li>例子程序： </li>
</ul>
<pre><code>// map/pair-test.cpp - Show basic use of pair.  
// 2004-02-29 - Fred Swartz - Rodenbach  

#include &lt;utility&gt;  
#include &lt;iostream&gt;  
#include &lt;string&gt;  
#include &lt;map&gt;  
using namespace std;  

int main() {  
    //-- Declare a pair variable.  
    pair&lt;string, int&gt; pr1;  

    //-- Declare and initialize with constructor.  
    pair&lt;string, int&gt; pr2(&quot;heaven&quot;, 7);  
    cout &lt;&lt; pr2.first &lt;&lt; &quot;=&quot; &lt;&lt; pr2.second &lt;&lt; endl;  
    // Prints heaven=7  

    //-- Declare and initialize pair pointer.  
    pair&lt;string, int&gt;* prp = new pair&lt;string, int&gt;(&quot;yards&quot;, 9);  
    cout &lt;&lt; prp-&gt;first &lt;&lt; &quot;=&quot; &lt;&lt; prp-&gt;second &lt;&lt; endl;  
    // Prints yards=9  

    //-- Declare map and assign value to keys.  
    map&lt;string, string&gt; engGerDict;  
    engGerDict[&quot;shoe&quot;] = &quot;Schuh&quot;;  
    engGerDict[&quot;head&quot;] = &quot;Kopf&quot;;  

    //-- Iterate over map.  Iterator value is a key-value pair.  
    //   Iteration in map is in sorted order.  
    map&lt;string, string&gt;::const_iterator it;  
    for (it=engGerDict.begin(); it != engGerDict.end(); ++it) {  
        cout &lt;&lt; it-&gt;first &lt;&lt; &quot;=&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;  
    }  
    // Prints head=kopf  
    //        shoe=Schuh  

    system(&quot;PAUSE&quot;);  
    return 0;  
}  
</code></pre><p>除了直接定义一个pair对象外，如果需要即时生成一个pair对象，也可以调用在<utility>中定义的一个模板函数：make_pair。make_pair需要两个参数，分别为元素对的首元素和尾元素。</utility></p>
<ul>
<li>例子程序： </li>
<li></li>
</ul>
<pre><code>// mkpair.cpp  
// compile with: /EHsc  
// Illustrates how to use the make_pair function.  
//  
// Functions: make_pair - creates an object pair containing two data  
//                        elements of any type.  

========make_pair  
#include &lt;utility&gt;  
#include &lt;iostream&gt;  

using namespace std;  

/* STL pair data type containing int and float 
*/  

typedef struct pair&lt;int,float&gt; PAIR_IF;  

int main(void)  
{  
  PAIR_IF pair1=make_pair(18,3.14f);  

  cout &lt;&lt; pair1.first &lt;&lt; &quot;  &quot; &lt;&lt; pair1.second &lt;&lt; endl;  
  pair1.first=10;  
  pair1.second=1.0f;  
  cout &lt;&lt; pair1.first &lt;&lt; &quot;  &quot; &lt;&lt; pair1.second &lt;&lt; endl;  
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>SGU 194. Reactor Cooling【无源汇上下界最大流】</title>
    <url>/article/csdn/SGU_194._Reactor_Cooling%E3%80%90%E6%97%A0%E6%BA%90%E6%B1%87%E4%B8%8A%E4%B8%8B%E7%95%8C%E6%9C%80%E5%A4%A7%E6%B5%81%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48215853" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48215853</a></p>
<p>题目链接： <a href="http://acm.sgu.ru/problem.php?contest=0&amp;problem=194" target="_blank" rel="noopener"> http://acm.sgu.ru/problem.php?contest=0&amp;problem=194
</a></p>
<p>当所有附加边全部满流时（即maxflow==所有du[]&gt;0之和），有可行解。</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;sstream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;string&gt;

using namespace std;

const int MAXN = 1010;//点数的最大值
const int MAXM = 400100;//边数的最大值
const int INF = 0x3f3f3f3f;

struct Edge
{
    int to, next, cap, flow;
}edge[MAXM];//注意是MAXM

int tol;
int head[MAXN];
int gap[MAXN], dep[MAXN], pre[MAXN], cur[MAXN];

void init()
{
    tol = 0;
    memset(head, -1, sizeof(head));
}
//加边，单向图三个参数，双向图四个参数
void addedge(int u, int v, int w, int rw = 0)
{
    edge[tol].to = v; edge[tol].cap = w; edge[tol].next = head[u];
    edge[tol].flow = 0; head[u] = tol++;
    edge[tol].to = u; edge[tol].cap = rw; edge[tol].next = head[v];
    edge[tol].flow = 0; head[v] = tol++;
}
//输入参数：起点、终点、点的总数
//点的编号没有影响，只要输入点的总数
int sap(int start, int end, int N)
{
    memset(gap, 0, sizeof(gap));
    memset(dep, 0, sizeof(dep));
    memcpy(cur, head, sizeof(head));
    int u = start;
    pre[u] = -1;
    gap[0] = N;
    int ans = 0;
    while (dep[start] &lt; N)
    {
        if (u == end)
        {
            int Min = INF;
            for (int i = pre[u]; i != -1; i = pre[edge[i ^ 1].to])
                if (Min &gt; edge[i].cap - edge[i].flow)
                    Min = edge[i].cap - edge[i].flow;
            for (int i = pre[u]; i != -1; i = pre[edge[i ^ 1].to])
            {
                edge[i].flow += Min;
                edge[i ^ 1].flow -= Min;
            }
            u = start;
            ans += Min;
            continue;
        }
        bool flag = false;
        int v;
        for (int i = cur[u]; i != -1; i = edge[i].next)
        {
            v = edge[i].to;
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[v] + 1 == dep[u])
            {
                flag = true;
                cur[u] = pre[v] = i;
                break;
            }
        }
        if (flag)
        {
            u = v;
            continue;
        }
        int Min = N;
        for (int i = head[u]; i != -1; i = edge[i].next)
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min)
            {
                Min = dep[edge[i].to];
                cur[u] = i;
            }
        gap[dep[u]]--;
        if (!gap[dep[u]])return ans;
        dep[u] = Min + 1;
        gap[dep[u]]++;
        if (u != start) u = edge[pre[u] ^ 1].to;
    }
    return ans;
}

int n, m;
int in[MAXN], least[MAXM], num[MAXM];

int main()
{
    while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))
    {
        init();
        memset(in, 0, sizeof(in));
        memset(least, 0, sizeof(least));

        int a, b, c, d;
        for (int i = 1;i &lt;= m;i++)
        {
            scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d);
            num[i] = tol;
            least[i] = c;
            in[a] -= c;
            in[b] += c;

            addedge(a, b, d - c);
        }
        int sum = 0;
        for (int i = 1;i &lt;= n;i++)
        {
            if (in[i] &gt; 0)
            {
                addedge(0, i, in[i]);
                sum += in[i];
            }
            else addedge(i, n + 1, -in[i]);
        }
        if (sap(0, n + 1, n + 2) != sum) puts(&quot;NO&quot;);
        else
        {
            puts(&quot;YES&quot;);
            for (int i = 1;i &lt;= m;i++) printf(&quot;%d\n&quot;, edge[num[i]].flow + least[i]);
        }

    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Traveling 【图的性质】</title>
    <url>/article/csdn/Traveling_%E3%80%90%E5%9B%BE%E7%9A%84%E6%80%A7%E8%B4%A8%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44727349" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44727349</a></p>
<p>Traveling<br>时间限制: 1 Sec 内存限制: 32 MB<br>提交: 41 解决: 23<br>[提交][状态][讨论版]<br>题目描述<br>SH likes traveling around the world. When he arrives at a city, he will ask<br>the staff about the number of cities that connected with this city directly.<br>After traveling around a mainland, SH will collate data and judge whether the<br>data is correct.<br>A group of data is correct when it can constitute an undirected graph.<br>输入<br>There are multiple test cases. The first line of each test case is a positive<br>integer N (1&lt;=N&lt;=10000) standing for the number of cities in a mainland. The<br>second line has N positive integers a1, a2, …,an. ai stands for the number of<br>cities that connected directly with the ith city. Input will be ended by the<br>END OF FILE.<br>输出<br>If a group of data is correct, output “YES” in one line, otherwise, output<br>“NO”.<br>样例输入<br>8<br>7 7 4 3 3 3 2 1<br>10<br>5 4 3 3 2 2 2 1 1 1<br>样例输出<br>NO<br>YES</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;

using namespace std;

const int MAXN =10010;

int p[MAXN];
int n;

int solve ()
{
    for(int i=0;i&lt;n;i++)
    {
        for(int j=i+1;j&lt;n;j++)
        {
            if (p[i]&gt;0 &amp;&amp; p[j] &gt;0)
            {
                p[i]-- ;
                p[j]--;
            }
        }
        if (p[i]!=0)
        {
            return 0;
        }
    }
    return 1;
}

int main()
{
    while (scanf(&quot;%d&quot;,&amp;n)!=EOF)
    {
        for(int i=0;i&lt;n;i++)
            scanf(&quot;%d&quot;,&amp;p[i]);
        if (solve())
            printf(&quot;YES\n&quot;);
        else
            printf(&quot;NO\n&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Socket基本API 总结</title>
    <url>/article/csdn/Socket%E5%9F%BA%E6%9C%ACAPI_%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46432733" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46432733</a></p>
<p>套接字建立过程：</p>
<pre><code>srever:
1 socket创建套接字
2 bind ip和port
3 listen
4 accept
5 read/write
6 close

client:
1 socket
2 connect
3 read/write
4 close


int socket(int domain, int type, int protocol);
//失败返回-1，成功返回文件描述符
//domain 套接字协议族 type数据类型 protocol通信协议信息

int bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen);

int listen(int sockfd, int backlog);

int accept(int sockfd, struct sockaddr *addr,socklen_t *addrlen);

int connect(int sockfd, struct,sockaddr *serv_addr, socklen_t, addrlen);
/*
成功返回0，失败返回-1
*/
</code></pre><p>协议族：<br>PF_INET, PF_INET6,PF_LOCAL等</p>
<p>套接字类型：<br>SOCK_STREAM 面向连接<br>SOCK_DGRAM 面向消息</p>
<p>文件描述符：</p>
<pre><code>int open(const char *path, int flag);
//path 地址,flag打开方式

int close(int fd);
//成功返回0，失败返回-1

//写入文件：
ssize_t write(int fd, const void *buf, size_t, ntypes);
//失败返回-1，成功返回写入的字节数

//读取文件
ssize_t read(int fd, void *buf, size_t nbytes);
//失败返回-1，成功返回接收的字节数
</code></pre><p>IPv4结构体</p>
<pre><code>struct sockaddr_in
{
    sa_family_t    sin_family; //地址族
    uint16_t       sin_port;   //端口号
    struct in_addr sin_addr;   //32位ip
    char           sin_zero[8];//不使用   
};

struct in_addr
{
    In_addr_t   s_addr;        //32位iPv4地址
}
</code></pre><p>地址族： AF_INET,AF_INET6,AF_LOCAL</p>
<p>字节序转换：</p>
<pre><code>unsigned short htons(unsigned short);
unsigned short ntohs(unsigned short);
unsigned short htonl(unsigned short);
unsigned short ntohl(unsigned short);
/*
h代表主机(host)字节序
n代表网络(network)字节序
s是short
l是long
*/

in_addr_t inet_addr(const char *string);
//返回32位大端整数值，失败返回INADDR_NONE

int inet_aton(const char *string, struct in_addr * addr);
//成功返回1，失败返回0
//将字符串32位ip地址转换为整数

char *inet_ntoa(struct in_addr adr);
//成功返回地址值，失败返回-1
//将整数ip转换为字符串
</code></pre><p>UDP函数</p>
<pre><code>ssize_t sendto(int sock, void *buff, size_t ntypes, int flags, struct sockaddr *to, socklen_t addrlen);

ssize_t recvfrom(int sock, void *buff, size_t nbytes, int flags, struct sockaddr *from, socklen_t *addrlen);
</code></pre><p>断开函数shutdown</p>
<pre><code>int shutdown(int sock, int howto);
/*
第二个参数是断开方式：
SHUT_RD    断开输入流
SHUT_WR    断开输出流
SHUT_RDWR  同时断开O/I流
*/
</code></pre><p>IP与域名的转换</p>
<pre><code>struct hostent * gethostbyname(const char *hostname);
//通过域名获得ip

struct hostent * gethostbyaddr(const char *addr, socklen_t len, int family);
//通过ip获得域相关信息

struct hostent
{
    char * h_name;       //official name
    char ** h_aliases;   //alias list 
    int h_addrtype;      //host address type
    int h_length;        //address length
    char ** h_addr_list; //address list
};
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>UVA 10099	The Tourist Guide【floyd】</title>
    <url>/article/csdn/UVA_10099_The_Tourist_Guide%E3%80%90floyd%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47446241" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47446241</a></p>
<p>题目链接：<br><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1040" target="_blank" rel="noopener"><br>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1040
</a></p>
<p>题意：<br>n个点，m条路径，每条路径最多通过人数最多为value人，求把v个游客从a点运送到b点，需要几辆车，注意导游自己也算一个人。<br>思路：floyd找出两点间最大运送量，然后计算需要几躺即可</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;

using namespace std;

int n,r;

int p[110][110];

int main()
{
    int cases=1;
    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;r) &amp;&amp;n)
    {
        int a,b,c;
        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;=n;j++)
        {
            if (i == j) p[i][j] = 0;
            else p[i][j] = -1;
        }
        for(int i=1;i&lt;=r;i++)
        {
            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
            if (p[a][b] &lt; c)
            {
                p[a][b] = p[b][a] = c;
            }
        }
        for(int k=1;k&lt;=n;k++)
            for(int i=1;i&lt;=n;i++)
                for(int j=1;j&lt;=n;j++)
                {
                    if(p[i][k]!=-1 &amp;&amp; p[k][j]!=-1)
                        p[i][j] = max(p[i][j],min(p[i][k],p[k][j]));
                }
        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
       // printf(&quot;           %d\n&quot;,p[a][b]);
        int tmp=p[a][b];
        int ans = c / (tmp-1);
        if (c % (tmp-1)) ans+=1;
        printf(&quot;Scenario #%d\n&quot;,cases++);
        printf(&quot;Minimum Number of Trips = %d\n\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>uva</tag>
      </tags>
  </entry>
  <entry>
    <title>The Minimum Length 【kmp】</title>
    <url>/article/csdn/The_Minimum_Length_%E3%80%90kmp%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44116355" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44116355</a></p>
<p>The Minimum Length</p>
<p><strong>Time Limit:</strong> 1000  MS <strong>Memory Limit:</strong> 131072  KB <strong>64bit IO Format:</strong><br>%lld  &amp; %llu</p>
<p>Submit  <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=70325#status//F/0" target="_blank" rel="noopener"> Status
</a></p>
<p>Description</p>
<p>There is a string A. The length of A is less than 1,000,000. I rewrite it<br>again and again. Then I got a new string: AAAAAA…… Now I cut it from two<br>different position and get a new string B. Then, give you the string B, can<br>you tell me the length of the shortest possible string A. For example,<br>A=”abcdefg”. I got abcd <strong> efgabcdefgabcde  </strong> fgabcdefg…. Then I cut the<br>red part: efgabcdefgabcde as string B. From B, you should find out the<br>shortest A.</p>
<p>Input</p>
<p>Multiply Test Cases. For each line there is a string B which contains only<br>lowercase and uppercase charactors. The length of B is no more than 1,000,000.</p>
<p>Output</p>
<p>For each line, output an integer, as described above.</p>
<p>Sample Input</p>
<pre><code>bcabcab
efgabcdefgabcde
</code></pre><p>Sample Output</p>
<pre><code>3
7
</code></pre><p>同样还是循环节的考察，求最短循环节。</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;

using namespace std;

char  b[1000500];
int Next[1000500];

void get_next(char b[], int m)
{
    int i = 0,j = -1;
    memset(Next,0,sizeof(Next));
    Next[0] = -1;
    while (b[i])
    {
        if (j == -1 || b[i] == b[j])
        {
            ++i;
            ++j;
            Next[i] = j;
        }
        else
            j = Next[j];
    }
}

int main()
{
    int cases = 1, n, m, i, j;

    while (scanf(&quot;%s&quot;,&amp;b)!=EOF)
    {
        n = strlen(b);
        get_next(b, n);
        int ans = 0;

        for (int i = 1; b[i-1]; i++)
        {
            int t = Next[i];
            int s = i - t;
            if (i % s == 0 )
            {
                ans = max(ans,s);
            }
        }
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>UVA 10441	Catenyms【欧拉路】</title>
    <url>/article/csdn/UVA_10441_Catenyms%E3%80%90%E6%AC%A7%E6%8B%89%E8%B7%AF%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47359777" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47359777</a></p>
<p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/problem/visitOriginUrl.action?id=41674" target="_blank" rel="noopener"> http://acm.hust.edu.cn/vjudge/problem/visitOriginUrl.action?id=41674
</a></p>
<p>题意：给定一些单词，如果一个单词的尾字母与另一个的首字母相同则可以连接。问是否可以每个单词用一次，将所有单词连接，可以则输出字典序最小的序列。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int t;
int n;
string s[1010];

struct Edge
{
    int to, next;
    int index;
    bool flag;
}edge[2010];

int head[300], tot;

void init()
{
    tot = 0;
    memset(head,-1,sizeof(head));
}

void addedge(int u, int v, int index)
{
    edge[tot].to = v;
    edge[tot].next = head[u];
    edge[tot].index = index;
    edge[tot].flag = false;
    head[u] = tot++;
}

int in[250], out[250];

int cnt;
int ans[1010];

void dfs(int u)
{
    for (int i = head[u]; i != -1; i = edge[i].next)
    {
        if (!edge[i].flag)
        {
            edge[i].flag = true;
            dfs(edge[i].to);
            ans[cnt++] = edge[i].index;
        }
    }
}

int main()
{
    int t;
    cin &gt;&gt; t;
    while (t--)
    {

        scanf(&quot;%d&quot;,&amp;n);
        for (int i = 0; i &lt; n; i++)
            cin &gt;&gt; s[i];
        sort(s, s + n);
        init();
        memset(in,0,sizeof(in));
        memset(out, 0, sizeof(out));
        int start = 100;
        for (int i = n - 1; i &gt;= 0; i--)
        {
            int u = s[i][0] - &#39;a&#39;;
            int v = s[i][s[i].length() - 1] - &#39;a&#39;;
            addedge(u,v,i);
            out[u]++;
            in[v]++;
            if (u &lt; start) start = u;
            if (v &lt; start) start = v;
        }
        int cc1 = 0, cc2 = 0;
        for (int i = 0; i &lt; 26; i++)
        {
            if (out[i] - in[i] == 1)
            {
                cc1++;
                start = i;
            }
            else if (out[i] - in[i] == -1)
                cc2++;
            else if (out[i] - in[i] != 0)
                cc1 = 3;
        }
        if (!((cc1 == 0 &amp;&amp; cc2 == 0) || (cc1 == 1 &amp;&amp; cc2 == 1)))
        {
            printf(&quot;***\n&quot;);
            continue;
        }
        cnt = 0;
        dfs(start);
        if (cnt != n)
        {
            printf(&quot;***\n&quot;);
            continue;
        }
        for (int i = n-1; i &gt;=0 ; i--)
        {
            cout &lt;&lt; s[ans[i]];
            if (i != 0) printf(&quot;.&quot;);
            else printf(&quot;\n&quot;);
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>UVA 10034	Freckles 【最小生成树】</title>
    <url>/article/csdn/UVA_10034_Freckles_%E3%80%90%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47441425" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47441425</a></p>
<p>题目链接：<br><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=975" target="_blank" rel="noopener"><br>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=975
</a></p>
<p>题意：裸的最小生成树</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;

using namespace std;
using namespace std;

#define INF 999999

double map[130][130],dis[130];
int v[130];

double prim(int n)
{
    int i,j,k;
    double min,sum=0;
    for(i=1;i&lt;=n;i++)
        dis[i]=map[1][i];
    memset(v,0,sizeof(v));
    v[1]=1;
    dis[1]=0;
    for(i=2;i&lt;=n;i++)
    {
        k=1;
        min=INF;
        for(j=1;j&lt;=n;j++)
            if(!v[j]&amp;&amp;min&gt;dis[j])
            {
                k=j;
                min=dis[j];
            }
        sum+=min;
        v[k]=1;
        for(j=1;j&lt;=n;j++)
            if(!v[j]&amp;&amp;dis[j]&gt;map[k][j])
                dis[j]=map[k][j];
    }
    return sum;
}

struct node
{
    double x,y;
}p[110];

double get_dis(node a,node b)
{
    return sqrt((a.x - b.x) *(a.x - b.x) + (a.y - b.y)*(a.y - b.y));
}

int main()
{
    int n;
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while(t--)
    {
        scanf(&quot;%d&quot;,&amp;n);
        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;=n;j++)
               {
                   if (i!=j) map[i][j]=INF;
                   else map[i][j] = 0;
               }
        for(int i=1;i&lt;=n;i++)
            scanf(&quot;%lf%lf&quot;,&amp;p[i].x,&amp;p[i].y);
        for(int i=1;i&lt;=n;i++)
            for(int j = 1;j&lt;=n;j++)
            map[i][j] = get_dis(p[i],p[j]);

        printf(&quot;%.2lf\n&quot;,prim(n));
        if (t) printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>UVA 10269	Adventure of Super Mario 【最短路 + dp】</title>
    <url>/article/csdn/UVA_10269_Adventure_of_Super_Mario_%E3%80%90%E6%9C%80%E7%9F%AD%E8%B7%AF_+_dp%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47449929" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47449929</a></p>
<p>题目链接：<br><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1210" target="_blank" rel="noopener"><br>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1210
</a></p>
<p>题意：<br>给你a（1~a）个村子 b(a+1 ~ b)个城堡 ,m条路, 问你回家（a+b 到<br>1）花费的最少能量.你有魔法鞋子，每次最多可以走L长的距离且不花费能量，最多使用K次，魔法鞋子不能穿越城堡。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;

using namespace std;

const int INF = 100000000;

int is[110][110];
int p[110][110];
int dp[110][20];// dp[i][j]  使用了 j 次魔法鞋到 i 点的最短距离
int a, b, l, m, k;

void dijkstra()
{
    memset(dp,0,sizeof(dp));
    for (int i = 1;i &lt;= a + b;i++)
        dp[i][0] = p[1][i];

    for (int i = 2;i &lt;= a + b;i++)
    {
        for (int kk = 1;kk &lt;= k;kk++)
        {
            int MIN = INF;
            for (int j = 1;j &lt; i;j++)
            {
                if (is[i][j])
                    MIN = min(MIN,dp[j][kk-1]);
                MIN = min(MIN,dp[j][kk] + p[i][j]);
            }
            dp[i][kk] = MIN;
        }
    }
}

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%d%d%d%d%d&quot;, &amp;a, &amp;b, &amp;m, &amp;l, &amp;k);
        int u, v, w;
        memset(is, 0, sizeof(is));
        for (int i = 1;i &lt;= a + b;i++)
            for (int j = 1;j &lt;= a + b;j++)
            {
                if (i == j) p[i][j] = 0;
                else p[i][j] = INF;
            }
        while (m--)
        {
            scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);
            p[u][v] = p[v][u] = w;
            if (w &lt;= l) is[u][v] = is[v][u] = 1;
        }
        for (int kk = 1;kk &lt;= a + b;kk++)
            for (int i = 1;i &lt;= a + b;i++)
                for (int j = 1;j &lt;= a + b;j++)
                {
                    if (p[i][kk] + p[kk][j] &lt; p[i][j])
                    {
                        p[i][j] = p[i][kk] + p[kk][j];
                        if (p[i][j] &lt;= l &amp;&amp; kk &lt;= a) is[i][j] = is[j][i] = 1;
                    }
                }
        dijkstra();
        printf(&quot;%d\n&quot;,dp[a+b][k]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>uva</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA 10608	Friends【并查集】</title>
    <url>/article/csdn/UVA_10608_Friends%E3%80%90%E5%B9%B6%E6%9F%A5%E9%9B%86%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47446725" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47446725</a></p>
<p>题目链接：<br><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1549" target="_blank" rel="noopener"><br>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1549
</a></p>
<p>题意：给定n个人m种朋友关系，求最大朋友圈的人数。裸并查集</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;

using namespace std;

int f[30010];
int c[30010];

int find(int x)
{
    if (f[x] == x) return x;
    else return f[x] = find(f[x]);
}

int main()
{
    int t;
    int n,m;
    scanf(&quot;%d&quot;,&amp;t);
    while(t--)
    {
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
        for(int i=1;i&lt;=n;i++)
        {
            f[i]=i;c[i]=1;
        }
        int a,b;
        int ans = -1;
        for(int i=1;i&lt;=m;i++)
        {
            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
            int t1 = find(a);
            int t2 = find(b);
            if (t1 != t2)
            {
                f[t2] = t1;
                c[t1] += c[t2];
                ans = max(ans,c[t1]);
            }
        }
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>UVA 10369	Arctic Network【最小生成树】</title>
    <url>/article/csdn/UVA_10369_Arctic_Network%E3%80%90%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47629973" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47629973</a></p>
<p>题目链接：<br><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1310" target="_blank" rel="noopener"><br>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1310
</a></p>
<p>题意：<br>有m个卫星，n个站点，卫星可以不用代价相连，剩下要用无线电连，求无线电连接中最大距离的最小</p>
<p>解法：<br>最小边开始加入，这样第n - m 条边的权值就是答案</p>
<p>代码：略</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>uva</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA 10746	Crime Wave - The Sequel【最小费用最大流】</title>
    <url>/article/csdn/UVA_10746_Crime_Wave_-_The_Sequel%E3%80%90%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47701827" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47701827</a></p>
<p>题目链接：<br><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1687" target="_blank" rel="noopener"><br>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1687
</a></p>
<p>题意：给你n个城市到m个海港的距离，求每个城市都有船只去的最短平均航行距离。</p>
<p>源点向城市建边 城市向海港 海港向汇点建边 容量为1，最后城市向海港的费用为距离</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
using namespace std;


//************************************************************
//最小费用最大流算法
//SPFA求最短路
//邻接矩阵形式
//初始化:cap:容量，没有边为0
//cost:耗费，对称形式，没有边的也为0
//c是最小费用
//f是最大流
//*******************************************************
const int MAXN = 500;
const double INF = 0x3fffffff;
double cap[MAXN][MAXN];//容量，没有边为0
double flow[MAXN][MAXN];
//耗费矩阵是对称的，有i到j的费用，则j到i的费用为其相反数
double cost[MAXN][MAXN];//花费


int n;//顶点数目0~n-1
double f;//最大流
double c;//最小费用
int start, End;//源点和汇点

bool vis[MAXN];//在队列标志
int que[MAXN];
int pre[MAXN];
double dist[MAXN];//s-t路径最小耗费

bool SPFA()
{
    int front = 0, rear = 0;
    for (int u = 0; u &lt;= n; u++)
    {
        if (u == start)
        {
            que[rear++] = u;
            dist[u] = 0;
            vis[u] = true;
        }
        else
        {
            dist[u] = INF;
            vis[u] = false;
        }
    }
    while (front != rear)
    {
        int u = que[front++];
        vis[u] = false;
        if (front &gt;= MAXN)front = 0;
        for (int v = 0; v &lt;= n; v++)
        {
            if (cap[u][v]&gt;flow[u][v] &amp;&amp; dist[v]&gt;dist[u] + cost[u][v])
            {
                dist[v] = dist[u] + cost[u][v];
                pre[v] = u;
                if (!vis[v])
                {
                    vis[v] = true;
                    que[rear++] = v;
                    if (rear &gt;= MAXN)rear = 0;
                }
            }
        }
    }
    if (dist[End] &gt;= INF)return false;
    return true;
}

void minCostMaxflow()
{
    memset(flow, 0, sizeof(flow));
    memset(pre, -1, sizeof(pre));
    memset(dist, 0, sizeof(dist));

    c = f = 0;
    while (SPFA())
    {
        double Min = INF;
        for (int u = End; u != start; u = pre[u])
            Min = min(Min, cap[pre[u]][u] - flow[pre[u]][u]);
        for (int u = End; u != start; u = pre[u])
        {
            flow[pre[u]][u] += Min;
            flow[u][pre[u]] -= Min;
        }
        c += dist[End] * Min;
        f += Min;
    }
}
//************************************************************

int main()
{
    int N, M, K;
    while (~scanf(&quot;%d%d&quot;, &amp;N, &amp;M))
    {
        if (N == 0 &amp;&amp; M == 0) break;
        memset(cap, 0, sizeof(cap));
        memset(cost, 0, sizeof(cost));
        memset(vis, false, sizeof(vis));

        start = 0;
        n = N + M + 2;
        End = M + N + 1;

        double tmp;

        for (int i = 1; i &lt;= N; i++)
            cap[0][i] = 1;
        for (int i = 1; i &lt;= M; i++)
            cap[i + N][N + M + 1] = 1;

        for (int i = 1; i &lt;= N; i++)
        {
            for (int j = 1; j &lt;= M; j++)
            {
                scanf(&quot;%lf&quot;, &amp;tmp);
                cost[i][j + N] = tmp;
                cost[j + N][i] = -tmp;
                cap[i][j + N] = 1;
            }
        }
        minCostMaxflow();
        printf(&quot;%.2lf\n&quot;, c / N + 0.001);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>UVA 10457 - Magic Car【最小瓶颈树】</title>
    <url>/article/csdn/UVA_10457_-_Magic_Car%E3%80%90%E6%9C%80%E5%B0%8F%E7%93%B6%E9%A2%88%E6%A0%91%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47404989" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47404989</a></p>
<p>题目链接：<br><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=600&amp;problem=1398&amp;mosmsg=Submission+received+with+ID+14106648" target="_blank" rel="noopener"><br>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=600&amp;problem=1398&amp;mosmsg=Submission+received+with+ID+14106648
</a></p>
<p>题意：<br>m条路，每条路上必须维持速度v，现在有一辆车，启动能量和结束能量为a,<br>b，途中消耗能量为经过路径最大速度减去最小速度，现在每次循环给定起点终点，问最小能量花费</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;math.h&gt;
#include &lt;string&gt;

using namespace std;

const int MAXN = 410000;//点
const int MAXM = 410000;//边

struct Edge
{
    int u, v;
    int w;
    friend bool operator &lt; (Edge a, Edge b)
    {
        return a.w &lt; b.w;
    }
}edge[MAXM];

int f[MAXN];
int find(int x)
{
    if (f[x] == x) return x;
    else return f[x] = find(f[x]);
}

int main()
{
    int n, m, k;
    while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)
    {
        int x, y, z;
        for (int i = 0; i &lt; m; i++)
        {
            scanf(&quot;%d%d%d&quot;, &amp;edge[i].u, &amp;edge[i].v, &amp;edge[i].w);
        }
        sort(edge, edge + m);
        scanf(&quot;%d%d&quot;, &amp;x, &amp;y); int ans = x + y;
        scanf(&quot;%d&quot;,&amp;k);
        while (k--)
        {
            scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
            int tmp = 1000000000;

            for (int i = 0; i &lt; m; i++)
            {
                for (int j = 1; j &lt;= n; j++) f[j] = j;
                for (int j = i; j &lt; m; j++)
                {
                    int t1 = find(edge[j].u);
                    int t2 = find(edge[j].v);
                    if (t1 != t2) f[t1] = t2;
                    if (find(x) == find(y))
                    {
                        tmp = min(tmp, edge[j].w - edge[i].w);
                        break;
                    }
                }
            }
            printf(&quot;%d\n&quot;, ans + tmp);
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>UVA 10968 - KuPellaKeS 【BFS】</title>
    <url>/article/csdn/UVA_10968_-_KuPellaKeS_%E3%80%90BFS%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47993793" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47993793</a></p>
<p>题目：<br>In ancient times, many territories were under the control of a powerful king<br>called Basm. Basm is<br>well-known in history because of his strange works and as a result, there are<br>many history-lovers who<br>wish to know more about him. Koorosh is one of them and he has worked hard to<br>find a way to know<br>more about Basms works.<br>Recently, he managed to invent a Time MachineTM and traveled to the past to<br>Basm time in order<br>to be able to see and study his weird works thoroughly. Unfortunately, he has<br>been caught by royal<br>guard soldiers of Basm and is now in his prison. Basm ordered him to solve a<br>problem if he wants to stay<br>alive. King Basm wants to change the structure of roads of his newly captured<br>territory, KuPellaKes<br>in such a way that each city has an even number of neighboring cities. Now, he<br>wants to know the<br>minimum number of roads that should be destroyed in order to satisfy this<br>condition. Note that each<br>city must have at least one neighbor city after the road destruction process.<br>Also, It should be noted<br>that in the given territory at most two cites of KuPellaKes have an odd number<br>of neighboring cities<br>and there is at most one road between two cities. Also, there is no road from<br>a city to itself.</p>
<p>题意：<br>给定一个图，要求把这个图删掉一些边后，使得他所以有点度数为不等于0的偶数，保证图一开始最多只有最多2个奇数度数结点。求最小删边数</p>
<p>解法：求奇数点间的距离。奇数点为 0 个，答案为0。</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;

using namespace std;

int n, m;
vector&lt;int&gt; g[1010];
int du[1010];
int cnt[1010];
int st, ed;

bool solve()
{
    st = ed = 0;
    for (int i = 1; i &lt;= n; i++)
    {
        if (du[i] == 0 || du[i] == 1) return false;
        if (du[i] % 2 == 1)
        {
            if (st == 0) st = i;
            else ed = i;
        }
    }

    if (st == 0)
    {
        printf(&quot;0\n&quot;);
        return true;
    }

    memset(cnt, -1, sizeof(cnt));
    queue&lt;int&gt; q;
    while (!q.empty()) q.pop();
    q.push(st);
    cnt[st] = 0;

    while (!q.empty())
    {
        int tp = q.front();q.pop();
        if (tp == ed)
        {
            printf(&quot;%d\n&quot;,cnt[tp]);
            return true;
        }
        for (int i = 0; i &lt; g[tp].size(); i++)
        {
            int tt = g[tp][i];
            if (du[tt] == 2) continue;
            if (cnt[tt] != -1) continue;
            cnt[tt] = cnt[tp] + 1;
            q.push(tt);
        }
    }
    return false;
}

int main()
{
    while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &amp;&amp; n)
    {
        memset(du,0,sizeof(du));
        for (int i = 0; i &lt;= n; i++) g[i].clear();
        int a, b;
        while (m--)
        {
            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
            du[a]++; du[b]++;
            g[a].push_back(b);
            g[b].push_back(a);
        }
        if (!solve()) printf(&quot;Poor Koorosh\n&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>UVA 10986	Sending email 【dijkstra + 堆优化】</title>
    <url>/article/csdn/UVA_10986_Sending_email_%E3%80%90dijkstra_+_%E5%A0%86%E4%BC%98%E5%8C%96%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47626783" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47626783</a></p>
<p>题目链接：<br><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1927" target="_blank" rel="noopener"><br>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1927
</a></p>
<p>题意：n个点m条边，求s到e的最短距离</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;string.h&gt;

using namespace std;


const int INF = 0x3f3f3f3f;
const int MAXN = 1000010;

struct qnode
{
    int v;
    int c;
    qnode(int _v = 0, int _c = 0) :v(_v), c(_c){}
    bool operator &lt; (const qnode &amp;r) const
    {
        return c &gt; r.c;
    }
};

struct Edge
{
    int v, cost;
    Edge(int _v = 0, int _cost = 0) :v(_v), cost(_cost) {}
};

vector&lt;Edge&gt; E[MAXN];
bool vis[MAXN];
int dist[MAXN];

void dijkstra(int n,int start,int ed)
{
    memset(vis, false, sizeof(vis));
    for (int i = 0; i &lt; n; i++)
        dist[i] = INF;
    priority_queue&lt;qnode&gt; que;
    while (!que.empty()) que.pop();
    dist[start] = 0;
    que.push(qnode(start, 0));
    qnode tmp;
    while (!que.empty())
    {
        tmp = que.top(); que.pop();
        int u = tmp.v;
        if (vis[ed]) continue;
        if (vis[u]) continue;
        vis[u] = true;
        for (int i = 0; i &lt; E[u].size(); i++)
        {
            int v = E[u][i].v;
            int cost = E[u][i].cost;
            if (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost)
            {
                dist[v] = dist[u] + cost;
                que.push(qnode(v, dist[v]));
            }
        }
    }
}

void addedge(int u, int v, int w)
{
    E[u].push_back(Edge(v, w));
}

int n, m, s, d;
int a, b, c;

int main()
{
    int t;
    int cases = 1;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;d);
        for (int i = 0; i &lt;= n; i++) E[i].clear();
        while (m--)
        {
            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
            addedge(a, b, c);
            addedge(b, a, c);
        }
        dijkstra(n, s, d);
        if (dist[d] == INF)
            printf(&quot;Case #%d: unreachable\n&quot;, cases++);
        else
            printf(&quot;Case #%d: %d\n&quot;, cases++, dist[d]);

    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>uva 11029 【快速幂】</title>
    <url>/article/csdn/UVA_11029_%E3%80%90%E5%BF%AB%E9%80%9F%E5%B9%82%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44158189" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44158189</a></p>
<p>Leading and Trailing</p>
<p><strong>Time Limit:</strong> 2000  MS <strong>Memory Limit:</strong> 32768  KB <strong>64bit IO Format:</strong> %lld<br>&amp; %llu</p>
<p>Submit  <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=70017#status//E/0" target="_blank" rel="noopener"> Status
</a></p>
<p>Description</p>
<p>You are given two integers: <strong>n</strong> and <strong>k</strong> , your task is to find the most<br>significant three digits, and least significant three digits of <strong>n k  </strong> .</p>
<p>Input</p>
<p>Input starts with an integer <strong>T (≤ 1000)</strong> , denoting the number of test<br>cases.</p>
<p>Each case starts with a line containing two integers: <strong>n (2 ≤ n &lt; 2  31  ) </strong><br>and <strong>k (1 ≤ k ≤ 10 7  ) </strong> .</p>
<p>Output</p>
<p>For each case, print the case number and the three leading digits (most<br>significant) and three trailing digits (least significant). You can assume<br>that the input is given such that <strong>n k  </strong> contains at least six digits.</p>
<p>Sample Input</p>
<p>5</p>
<p>123456 1</p>
<p>123456 2</p>
<p>2 31</p>
<p>2 32</p>
<p>29 8751919</p>
<p>Sample Output</p>
<p>Case 1: 123 456</p>
<p>Case 2: 152 936</p>
<p>Case 3: 214 648</p>
<p>Case 4: 429 296</p>
<p>Case 5: 665 669</p>
<p>题意： 求解a^b 的前三位和后三位</p>
<p>解法： 对于后三位，快速幂取模1000即可；</p>
<p>前三位要具体进行分析。</p>
<p>n可以写成n=10^b,这个a是个小数</p>
<p>所以b=i+d，i是整数部分，d是数部分<br>则n=10^(i+d)=10^i <em> 10^d<br>这里很重要，10^i其实有什么用？i是整数，所以10^i一定是1000…………000，然后</em>10^d，d是一个小于1的小数（别忘了是b的小数部分）<br>所以决定n这个大数会出现什么数字的，是10^d，10^i只是给10^d起到往后移动小数点的作用<br>所以我们要知道10^d<br>另外我们知道0 &lt;=d&lt;1，所以 10^0 &lt;= 10^d &lt; 10^1   即1&lt;=10^d&lt;10</p>
<p>这样只需要10^d*100然后取整数部分，就能得到一个3位整数，这3个数字正是我们要的答案</p>
<p>a=10^k , a^n=(10^k)^n=10^k<em>n=10^i </em> 10^d    ,  这里i是k<em>n的整数部分，d是k</em>n的小数部分</p>
<p>要得到k就使用库函数fmod即可    d=fmod(k<em>n , 1) ， 返回k</em>n/1的余数，也就是小数部分</p>
<p>另外k=log10(a) ， 写在一起就是   d=fmod( log10(a)*n , 1)</p>
<p>然后就是求  100*10^d=10^(d+2)</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;
#include &lt;iterator&gt;

using namespace std;

long long quickpow(long long m, long long n, long long  k)//快速幂
{
    long long  b = 1;
    while (n &gt; 0)
    {
        if (n &amp; 1)
            b = (b*m) % k;
        n = n &gt;&gt; 1;
        m = (m*m) % k;
    }
    return b;
}

int t;
long long a, b , ans1, ans2;

int main()
{
    int cases = 1;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%lld %lld&quot;,&amp;a,&amp;b);
        long long x = a % 1000;
        ans1 = (int)pow(10, 2 + fmod (b * log10(a*1.0) ,1 ));//求前三位
        ans2 = quickpow(x,b,1000);
        printf(&quot;Case %d: %03lld %03lld\n&quot;, cases++, ans1, ans2);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>UVA 11292 DRAGON OF LOOWATER 【贪心】</title>
    <url>/article/csdn/UVA_11292_DRAGON_OF_LOOWATER_%E3%80%90%E8%B4%AA%E5%BF%83%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46383453" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46383453</a></p>
<p>Description</p>
<p>Problem C: The Dragon of Loowater</p>
<p>Once upon a time, in the Kingdom of Loowater, a minor nuisance turned into a<br>major problem.The shores of Rellau Creek in central Loowater had always been a<br>prime breeding ground for geese. Due to the lack of predators, the geese<br>population was out of control. The people of Loowater mostly kept clear of the<br>geese. Occasionally, a goose would attack one of the people, and perhaps bite<br>off a finger or two, but in general, the people tolerated the geese as a minor<br>nuisance.</p>
<p>One day, a freak mutation occurred, and one of the geese spawned a multi-<br>headed fire-breathing dragon. When the dragon grew up, he threatened to burn<br>the Kingdom of Loowater to a crisp. Loowater had a major problem. The king was<br>alarmed, and called on his knights to slay the dragon and save the kingdom.</p>
<p>The knights explained: “To slay the dragon, we must chop off all its heads.<br>Each knight can chop off one of the dragon’s heads. The heads of the dragon<br>are of different sizes. In order to chop off a head, a knight must be at least<br>as tall as the diameter of the head. The knights’ union demands that for<br>chopping off a head, a knight must be paid a wage equal to one gold coin for<br>each centimetre of the knight’s height.”</p>
<p>Would there be enough knights to defeat the dragon? The king called on his<br>advisors to help him decide how many and which knights to hire. After having<br>lost a lot of money building Mir Park, the king wanted to minimize the expense<br>of slaying the dragon. As one of the advisors, your job was to help the king.<br>You took it very seriously: if you failed, you and the whole kingdom would be<br>burnt to a crisp!</p>
<p>INPUT SPECIFICATION:</p>
<p>The input contains several test cases. The first line of each test case<br>contains two integers between 1 and 20000 inclusive, indicating the number n<br>of heads that the dragon has, and the number m of knights in the kingdom. The<br>next n lines each contain an integer, and give the diameters of the dragon’s<br>heads, in centimetres. The following m lines each contain an integer, and<br>specify the heights of the knights of Loowater, also in centimetres.</p>
<p>The last test case is followed by a line containing:</p>
<p>0 0<br>OUTPUT SPECIFICATION:</p>
<p>For each test case, output a line containing the minimum number of gold coins<br>that the king needs to pay to slay the dragon. If it is not possible for the<br>knights of Loowater to slay the dragon, output the line:</p>
<p>Loowater is doomed!<br>SAMPLE INPUT:</p>
<p>2 3<br>5<br>4<br>7<br>8<br>4<br>2 1<br>5<br>5<br>10<br>0 0<br>OUTPUT FOR SAMPLE INPUT:</p>
<p>11<br>Loowater is doomed!</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;cstdio&gt;  
#include &lt;cstring&gt;  
#include &lt;algorithm&gt;  
#include &lt;string&gt;  
#include &lt;queue&gt;  

using namespace std;

int n, m;
int p[20010], q[20010];

int main()
{
    while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)
    {
        if (n == 0 &amp;&amp; m == 0) break;
        for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;,&amp;p[i]);
        for (int i = 0; i &lt; m; i++) scanf(&quot;%d&quot;, &amp;q[i]);
        sort(p, p + n);
        sort(q, q + m);
        if (n &gt; m)
        {
            printf(&quot;Loowater is doomed!\n&quot;);
            continue;
        }
        int num = 0;
        int ans = 0;
        for (int i = 0; i &lt; m; i++)
        {
            if (num == n) break;
            if (q[i] &gt;= p[num])
            {
                num++;
                ans += q[i];
            }
        }
        if (num == n) printf(&quot;%d\n&quot;,ans);
        else printf(&quot;Loowater is doomed!\n&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>UVA 11300 SPREADING THE WEALTH 【数学】</title>
    <url>/article/csdn/UVA_11300_SPREADING_THE_WEALTH_%E3%80%90%E6%95%B0%E5%AD%A6%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46383439" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46383439</a></p>
<p>Description</p>
<p>Problem</p>
<p>A Communist regime is trying to redistribute wealth in a village. They have<br>have decided to sit everyone around a circular table. First, everyone has<br>converted all of their properties to coins of equal value, such that the total<br>number of coins is divisible by the number of people in the village. Finally,<br>each person gives a number of coins to the person on his right and a number<br>coins to the person on his left, such that in the end, everyone has the same<br>number of coins. Given the number of coins of each person, compute the minimum<br>number of coins that must be transferred using this method so that everyone<br>has the same number of coins.</p>
<p>The Input</p>
<p>There is a number of inputs. Each input begins with n(n&lt;1000001), the number<br>of people in the village. n lines follow, giving the number of coins of each<br>person in the village, in counterclockwise order around the table. The total<br>number of coins will fit inside an unsigned 64 bit integer.</p>
<p>The Output</p>
<p>For each input, output the minimum number of coins that must be transferred on<br>a single line.</p>
<p>Sample Input</p>
<p>3<br>100<br>100<br>100<br>4<br>1<br>2<br>5<br>4<br>Sample Output</p>
<p>0<br>4</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;cstdio&gt;  
#include &lt;cstring&gt;  
#include &lt;algorithm&gt;  
#include &lt;string&gt;  
#include &lt;queue&gt;  

using namespace std;

int n;
long long p[1010000];
long long c[1010000];

int main()
{
    while (scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        long long sum = 0;
        for (int i = 0; i &lt; n; i++)
        {
            scanf(&quot;%lld&quot;, &amp;p[i]);
            sum += p[i];
        }
        long long t = sum / n;
        c[0] = 0;
        for (int i = 1; i &lt; n; i++) c[i] = c[i - 1] + p[i] - t;
        sort(c,c+n);
        long long tmp = c[n / 2], ans = 0;
        for (int i = 0; i &lt; n; i++) ans += abs(tmp - c[i]);
        printf(&quot;%lld\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>UVA 11573 - Ocean Currents【BFS+优先队列】</title>
    <url>/article/csdn/UVA_11573_-_Ocean_Currents%E3%80%90BFS+%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47379671" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47379671</a></p>
<p>题目链接：<br><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2620" target="_blank" rel="noopener"><br>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2620
</a></p>
<p>题意：给定一个海面，数字分别代表海流方向，顺着海流不用费能量，逆海流要费1点能量，每次询问给一个起点一个终点，问起点到终点耗费的最小能量</p>
<p>思路：广搜，队列用优先队列，每次取能量最低的点。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;math.h&gt;
#include &lt;map&gt;
#include &lt;string&gt;

using namespace std;

int dir[10][2] = { { -1, 0 },{ -1, 1 },{ 0, 1 },{ 1, 1 },{ 1, 0 },{ 1, -1 },{ 0, -1 },{ -1, -1 } };

int r, c;
char p[1010][1010];
int vis[1010][1010];
int x1, y11, x2, y2;

bool is_ok(int x, int y)
{
    if (x &gt;= 1 &amp;&amp; x &lt;= r &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= c) return true;
    return false;
}

struct node
{
    int x, y;
    int t;
    node() {}
    friend bool operator &lt; (node a,node b) 
    {
        return a.t &gt; b.t;
    }
};

int main()
{
    while (scanf(&quot;%d%d&quot;,&amp;r,&amp;c) != EOF)
    {
        for (int i = 1; i &lt;= r; i++)
            scanf(&quot;%s&quot;, p[i] + 1);

        int n;
        cin &gt;&gt; n;
        while(n--)
        {
            int ans = 0;
            cin &gt;&gt; x1 &gt;&gt; y11 &gt;&gt; x2 &gt;&gt; y2;
            priority_queue&lt;node&gt; que;
            while (!que.empty()) que.pop();
            memset(vis, -1, sizeof(vis));

            vis[x1][y11] = 0;
            node a;
            a.x = x1, a.y = y11, a.t = 0;
            que.push(a);

            while (!que.empty())
            {
                node tmp = que.top(); que.pop();
                if (tmp.x == x2 &amp;&amp; tmp.y == y2)
                {
                    ans = tmp.t;
                    break;
                }
                node res;
                for (int i = 0; i &lt; 8; i++)
                {
                    int x = tmp.x + dir[i][0];
                    int y = tmp.y + dir[i][1];
                    if (!is_ok(x, y)) continue;
                    //if (!is_ok(x, y) &amp;&amp; vis[x][y] != -1) continue;
                    res.x = x; res.y = y; 
                    if (p[tmp.x][tmp.y]-&#39;0&#39; == i) res.t = tmp.t;
                    else  res.t = tmp.t + 1;

                    if (vis[x][y] == -1 || res.t &lt; vis[x][y])
                    {
                        vis[x][y] = res.t;
                        que.push(res);
                    }
                }
            }
            printf(&quot;%d\n&quot;,ans);
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>uva</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA 1160	X-Plosives【并查集】</title>
    <url>/article/csdn/UVA_1160_X-Plosives%E3%80%90%E5%B9%B6%E6%9F%A5%E9%9B%86%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47730831" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47730831</a></p>
<p>题目链接：<br><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3601" target="_blank" rel="noopener"><br>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3601
</a></p>
<p>题意：<br>每次给定一个两个元素a,b组成的化合物，如果车上有k个化合物，又包含了k个元素，就会形成爆炸物，所以每次装上去前要检查一下，输入一些化合物，求不能装的个数</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;map&gt;

using namespace std;

int fa[1000010];

int fd(int x)
{
    if (fa[x] == -1) return x;
    else return fa[x] = fd(fa[x]);
}

int main()
{
    int a, b;
    while (~scanf(&quot;%d&quot;, &amp;a))
    {
        memset(fa, -1, sizeof(fa));
        int ans = 0;
        while (a != -1)
        {
            scanf(&quot;%d&quot;, &amp;b);
            int aa = fd(a);
            int bb = fd(b);
            if (aa == bb) ans++;
            else fa[aa] = bb;
            scanf(&quot;%d&quot;,&amp;a);
        }
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>uva</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA 11729 COMMANDO WAR【贪心】</title>
    <url>/article/csdn/UVA_11729_COMMANDO_WAR%E3%80%90%E8%B4%AA%E5%BF%83%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46383447" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46383447</a></p>
<p>11729 Commando War</p>
<p>“Waiting for orders we held in the wood, word from the front never came By<br>evening the sound of the gunfire was miles away Ah softly we moved through the<br>shadows, slip away through the trees Crossing their lines in the mists in the<br>fields on our hands and our knees And all that I ever, was able to see The<br>fire in the air, glowing red, silhouetting the smoke on the breeze” There is a<br>war and it doesn’t look very promising for your country. Now it’s time to act.<br>You have a commando squad at your disposal and planning an ambush on an<br>important enemy camp located nearby. You have N soldiers in your squad. In<br>your master-plan, every single soldier has a unique responsibility and you<br>don’t want any of your soldier to know the plan for other soldiers so that<br>everyone can focus on his task only. In order to enforce this, you brief every<br>individual soldier about his tasks separately and just before sending him to<br>the battlefield. You know that every single soldier needs a certain amount of<br>time to execute his job. You also know very clearly how much time you need to<br>brief every single soldier. Being anxious to finish the total operation as<br>soon as possible, you need to find an order of briefing your soldiers that<br>will minimize the time necessary for all the soldiers to complete their tasks.<br>You may assume that, no soldier has a plan that depends on the tasks of his<br>fellows. In other words, once a soldier begins a task, he can finish it<br>without the necessity of pausing in between.</p>
<p>Input</p>
<p>There will be multiple test cases in the input file. Every test case starts<br>with an integer N (1 ≤ N ≤ 1000), denoting the number of soldiers. Each of the<br>following N lines describe a soldier with two integers B (1 ≤ B ≤ 10000) &amp; J<br>(1 ≤ J ≤ 10000). B seconds are needed to brief the soldier while completing<br>his job needs J seconds. The end of input will be denoted by a case with N =</p>
<ol start="0">
<li>This case should not be processed. Output For each test case, print a line<br>in the format, ‘Case X: Y ’, where X is the case number &amp; Y is the total<br>number of seconds counted from the start of your first briefing till the<br>completion of all jobs.</li>
</ol>
<p>Sample Input 3 2 5 3 2 2 1 3 3 3 4 4 5 5 0</p>
<p>Sample Output</p>
<p>Case 1: 8</p>
<p>Case 2: 15<br>代码：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;cstdio&gt;  
#include &lt;cstring&gt;  
#include &lt;algorithm&gt;  
#include &lt;string&gt;  
#include &lt;queue&gt;  

using namespace std;

int n;

struct node
{
    int b, j;
}p[2010];

bool cmp(node a, node b)
{
    return a.j &gt; b.j;
}

int main()
{
    int cases = 1;
    while (scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        if (n == 0) break;
        for (int i = 0; i &lt; n; i++)
            scanf(&quot;%d%d&quot;,&amp;p[i].b,&amp;p[i].j);
        sort(p, p + n, cmp);
        int ans = 0;
        int tmp = 0;
        for (int i = 0; i &lt; n;i++)
        {
            tmp += p[i].b;
            ans = max(ans,tmp+p[i].j);
        }
        printf(&quot;Case %d: %d\n&quot;,cases++,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>UVA 11401 TRIANGLE COUNTING 【加法原理】</title>
    <url>/article/csdn/UVA_11401_TRIANGLE_COUNTING_%E3%80%90%E5%8A%A0%E6%B3%95%E5%8E%9F%E7%90%86%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46383409" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46383409</a></p>
<p>Description</p>
<p>Problem G<br>Triangle Counting</p>
<p>Input: Standard Input</p>
<p>Output: Standard Output</p>
<p>You are given n rods of length 1, 2…, n. You have to pick any 3 of them &amp;<br>build a triangle. How many distinct triangles can you make? Note that, two<br>triangles will be considered different if they have at least 1 pair of arms<br>with different length.</p>
<p>Input</p>
<p>The input for each case will have only a single positive integer n<br>(3&lt;=n&lt;=1000000). The end of input will be indicated by a case with n&lt;3. This<br>case should not be processed.</p>
<p>Output</p>
<p>For each test case, print the number of distinct triangles you can make.</p>
<p>Sample Input Output for Sample Input</p>
<p>5<br>8</p>
<p>0</p>
<p>3<br>22</p>
<p>Problemsetter: Mohammad Mahmudur Rahman</p>
<p>f[i] 是以i为最大边的三角形的个数。<br>代码：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;cstdio&gt;  
#include &lt;cstring&gt;  
#include &lt;algorithm&gt;  
#include &lt;string&gt;  
#include &lt;queue&gt;  
#include &lt;stack&gt;

using namespace std;

int n;
long long f[1000010];

int main()
{
    f[3] = 0;
    for (long long x = 4; x &lt;= 1000000; x++)
        f[x] = f[x - 1] + ((x - 1)*(x - 2) / 2 - (x - 1) / 2) / 2;

    while (scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        if (n &lt; 3) break;
        printf(&quot;%lld\n&quot;,f[n]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>UVA 11997	K Smallest Sums</title>
    <url>/article/csdn/UVA_11997_K_Smallest_Sums.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47758295" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47758295</a></p>
<p>题目链接：<br><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3148" target="_blank" rel="noopener"><br>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3148
</a></p>
<p>题意：给定k个数组，每个数组k个数字，要求每个数字选出一个数字，构成和，这样一共有kk种情况，要求输出最小的k个和<br>其实只要能求出2组的前k个值，然后不断两两合并就可以了</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;vector&gt;

using namespace std;

struct Item
{
    int s, b;
    Item(int s, int b) :s(s), b(b) {}
    bool operator &lt; (const Item&amp; rhs) const
    {
        return s &gt; rhs.s;
    }
};

const int MAXN = 1100;
int a[MAXN][MAXN];
int b[MAXN];

void merge(int* A, int* B, int* C, int n)
{
    priority_queue&lt;Item&gt; q;
    for (int i = 0; i &lt; n; i++)
        q.push(Item (A[i] + B[0], 0));
    for (int i = 0; i &lt; n; i++)
    {
        Item item = q.top(); q.pop();
        C[i] = item.s;
        int b = item.b;
        if (b + 1 &lt; n) q.push(Item(C[i] - B[b] + B[b+1], b + 1));
    }
}

int main()
{
    int n;
    while (scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        for (int i = 0; i &lt; n; i++)
        {
            for (int j = 0; j &lt; n; j++)
                scanf(&quot;%d&quot;, &amp;a[i][j]);
            sort(a[i], a[i] + n);
        }
        for (int i = 1; i &lt; n; i++)
        {
            merge(a[0], a[i], b, n);
            for (int ii = 0; ii &lt; n; ii++)
                a[0][ii] = b[ii];
        }
        printf(&quot;%d&quot;,a[0][0]);
        for (int i = 1; i &lt; n; i++) printf(&quot; %d&quot;,a[0][i]);
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>uva</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA 11991	Easy Problem from Rujia Liu?【STL】</title>
    <url>/article/csdn/UVA_11991_Easy_Problem_from_Rujia_Liu?%E3%80%90STL%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47729955" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47729955</a></p>
<p>题目链接：<br><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3142" target="_blank" rel="noopener"><br>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3142
</a></p>
<p>题意：<br>给一个长度n的序列，有m询问，每个询问会问第k个出现的数字的下标是多少<br>用map记录</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;map&gt;

using namespace std;

int n, m;
map&lt;int ,vector&lt;int&gt; &gt; mp;

int c[1001000];

int main()
{
    while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))
    {
        mp.clear();
        memset(c, 0, sizeof(c));

        int tmp;
        for (int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;, &amp;tmp);
            mp[tmp].push_back(i);
        }
        int a, b;
        while (m--)
        {
            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
            if (mp[b].size() &lt; a) printf(&quot;0\n&quot;);
            else printf(&quot;%d\n&quot;, mp[b][a - 1]);
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>UVA 11748	Rigging Elections 【dfs】</title>
    <url>/article/csdn/UVA_11748_Rigging_Elections_%E3%80%90dfs%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47362411" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47362411</a></p>
<p><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2848" target="_blank" rel="noopener"><br>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2848
</a><br>题意：n个人选举，给出m个人的投票人对于每个人的优先级，想让第c个人赢，问能不能</p>
<p>思路：对于两个人上场，如果a能赢b,就建一条a-&gt;b的边，然后问题其实就变成能否以c为根节点是一棵树，直接dfs一遍即可</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;math.h&gt;
#include &lt;map&gt;
#include &lt;string&gt;

using namespace std;

int n, m, c;

vector&lt;int&gt; g[110];
int is[110][110];
int vis[110];
int ans;

void dfs(int u)
{
    if (!vis[u]) ans += 1;
    vis[u] = 1;
    for (int i = 0; i &lt; g[u].size(); i++)
        if (!vis[g[u][i]]) dfs(g[u][i]);
}

int main()
{
    while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; c)
    {
        if (n == 0 &amp;&amp; m == 0 &amp;&amp; c == 0) break;
        memset(is,0,sizeof(is));
        memset(vis, 0, sizeof(vis));
        for (int i = 0; i &lt;= 105; i++) g[i].clear();

        for (int i = 1; i &lt;= m; i++)
        {
            for (int j = 1; j &lt;= n; j++)
            {
                int x;
                cin &gt;&gt; x;
                is[i][x] = j;
            }
        }

        for (int i = 1; i &lt;= n; i++)
            for (int j = i + 1; j &lt;= n; j++)
            {
                int num = 0;
                for (int k = 1; k &lt;= m; k++)
                {
                    if (is[k][i] &lt; is[k][j])
                        num++;
                }
                if (num * 2 &gt; m)
                    g[i].push_back(j);
                else
                    g[j].push_back(i);
            }
        ans = 0;
        dfs(c);
        if (ans == n) puts(&quot;yes&quot;);
        else puts(&quot;no&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>uva</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA 1329	Corporative Network【并查集】</title>
    <url>/article/csdn/UVA_1329_Corporative_Network%E3%80%90%E5%B9%B6%E6%9F%A5%E9%9B%86%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47731327" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47731327</a></p>
<p>题目链接：<br><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4075" target="_blank" rel="noopener"><br>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4075
</a></p>
<p>题意：<br>有n个结点，开始都是单独的结点，现在有I操作和E操作，I u v表示吧u的父亲结点设为，距离为|u - v| % 1000，E操作询问u到根的距离</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;map&gt;

using namespace std;

int fa[1000010];
int d[1000010];

int fd(int x)
{
    if (fa[x] != -1)
    {
        int rot = fd(fa[x]);
        d[x] += d[fa[x]];
        return fa[x] = fd(fa[x]);
    }
    else return x;
}

int main()
{
    int a, b;
    int t, n;
    scanf(&quot;%d&quot;,&amp;t);
    char cmd[10];
    while (t--)
    {
        memset(fa, -1, sizeof(fa));
        memset(d,0,sizeof(d));
        scanf(&quot;%d&quot;, &amp;n);
        while (scanf(&quot;%s&quot;, cmd) &amp;&amp; cmd[0] != &#39;O&#39;)
        {
            if (cmd[0] == &#39;E&#39;)
            {
                scanf(&quot;%d&quot;, &amp;a);
                fd(a);
                printf(&quot;%d\n&quot;, d[a]);
            }
            else
            {
                scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
                fa[a] = b;
                d[a] = abs(a - b) % 1000;
            }
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>UVA 11995	I Can Guess the Data Structure!【模拟】</title>
    <url>/article/csdn/UVA_11995_I_Can_Guess_the_Data_Structure!%E3%80%90%E6%A8%A1%E6%8B%9F%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47728639" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47728639</a></p>
<p>题目链接：<br><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3146" target="_blank" rel="noopener"><br>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3146
</a></p>
<p>题意：<br>给定一堆的操作，问这个数据结构是什么</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;

using namespace std;

int n;
int a, b;

queue&lt;int&gt; que;
stack&lt;int&gt; st;
priority_queue&lt;int&gt;que1;

int main()
{
    while (~scanf(&quot;%d&quot;, &amp;n))
    {
        while (!que.empty()) que.pop();
        while (!st.empty()) st.pop();
        while (!que1.empty()) que1.pop();

        int ok1 = 1, ok2 = 1, ok3 = 1;
        int cnt = 3;

        for (int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
            if (a == 1)
            {
                que.push(b);
                st.push(b);
                que1.push(b);
            }
            else
            {
                if ((que.empty() || b != que.front()) &amp;&amp; ok1) {
                    ok1 = 0; cnt--;
                }
                if ((st.empty() || b != st.top()) &amp;&amp; ok2) {
                    ok2 = 0; cnt--;
                }
                if ((que1.empty() || b != que1.top()) &amp;&amp; ok3) {
                    ok3 = 0; cnt--;
                }

                if (!que.empty()) que.pop();
                if (!st.empty()) st.pop();
                if (!que1.empty()) que1.pop();
            }
        }

        if (cnt == 0) printf(&quot;impossible\n&quot;);
        else if (cnt &gt; 1) printf(&quot;not sure\n&quot;);
        else
        {
            if (ok1) printf(&quot;queue\n&quot;);
            else if(ok2) printf(&quot;stack\n&quot;);
            else printf(&quot;priority queue\n&quot;);
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>UVA 315【求割点数目】</title>
    <url>/article/csdn/UVA_315%E3%80%90%E6%B1%82%E5%89%B2%E7%82%B9%E6%95%B0%E7%9B%AE%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47312381" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47312381</a></p>
<p><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=251" target="_blank" rel="noopener"><br>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=251
</a></p>
<p>题意：求割点数目</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;ctime&gt;  
#include &lt;math.h&gt;  
#include &lt;limits.h&gt;  
#include &lt;complex&gt;  
#include &lt;string&gt;  
#include &lt;functional&gt;  
#include &lt;iterator&gt;  
#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;stack&gt;  
#include &lt;queue&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;list&gt;  
#include &lt;bitset&gt;  
#include &lt;sstream&gt;  
#include &lt;iomanip&gt;  
#include &lt;fstream&gt;  
#include &lt;iostream&gt;  
#include &lt;ctime&gt;  
#include &lt;cmath&gt;  
#include &lt;cstring&gt;  
#include &lt;cstdio&gt;  
#include &lt;time.h&gt;  
#include &lt;ctype.h&gt;  
#include &lt;string.h&gt;  
#include &lt;assert.h&gt;  
#pragma comment (linker, &quot;/STACK:102400000,102400000&quot;)

using namespace std;

int n, m, x, y;

const int MAXN = 10010;
const int MAXM = 100010;
struct Edge
{
    int to, next;
    bool cut;//是否为桥的标记
}edge[MAXM];
int head[MAXN], tot;
int Low[MAXN], DFN[MAXN], Stack[MAXN];
int Index, top;
bool Instack[MAXN];
bool cut[MAXN];
int add_block[MAXN];//删除一个点后增加的连通块
int bridge;

void addedge(int u, int v)
{
    edge[tot].to = v; edge[tot].next = head[u]; edge[tot].cut = false;
    head[u] = tot++;
}


void Tarjan(int u, int pre)
{
    int v;
    Low[u] = DFN[u] = ++Index;
    Stack[top++] = u;
    Instack[u] = true;
    int son = 0;
    for (int i = head[u]; i != -1; i = edge[i].next)
    {
        v = edge[i].to;
        if (v == pre)continue;
        if (!DFN[v])
        {
            son++;
            Tarjan(v, u);
            if (Low[u] &gt; Low[v])Low[u] = Low[v];
            //桥
            //一条无向边(u,v)是桥，当且仅当(u,v)为树枝边，且满足DFS(u)&lt;Low(v)。
            if (Low[v] &gt; DFN[u])
            {
                bridge++;
                edge[i].cut = true;
                edge[i ^ 1].cut = true;
            }
            //割点
            //一个顶点u是割点，当且仅当满足(1)或(2) (1) u为树根，且u有多于一个子树。
            //(2) u不为树根，且满足存在(u,v)为树枝边(或称父子边，
            //即u为v在搜索树中的父亲)，使得DFS(u)&lt;=Low(v)
            if (u != pre &amp;&amp; Low[v] &gt;= DFN[u])//不是树根
            {
                cut[u] = true;
                add_block[u]++;
            }
        }
        else if (Low[u] &gt; DFN[v])
            Low[u] = DFN[v];
    }
    //树根，分支数大于1
    if (u == pre &amp;&amp; son &gt; 1)cut[u] = true;
    if (u == pre)add_block[u] = son - 1;
    Instack[u] = false;
    top--;
}

void solve(int N)
{
    memset(DFN, 0, sizeof(DFN));
    memset(Instack, false, sizeof(Instack));
    memset(add_block, 0, sizeof(add_block));
    memset(cut, false, sizeof(cut));
    Index = top = 0;
    bridge = 0;
    for (int i = 1; i &lt;= N; i++)
        if (!DFN[i])
            Tarjan(i, i);
    int ans = 0;
    for (int i = 1; i &lt;= N; i++)
        if (cut[i])
            ans++;
    printf(&quot;%d\n&quot;, ans);
}

void init()
{
    tot = 0;
    memset(head, -1, sizeof(head));
}

int main()
{
    while (~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)
    {
        init();
        while (scanf(&quot;%d&quot;, &amp;m) &amp;&amp; m)
        {
            while (getchar() != &#39;\n&#39;)
            {
                scanf(&quot;%d&quot;, &amp;x);
                addedge(m, x);
                addedge(x, m);
            }
        }
        solve(n);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>UVA 1203	Argus【优先队列】</title>
    <url>/article/csdn/UVA_1203_Argus%E3%80%90%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47730355" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47730355</a></p>
<p>题目链接：<br><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3644" target="_blank" rel="noopener"><br>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3644
</a></p>
<p>题意：<br>给定一些注册命令，表示每隔时间t，执行一次编号num的指令，注册命令结束后，给定k，输出前k个执行顺序</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;map&gt;

using namespace std;

char s[100];

struct node
{
    int num;
    int tm, per;
    friend bool operator &lt; (node a, node b)
    {
        return a.tm &gt; b.tm || (a.tm == b.tm &amp;&amp; a.num &gt; b.num);
    }
};

int main()
{
    int a, b;
    priority_queue&lt;node&gt; q;
    while (scanf(&quot;%s&quot;,s) &amp;&amp; s[0] != &#39;#&#39;)
    {
        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
        node tmp;
        tmp.num = a; tmp.per = b; tmp.tm = b;
        q.push(tmp);
    }
    int k;
    scanf(&quot;%d&quot;, &amp;k);
    while (k--)
    {
        if (!q.empty())
        {
            node tmp;
            tmp = q.top(); q.pop();
            printf(&quot;%d\n&quot;,tmp.num);
            tmp.tm += tmp.per;
            q.push(tmp);
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>UVA 534	Frogger 【最小瓶颈树】</title>
    <url>/article/csdn/UVA_534_Frogger_%E3%80%90%E6%9C%80%E5%B0%8F%E7%93%B6%E9%A2%88%E6%A0%91%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47361077" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47361077</a></p>
<p><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=475" target="_blank" rel="noopener"><br>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=475
</a></p>
<p>题意：求点1到2所有路径上最大边的最小值。</p>
<p>解法：Kruskal按边值排序。直到1，2联通。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;math.h&gt;

using namespace std;

const int MAXN = 410000;//点
const int MAXM = 410000;//边

struct Edge
{
    int u, v;
    double w;
}edge[MAXM];


bool cmp(Edge a, Edge b)
{
    return a.w &lt; b.w;
}

int tol;

void addedge(int u, int v, double w)
{
    edge[tol].u = u;
    edge[tol].v = v;
    edge[tol++].w = w;
}

int f[MAXN];//并查集使用
int find(int x)
{
    if (f[x] == -1) return x;
    else return f[x] = find(f[x]);
}

struct node
{
    int x, y;
}pos[MAXN];

double get_dis(node a, node b)
{
    int x = a.x - b.x;
    int y = a.y - b.y;
    return sqrt(x*x + y*y);
}

int main()
{
    int cases = 1;
    int n;
    while (~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)
    {
        tol = 0;
        memset(f, -1, sizeof(-1));
        for (int i = 0; i &lt; n; i++)
        {
            scanf(&quot;%d %d&quot;, &amp;pos[i].x, &amp;pos[i].y);
            for (int j = 0; j &lt; i; j++)
                addedge(i, j, get_dis(pos[i], pos[j]));
        }
        sort(edge, edge + tol, cmp);
        for (int i = 0; i &lt; tol; i++)
        {
            int u = edge[i].u;
            int v = edge[i].v;
            int t1 = find(u);
            int t2 = find(v);
            if (t1 != t2) f[t1] = t2;
            if (find(1) == find(0))
            {
                printf(&quot;Scenario #%d\nFrog Distance = %.3lf\n\n&quot;, cases++, edge[i].w);
                break;
            }
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>UVA 538 - Balancing Bank Accounts</title>
    <url>/article/csdn/UVA_538_-_Balancing_Bank_Accounts.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47382737" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47382737</a></p>
<p>题目链接：<br><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=599&amp;problem=479&amp;mosmsg=Submission+received+with+ID+14105881" target="_blank" rel="noopener"><br>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=599&amp;problem=479&amp;mosmsg=Submission+received+with+ID+14105881
</a></p>
<p>题意：<br>给定一些人的欠钱关系，要求在n-1次内还清钱，问方案</p>
<p>解法：所有人与第n个人结账。计算关系。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;math.h&gt;
#include &lt;map&gt;
#include &lt;string&gt;

using namespace std;

int n, m;
map&lt;string, int&gt; Hash;
int is[100];
string name[100];

int main()
{
    int cases = 1;
    while (cin &gt;&gt; n &gt;&gt; m)
    {
        if (n == 0 &amp;&amp; m == 0) break;
        memset(is, 0, sizeof(is));
        Hash.clear();
        string s,ss;
        int tmp;
        for (int i = 1; i &lt;= n; i++)
        {
            cin &gt;&gt; name[i];
            Hash[name[i]] = i;
        }
        for (int i = 1; i &lt;= m; i++)
        {
            cin &gt;&gt; s &gt;&gt; ss &gt;&gt; tmp;
            is[Hash[s]] += tmp;
            is[Hash[ss]] -= tmp;
        }
        printf(&quot;Case #%d\n&quot;,cases++);
        for (int i = 1; i &lt; n; i++)
        {
            if (is[i] &gt; 0)
                cout &lt;&lt; name[n] &lt;&lt; &quot; &quot; &lt;&lt; name[i] &lt;&lt; &quot; &quot; &lt;&lt; is[i] &lt;&lt; endl;
            else 
                cout &lt;&lt; name[i] &lt;&lt; &quot; &quot; &lt;&lt; name[n] &lt;&lt; &quot; &quot; &lt;&lt; -is[i] &lt;&lt; endl;
            is[n] -= is[i];
        }
        cout &lt;&lt; endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>UVA 1423	Guess 【拓扑排序】</title>
    <url>/article/csdn/UVA_1423_Guess_%E3%80%90%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47359527" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47359527</a></p>
<p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/problem/visitOriginUrl.action?id=36239" target="_blank" rel="noopener"> http://acm.hust.edu.cn/vjudge/problem/visitOriginUrl.action?id=36239
</a></p>
<p>题意：给你序列的区间和的正负，要求构造一组序列满足条件。<br>转换为前缀和，进行拓扑序列。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;

using namespace std;

char s[123];
int n;
int sum[110];
int du[110], is[15][15];

void toposort()
{
    queue&lt;int&gt; que;
    while (!que.empty()) que.pop();
    for (int i = 0; i &lt;= n; i++)
        if (du[i] == 0) que.push(i);

    int tmp = 0;

    while (!que.empty())
    {
        int t = que.front(); que.pop();
        tmp++;
        for (int i = 0; i &lt;= n; i++)
        {
            if (is[t][i])
            {
                du[i]--;
                if (du[i] == 0)
                {
                    que.push(i);
                    sum[i] = tmp;
                }
            }
        }
    }
    return;
}

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%d&quot;,&amp;n);
        scanf(&quot; %s&quot;, s);
        memset(sum, 0, sizeof(sum));
        memset(du, 0, sizeof(du));
        memset(is, 0, sizeof(is));

        int pos = 0;
        for (int i = 1; i &lt;= n; i++)
            for (int j = i; j &lt;= n; j++)
            {
                if (s[pos] == &#39;+&#39;)
                {
                    is[i - 1][j] = 1;
                    du[j]++;
                }
                else if (s[pos] == &#39;-&#39;)
                {
                    is[j][i - 1] = 1;
                    du[i - 1]++;
                }
                pos++;
            }
        toposort();
        for (int i = 1; i &lt;= n; i++)
            printf(&quot;%d%c&quot;, sum[i] - sum[i - 1], i == n ? &#39;\n&#39; : &#39; &#39;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>UVA 436	Arbitrage (II)【floyd】</title>
    <url>/article/csdn/UVA_436_Arbitrage_(II)%E3%80%90floyd%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47361729" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47361729</a></p>
<p><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=377" target="_blank" rel="noopener"><br>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=377
</a></p>
<p>题意：硬币兑换，能不能兑换一圈使得手中的钱变多。<br>floyd传递闭包。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;math.h&gt;
#include &lt;map&gt;
#include &lt;string&gt;

using namespace std;

int n, m;

map&lt;string, int&gt; MP;
double a[50][50];

int main()
{
    string s,y;
    double tmp;
    int cases = 1;
    while (cin &gt;&gt; n &amp;&amp; n)
    {
        memset(a, 0, sizeof(a));
        MP.clear();
        for (int i = 1; i &lt;= n; i++)
        {
            cin &gt;&gt; s;
            MP[s] = i;
        }
        for (int i = 1; i &lt;= n; i++)
            a[i][i] = 1.0;
        cin &gt;&gt; m;
        for (int i = 1; i &lt;= m; i++)
        {
            cin &gt;&gt; s &gt;&gt; tmp &gt;&gt; y;
            a[MP[s]][MP[y]] = tmp;
        }
        for (int k = 1; k &lt;= n; k++)
            for (int i = 1; i &lt;= n; i++)
                for (int j = 1; j &lt;= n; j++)
                {
                    if (a[i][j] &lt; a[i][k] * a[k][j])
                        a[i][j] = a[i][k] * a[k][j];
                }
        int ok = 0;
        for (int i = 1; i &lt;= n; i++)
            if (a[i][i] &gt; 1.0)
            {
                ok = 1;
                break;
            }
        printf(&quot;Case %d: &quot;,cases++);
        if (ok) printf(&quot;Yes\n&quot;);
        else printf(&quot;No\n&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>UVA 558	Wormholes 【SPFA 判负环】</title>
    <url>/article/csdn/UVA_558_Wormholes_%E3%80%90SPFA_%E5%88%A4%E8%B4%9F%E7%8E%AF%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47627487" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47627487</a></p>
<p>题目链接：<br><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=499" target="_blank" rel="noopener"><br>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=499
</a></p>
<p>题意：就是判断图中有无负环<br>SPFA,某个节点入队次数大于n就是有负环。</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;vector&gt;
#include &lt;malloc.h&gt;

using namespace std;

const int MAXN = 41000;
const int INF = 0x3f3f3f3f;

struct Edge
{
    int v;
    int cost;
    Edge(int _v = 0, int _cost = 0)
    {
        v = _v;
        cost = _cost;
    }
};
vector&lt;Edge&gt; E[MAXN];

void addedge(int u, int v, int cost)
{
    E[u].push_back(Edge(v, cost));
}

bool vis[MAXN];
int cnt[MAXN];//记录入队列的次数
int dist[MAXN];

////////////////
bool SPFA(int start, int n)
{
    memset(vis, false, sizeof(vis));
    memset(cnt, 0, sizeof(cnt));
    for (int i = 0; i &lt;= n; i++) dist[i] = INF;
    vis[start] = true;
    dist[start] = 0;
    queue&lt;int&gt; que;
    while (!que.empty()) que.pop();
    que.push(start);
    cnt[start] = 1;

    while (!que.empty())
    {
        int u = que.front(); que.pop();
        vis[u] = false;
        for (int i = 0; i&lt;E[u].size(); i++)
        {
            int v = E[u][i].v;
            if (dist[v]&gt;dist[u] + E[u][i].cost)
            {
                dist[v] = dist[u] + E[u][i].cost;
                if (!vis[v])
                {
                    vis[v] = true;
                    que.push(v);
                    cnt[v]++;
                    if (cnt[v] &gt; n) return false;
                }
            }
        }
    }
    return true;
}

int n, m;
int a, b, c;

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
        for (int i = 0; i &lt;= n; i++) E[i].clear();
        while (m--)
        {
            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
            addedge(a, b, c);
            //addedge(b, a, c);
        }
        if (!SPFA(0, n)) puts(&quot;possible&quot;);
        else puts(&quot;not possible&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>UVA 567	Risk【floyd】</title>
    <url>/article/csdn/UVA_567_Risk%E3%80%90floyd%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47440955" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47440955</a></p>
<p>题目链接：<br><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=508" target="_blank" rel="noopener"><br>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=508
</a></p>
<p>题意：20个点的任意最短路。floyd</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;string&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;

using namespace std;

int a[25][25];
char c;

int main()
{
    int cases=1;
    int n,m;
    while (~scanf(&quot;%d&quot;,&amp;n))
    {
        for(int i=1;i&lt;=20;i++)
                for(int j= 1;j&lt;=20;j++)
                {
                    if (i==j) a[i][j] = 0;
                    else a[i][j] = 100000000;
                }
        while(n--)
            {
                scanf(&quot;%d&quot;,&amp;m);
                a[1][m] = a[m][1] = 1;
            }
        for(int i=2;i&lt;=19;i++)
        {
            scanf(&quot;%d&quot;,&amp;n);
            while(n--)
            {
                scanf(&quot;%d&quot;,&amp;m);
                a[i][m] = a[m][i] = 1;
            }
        }
        for(int k=1;k&lt;=20;k++)
            for(int i=1;i&lt;=20;i++)
                for(int j= 1;j&lt;=20;j++)
        {
            if (a[i][k] + a[k][j] &lt; a[i][j])
                a[i][j] =  a[i][k] + a[k][j];
        }
        int s,d;
        scanf(&quot;%d&quot;,&amp;n);
        printf(&quot;Test Set #%d\n&quot;,cases++);
        while(n--)
        {
            scanf(&quot;%d%d&quot;,&amp;s,&amp;d);
            printf(&quot;%2d to %2d: %d\n&quot;,s,d,a[s][d]);
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>uva</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA 707 - Robbery【记忆化搜索】</title>
    <url>/article/csdn/UVA_707_-_Robbery%E3%80%90%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47400047" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47400047</a></p>
<p>题目链接：<br><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=599&amp;problem=648&amp;mosmsg=Submission+received+with+ID+14106133" target="_blank" rel="noopener"><br>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=599&amp;problem=648&amp;mosmsg=Submission+received+with+ID+14106133
</a></p>
<p>题意：<br>在一个w *<br>h的图上，t个时刻，然后给你一些信息，知道某些时刻没有小偷的矩阵，问哪些时刻可以唯一确定小偷所在的位置，和确定小偷是否已经逃走，如果没逃走，但是也没有时刻可以可以确定小偷位置，输出不知道</p>
<p>解法：记忆化搜索<br>dp[i][j][t]=1 表示t时刻ij可能出现劫犯<br>dp[i][j][t]=0 表示t时刻ij不可能出现劫犯</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;math.h&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

int dir[][2] = { {0,0},{1,0},{-1,0},{0,1}, {0,-1} };
int W, H, T;
bool is_ok(int x, int y)
{
    if (x &gt;= 1 &amp;&amp; x &lt;= W &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= H) return true;
    return false;
}
int n;
int dp[110][110][110]; //dp[i][j][t]=1 表示t时刻ij可能出现劫犯 
                     //dp[i][j][t]=0 表示t时刻ij不可能出现劫犯 

vector&lt;pair&lt;int, int&gt; &gt; ans[110];

int dfs(int x, int y, int t)
{
    if (dp[x][y][t] != -1) 
        return dp[x][y][t];

    if (t == T)
    {
        dp[x][y][t] = 1;
        return 1;
    }
    dp[x][y][t] = 0;

    for (int i = 0; i &lt; 5; i++)
    {
        int xx = x + dir[i][0];
        int yy = y + dir[i][1];
        if (!is_ok(xx, yy)) continue;
        if (dfs(xx, yy, t + 1))
            dp[x][y][t] = 1;
    }
    return dp[x][y][t];
}

int main()
{
    int cases = 1;
    while (~scanf(&quot;%d%d%d&quot;, &amp;W, &amp;H, &amp;T) &amp;&amp; W)
    {
        memset(dp, -1, sizeof(dp));
        for (int i = 0; i &lt;= 105;i++) ans[i].clear();

        scanf(&quot;%d&quot;,&amp;n);
        int t, x, xx, y, yy;
        for (int ii = 1; ii &lt;= n; ii++)
        {
            scanf(&quot;%d%d%d%d%d&quot;, &amp;t, &amp;x, &amp;y, &amp;xx, &amp;yy);
            for (int i = x; i &lt;= xx; i++)
                for (int j = y; j &lt;= yy; j++)
                    dp[i][j][t] = 0;
        }

        for (int i = 1; i &lt;= W; i++)
            for (int j = 1; j &lt;= H; j++)
                dfs(i, j, 1);

        printf(&quot;Robbery #%d:\n&quot;, cases++);

        int ok;
        int res = 1;
        for (int k = 1; k &lt;= T; k++)
        {
            ok = 0;
            for (int i = 1; i &lt;= W; i++)
            {
                for (int j = 1; j &lt;= H; j++)
                {
                    if (dp[i][j][k] == 1)
                    {
                        ans[k].push_back((make_pair(i, j)));
                        ok = 1;
                    }
                }
            }
            if (!ok)
            {
                res = 0;
                break;
            }
        }
        if (!res)
        {
            puts(&quot;The robber has escaped.&quot;);
            printf(&quot;\n&quot;);
            continue;
        }
        for (int i = 1; i &lt;= T; i++)
        {
            if (ans[i].size() == 1)
            {
                printf(&quot;Time step %d: The robber has been at %d,%d.\n&quot;,i,ans[i][0].first,ans[i][0].second);
                res = 0;
            }
        }
        if (res)
            puts(&quot;Nothing known.&quot;);
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu的挂起和休眠</title>
    <url>/article/csdn/Ubuntu%E7%9A%84%E6%8C%82%E8%B5%B7%E5%92%8C%E4%BC%91%E7%9C%A0.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46464053" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46464053</a></p>
<h3><span id="休眠和挂起有什么区别">休眠和挂起有什么区别？</span></h3><p>挂起==Suspend To RAM(STR)<br>休眠==Suspend To Disk(STD)</p>
<p>挂起之后内存还在工作，休眠之后所有设备都停止工作。<br>挂起速度比休眠快，恢复的也快。</p>
<p>挂起是挂起硬盘，把计算机的当前状态全部装载到内存里，即硬盘停止供电，但内存还要供电。优点是恢复快，缺点是要持续供电，断电就得重启了。</p>
<p>休眠是把系统当前状态保存到硬盘中的一个休眠文件里，然后所有设备全部关闭，你可以安全地关闭电源了，下次重启，会自动调用硬盘里保存的文件，恢复到关机前的状态。<br>优点是不需要供电，可休眠很长时间，缺点是恢复速度慢（相对于挂起）。</p>
<p>挂起恢复时只要几秒钟，很快。休眠恢复时需要十几秒，比挂起慢，但比重启快很多。</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>UVA 796 - Critical Links【求桥】</title>
    <url>/article/csdn/UVA_796_-_Critical_Links%E3%80%90%E6%B1%82%E6%A1%A5%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47326023" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47326023</a></p>
<p>link: <a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=737" target="_blank" rel="noopener"><br>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=737
</a></p>
<p>题意：<br>求桥的数目及边，要求输出边的点的次序由小到大</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;ctime&gt;  
#include &lt;math.h&gt;  
#include &lt;limits.h&gt;  
#include &lt;complex&gt;  
#include &lt;string&gt;  
#include &lt;functional&gt;  
#include &lt;iterator&gt;  
#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;stack&gt;  
#include &lt;queue&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;list&gt;  
#include &lt;bitset&gt;  
#include &lt;sstream&gt;  
#include &lt;iomanip&gt;  
#include &lt;fstream&gt;  
#include &lt;iostream&gt;  
#include &lt;ctime&gt;  
#include &lt;cmath&gt;  
#include &lt;cstring&gt;  
#include &lt;cstdio&gt;  
#include &lt;time.h&gt;  
#include &lt;ctype.h&gt;  
#include &lt;string.h&gt;  
#include &lt;assert.h&gt;  
#pragma comment (linker, &quot;/STACK:102400000,102400000&quot;)

using namespace std;

int n, m, x, y;

const int MAXN = 1001000;
const int MAXM = 1000100;

int num;
char tmp;
vector&lt;pair&lt;int, int&gt; &gt; a;

struct Edge
{
    int to, next;
    bool cut;//是否为桥的标记
}edge[MAXM];
int head[MAXN], tot;
int Low[MAXN], DFN[MAXN], Stack[MAXN];
int Index, top;
bool Instack[MAXN];
bool cut[MAXN];
int add_block[MAXN];//删除一个点后增加的连通块
int bridge;

void addedge(int u, int v)
{
    edge[tot].to = v; edge[tot].next = head[u]; edge[tot].cut = false;
    head[u] = tot++;
}


void Tarjan(int u, int pre)
{
    int v;
    Low[u] = DFN[u] = ++Index;
    Stack[top++] = u;
    Instack[u] = true;
    int son = 0;
    for (int i = head[u]; i != -1; i = edge[i].next)
    {
        v = edge[i].to;
        if (v == pre)continue;
        if (!DFN[v])
        {
            son++;
            Tarjan(v, u);
            if (Low[u] &gt; Low[v])Low[u] = Low[v];
            //桥
            //一条无向边(u,v)是桥，当且仅当(u,v)为树枝边，且满足DFS(u)&lt;Low(v)。
            if (Low[v] &gt; DFN[u])
            {
                bridge++;
                edge[i].cut = true;
                edge[i ^ 1].cut = true;
                a.push_back(make_pair(min(u, v), max(u, v)));
            }
            //割点
            //一个顶点u是割点，当且仅当满足(1)或(2) (1) u为树根，且u有多于一个子树。
            //(2) u不为树根，且满足存在(u,v)为树枝边(或称父子边，
            //即u为v在搜索树中的父亲)，使得DFS(u)&lt;=Low(v)
            if (u != pre &amp;&amp; Low[v] &gt;= DFN[u])//不是树根
            {
                cut[u] = true;
                add_block[u]++;
            }
        }
        else if (Low[u] &gt; DFN[v])
            Low[u] = DFN[v];
    }
    //树根，分支数大于1
    if (u == pre &amp;&amp; son &gt; 1)cut[u] = true;
    if (u == pre)add_block[u] = son - 1;
    Instack[u] = false;
    top--;
}

void solve(int N)
{
    memset(DFN, 0, sizeof(DFN));
    memset(Instack, false, sizeof(Instack));
    memset(add_block, 0, sizeof(add_block));
    memset(cut, false, sizeof(cut));
    Index = top = 0;
    bridge = 0;
    for (int i = 1; i &lt;= N; i++)
        if (!DFN[i])
            Tarjan(i, i);
    sort(a.begin(), a.end());
    printf(&quot;%d critical links\n&quot;, bridge);
    for (int i = 0; i &lt; a.size(); i++)
        printf(&quot;%d - %d\n&quot;, a[i].first - 1, a[i].second - 1);
    printf(&quot;\n&quot;);
}

void init()
{
    tot = 0;
    num = 0;
    a.clear();
    memset(head, -1, sizeof(head));
}

int main()
{
    while (~scanf(&quot;%d&quot;, &amp;n))
    {
        init();
        for (int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;, &amp;m);
            m += 1;
            getchar();
            scanf(&quot;%c&quot;, &amp;tmp);
            scanf(&quot;%d&quot;,&amp;x);
            scanf(&quot;%c&quot;, &amp;tmp);
            while (x--)
            {
                scanf(&quot;%d&quot;, &amp;y);
                y += 1;
                addedge(m, y);
                addedge(y, m);
            }
        }
        solve(n);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Uva 10048 Audiophobia 【floyd】</title>
    <url>/article/csdn/Uva_10048_Audiophobia_%E3%80%90floyd%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44749211" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44749211</a></p>
<p>Consider yourself lucky! Consider yourself lucky to be still breathing and<br>having fun participating in<br>this contest. But we apprehend that many of your descendants may not have this<br>luxury. For, as you<br>know, we are the dwellers of one of the most polluted cities on earth.<br>Pollution is everywhere, both in<br>the environment and in society and our lack of consciousness is simply<br>aggravating the situation.<br>However, for the time being, we will consider only one type of pollution - the<br>sound pollution. The<br>loudness or intensity level of sound is usually measured in decibels and sound<br>having intensity level 130<br>decibels or higher is considered painful. The intensity level of normal<br>conversation is 60 65 decibels and<br>that of heavy traffic is 70 80 decibels.<br>Consider the following city map where the edges refer to streets and the nodes<br>refer to crossings.<br>The integer on each edge is the average intensity level of sound (in decibels)<br>in the corresponding street.<br><img src="https://img-blog.csdn.net/20150330123713359" alt="这里写图片描述"><br>To get from crossing A to crossing G you may follow the following path: A- C-<br>F- G. In that case<br>you must be capable of tolerating sound intensity as high as 140 decibels. For<br>the paths A- B- E- G,<br>A- B- D- G and A- C- F- D- G you must tolerate respectively 90, 120 and 80<br>decibels of sound intensity.<br>There are other paths, too. However, it is clear that A- C- F- D- G is the<br>most comfortable path since<br>it does not demand you to tolerate more than 80 decibels.<br>In this problem, given a city map you are required to determine the minimum<br>sound intensity level<br>you must be able to tolerate in order to get from a given crossing to another.<br>Input<br>The input may contain multiple test cases.<br>The first line of each test case contains three integers C(≤ 100), S(≤ 1000)<br>and Q(≤ 10000) where<br>C indicates the number of crossings (crossings are numbered using distinct<br>integers ranging from 1 to<br>C), S represents the number of streets and Q is the number of queries.<br>Each of the next S lines contains three integers: c1, c2 and d indicating that<br>the average sound<br>intensity level on the street connecting the crossings c1 and c2 (c1 ̸= c2) is<br>d decibels.<br>Each of the next Q lines contains two integers c1 and c2 (c1 ̸= c2) asking for<br>the minimum sound<br>intensity level you must be able to tolerate in order to get from crossing c1<br>to crossing c2.<br>The input will terminate with three zeros form C, S and Q.<br>Output<br>For each test case in the input first output the test case number (starting<br>from 1) as shown in the<br>sample output. Then for each query in the input print a line giving the<br>minimum sound intensity level<br>(in decibels) you must be able to tolerate in order to get from the first to<br>the second crossing in the<br>query. If there exists no path between them just print the line “no path”.<br>Print a blank line between two consecutive test cases.<br>Sample Input<br>7 9 3<br>1 2 50<br>1 3 60<br>2 4 120<br>2 5 90<br>3 6 50<br>4 6 80<br>4 7 70<br>5 7 40<br>6 7 140<br>1 7<br>2 6<br>6 2<br>7 6 3<br>1 2 50<br>1 3 60<br>2 4 120<br>3 6 50<br>4 6 80<br>5 7 40<br>7 5<br>1 7<br>2 4<br>0 0 0<br>Sample Output<br>Case #1<br>80<br>60<br>60<br>Case #2<br>40<br>no path<br>80</p>
<p>求路径中最大值最小的边；<br>floyd 传递闭包；</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;iostream&gt;  
#include &lt;string.h&gt;  
#include &lt;algorithm&gt;  
#include &lt;math.h&gt;  
#include &lt;stack&gt;  
#include &lt;queue&gt;  

using namespace std;

const int MAXN = 1010;
const int inf = 1e9;

int c, s, q;
int dp[MAXN][MAXN];
int u, v, w, cases = 1;

int main()
{
    while (scanf(&quot;%d%d%d&quot;, &amp;c, &amp;s, &amp;q) != EOF)
    {
        if (c == 0 &amp;&amp; s == 0 &amp;&amp; q == 0)
            break;
        for (int i = 1; i &lt;= c; i++)
            for (int j = 1; j &lt;= c; j++)
            {
                if (i == j)
                    dp[i][j] = 0;
                else
                    dp[i][j] = inf;
            }
        while (s--)
        {
            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
                dp[u][v] = dp[v][u] = w;
        }

        for (int k = 1; k &lt;= c; k++)
            for (int i = 1; i &lt;= c; i++)
                for (int j = 1; j &lt;= c; j++)
                {
                    if (dp[i][k]!=-1 &amp;&amp; dp[k][j]!=-1)
                        dp[i][j] = min(dp[i][j],max(dp[i][k],dp[k][j]));
                }
        if (cases != 1) printf(&quot;\n&quot;);
        printf(&quot;Case #%d\n&quot;, cases++);
        while (q--)
        {
            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
            if (dp[u][v] != inf)
                printf(&quot;%d\n&quot;,dp[u][v]);
            else
                printf(&quot;no path\n&quot;);
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>VIM配置</title>
    <url>/article/csdn/VIM%E9%85%8D%E7%BD%AE.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/51384471" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/51384471</a></p>
<p><img src="https://img-blog.csdn.net/20160512152555332" alt="这里写图片描述"><br>ubuntu系统下打开终端，输入vim就进入vim了。</p>
<p>配置方法是输入 vim ~/.vimrc (这样是用vim编辑配置文件，或者用 gedit ~/.vimrc 就是用gedit编辑了)</p>
<p>配置的话，按照自己习惯加几句配置文件就可以使用了。</p>
<p>一般配置下面几个：</p>
<pre><code>syntax on
set nu
set tabstop=4
set shiftwidth=4
colo evening
set mouse=a
set cin
</code></pre><p>然后配置以后保存。VIM的配置就结束了。<br>然后在终端里面 输入 vim A.cpp 然后就开始写代码了。</p>
<p>编译运行的话，可以另外打开一个终端（就是左侧右击，然后new一个出来），就可以一边编辑，一遍保存了。<br>但是注意在代码编译以后，一定要 :w 来保存下，然后进行编译运行。<br>编译可以输入 g++ A.cpp -o A<br>如果没有错就可以了。<br>然后输入 ./A 来运行，然后输入数据啥的，退出的话是 按 Ctrl+C</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Vernam加密法 Playfair密码加密</title>
    <url>/article/csdn/Vernam%E5%8A%A0%E5%AF%86%E6%B3%95_Playfair%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48684165" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48684165</a></p>
<p>Vernam加密法：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;set&gt;
#include &lt;sstream&gt;
#include &lt;time.h&gt;

using namespace std;

char clear_text[10000];
string ans;
char key[10000];

int main()
{
    memset(key, 0, sizeof(key));
    ans.clear();

    printf(&quot;please enter the clear_text :&quot;);
    scanf(&quot;%s&quot;, clear_text);
    int len = strlen(clear_text);
    printf(&quot;please enter key :&quot;);
    scanf(&quot;%s&quot;, &amp;key);
    for (int i = 0;i &lt; len;i++)
    {
        int tmp = (clear_text[i] - &#39;a&#39; + key[i] - &#39;a&#39;) % 26;
        ans += (char)(tmp + &#39;a&#39;);
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre><p>Playfair密码加密：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;set&gt;
#include &lt;sstream&gt;
#include &lt;time.h&gt;

using namespace std;

char key[100];
int mat[30][30];
string text, ans;
bool vis[30];

void init()
{
    memset(vis, false, sizeof(vis));
    memset(mat, 0, sizeof(mat));
    ans.clear();
    text.clear();
}

struct Loca
{
    int x, y;
}loc[100];

int main()
{
    init();
    printf(&quot;please entry the key :&quot;);
    scanf(&quot;%s&quot;, key);
    int len = strlen(key);
    int tot = 0;
    for (int i = 0;i &lt; len;i++)
    {
        if (!vis[key[i] - &#39;a&#39;])
        {
            int x = tot / 5;
            int y = tot % 5;
            loc[key[i] - &#39;a&#39;].x = x;
            loc[key[i] - &#39;a&#39;].y = y;
            mat[x][y] = key[i] - &#39;a&#39;;
            vis[key[i] - &#39;a&#39;] = true;
            if (key[i] == &#39;i&#39; || key[i] == &#39;j&#39;)
            {
                vis[&#39;i&#39; - &#39;a&#39;] = vis[&#39;j&#39; - &#39;a&#39;] = true;
                loc[&#39;i&#39; - &#39;a&#39;].x = x;
                loc[&#39;i&#39; - &#39;a&#39;].y = y;
                loc[&#39;j&#39; - &#39;a&#39;].x = x;
                loc[&#39;j&#39; - &#39;a&#39;].y = y;
            }
            tot++;
        }
    }

    int pos = 0;
    while (1)
    {
        if (!vis[pos])
        {
            int x = tot / 5;
            int y = tot % 5;
            loc[pos].x = x;
            loc[pos].y = y;
            mat[x][y] = pos;
            vis[pos] = true;
            if (pos == &#39;i&#39; - &#39;a&#39; || pos == &#39;j&#39; - &#39;a&#39;)
            {
                vis[&#39;i&#39; - &#39;a&#39;] = vis[&#39;j&#39; - &#39;a&#39;] = true;
                loc[&#39;i&#39; - &#39;a&#39;].x = x;
                loc[&#39;i&#39; - &#39;a&#39;].y = y;
                loc[&#39;j&#39; - &#39;a&#39;].x = x;
                loc[&#39;j&#39; - &#39;a&#39;].y = y;
            }
            tot++;
        }
        pos++;
        if (pos == 26) break;
    }

    printf(&quot;plaese enter the  clear text :&quot;);
    cin &gt;&gt; text;
    if (text.size() % 2) text += &#39;m&#39;;//事先约定奇数+’m‘

    //开始加密
    for (int i = 0;i &lt; text.size();i += 2)
    {
        int u = text[i] - &#39;a&#39;;
        int v = text[i + 1] - &#39;a&#39;;
        int x1 = loc[u].x;
        int y1 = loc[u].y;
        int x2 = loc[v].x;
        int y2 = loc[v].y;
        if (x1 == x2 &amp;&amp; y1 == y2)//事先约定相同算作为&quot;fq&quot;
            ans += &quot;fq&quot;;
        else if (x1 == x2)
        {
            int tmp = (y1 + 1) % 5;
            while (tmp == y1 || tmp == y2)
                tmp = (tmp + 1) % 5;
            ans += mat[x1][tmp] + &#39;a&#39;;

            int tmp2 = (y2 + 1) / 5;
            while (tmp2 == y1 || tmp2 == y2 || tmp2 == tmp)
                tmp2 = (tmp2 + 1) % 5;
            ans += mat[x2][tmp2] + &#39;a&#39;;
        }
        else if (y1 == y2)
        {
            int tmp = (x1 + 1) % 5;
            while (tmp == x1 || tmp == x2)
                tmp = (tmp + 1) % 5;
            ans += mat[tmp][y1] + &#39;a&#39;;

            int tmp2 = (x2 + 1) % 5;
            while (tmp == x1 || tmp == x2 || tmp2 == tmp)
                tmp2 = (tmp2 + 1) % 5;
            ans += mat[tmp2][y2] + &#39;a&#39;;
        }
        else if (x1 != x2 &amp;&amp; y1 != y2)
        {
            ans += mat[x1][y2] + &#39;a&#39;;
            ans += mat[x2][y1] + &#39;a&#39;;
        }
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
/*
hello
university
*/
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Vigenere密码 Hill密码</title>
    <url>/article/csdn/Vigenere%E5%AF%86%E7%A0%81_Hill%E5%AF%86%E7%A0%81.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48686543" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48686543</a></p>
<p>Vigenere密码代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;set&gt;
#include &lt;sstream&gt;
#include &lt;time.h&gt;

using namespace std;

char clear_text[10000];
string ans;
char key[10000];

int main()
{
    memset(key, 0, sizeof(key));
    ans.clear();

    int m;
    printf(&quot;please enter m :&quot;);
    scanf(&quot;%d&quot;, &amp;m);
    printf(&quot;please enter key :&quot;);
    scanf(&quot;%s&quot;, &amp;key);
    printf(&quot;please enter the clear_text :&quot;);
    scanf(&quot;%s&quot;, clear_text);
    int len = strlen(clear_text);

    for (int i = 0;i &lt; len;i++)
    {
        int pos = i;
        for (int j = 0;j &lt; m;j++)
        {
            int tmp = (clear_text[pos++] - &#39;a&#39; + key[j] - &#39;a&#39;) % 26;
            ans += (char)(tmp + &#39;a&#39;);
        }
        i = i + m - 1;
    } 
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
/*
5
hello
university
*/
</code></pre><p>Hill:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;assert.h&gt;

using namespace std;

int m;
int mat[510][510];
char clear[1000];
string ans;

int main()
{
    memset(mat, 0, sizeof(mat));
    ans.clear();

    printf(&quot;please enter m :&quot;);
    scanf(&quot;%d&quot;,&amp;m);

    printf(&quot;please enter key_mat :&quot;);
    for (int i = 0;i &lt; m;i++)
        for (int j = 0;j &lt; m;j++)
            scanf(&quot;%d&quot;, &amp;mat[i][j]);

    printf(&quot;please enter the clear_text :&quot;);
    scanf(&quot;%s&quot;, clear);

    int len = strlen(clear);
    int pos = 0;
    for (int i = 0;i &lt; len;i++)
    {
        string tmp;
        tmp.clear();
        for (int j = i;j &lt; i + m;j++) tmp += clear[j];

        int pos = 0;
        int cnt = 0;
        for (int j = 0;j &lt; m;j++)
        {
            cnt = 0;
            int t2 = 0;
            for (int k = 0;k &lt; m;k++)
            {
                int t1 = tmp[cnt++] - &#39;a&#39;;
                t2 += mat[k][pos] * t1;
            }
            t2 %= 26;
            ans += (char)(t2 + &#39;a&#39;);
            pos++;
        }
        i = i + m - 1;
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
/*
2
11 8 3 7
hill
*/
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>bellman_ford 模板</title>
    <url>/article/csdn/bellman_ford_%E6%A8%A1%E6%9D%BF.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/49945673" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/49945673</a></p>
<pre><code>const int INF = 0x3f3f3f3f;
const int MAXN = 550;

int dis[MAXN];

struct Edge
{
    int u, v, cost;
    Edge(int _u = 0, int _v = 0, int _cost = 0) :u (_u),v(_v), cost(_cost){};
};

vector&lt;Edge&gt; E;

bool bellman_ford(int start,int n)
{
    for (int i = 0;i &lt;= n;i++) dis[i] = INF;
    dis[start] = 0;
    for (int i = 1;i &lt; n;i++)
    {
        bool flag = false;
        for (int j = 0;j &lt; E.size();j++)
        {
            int u = E[j].u;
            int v = E[j].v;
            int cost = E[j].cost;
            if (dis[v] &gt; dis[u] + cost)
            {
                dis[v] = dis[u] + cost;
                flag = true;
            }
        }
        if (!flag) return true;
    }

    for (int j = 0;j &lt; E.size();j++)
    {
        if (dis[E[j].v] &gt; dis[E[j].u] + E[j].cost)
            return false;
    }
    return true;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>atof 函数说明</title>
    <url>/article/csdn/atof_%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43277045" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43277045</a></p>
<pre><code>/*

函数名： atof
功 能： 把字符串转换成浮点数
名字来源：ascii to floating point numbers 的缩写
用 法： double atof(const char *nptr);

atof（将字串转换成浮点型数）
表头文件 #include &lt;stdlib.h&gt;
定义函数 double atof(const char *nptr);
函数说明 atof()会扫描参数nptr字符串，跳过前面的空格字符，直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(&#39;\0&#39;)才结束转换，并将结果返回。参数nptr字符串可包含正负号、小数点或E(e)来表示指数部分，如123.456或123e-2。
返回值 返回转换后的浮点型数。
附加说明 atof()与使用strtod(nptr,(char**)NULL)结果相同。

*/
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;

using namespace std;

int main ()
{
    double f ;
    char s [50];
    cin&gt;&gt;s;
    cout&lt;&lt;s&lt;&lt;endl;
    f = atof(s);
    cout&lt;&lt;f&lt;&lt;endl;
    return 0;
}
</code></pre><p><img src="https://img-
blog.csdn.net/20150129203344381?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQyNzE5Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>WJMZBMR在成都赛区开幕式上的讲话</title>
    <url>/article/csdn/WJMZBMR%E5%9C%A8%E6%88%90%E9%83%BD%E8%B5%9B%E5%8C%BA%E5%BC%80%E5%B9%95%E5%BC%8F%E4%B8%8A%E7%9A%84%E8%AE%B2%E8%AF%9D.html</url>
    <content><![CDATA[<p>各位选手，各位教练，大家好，我是来自清华大学交叉信息学院的陈立杰，今天很荣幸站在这里代表全体参赛选手发言。对于我来说，这是我第一次正式参加ACM的比赛。不过我跟ACM之间的缘分，大概在很早的时候就已经存在了。<br>我还依稀记得，在我初三的时候，晚上我的一个好朋友在用手机跟妹子聊天，而我在用手机看OI和ACM的题目。自习课上我的那个朋友跟妹子一起学习，而我则翘课想去机房，有时候机房老师不让我去，我就跑去天台用草稿纸想题目。中午的时候我的那个朋友去跟妹子一起吃饭了，而我在机房里啃泡面。周末他们出去看电影逛公园，我就在电脑前面刷出一整版的WA。就这样日子悠悠的过去，我的朋友如今跟妹子过的很幸福，不过我觉得我跟我的电脑过的要更加幸福（笑）。<br>那时我还年轻，也想不到以后会怎么样，就是想要呆在机房里，为了做出题目这样纯粹的感动而活下去。一晃五年过去了，有如白驹过隙，Android从1.0到了4.3，srm从424到了594。从我AC第一道A+B以来，世界已经变了太多，曾经的感动和梦想似乎也随风而去。然而我心中却始终回荡着几天后AC的欢呼声，差几秒钟提交的捶桌声，比赛失利的呜咽声，以及永恒的机房主题<br>—-键盘声。<br>我还记得很久以前有人跟我说的话，自己选择的路，跪着也要走完。朋友们，虽然这个世界日益浮躁起来，只要能够为了当时纯粹的梦想和感动坚持努力下去，不管其它人怎么样，我们也能够保持自己的本色走下去。</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>bnu-44582</title>
    <url>/article/csdn/bnu-44582.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/42193079" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/42193079</a></p>
<p>昨天北师大新生赛的题，本弱做一做。。。</p>
<p>贪心题，按照结束时间排序进行贪心。</p>
<p><a href="http://www.bnuoj.com/v3/problem_show.php?pid=44582" target="_blank" rel="noopener"> http://www.bnuoj.com/v3/problem_show.php?pid=44582
</a>  </p>
<h2><span id="mlx的疯狂睡眠">MLX的疯狂睡眠</span></h2><p>Time Limit: 1000ms</p>
<p>Memory Limit: 65536KB</p>
<p>64-bit integer IO format:  %lld  Java class name:  Main</p>
<p><a href="http://www.bnuoj.com/v3/problem_show.php?pid=44581" target="_blank" rel="noopener"> Prev </a></p>
<p><a href="http://www.bnuoj.com/v3/problem_show.php?pid=44582#" target="_blank" rel="noopener"> Submit </a> <a href="http://www.bnuoj.com/v3/status.php?showpid=44582" target="_blank" rel="noopener"> Status
</a> <a href="http://www.bnuoj.com/v3/problem_stat.php?pid=44582" target="_blank" rel="noopener"> Statistics
</a> <a href="http://www.bnuoj.com/v3/discuss.php?pid=44582" target="_blank" rel="noopener"> Discuss
</a></p>
<p><a href="http://www.bnuoj.com/v3/problem_show.php?pid=44583" target="_blank" rel="noopener"> Next </a></p>
<p>Type:</p>
<p>None</p>
<p>None  Graph Theory  2-SAT  Articulation/Bridge/Biconnected Component<br>Cycles/Topological Sorting/Strongly Connected Component  Shortest Path<br>Bellman Ford  Dijkstra/Floyd Warshall  Euler Trail/Circuit  Heavy-Light<br>Decomposition  Minimum Spanning Tree  Stable Marriage Problem  Trees  Directed<br>Minimum Spanning Tree  Flow/Matching  Graph Matching  Bipartite Matching<br>Hopcroft–Karp Bipartite Matching  Weighted Bipartite Matching/Hungarian<br>Algorithm  Flow  Max Flow/Min Cut  Min Cost Max Flow  DFS-like  Backtracking<br>with Pruning/Branch and Bound  Basic Recursion  IDA* Search  Parsing/Grammar<br>Breadth First Search/Depth First Search  Advanced Search Techniques  Binary<br>Search/Bisection  Ternary Search  Geometry  Basic Geometry  Computational<br>Geometry  Convex Hull  Pick’s Theorem  Game Theory  Green Hackenbush/Colon<br>Principle/Fusion Principle  Nim  Sprague-Grundy Number  Matrix  Gaussian<br>Elimination  Matrix Exponentiation  Data Structures  Basic Data Structures<br>Binary Indexed Tree  Binary Search Tree  Hashing  Orthogonal Range Search<br>Range Minimum Query/Lowest Common Ancestor  Segment Tree/Interval Tree  Trie<br>Tree  Sorting  Disjoint Set  String  Aho Corasick  Knuth-Morris-Pratt  Suffix<br>Array/Suffix Tree  Math  Basic Math  Big Integer Arithmetic  Number Theory<br>Chinese Remainder Theorem  Extended Euclid  Inclusion/Exclusion  Modular<br>Arithmetic  Combinatorics  Group Theory/Burnside’s lemma  Counting<br>Probability/Expected Value  Others  Tricky  Hardest  Unusual  Brute Force<br>Implementation  Constructive Algorithms  Two Pointer  Bitmask  Beginner<br>Discrete Logarithm/Shank’s Baby-step Giant-step Algorithm  Greedy  Divide and<br>Conquer  Dynamic Programming  Tag it!</p>
<p>在一个寝室中，有早上6点多起床跑自习室或者图书馆，晚上11点多回寝室洗洗直接睡觉的神牛（真是神一般的存在）；也有早上11点多起来直接吃饭，下午玩一会累了又sleep的睡神；也有白天一直陪妹子，大晚上和寝室程序猴子作伴的泡神；也有早上不知道何时起，从下午到第二天早些时候（确实早啊！）一直code的神码手····那么现在问题来了，寝室本来是一个非常友好的team，但是为了证明自己的睡眠行为是大学最完美的，他们决定来一场惊天地的辩论····MLX作为寝室的一员，突然做出一个疯狂的决定：统计出寝室每一个成员的睡眠时间段（每一个成员可能有多个睡眠时间段），然后将亲自实践每一个成员睡眠方式，然后再决定谁的更好。聪明的您可能会想这样一个问题：如果MLX从进入一个睡眠段开始到结束中途不醒，MLX那一天最多能睡多少次？</p>
<p>现在将问题进一步抽象为：一天内有n个睡眠区间，每一个睡眠区间分别为距离当天0点的第Si秒开始，第Ti秒结束。对于每一次睡眠，MLX都可以参与或者不参与，如果选择了，那么MLX就必须将本次睡眠进行到底。此外，参与睡眠的时间不能重复（即使是刚开始的瞬间和结束的瞬间的重复也是不允许的），请问MLX最多能参与多少次睡眠？</p>
<h3><span id="input">Input</span></h3><p>第一行输入T，表示T组测试数据。</p>
<p>每一组的第一行输入n，表示有n个睡眠区间（1&lt;= n &lt;=10^5 ）</p>
<p>接下来n行，每一行输入两个整数Si，Ti（空格隔开），表示睡眠区间的开始和结束时间（1&lt;= Si&lt; Ti&lt; 24*3600）</p>
<h3><span id="output">Output</span></h3><p>MLX最多参与的睡眠次数</p>
<h3><span id="sample-input">Sample Input</span></h3><pre><code>1
5
1 3
2 5
4 7
6 9
8 10
</code></pre><h3><span id="sample-output">Sample Output</span></h3><pre><code>3
</code></pre><h3><span id="hint">Hint</span></h3><p>参与的睡眠编号依次是（1,3,5）</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt;
#include&lt;malloc.h&gt;

using namespace std;

int n;

struct Q
{
    int s;
    int e;
}p[100010];

bool cmp(Q a, Q b)
{
    return a.e &lt; b.e;
}

int cases;

int main()
{
    cin &gt;&gt; cases;

    while (cases--)
    {
        cin &gt;&gt; n;
        for (int i = 1; i &lt;= n; i++)
            cin &gt;&gt; p[i].s &gt;&gt; p[i].e;

        sort(p+1,p+1+n,cmp);

        int ans = 1;
        int t = p[1].e;

        for (int i = 2; i &lt;= n; i++)
        {
            if (t &lt; p[i].s)
            {
                ans++; 
                t = p[i].e;
            }
        }
        cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>ZOJ 3203  3203 Light Bulb【三分法】</title>
    <url>/article/csdn/ZOJ_3203_3203_Light_Bulb%E3%80%90%E4%B8%89%E5%88%86%E6%B3%95%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48959865" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48959865</a></p>
<p>题目链接： <a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=3366" target="_blank" rel="noopener"> http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=3366
</a></p>
<p>二分法用来解决单调问题，三分法解决凸（凹）函数问题，逼近求解</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;sstream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string&gt;

using namespace std;

int t;
double H,h,d;

const double EPS = 1e-10;

double calc(double x)
{
    return d-x+H-(H-h)*d/x;
}

double ternarySearch(double low, double high)
{
    double mid, midmid;
    double mid_value;
    double midmid_value;
    while (low + EPS &lt; high)
    {
        mid = (low + high) / 2;
        midmid = (mid + high) / 2;
        mid_value = calc(mid);
        midmid_value = calc(midmid);
        if (mid_value &gt; midmid_value)
            high = midmid;
        else
            low = mid;
    }
    return mid_value;
}

int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%lf%lf%lf&quot;,&amp;H,&amp;h,&amp;d);
        double ans = ternarySearch((H-h)*d/H,d);
        printf(&quot;%.3lf\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>c c++ 随机数</title>
    <url>/article/csdn/c_c++_%E9%9A%8F%E6%9C%BA%E6%95%B0.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41748935" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41748935</a></p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;//头文件
#include &lt;iostream&gt;

using namespace std;

int main ()
{
    srand(time(NULL));//初始化随机数
    //srand(time(0));//初始化随机数
    //srand(10);//初始化随机数

    for(int i=1;i&lt;=10;i++)
        cout&lt;&lt;rand()%1000&lt;&lt;endl;//生成1000以内的随机数
        //cout&lt;&lt;rand()&lt;&lt;endl;//产生随机数而不需要设定范围的话，只要用rand()就可以了,范围在0至RAND_MAX 间.RAND_MAX定义在stdlib.h, 其值为2147483647.

    srand(time(0));
    int a,b;
    cin&gt;&gt;a&gt;&gt;b;
    int c = double( rand()/RAND_MAX )* (b-a) +a;//生成[a,b]的随机数
    cout&lt;&lt;c&lt;&lt;endl;

    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>c++ string 类的 ”数值转换“ 操作</title>
    <url>/article/csdn/c++_string_%E7%B1%BB%E7%9A%84_%E2%80%9D%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2%E2%80%9C_%E6%93%8D%E4%BD%9C.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47066197" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47066197</a></p>
<p>实现标准库string和数值数据之间的转换。</p>
<pre><code>int a = 45;
string s = to_string(a);//将整数转换为string表示形式
double d = stod(s);//将字符转换为浮点数
</code></pre><p>其他函数：</p>
<pre><code>stoi(s, p, b);//返回s字符串的整数表达的数值。依次为 int, long ,unsigned long, long long, unsigned long long  
    stol(s, p, b);// b 是转换的基数 默认为 10
    stoul(s, p, b);// p 为 size_t指针，保存s中第一个非数值字符下标，初始为0，即函数不保存下标
    stoll(s, p, b);
    stoull(s, p, b);

//
    stof(s,p);//返回s字符串的浮点数表达的数值。依次为 float, double, long double
    stod(s,p);// p 为 size_t指针，保存s中第一个非数值字符下标，初始为0，即函数不保存下标
    stold(s,p);
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>fork之后子进程与父进程关系</title>
    <url>/article/csdn/fork%E4%B9%8B%E5%90%8E%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%88%B6%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/42806307" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/42806307</a></p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;unistd.h&gt;

void main()
{
    char str[6]=&quot;hello&quot;;

    pid_t pid=fork();

    if(pid==0)
    {
        str[0]=&#39;b&#39;;
        printf(&quot;子进程中str=%s\n&quot;,str);
        printf(&quot;子进程中str指向的首地址:%x\n&quot;,(unsigned int)str);
    }
    else
    {
        sleep(1);
        printf(&quot;父进程中str=%s\n&quot;,str);
        printf(&quot;父进程中str指向的首地址:%x\n&quot;,(unsigned int)str);
    }
}
</code></pre><p>子进程中str=bello  </p>
<p>子进程中str指向的首地址:bfdbfc06</p>
<p>父进程中str=hello</p>
<p>父进程中str指向的首地址:bfdbfc06</p>
<p>这里就涉及到物理地址和逻辑地址（或称虚拟地址）的概念。</p>
<p>从逻辑地址到物理地址的映射称为地址重定向。分为：</p>
<p>静态重定向–在程序装入主存时已经完成了逻辑地址到物理地址和变换，在程序执行期间不会再发生改变。</p>
<p>动态重定向–程序执行期间完成，其实现依赖于硬件地址变换机构，如基址寄存器。</p>
<p>逻辑地址：CPU所生成的地址。  CPU产生的逻辑地址被分为 :p （页号） 它包含每个页在物理内存中的基址，用来作为页表的索引；d<br>（页偏移），同基址相结合，用来确定送入内存设备的物理内存地址。</p>
<p>物理地址：内存单元所看到的地址。</p>
<p>用户程序看不见真正的物理地址。用户只生成逻辑地址，且认为进程的地址空间为0到max。物理地址范围从R+0到R+max<br>，R为基地址,地址映射－将程序地址空间中使用的逻辑地址变换成内存中的物理地址的过程。由内存管理单元（MMU）来完成。</p>
<p>fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，<br>出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。<br>在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。</p>
<p>fork时子进程获得  父进程数据空间、堆和栈的复制  ，所以变量的地址（当然是虚拟地址）也是一样的。  </p>
<p>每个进程都有自己的虚拟地址空间，不同进程的相同的虚拟地址显然可以对应不同的物理地址。因此地址相同（虚拟地址）而值不同没什么奇怪。  </p>
<p>具体过程是这样的：<br>fork子进程完全复制父进程的栈空间，也复制了页表，但没有复制物理页面，所以这时虚拟地址相同，物理地址也相同，但是会把父子共享的页面标记为“只读”（类似mmap的private的方式），如果父子进程一直对这个页面是同一个页面，知道其中任何一个进程要对共享的页面“写操作”，这时内核会复制一个物理页面给这个进程使用，同时修改页表。而把原来的只读页面标记为“可写”，留给另外一个进程使用。  </p>
<p>这就是所谓的“写时复制”。正因为fork采用了这种写时复制的机制，所以fork出来子进程之后，父子进程哪个先调度呢？内核一般会先调度子进程，因为很多情况下子进程是要马上执行exec，会清空栈、堆。。这些和父进程共享的空间，加载新的代码段。。。，这就避免了“写时复制”拷贝共享页面的机会。如果父进程先调度很可能写共享页面，会产生“写时复制”的无用功。所以，一般是子进程先调度滴。</p>
<p><strong> 假定父进程malloc的指针指向0x12345678, fork 后，子进程中的指针也是指向0x12345678，但是这两个地址都是虚拟内存地址<br>（virtual memory)，经过内存地址转换后所对应的 物理地址是不一样的。所以两个进城中的这两个地址相互之间没有任何关系。  </strong></p>
<p><strong> （注1：在理解时，你可以认为fork后，这两个相同的虚拟地址指向的是不同的物理地址，这样方便理解父子进程之间的独立性）<br>（注2：但实际上，linux为了提高 fork 的效率，采用了 copy-on-write<br>技术，fork后，这两个虚拟地址实际上指向相同的物理地址（内存页），只有任何一个进程试图修改这个虚拟地址里的内容前，两个虚拟地址才会指向不同的物理地址（新的物理地址的内容从原物理地址中复制得到））
</strong></p>
<p>转自：<a href="http://blog.csdn.net/xy010902100449/article/details/44851453" target="_blank" rel="noopener">http://blog.csdn.net/xy010902100449/article/details/44851453</a></p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>bzoj 2818 Gcd 【欧拉函数】</title>
    <url>/article/csdn/bzoj_2818_Gcd_%E3%80%90%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44201813" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44201813</a></p>
<p>问题：求  gcd(x,y)==质数, 1&lt;=x,y&lt;=n  的有多少对？</p>
<p>做这题的时候，懂得了一个非常重要的转化：求  (x, y) = k, 1 &lt;= x, y &lt;= n  的对数等于求  (x, y) = 1, 1 &lt;= x,<br>y &lt;= n/k  的对数！所以，枚举每个质数  p，  然后求  (x, y) = 1, 1 &lt;= x, y &lt;= n/p  的个数。  </p>
<p>(x, y) = 1 的个数如何求呢？欧拉函数！  </p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;
#include &lt;iterator&gt;

using namespace std;

const int MAXN = 1000000;
int n;

int main()
{
    while (scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        bool com[MAXN];
        int primes = 0, prime[MAXN], phi[MAXN];

        phi[1] = 1;
        for (int i = 2; i &lt;= n; ++i)
        {
            if (!com[i])
            {
                prime[primes++] = i;
                phi[i] = i - 1;
            }
            for (int j = 0; j &lt; primes &amp;&amp; i*prime[j] &lt;= n; ++j)
            {
                com[i*prime[j]] = true;
                if (i % prime[j])
                    phi[i*prime[j]] = phi[i] * (prime[j] - 1);
                else
                {
                    phi[i*prime[j]] = phi[i] * prime[j]; break;
                }
            }
        }

        for (int i = 2; i &lt;= n; i++)
            phi[i] = phi[i] + phi[i-1];
        long long ans = 0;

        for (int i = 0; i &lt; primes; i++)
            ans += phi[n/prime[i]] * 2 -1;
        printf(&quot;%lld\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>c++ decltype</title>
    <url>/article/csdn/c++_decltype.html</url>
    <content><![CDATA[<p><strong> 返回值 decltype(表达式)  </strong></p>
<p><strong> [返回值的类型是表达式参数的类型]  </strong></p>
<p><strong>  
</strong></p>
<p><strong>这个可也用来决定表达式的类型，就像Bjarne暗示的一样，如果我们需要去初始化某种类型的变量，auto是最简单的选择，但是如果我们所需的类型不是一个变量，例如返回值这时我们可也试一下decltype。</strong></p>
<p><strong>  
</strong></p>
<p><strong>现在我们回看一些例子我们先前做过的，</strong></p>
<hr>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/yshe_xun/article/details/7315135#" title="view plain" target="_blank" rel="noopener"> view plain
</a> <a href="http://blog.csdn.net/yshe_xun/article/details/7315135#" title="copy" target="_blank" rel="noopener"> copy
</a></p>
<ol>
<li>template  &lt; class  U,  class  V&gt;</li>
<li>void  Somefunction(U u, V v) </li>
<li>{ </li>
<li>result = u*v;  //now what type would be the result??? </li>
<li>decltype(u<em>v) result = u</em>v;  //Hmm …. we got what we want </li>
<li>} </li>
</ol>
<p><strong> 在下面的一个段落我将会让你熟悉这个观念用 auto 和 decltype 来声明模板函数的返回值，其类型依靠模板参数。  </strong></p>
<p><strong>  
</strong></p>
<p><strong>  
</strong></p>
<p><strong>1. 如果这个表达式是个函数，decltype 给出的类型为函数返回值的类型。</strong></p>
<hr>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/yshe_xun/article/details/7315135#" title="view plain" target="_blank" rel="noopener"> view plain
</a> <a href="http://blog.csdn.net/yshe_xun/article/details/7315135#" title="copy" target="_blank" rel="noopener"> copy
</a></p>
<ol>
<li>int  add(  int  i,  int  j){  return  i+j; } </li>
<li>decltype(add(5,6)) var = 5;  //Here the type of var is return of add() - &gt; which is int </li>
</ol>
<p>2.如果表达式是一个左值类型，那么 decltype 给出的类型为表达式左值引用类型。</p>
<hr>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/yshe_xun/article/details/7315135#" title="view plain" target="_blank" rel="noopener"> view plain
</a> <a href="http://blog.csdn.net/yshe_xun/article/details/7315135#" title="copy" target="_blank" rel="noopener"> copy
</a></p>
<ol>
<li>struct  M {  double  x; }; </li>
<li><ol start="3">
<li>double  pi = 3.14; </li>
</ol>
</li>
<li>const  M* m =  new  M(); </li>
<li>decltype( (m- &gt;x) ) piRef = pi; </li>
<li><ol start="7">
<li>// Note: Due to the inner bracets the inner statement is evaluated as expression, </li>
</ol>
</li>
<li>// rather than member ‘x’ and as type of x is double and as this is lvale </li>
<li>// the return of declspec is double&amp; and as ‘m’ is a const pointer </li>
<li>// the return is actually const double&amp;. </li>
<li>// So the type of piRef is const double&amp;</li>
</ol>
<p><strong>3.非常重要的标记一下， decltype 不会执行表达式而auto会  ，他仅仅推论一下表达式的类型。 </strong></p>
<hr>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/yshe_xun/article/details/7315135#" title="view plain" target="_blank" rel="noopener"> view plain
</a> <a href="http://blog.csdn.net/yshe_xun/article/details/7315135#" title="copy" target="_blank" rel="noopener"> copy
</a></p>
<ol>
<li>int  foo(){} </li>
<li>decltype( foo() ) x;  // x is an int and note that </li>
<li>// foo() is not actually called at runtime </li>
</ol>
<p><strong>跟踪返回类型：</strong></p>
<p><strong>这对 C++ 开发者来说是一个全新的特性，直到现在函数的返回类型必须放在函数名的前面。到了<br>C++11，我们也可以将函数返回值的类型放在函数声明后，当然仅需要用 auto 替代返回类型。现在我们想知道怎么做，让我们来寻找答案：</strong></p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/yshe_xun/article/details/7315135#" title="view plain" target="_blank" rel="noopener"> view plain
</a> <a href="http://blog.csdn.net/yshe_xun/article/details/7315135#" title="copy" target="_blank" rel="noopener"> copy
</a></p>
<ol>
<li>template  &lt; class  U,  class  V&gt;</li>
<li>??? Multiply(U u, V v)  // how to specifiy the type of the return value </li>
<li>{ </li>
<li>return  u*v; </li>
<li>} </li>
</ol>
<p>我们明显的不能像这样：</p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/yshe_xun/article/details/7315135#" title="view plain" target="_blank" rel="noopener"> view plain
</a> <a href="http://blog.csdn.net/yshe_xun/article/details/7315135#" title="copy" target="_blank" rel="noopener"> copy
</a></p>
<ol>
<li>template  &lt; class  U,  class  V&gt;</li>
<li>decltype(u*v) Multiply(U u, V v)  // Because u &amp; v are not defined before Multiply. </li>
<li>//  What to do…what to do !!! </li>
<li>{ </li>
<li>return  u*v; </li>
<li>} </li>
</ol>
<p><strong>  
</strong></p>
<p><strong>这种情况我们可也使用 auto 然后当我们使用 decltype(u*v) 作为返回值这个类型便知晓了.</strong></p>
<p><strong>这是不是很酷？</strong></p>
<hr>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/yshe_xun/article/details/7315135#" title="view plain" target="_blank" rel="noopener"> view plain
</a> <a href="http://blog.csdn.net/yshe_xun/article/details/7315135#" title="copy" target="_blank" rel="noopener"> copy
</a></p>
<ol>
<li>template  &lt; class  U,  class  V&gt;</li>
<li>auto Multiply(U u, V v) -&gt; decltype(u*v)  // Note -&gt; after the function bracet. </li>
<li>{ </li>
<li>return  u*v; </li>
<li>}<br>6.</li>
</ol>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hash冲突处理</title>
    <url>/article/csdn/hash%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86.html</url>
    <content><![CDATA[<p>对于Hash冲突，我们是怎样来处理冲突的。现在就来介绍一些经典的Hash冲突处理的方法。主要包括</p>
<p>（1）开放地址法</p>
<p>（2）拉链法</p>
<p>（3）再哈希法</p>
<p>（4）建立公共溢出区</p>
<p>（1）开放地址法</p>
<p>基本思想：当发生地址冲突时，按照某种方法继续探测Hash表中其它存储单元，直到找到空位置为止。描述如下</p>
<p><img src="https://img-blog.csdn.net/20140901163946233" alt=""></p>
<p>其中 <img src="https://img-blog.csdn.net/20140901164038696" alt=""> ， <img src="https://img-
blog.csdn.net/20140901164127961" alt=""> 为关键字 <img src="https://img-
blog.csdn.net/20140901163943843" alt=""> 的直接Hash地址， <img src="https://img-
blog.csdn.net/20140901164045718" alt=""> 为Hash表的长度， <img src="https://img-
blog.csdn.net/20140901164405006" alt=""> 为</p>
<p>每次再探测时的地址增量。  根据 <img src="https://img-blog.csdn.net/20140901164405006" alt=""><br>的不同取法，有不同的称呼。</p>
<p>线性探测再散列 <img src="https://img-blog.csdn.net/20140901164624390" alt=""></p>
<p>二次探测再散列 <img src="https://img-blog.csdn.net/20140901164956693" alt=""></p>
<p>伪随机再散列 <img src="https://img-blog.csdn.net/20140901165212975" alt=""> 伪随机数</p>
<p>（2）拉链法</p>
<p>拉链法又叫链地址法，适合处理冲突比较严重的情况。基本思想是把所有关键字为同义词的记录存储在同一个</p>
<p>线性链  表中。</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

using namespace std;
const int N = 35;

struct node
{
    int key;    //关键字
    int len;    //每个节点引出的链表长度
    bool flag;  //有数据的标志
    node *next;
};

node list[N];

void Init(node list[])
{
    for(int i=0; i&lt;N; i++)
    {
        list[i].len = 0;
        list[i].flag = 0;
        list[i].next = NULL;
    }
}

void Insert(node list[], int val, int m)
{
    int id = val % m;
    if(!list[id].flag)
    {
        list[id].key = val;
        list[id].flag = 1;
    }
    else
    {
        node *p = new node();
        p-&gt;key = val;
        p-&gt;next = list[id].next;
        list[id].next = p;
    }
}

//输出HashTable
void Print(node list[], int m)
{
    for(int i=0; i&lt;m; i++)
    {
        node *p = list[i].next;
        if(!list[i].flag)
            printf(&quot;The %dth record is NULL!\n&quot;, i);
        else
        {
            printf(&quot;The %dth record is %d&quot;, i, list[i].key);
            list[i].len++;
            while(p)
            {
                printf(&quot;-&gt;%d&quot;, p-&gt;key);
                p = p-&gt;next;
                list[i].len++;
            }
            puts(&quot;&quot;);
        }
    }
}

//计算平均查找长度
double ASL(node list[], int m)
{
    double ans = 0;
    for(int i=0; i&lt;m; i++)
        ans += (list[i].len + 1) * list[i].len / 2.0;
    return ans / m;
}

int main()
{
    int n, m;
    Init(list);
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    for(int i=0; i&lt;n; i++)
    {
        int val;
        scanf(&quot;%d&quot;, &amp;val);
        Insert(list, val, m);
    }
    Print(list, m);
    printf(&quot;The Average Search Length is %.5lf\n&quot;, ASL(list, m));
    return 0;
}

/**
12 11
47 7 29 11 16 92 22 8 3 37 89 50
*/
</code></pre><p>关于拉链法还可以参考：  <a href="http://www.51nod.com/question/index.html#!questionId=1191" target="_blank" rel="noopener"> http://www.51nod.com/question/index.html#!questionId=1191
</a></p>
<p>（3）再哈希法</p>
<p>再哈希法又叫双哈希法，有多个不同的Hash函数，当发生冲突时，使用第二个，第三个，….，等哈希函数</p>
<p>计算地址，直到无冲突。虽然不易发生聚集，但是增加了计算时间。</p>
<p>（4）建立公共溢出区</p>
<p>建立公共溢出区的基本思想是：假设哈希函数的值域是[1,m-1]，则设向量HashTable[0…m-1]为基本</p>
<p>表，每个分量存放一个记录，另外设向量OverTable[0…v]为溢出表，所有关键字和基本表中关键字为同义</p>
<p>词的记录，不管它们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表。</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>hau 3037 Saving Beans【Lucas定理】</title>
    <url>/article/csdn/hau_3037_Saving_Beans%E3%80%90Lucas%E5%AE%9A%E7%90%86%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/50518527" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/50518527</a></p>
<p>题目链接：<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3037" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=3037
</a></p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;

using namespace std;

long long pow(long long a, long long b, long long c)
{
    long long tmp = 1;
    while (b)
    {
        if (b &amp; 1) tmp = (tmp*a) % c;
        a = (a*a) % c;
        b &gt;&gt;= 1;
    }
    return tmp;
}

long long fac[100005];

void get_fac(long long p)
{
    fac[0] = 1;
    for (int i = 1;i &lt;= p;i++)
        fac[i] = (fac[i-1] * i) % p;
}

long long Lucas(long long n, long long m, long long p)
{
    long long tmp = 1;
    while (n &amp;&amp; m)
    {
        long long a = n%p,b = m%p;
        if (a &lt; b) return 0;
        tmp = (tmp * fac[a] * pow(fac[b] * fac[a - b] % p, p - 2, p)) % p;

        n /= p;
        m /= p;
    }
    return tmp;
}

int main()
{
    long long n, m, p;
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    while (T--)
    {
        scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;p);
        get_fac(p);
        printf(&quot;%lld\n&quot;, Lucas(n + m, m, p));
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1010</title>
    <url>/article/csdn/hdu-1010.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41524431" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41524431</a></p>
<p>简单深搜 剪枝</p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1010" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1010
</a>  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;sstream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;

using namespace std;

int n,m;
int t;

char p[10][10];
int ok ;
int sx,sy,ex,ey;

int dir[4][2]={ {0,1},{0,-1},{1,0},{-1,0}};

void dfs (int x,int y,int ans )
{
    if (ans == t)//判断时间是否用尽
    {
        if (x == ex &amp;&amp; y == ey)
            ok = 1;
        return ;
    }
    if (ok)
        return ;

    int temp = abs(x-ex) + abs(y - ey) - abs(ans - t);//剪枝（重要）

    if ( temp &gt; 0 || temp % 2  )
        return ;

    for(int i=0;i&lt;4;i++)
    {
        int xx,yy;
        xx = x + dir[i][0];
        yy = y + dir[i][1];
        if (xx &gt;=0 &amp;&amp; xx &lt;n &amp;&amp; yy &gt;=0 &amp;&amp; yy&lt; m &amp;&amp; p[xx][yy] != &#39;X&#39;)
        {
            p[xx][yy] = &#39;X&#39;;
            dfs (xx,yy,ans+1);
            p[xx][yy] = &#39;.&#39;;//回溯
        }

    }
}


int main ()
{
    while (cin&gt;&gt;n&gt;&gt;m&gt;&gt;t)
    {
        if (n==0 &amp;&amp; m==0 &amp;&amp; t==0)
            return 0;

        for (int i=0;i&lt;10;i++)
            for(int j=0;j&lt;10;j++)
            {
                p[i][j] = &#39;X&#39;;
            }


        for(int i=0;i&lt;n;i++)
            cin&gt;&gt;p[i];

        int  tt = 0;
        for(int i=0;i&lt;n;i++)
            for(int j=0;j&lt;m;j++)
            {
                if ( p[i][j] == &#39;S&#39; )
                {
                    sx=i;
                    sy=j;
                }
                if ( p[i][j] == &#39;D&#39; )
                {
                    ex= i;
                    ey =j;
                }
                if ( p[i][j] == &#39;X&#39; )        
                    tt++;
            }

        if (  m*n - tt &lt;= t )//如果时间大于最大步数 不符合条件
        {
            cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;
        }
        else 
        {
            ok = 0 ;
            p[sx][sy] = &#39;X&#39;;// 因为这里WA了好几次
            dfs (sx,sy,0);

            if (ok)
                cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;
            else
                cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1004</title>
    <url>/article/csdn/hdu-1004.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40650803" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40650803</a></p>
<p>map的应用</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;

using namespace std;

int main()  
{  
    int n;  
    map&lt;string,int&gt; s;  
    while(cin&gt;&gt;n &amp;&amp; n)
    {
        string str ;
        s.clear();
        for(int i=0;i&lt;n;i++)
        {
            cin&gt;&gt; str;
            s[str]++;
        }

        map&lt;string,int&gt;::iterator r; 
        int max=-1;

        for(r=s.begin ();r != s.end();r++)
        {
            if(r-&gt;second &gt; max)
                max=r -&gt;second ;
        }
        for(r=s.begin ();r!=s.end();r++)
        {
            if(r-&gt;second ==max)
                cout&lt;&lt;r-&gt;first &lt;&lt; endl; 
        }
    }

    return 0;  
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>c语言</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu-1016</title>
    <url>/article/csdn/hdu-1016.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41791633" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41791633</a></p>
<p>约瑟夫换问题</p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1016" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1016
</a>  </p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;

int n,cas=1,visit[20],result[20]={0,1}; 
int p[]={0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0};

void DFS(int pos)
{
    int i;
    if(pos==n &amp;&amp; p[result[1]+result[n]])
    {
        printf(&quot;%d&quot;,result[1]);
        for(i=2;i&lt;=n;i++)
            printf(&quot; %d&quot;,result[i]);
        printf(&quot;\n&quot;);
        return;
    }

    for(i=2;i&lt;=n;i++)
    {
        if(!visit[i] &amp;&amp; p[i+result[pos]])
        {
            result[pos+1]=i;
            visit[i]=1;
            DFS(pos+1);
            visit[i]=0;
        }
    }
}

int main()
{
    while(scanf(&quot;%d&quot;,&amp;n)!=EOF )
    {
        memset(visit,0,sizeof(visit));
        printf(&quot;Case %d:\n&quot;,cas++);
        if(n%2==0)
            DFS(1);
        printf(&quot;\n&quot;);
    }
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1087</title>
    <url>/article/csdn/hdu-1087.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40534853" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40534853</a></p>
<p>最大递增子段和</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt; 
#include&lt;malloc.h&gt; 
#include&lt;stdexcept&gt;

using namespace std;
int a[10000];
int dp[10000];

int maxx (int a,int b)
{
    if (a&gt;b)
        return a;
    else
        return b;
}

int main()
{
    int n;
    while (scanf (&quot;%d&quot;,&amp;n)!=EOF &amp;&amp; n )
    {
        for (int i=1;i&lt;=n;i++)

            scanf (&quot;%d&quot;,&amp;a[i]);

        dp[1]=a[1];
        int ans=dp[1];
        int max ;
        for (int i=2;i&lt;=n;i++)    
        {
            max=0;
            for (int j=1;j&lt;i;j++)
            {
                if (a[j]&lt; a[i] &amp;&amp; dp[j] &gt; max )
                    max= dp[j];
            }

            dp[i]=max+a[i]; 
            ans= maxx (ans,dp[i]);

        }
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1028 Ignatius and the Princess III 【母函数】</title>
    <url>/article/csdn/hdu-1028_Ignatius_and_the_Princess_III_%E3%80%90%E6%AF%8D%E5%87%BD%E6%95%B0%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40326901" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40326901</a></p>
<h1><span id="ignatius-and-the-princess-iii">Ignatius and the Princess III</span></h1><p><strong> Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 14254    Accepted Submission(s): 10028  
</strong>  </p>
<p>Problem Description</p>
<p>“Well, it seems the first problem is too easy. I will let you know how foolish<br>you are later.” feng5166 says.  </p>
<p>“The second problem is, given an positive integer N, we define an equation<br>like this:<br>N=a[1]+a[2]+a[3]+…+a[m];<br>a[i] &gt;0,1&lt;=m&lt;=N;<br>My question is how many different equations you can find for a given N.<br>For example, assume N is 4, we can find:<br>4 = 4;<br>4 = 3 + 1;<br>4 = 2 + 2;<br>4 = 2 + 1 + 1;<br>4 = 1 + 1 + 1 + 1;<br>so the result is 5 when N is 4. Note that “4 = 3 + 1” and “4 = 1 + 3” is the<br>same in this problem. Now, you do it!”  </p>
<p>Input</p>
<p>The input contains several test cases. Each test case contains a positive<br>integer N(1&lt;=N&lt;=120) which is mentioned above. The input is terminated by the<br>end of file.  </p>
<p>Output</p>
<p>For each test case, you have to output a line contains an integer P which<br>indicate the different equations you have found.  </p>
<p>Sample Input</p>
<p>4 10 20</p>
<p>Sample Output</p>
<p>5 42 627</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt; 
#include&lt;malloc.h&gt; 
#include&lt;stdexcept&gt;

using namespace std;

int n;
int c1[10000];
int c2[10000];

int main ()
{
    int n;
    while (scanf (&quot;%d&quot;,&amp;n)!=EOF )
    {
        for (int i=0;i&lt;=n;i++)
        {
            c1[i]=1;
            c2[i]=0;
        }


        for (int i=2;i&lt;=n;i++)
        {
            for (int j=0;j&lt;=n;j++)
            {
                for (int k=0;k+j&lt;=n;k+=i)
                {
                    c2[j+k]+=c1[j];
                }

            }

            for (int j=0;j&lt;=n;j++)
            {
                c1[j]=c2[j];
                c2[j]=0;
            }
        }
        printf(&quot;%d\n&quot;,c1[n]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1069</title>
    <url>/article/csdn/hdu-1069.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41044193" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41044193</a></p>
<p>动态规划</p>
<p>和最长不增子序列类似，注意底面的两边不可以是相同的  </p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt;
#include&lt;malloc.h&gt;
#include&lt;stdexcept&gt;

using namespace std;

int n;

struct q
{
    int x;
    int y;
    int z;
}p[1000];

int dp[1000];

bool cmp(q a ,q b)
{
    if (a.x != b.x )
        return a.x &gt; b.x;
    else
        return a.y &gt; b.y;
}

int k=1 ;
int x ,y,z;

int main()
{
    while (scanf(&quot;%d&quot;,&amp;n)!=EOF &amp;&amp; n)
    {
        int len =1 ;
        for (int i=1 ;i&lt;=n;i++)
        {
            scanf(&quot;%d %d %d&quot;,&amp;x ,&amp;y ,&amp;z);
            p[len].x = x;
            p[len].y = y;
            p[len].z = z;
            len ++;
            p[len].x = x;
            p[len].y = z;
            p[len].z = y;
            len ++;
            p[len].x = y;
            p[len].y = x;
            p[len].z = z;
            len ++;
            p[len].x = y;
            p[len].y = z;
            p[len].z = x;
            len ++;
            p[len].x = z;
            p[len].y = x;
            p[len].z = y;
            len ++;
            p[len].x = z;
            p[len].y = y;
            p[len].z = x;
            len ++;
        }

        sort (p+1,p+len,cmp);

        memset(dp,0,sizeof(dp) );

        for (int i=1 ;i&lt;=len-1;i++)
        {
            dp[i] = p[i].z;
            for(int j =1 ;j&lt;=i;j++)
            {
                if ( p[j].x &gt; p[i].x &amp;&amp; p[j].y &gt; p[i].y  )
                    {
                       dp[i] = max (dp[i] , dp[j] + p[i].z);
                    }
            }
        }

        int ans =0;
        for (int i=1 ;i&lt;=len-1;i++)
        {
            ans = max (ans ,dp[i]);
        }
        printf(&quot;Case %d: maximum height = %d\n&quot;,k++,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1159【最长公共子序列】</title>
    <url>/article/csdn/hdu-1159%E3%80%90%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40477515" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40477515</a></p>
<p>经典DP，最长公共子序列，状态转移方程:</p>
<p>if (a[i-1] == b[j-1])<br>dp[i][j] = dp[i-1][j-1]+1;<br>else<br>dp[i][j]=max(dp[i-1][j],dp[i][j-1]);</p>
<p><img src="http://hi.csdn.net/attachment/201201/21/0_1327121687XfYy.gif" alt="">  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
#include &lt;sstream&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;
#include&lt;bitset&gt;

using namespace std;

char a[1001],b[1001];
int dp[1001][1001];

int main()
{
    while (scanf (&quot;%s %s&quot;,a,b)!=EOF)
    {
        int l1= strlen(a);
        int l2= strlen(b);

        for (int i =0 ;i&lt;=l1;i++)
            for(int j =0;j&lt;=l2;j++)
                dp[i][j]=0;


        for (int i =1;i&lt;=l1;i++)
            for (int j=1;j&lt;=l2;j++)
        {
            if (a[i-1] == b[j-1])
                dp[i][j] = dp[i-1][j-1]+1;
            else
                dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
        }
        printf(&quot;%d\n&quot;,dp[l1][l2]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1160 FatMouse&#39;s Speed 【最长上升子序列】</title>
    <url>/article/csdn/hdu-1160_FatMouse&#39;s_Speed_%E3%80%90%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44016445" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44016445</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1160" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1160
</a></p>
<h1><span id="fatmouses-speed">FatMouse’s Speed</span></h1><p><strong> Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 9965    Accepted Submission(s): 4427<br>Special Judge  </strong>  </p>
<p>Problem Description</p>
<p>FatMouse believes that the fatter a mouse is, the faster it runs. To disprove<br>this, you want to take the data on a collection of mice and put as large a<br>subset of this data as possible into a sequence so that the weights are<br>increasing, but the speeds are decreasing.  </p>
<p>Input</p>
<p>Input contains data for a bunch of mice, one mouse per line, terminated by end<br>of file.  </p>
<p>The data for a particular mouse will consist of a pair of integers: the first<br>representing its size in grams and the second representing its speed in<br>centimeters per second. Both integers are between 1 and 10000. The data in<br>each test case will contain information for at most 1000 mice.  </p>
<p>Two mice may have the same weight, the same speed, or even the same weight and<br>speed.  </p>
<p>Output</p>
<p>Your program should output a sequence of lines of data; the first line should<br>contain a number n; the remaining n lines should each contain a single<br>positive integer (each one representing a mouse). If these n integers are<br>m[1], m[2],…, m[n] then it must be the case that  </p>
<p>W[m[1]]  &lt; W[m[2]] &lt; … &lt; W[m[n]]  </p>
<p>and  </p>
<p>S[m[1]] &gt; S[m[2]] &gt; … &gt; S[m[n]]  </p>
<p>In order for the answer to be correct, n should be as large as possible.<br>All inequalities are strict: weights must be strictly increasing, and speeds<br>must be strictly decreasing. There may be many correct outputs for a given<br>input, your program only needs to find one.  </p>
<p>Sample Input</p>
<p>6008 1300 6000 2100 500 2000 1000 4000 1100 3000 6000 2000 8000 1400 6000 1200<br>2000 1900</p>
<p>Sample Output</p>
<p>4 4 5 9 7</p>
<p>最长上升子序列及记录路径</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;

using namespace std;

struct node
{
    int x, y, num;
}p[10010];

bool cmp(node a, node b)
{
    return a.x &lt; b.x;
}

int pre[10010], dp[10010];
vector&lt;int&gt; q;

int main()
{
    int x, y;
    int len = 1;
    while (scanf(&quot;%d%d&quot;,&amp;x,&amp;y)!=EOF)
    //for (int i = 1; i &lt; 10; i++)
    {
        //cin &gt;&gt; x &gt;&gt; y;
        p[len].x = x;
        p[len].y = y;
        p[len].num = len;
        len++;
    }
    sort(p+1,p+len,cmp);
    memset(pre,0,sizeof(pre));

    for (int i = 1; i &lt; len; i++)
    {
        dp[i] = 1;
        for (int j = 1; j &lt; i; j++)
        {
            if (p[i].x &gt; p[j].x &amp;&amp; p[i].y &lt; p[j].y )
            {
                if (dp[i] &lt; dp[j] + 1)
                {
                    dp[i] = dp[j] + 1;
                    pre[p[i].num] = p[j].num;
                }
            }
        }
    }
    int ans = -1, num = 1;
    for (int i = 1; i &lt; len; i++)
    {
        if (ans &lt; dp[i])
        {
            ans = dp[i];
            num = p[i].num;
        }
    }
    printf(&quot;%d\n&quot;,ans);
    q.clear();
    while (num != 0)
    {
        q.push_back(num);
        num = pre[num];
    }
    reverse(q.begin(),q.end());
    for (int i = 0; i &lt; q.size(); i++)
        printf(&quot;%d\n&quot;,q[i]);
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1162</title>
    <url>/article/csdn/hdu-1162.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41452773" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41452773</a></p>
<p>最小生成树</p>
<pre><code>//prim 求最小生成树
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;
#define MAXN 105
#define UPPERDIS 999999
double lowcost[MAXN],vist[MAXN];
double cost[MAXN][MAXN];
int n;
double prim(int v0)
{
    int i, j, minone;
    double mindis;
    double ans = 0;/*用来记录最小生成树的总长度*/
    memset(vist, 0, sizeof(vist));
    /*各点距离初始化*/
    for(i = 0;i &lt; n;i++)
    {
        lowcost[i] = cost[v0][i];
    }
    vist[v0] = 1;
    for(i = 0;i &lt; n-1;i++)
    {
        mindis = UPPERDIS;
        for(j = 0;j &lt; n;j++)
          if(!vist[j] &amp;&amp; mindis &gt; lowcost[j])
          {
              mindis = lowcost[j];
              minone = j;
          }
        /*将找到的最近点加入最小生成树*/
        ans += mindis;
        vist[minone] = 1;
        /*修正其他点到最小生成树的距离*/
        for(j = 0;j &lt; n;j++)
          if(!vist[j] &amp;&amp; cost[minone][j] &lt; lowcost[j])
          {
              lowcost[j] = cost[minone][j];
          }
    }
    return ans;
}
struct point {
    double x, y;
}p[MAXN];
double dis(point p1, point p2)
{
    return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
}
int main()
{
    int i, j;
    while (~scanf(&quot;%d&quot;, &amp;n))
    {
        for(i = 0; i &lt; n; i++)
            scanf(&quot;%lf%lf&quot;, &amp;p[i].x, &amp;p[i].y);
        for(i = 0; i &lt; n; i++)
            for(j = i; j &lt; n; j++)
                if(j == i)
                    cost[i][i] = 1000000.0;
                else
                    cost[i][j] = cost[j][i] = dis(p[i], p[j]);
        printf(&quot;%.2lf\n&quot;,prim(0));
    }
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1166</title>
    <url>/article/csdn/hdu-1166.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40592915" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40592915</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1166" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1166
</a>  </p>
<p>线段树点操作</p>
<p>代码风格更新后：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;vector&gt;

#define Mid(a,b) ( a+((b-a)&gt;&gt;1))
#define ll(x) (x&lt;&lt;1)
#define rr(x) (x&lt;&lt;1|1)

const int N = 50010;

using namespace std;

int t,n;

int a[N];

struct node
{
    int left;
    int right;
    int sum;
    int mid() { return Mid(left, right); }
};

struct segtree
{
    node tree[N * 4];

    void buildtree(int left,int right,int ind)
    {
        tree[ind].left = left;
        tree[ind].right = right;
        tree[ind].sum = 0;

        if (left == right)
            tree[ind].sum = a[left];
        else
        {
            int mid = tree[ind].mid();

            buildtree(left,mid,ll(ind));
            buildtree(mid+1,right,rr(ind));
            tree[ind].sum = tree[ll(ind)].sum + tree[rr(ind)].sum;
        }
    }

    void update(int pos,int ind,int val)
    {
        if (tree[ind].left == tree[ind].right) tree[ind].sum += val;
        else
        {
            int mid = tree[ind].mid();

            if (pos &lt;= mid)
                update(pos,ll(ind),val);
            else
                update(pos,rr(ind),val);
            tree[ind].sum = tree[ll(ind)].sum + tree[rr(ind)].sum;
        }
    }

    int query(int st ,int ed,int ind)
    {
        int left = tree[ind].left;
        int right = tree[ind].right;

        if (st &lt;= left &amp;&amp; right &lt;= ed)
            return tree[ind].sum;

        else
        {
            int mid = tree[ind].mid();
            int sum1 = 0;
            int sum2 = 0;
            if (st &lt;= mid)
                sum1 = query(st,ed,ll(ind));
            if (ed &gt; mid)
                sum2 = query(st,ed,rr(ind));

            return sum1 + sum2;
        }
    }
}seg;

int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    int cases = 1;
    while (t--)
    {
        scanf(&quot;%d&quot;,&amp;n);
        for (int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;,&amp;a[i]);
        }

        seg.buildtree(1, n, 1);

        cout &lt;&lt; &quot;Case &quot; &lt;&lt; cases++ &lt;&lt; &quot;:&quot; &lt;&lt; endl;
        char opr[20];
        while (1)
        {
            scanf(&quot;%s&quot;,opr);
            int c, d;
            if (!strcmp(opr, &quot;End&quot;))
                break;
            scanf(&quot;%d %d&quot;,&amp;c,&amp;d);

            if (!strcmp(opr, &quot;Add&quot;))
            {
                seg.update(c, 1, d);
            }
            else if (!strcmp(opr, &quot;Sub&quot;))
            {
                seg.update(c, 1, -d);
            }
            else if (!strcmp(opr, &quot;Query&quot;))
            {
                printf(&quot;%d\n&quot;, seg.query(c, d, 1));
            }
        }
    }
    return 0;
}
</code></pre><p>之前</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include &lt;sstream&gt;
#include &lt;time.h&gt;
#include &lt;utility&gt; 
#include &lt;malloc.h&gt; 

using namespace std;

struct node
{
    int left ;
    int right;
    int sum;
}b[5001000];

int a[5000010];

void build(int left ,int right ,int i)
{
    int mid;
    b[i].left =left;
    b[i].right =right ;
    if (left == right )
    {
        b[i].sum=a[left];
        return ;
    }

    mid = (left + right )/2;
    build(left ,mid,2*i);
    build( mid+1,right ,2*i+1);
    b[i].sum=b[i*2].sum+b[i*2+1].sum;
}

void add (int id,int num,int i)//add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）&lt;/span&gt;
{
    if(b[i].left == b[i].right )
    {
        b[i].sum += num;
        return ;
    }
    else 
    {
        b[i].sum=b[i].sum+num;
        if (id&lt;= b[i*2].right )
            add (id,num,i*2);
        else
            add    (id,num,i*2+1);
    }
}

int query (int left,int right ,int i)//query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;&lt;/span&gt;
{
    int mid;
    if (b[i].right  == right &amp;&amp; b[i].left ==left )
    return b[i].sum ;

    mid=(b[i].left +b[i].right )/2;    
    if (right &lt;= mid)
        return query (left ,right,2*i);
    else if (left &gt; mid)
        return query (left ,right,2*i+1);
    else
        return query (left ,mid,2*i)+query (mid+1 ,right,2*i+1);
}

int main()
{
    int t;
    int l=1;
    scanf (&quot;%d&quot;,&amp;t);
    while (t--)
    {
        int n;
        scanf (&quot;%d&quot;,&amp;n);
        for (int i=1;i&lt;=n;i++)
            scanf (&quot;%d&quot;,&amp;a[i]);

        build(1,n,1);

        char bb[100];
        int c,d;

        printf(&quot;Case %d:\n&quot;,l++);

        while (scanf (&quot;%s&quot;,bb)  &amp;&amp; strcmp (bb,&quot;End&quot;))
        {
            scanf (&quot;%d%d&quot;,&amp;c,&amp;d);
            if(!strcmp(bb,&quot;Add&quot;))
            {
                add(c,d,1);
            }
            else if(!strcmp(bb,&quot;Sub&quot;))
            {
                add(c,-d,1);
            }
            else if(!strcmp(bb,&quot;Query&quot;))
            {
                printf(&quot;%d\n&quot;,query (c,d,1));
            }
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1176</title>
    <url>/article/csdn/hdu-1176.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40544263" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40544263</a></p>
<p>数塔DP的变形</p>
<p>引：可将所有的时间段和馅饼看成是一个矩阵，时间就是行数，掉馅饼的就是列数，则就是数字三角形问题，从最底层找一条路径，使得路径上的和最大。</p>
<p>状态转移方程为p[i][j]=max(p[i+1][j-1]，p[i+1][j，p[i+1][j-1])+p[i][j]。p[i][j]为时间i时在j位置掉的馅饼数目。</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;

using namespace std;

int p[100101][15];

int main ()
{
    int n;
    int x,t,t1;
    while (scanf (&quot;%d&quot;,&amp;n)!=EOF &amp;&amp; n)
    {
        t1=-1;
        memset (p,0,sizeof(p));
        for (int i =1 ;i&lt;=n;i++)
        {
            scanf (&quot;%d%d&quot;,&amp;x,&amp;t);
            p[t][x]++;
            t1=max(t1,t);
        }

        for (int i=t1-1;i&gt;=0;i--)
        {
             for (int j=0 ;j&lt;=10 ;j++)
            {
                if(j==0)
                {
                    p[i][j] = max (p[i+1][j],p[i+1][j+1])+p[i][j];
                }
                else if (j==10)
                {
                    p[i][j]=max(p[i+1][j-1],p[i+1][j])+p[i][j];
                }
                else
                {
                    p[i][j]=max (p[i+1][j], max(p[i+1][j-1],p[i+1][j+1]))+p[i][j];
                }
            }
        }
        printf(&quot;%d\n&quot;,p[0][5]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1195</title>
    <url>/article/csdn/hdu-1195.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41843453" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41843453</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1195" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1195
</a></p>
<p>bfs 加1 减 1 交换 ，三个方式</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt;
#include&lt;malloc.h&gt;
#include&lt;stdexcept&gt;
#include&lt;iomanip&gt;
#include&lt;iterator&gt;

using namespace std;

int t ;

char a[5],b[5];

struct node
{
    int num[5];
    int step;
};

node s1,s2;

int vis[10][10][10][10];

void bfs ()
{
    memset (vis,0,sizeof(vis));
    queue&lt;node&gt; q ;
    node qq ,qqq;

    s1.step = 0;
    vis[s1.num[0]][s1.num[1]][s1.num[2]][s1.num[3]] = 1;
    q.push(s1);
    while (!q.empty())
    {
        int ok = 1;
        qq = q.front();
        q.pop();
        for(int i=0;i&lt;4;i++)
        {
            if (qq.num[i] != s2.num[i])
            {
                ok = 0;
                break;
            }
        }

        if (ok)
        {
            printf(&quot;%d\n&quot;,qq.step);
            return ;
        }

        for(int i=0;i&lt;4;i++)//减1
        {
            qqq = qq;
            if (qq.num[i] == 1)
                qqq.num[i] = 9;
            else
                qqq.num[i] = qq.num[i] - 1;

            qqq.step = qq.step + 1;

            if(!vis[qqq.num[0]][qqq.num[1]][qqq.num[2]][qqq.num[3]])
            {
                vis[qqq.num[0]][qqq.num[1]][qqq.num[2]][qqq.num[3]] = 1 ;
                q.push(qqq);
            }
        }

        for(int i=0;i&lt;4;i++)//+1
        {
            qqq = qq;
            if (qq.num[i] == 9)
                qqq.num[i] = 1;
            else
                qqq.num[i] = qq.num[i] + 1;

            qqq.step = qq.step + 1;
            if(!vis[qqq.num[0]][qqq.num[1]][qqq.num[2]][qqq.num[3]])
            {
                vis[qqq.num[0]][qqq.num[1]][qqq.num[2]][qqq.num[3]] = 1 ;
                q.push(qqq);
            }
        }

        for(int i=0;i&lt;3;i++)//替换
        {
            qqq = qq;
            qqq.num[i] = qq.num[i+1];
            qqq.num[i+1] = qq.num[i];
            qqq.step = qq.step + 1;
            if(!vis[qqq.num[0]][qqq.num[1]][qqq.num[2]][qqq.num[3]])
            {
                vis[qqq.num[0]][qqq.num[1]][qqq.num[2]][qqq.num[3]] = 1 ;
                q.push(qqq);
            }
        }
    }
    return ;
}

int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%s %s&quot;,a,b);

        for(int i=0;i&lt;4;i++)
        {
            s1.num[i] = a[i] - &#39;0&#39;;
            s2.num[i] = b[i] - &#39;0&#39;;
        }
        bfs ();
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1238</title>
    <url>/article/csdn/hdu-1238.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41776303" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41776303</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1238" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1238
</a></p>
<h1><span id="substrings">Substrings</span></h1><p><strong> Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 7444    Accepted Submission(s): 3358  
</strong>  </p>
<p>Problem Description</p>
<p>You are given a number of case-sensitive strings of alphabetic characters,<br>find the largest string X, such that either X, or its inverse can be found as<br>a substring of any of the given strings.  </p>
<p>Input</p>
<p>The first line of the input file contains a single integer t (1  &lt;= t &lt;= 10),<br>the number of test cases, followed by the input data for each test case. The<br>first line of each test case contains a single integer n (1 &lt;= n &lt;= 100), the<br>number of given strings, followed by n lines, each representing one string of<br>minimum length 1 and maximum length 100. There is no extra white space before<br>and after a string.  </p>
<p>Output</p>
<p>There should be one line per test case containing the length of the largest<br>string found.  </p>
<p>Sample Input</p>
<p>2 3 ABCD BCDFF BRCD 2 rose orchid</p>
<p>Sample Output</p>
<p>2 2</p>
<p>Author</p>
<p>Asia 2002, Tehran (Iran), Preliminary</p>
<p>Recommend</p>
<p>Eddy   |   We have carefully selected several similar problems for you: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1239" target="_blank" rel="noopener"> 1239
</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1401" target="_blank" rel="noopener"> 1401
</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1548" target="_blank" rel="noopener"> 1548
</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1515" target="_blank" rel="noopener"> 1515
</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1180" target="_blank" rel="noopener"> 1180
</a></p>
<p>求最大公共子序列 暴力枚举</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt;
#include&lt;malloc.h&gt;
#include&lt;stdexcept&gt;

using namespace std;

char p[110][110];

int main ()
{
    int t,m,l;
    cin&gt;&gt;t;
    while ( t-- )
    {
        int n;
        cin&gt;&gt;n;
        m = 1000;
        for(int i=0;i&lt;n;i++)
            {
                cin&gt;&gt;p[i];
                 if ( m &gt; strlen (p[i]))
                 {
                     m = strlen(p[i]);
                     l = i;
                 }
            }

        char os[110],ps[110];
        int ans = 0;

        for(int i=0;i&lt;strlen(p[l]);i++)
            {
                for(int  j= i;j&lt;strlen(p[l]);j++ )
                {
                    int b = 0;
                    int c = j-i;
                    for(int k = i;k&lt;=j;k++)
                    {
                        os[b++] = p[l][k];
                        ps[c--] = p[l][k]; 
                    }

                    os[b] = &#39;\0&#39;;
                    ps[j-i+1] = &#39;\0&#39;;

                    int ok =1;

                    for(int k =0;k&lt;n;k++)
                    {
                         if (!strstr(p[k],os) &amp;&amp; !strstr (p[k],ps))
                         {
                             ok = 0;
                             break;
                         }
                    }

                    if (ok &amp;&amp; ans &lt; strlen(ps))
                    {
                        ans = strlen(ps);
                    }
                }
            }
        cout&lt;&lt;ans&lt;&lt;endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1240</title>
    <url>/article/csdn/hdu-1240.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41485583" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41485583</a></p>
<p>三维的BFS</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;sstream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;

using namespace std;

char str[10];
int n;
int sx,sy,sz;
int ex,ey,ez;
int ans ;

int vis[33][33][33];
char p[33][33][33];

int dir[6][3] = {{0,0,1},{0,0,-1},{1,0,0},{-1,0,0},{0,-1,0},{0,1,0}};

struct node 
{
    int x,y,z;
    int step;
};

int bfs ()
{
    memset(vis,0,sizeof(vis));

    node qq,qqq;

    qq.x = sx;
    qq.y = sy;
    qq.z = sz;
    qq.step = 0;

    vis[qq.x][qq.y][qq.z] = 1;

    queue&lt;node&gt; q;
    q.push(qq);

    while (!q.empty())
    {
        qqq = q.front();
        q.pop();
        if (qqq.x == ex &amp;&amp; qqq.y == ey &amp;&amp; qqq.z == ez)
        {
            ans = qqq.step;
            return 1;
        }
        for(int i=0;i&lt;6;i++)
        {
            qq.x = qqq.x + dir[i][0];
            qq.y = qqq.y + dir[i][1];
            qq.z = qqq.z + dir[i][2];
            qq.step = qqq.step;
            if (qq.x &lt; 0 || qq.x &gt;=n || qq.y &lt; 0 || qq.y &gt;=n || qq.z &lt; 0 || qq.z &gt;=n )
                continue;
            if(vis[qq.x][qq.y][qq.z] || p[qq.x][qq.y][qq.z]==&#39;X&#39;)
                continue;

            vis[qq.x][qq.y][qq.z] = 1;
            qq.step = qqq.step + 1;
            q.push(qq);
        }
    }
    return 0;
}

int main()
{
    while (scanf (&quot;%s%d&quot;,str,&amp;n)!=EOF)
    {
        for(int i=0;i&lt;n;i++)
        {
            for(int j=0;j&lt;n;j++)
            {
                scanf(&quot;%s&quot;,p[i][j]);
            }
        }
        scanf(&quot;%d %d %d&quot;,&amp;sx,&amp;sy,&amp;sz);
        scanf(&quot;%d %d %d&quot;,&amp;ex,&amp;ey,&amp;ez);
        scanf(&quot;%s&quot;,str);

        p[ex][ey][ez] = 0;

        if (bfs())
        {
            printf(&quot;%d %d\n&quot;,n,ans);
        }
        else 
            printf(&quot;NO ROUTE\n&quot;);

    }

    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu-1232 畅通工程</title>
    <url>/article/csdn/hdu-1232_%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/42466495" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/42466495</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1232" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1232
</a></p>
<p>并查集</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt; 
#include&lt;malloc.h&gt; 
#include&lt;stdexcept&gt;

using namespace std;

int n,m;
int p[10000];
int b [10000];

int find (int x)
{
    if (x==p[x])
        return x;
    else 
        return find (p[x]);
}

int fa,fb;
void un (int x,int y)
{
    fa=find(p[x]);
    fb=find(p[y]);
    if (fa!=fb)
    {
        if (fa&gt;fb)
            p[fa]=fb;
        else
            p[fb]=fa;
    }
}

int main ()
{

    while (scanf (&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF &amp;&amp; n)
    {
        for (int i=1;i&lt;=n;i++)
            p[i]=i;

        int sum=0;

        int a,b;
        for (int i=1;i&lt;=m;i++)
        {
            scanf (&quot;%d%d&quot;,&amp;a,&amp;b);
            un(a,b);
        }

        for (int i=1;i&lt;=n;i++)
        {
            if (p[i]==i)
                sum++;
        }
        printf(&quot;%d\n&quot;,sum-1);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1213 how many tables</title>
    <url>/article/csdn/hdu-1213_how_many_tables.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/42466617" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/42466617</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1213" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1213
</a></p>
<p>并查集</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt; 
#include&lt;malloc.h&gt; 
#include&lt;stdexcept&gt;

using namespace std;

int n, m, t;
int p[10000];
int b[10000];

int find(int x)
{
    if (x == p[x])
        return x;
    else
        return find(p[x]);
}

int fa, fb;
void un(int x, int y)
{
    fa = find(p[x]);
    fb = find(p[y]);
    if (fa != fb)
    {
        if (fa&gt;fb)
            p[fa] = fb;
        else
            p[fb] = fa;
    }
}

int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        for (int i = 1; i &lt;= n; i++)
            p[i] = i;

        int sum = 0;

        int a, b;
        for (int i = 1; i &lt;= m; i++)
        {
            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
            un(a, b);
        }

        for (int i = 1; i &lt;= n; i++)
        {
            if (p[i] == i)
                sum++;
        }
        printf(&quot;%d\n&quot;, sum);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu-1257</title>
    <url>/article/csdn/hdu-1257.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40509927" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40509927</a></p>
<p>刚开始单纯的以为 a[i] &gt;= a[i+1] ， 导弹的个数就会加一，结果可想而知。</p>
<p>思路：每次拿到一个值，判断他与前面的下降子序列中的最小值最接近的那个序列，然后把那个序列的最小值更新，如果前面的下降子序列</p>
<p>的最小值没有比这个值大的，就另开数组把他当成一个新的子序列的起点。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;

using namespace std;

int a[30010];

int main ()
{
    int n,m;
    while (scanf (&quot;%d&quot;,&amp;n) != EOF)
    {
       int i =1;
       int j;
       a[0]=33330;
       for (int k=0;k&lt;n;k++)
       {
           cin&gt;&gt;m;
           for (j=0;j&lt;=i;j++)
           {
               if ( a[j]&gt;=m )
               {
                   a[j]=m;
                   break;
               }
           }
           if (j&gt;i)
               a[++i] = m;
       }
       printf(&quot;%d\n&quot;,i);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1241</title>
    <url>/article/csdn/hdu-1241.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41524525" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41524525</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1241" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1241
</a></p>
<p>水题</p>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;string.h&quot;
#include &quot;stdlib.h&quot;
#include &quot;math.h&quot;

int m,n;
int i,j,k,visit[100][100];
char a[100][100];

int main()
{
    void dfs(int ,int  );
    while(scanf(&quot;%d%d&quot;,&amp;m,&amp;n)!=EOF &amp;&amp; m &amp;&amp; n )
    {

         for(int i=0;i&lt;m;i++)
              {
                  scanf(&quot;%s&quot;,a[i]);
                    for(int j=0;j&lt;n;j++)
                        a[i+1][j+1]=&#39;*&#39;;
         }
        int count=0;
         memset(visit,0,sizeof(visit));

        for(i=0;i&lt;m;i++)
                for(j=0;j&lt;n;j++)
        if(!visit[i][j] &amp;&amp; a[i][j]==&#39;@&#39;)
        {
            count++;
            dfs(i,j);
        }
        printf(&quot;%d\n&quot;,count);
    }
}


void dfs(int i,int j )
{
    if(!visit[i][j] &amp;&amp; a[i][j]==&#39;@&#39;)
    {
        visit[i][j]=1;
        dfs(i-1,j-1);dfs(i-1,j);dfs(i-1,j+1);
        dfs(i,j-1);             dfs(i,j+1);
        dfs(i+1,j-1);dfs(i+1,j);dfs(i+1,j+1);
    }
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1253</title>
    <url>/article/csdn/hdu-1253.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41732231" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41732231</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1253" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1253
</a>  </p>
<p>这道水题<br><img src="http://static.blog.csdn.net/xheditor/xheditor_emot/default/angry.gif" alt="发火"></p>
<pre><code>#include&lt;stdio.h&gt;    
#include&lt;iostream&gt;    
#include&lt;math.h&gt;    
#include&lt;stdlib.h&gt;    
#include&lt;ctype.h&gt;    
#include&lt;algorithm&gt;    
#include&lt;vector&gt;    
#include&lt;string.h&gt;    
#include&lt;queue&gt;    
#include&lt;stack&gt;    
#include&lt;set&gt;    
#include&lt;map&gt;    
#include&lt;sstream&gt;    
#include&lt;time.h&gt;    
#include&lt;utility&gt;    
#include&lt;malloc.h&gt;    
#include&lt;stdexcept&gt;    

using namespace std;

int k,n,m,t,tt,T;

int mapp[55][55][55];  
int vis[55][55][55];  
int d[55][55][55];  
int xx[6]={0,0,0,0,-1,1};  
int yy[6]={0,0,1,-1,0,0};  
int zz[6]={1,-1,0,0,0,0};  

void bfs()  
{  
  queue&lt;int&gt; q;  
  vis[1][1][1]=1;  
  d[1][1][1]=0;  
  int s=1*10000+100+1;  
  q.push(s);  
  while(!q.empty())  
  {  
      s=q.front();  
      q.pop();  
      int i;  
      int x,y,z;  
      int tz=s%100;  
      s=s/100;  
      int ty=s%100;  
      s=s/100;  
      int tx=s;  
      for(i=0;i&lt;6;i++)  
      {  
          x=tx+xx[i];  
          y=ty+yy[i];  
          z=tz+zz[i];  
          if(vis[x][y][z]==1||mapp[x][y][z]==1||mapp[x][y][z]==-1)  
                continue;  
          vis[x][y][z]=1;  
          d[x][y][z]=d[tx][ty][tz]+1;  
          q.push(x*10000+y*100+z);  
      }  
  }  
}  
int main()  
{  
    int k;  
    scanf(&quot;%d&quot;,&amp;k);  
    int cas=1;  
    for(cas=1;cas&lt;=k;cas++)  
    {  
        int a,b,c,t;  
        scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;c,&amp;t);  
        int i,j,l;  

        memset(mapp,-1,sizeof(mapp));  
        memset(vis,0,sizeof(vis));  
        memset(d,-1,sizeof(d));  

        for(i=1;i&lt;=a;i++)  
            for(j=1;j&lt;=b;j++)  
                for(l=1;l&lt;=c;l++)  
                    scanf(&quot;%d&quot;,&amp;mapp[i][j][l]);  

        bfs();  

        if(d[a][b][c] &lt;= t &amp;&amp; d[a][b][c] != -1)  
            printf(&quot;%d\n&quot;,d[a][b][c]);  
        else  
            printf(&quot;-1\n&quot;);  
    }  
    return 0;  
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu-1257 最少拦截系统</title>
    <url>/article/csdn/hdu-1257_%E6%9C%80%E5%B0%91%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43497767" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43497767</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1257" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1257
</a></p>
<h1><span id="最少拦截系统">最少拦截系统</span></h1><p><strong> Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 22272    Accepted Submission(s): 8722  
</strong>  </p>
<p>Problem Description</p>
<p>某国为了防御敌国的导弹袭击,发展出一种导弹拦截系统.但是这种导弹拦截系统有一个缺陷:虽然它的第一发炮弹能够到达任意的高度,但是以后每一发炮弹都不能超过前一发的高度.某天,雷达捕捉到敌国的导弹来袭.由于该系统还在试用阶段,所以只有一套系统,因此有可能不能拦截所有的导弹.<br>怎么办呢?多搞几套系统呗!你说说倒蛮容易,成本呢?成本是个大问题啊.所以俺就到这里来求救了,请帮助计算一下最少需要多少套拦截系统.  </p>
<p>Input</p>
<p>输入若干组数据.每组数据包括:导弹总个数(正整数),导弹依此飞来的高度(雷达给出的高度数据是不大于30000的正整数,用空格分隔)  </p>
<p>Output</p>
<p>对应每组数据输出拦截所有导弹最少要配备多少套这种导弹拦截系统.  </p>
<p>Sample Input</p>
<p>8 389 207 155 300 299 170 158 65</p>
<p>Sample Output</p>
<p>2</p>
<p>题意就不说了 ，DP题目，也有人说是贪心。。</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;string&gt;
#include&lt;sstream&gt;

using namespace std;

int a[30010];

int main()
{
    int n, m;
    while (cin&gt;&gt;n)
    {
        int i = 1;
        int j;
        a[0] = 33330;
        while (n--)
        {
            cin &gt;&gt; m;
            for (j = 0; j &lt;= i; j++)
            {
                if (a[j] &gt;= m)
                {
                    a[j] = m;
                    break;
                }
            }
            if (j&gt;i)
                a[++i] = m;
        }
        cout &lt;&lt; i &lt;&lt; endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1242</title>
    <url>/article/csdn/hdu-1242.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41544247" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41544247</a></p>
<p>dfs</p>
<p>可能有多个朋友 所以从angel搜朋友 遇到朋友就停止</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;sstream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;

using namespace std;

const int MAX = 202;

int n,m,t;
char p[MAX][MAX];
int vis[MAX][MAX];
int dir[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};
int sx,sy;

void dfs (int x,int y,int ans )
{
    if ( p[x][y] == &#39;r&#39; )
    {
        if (t &gt; ans)
            t = ans;
        return ;
    }

    for(int i=0;i&lt;4;i++)
    {
        int xx = x + dir[i][0];
        int yy = y + dir[i][1];
        if (xx &gt;=0 &amp;&amp; xx&lt;n &amp;&amp; yy&gt;=0 &amp;&amp; yy&lt;m &amp;&amp; !vis[xx][yy] &amp;&amp; p[xx][yy]!=&#39;#&#39;)
        {
            if (p[xx][yy] == &#39;.&#39; || p[xx][yy]==&#39;r&#39; )
            {
                vis[xx][yy] = 1;
                dfs (xx,yy,ans+1);
                vis[xx][yy] = 0;
            }
            else 
            {
                vis[xx][yy] = 1;
                dfs (xx,yy,ans+2);
                vis[xx][yy] = 0;
            }

        }
    }
}


int main ()
{
    while (scanf(&quot;%d %d&quot;,&amp;n,&amp;m)!=EOF)
    {

        for(int i=0;i&lt;n;i++)
        {
            scanf(&quot;%s&quot;,p[i]);
        }

        for(int i=0;i&lt;n;i++)
        {
            for(int j=0;j&lt;m;j++)
            {
                if (p[i][j] == &#39;a&#39;)
                {
                    sx = i;
                    sy = j;
                    break;
                }

            }
        }

        int ans = 0;
        t = INT_MAX;

        dfs (sx,sy,ans);

        if (t != INT_MAX )
            printf(&quot;%d\n&quot;,t);
        else 
            printf(&quot;Poor ANGEL has to stay in the prison all his life.\n&quot;);
    }

    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1272</title>
    <url>/article/csdn/hdu-1272.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40210089" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40210089</a></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt; 
#include&lt;malloc.h&gt; 
#include&lt;stdexcept&gt;

using namespace std;

int p[1000000];
int sset[100020];

int a,b;
int num=0;

int find (int i)
{
    if (i==p[i])
        return i;
    else
        return find (p[i]);
}

void un (int a,int b)
{
    int fa = find (a);
    int fb = find (b);
    if (fa == fb )
    {
        num++;//判断是否成环
        return ;
    }
    else 
    {
        if (fa&gt;fb)
            p[fa]=fb;
        else 
            p[fb]=fa;
    }
}

int main ()
{
    while (cin&gt;&gt;a&gt;&gt;b)
    {
        num=0;
        if (a==-1 &amp;&amp; b==-1)
            break;
        if (a==0 &amp;&amp; b==0)
        {
            printf(&quot;Yes\n&quot;);
            continue;
        }

        for (int i=1;i&lt;=100010;i++)
        {
            p[i]=i;
            sset[i]=0;
        }

        un(a,b);
        sset[a]=1;
        sset[b]=1;

        while (cin&gt;&gt;a&gt;&gt;b)
        {
            if (a==0 &amp;&amp; b==0)
                break;
            sset[a]=1;
            sset[b]=1;
            un(a,b);
        }
        int count=0;

        for(int i=1;i&lt;=100010;i++)
        {
            if (sset[i] &amp;&amp; i==p[i])//判断图是否联通 只要最后判断根节点的总数为1即可。
                count++;
        }

        if (count&gt;1)
            printf(&quot;No\n&quot;);
        else
            if (num == 0)
            printf(&quot;Yes\n&quot;);
        else
            printf(&quot;No\n&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1301</title>
    <url>/article/csdn/hdu-1301.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41451633" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41451633</a></p>
<p>模板题</p>
<pre><code>#include&lt;iostream&gt;
#define INF 999999
using namespace std;
int map[30][30],dis[30],v[30];
int prim(int n)
{
    int i,j,k,min,sum=0;
    for(i=1;i&lt;=n;i++)
        dis[i]=map[1][i];
    memset(v,0,sizeof(v));
    v[1]=1;
    dis[1]=0;
    for(i=2;i&lt;=n;i++)
    {
        k=1;
        min=INF;
        for(j=1;j&lt;=n;j++)
            if(!v[j]&amp;&amp;min&gt;dis[j])
            {
                k=j;
                min=dis[j];
            }
        sum+=min;
        v[k]=1;
        for(j=1;j&lt;=n;j++)
            if(!v[j]&amp;&amp;dis[j]&gt;map[k][j])
                dis[j]=map[k][j];
    }
    return sum;
}
int main()
{
    int n;
    while(~scanf(&quot;%d&quot;,&amp;n),n)
    {
        int i,m,q,j;
        char ch,cc;
        for(i=1;i&lt;=n;i++)
            for(j=1;j&lt;=n;j++)
                map[i][j]=INF;
        getchar();
        for(i=1;i&lt;=n-1;i++)
        {
            scanf(&quot;%c%d&quot;,&amp;ch,&amp;m);
            getchar();
            while(m--)
            {
                scanf(&quot;%c%d&quot;,&amp;cc,&amp;q);
                getchar();
                if(map[ch-&#39;A&#39;+1][cc-&#39;A&#39;+1]&gt;q)
                    map[ch-&#39;A&#39;+1][cc-&#39;A&#39;+1]=map[cc-&#39;A&#39;+1][ch-&#39;A&#39;+1]=q;
            }
        }
        printf(&quot;%d\n&quot;,prim(n));    
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu-1285</title>
    <url>/article/csdn/hdu-1285.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41092963" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41092963</a></p>
<p>拓扑排序：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;

using namespace std;

int n,m,r[600],a[600][600],ans[600];

void toposort()
{
    for(int i=1;i&lt;=n;i++)
    {
        int k=1;
        while(r[k]!=0 )
            k++;
        ans[i]=k;
        r[k]=-1;
        for(int j=1;j&lt;=n;j++)
        {
            if(a[k][j])
                r[j]--;
        }
    }
}

int main()
{
    int x,y;


    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m)!=EOF )
    {
        memset(a,0,sizeof(a));
        memset(r,0,sizeof(r));

        for(int i=1; i&lt;=m; i++)
        {
            scanf(&quot;%d %d&quot;,&amp;x,&amp;y);
            if(a[x][y]==0)
            {
                a[x][y]=1;
            }

        }

        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;=n;j++)
        {
            if(a[i][j]!=0)
                r[j]++;
        }

        toposort();

        for(int i=1; i&lt;=n; i++)
        {
            if(i != n) 
                printf(&quot;%d &quot;, ans[i]);
            else 
                printf(&quot;%d\n&quot;, ans[i]);
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1358 Period 【kmp】</title>
    <url>/article/csdn/hdu-1358_Period_%E3%80%90kmp%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44115387" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44115387</a></p>
<h1><span id="period">Period</span></h1><p><strong> Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 3443    Accepted Submission(s): 1727  
</strong>  </p>
<p>Problem Description</p>
<p>For each prefix of a given string S with N characters (each character has an<br>ASCII code between 97 and 126, inclusive), we want to know whether the prefix<br>is a periodic string. That is, for each i (2  &lt;= i &lt;= N) we want to know the<br>largest K &gt; 1 (if there is one) such that the prefix of S with length i can be<br>written as A  K  , that is A concatenated K times, for some string A. Of<br>course, we also want to know the period K.  </p>
<p>Input</p>
<p>The input file consists of several test cases. Each test case consists of two<br>lines. The first one contains N (2 &lt;= N &lt;= 1 000 000) – the size of the string<br>S. The second line contains the string S. The input file ends with a line,<br>having the number zero on it.  </p>
<p>Output</p>
<p>For each test case, output “Test case #” and the consecutive test case number<br>on a single line; then, for each prefix with length i that has a period K &gt; 1,<br>output the prefix size i and the period K separated by a single space; the<br>prefix sizes must be in increasing order. Print a blank line after each test<br>case.  </p>
<p>Sample Input</p>
<p>3 aaa 12 aabaabaabaab 0</p>
<p>Sample Output</p>
<p>Test case #1 2 2 3 3 Test case #2 2 2 6 2 9 3 12 4</p>
<p>题意： 从字符串第二个位置开始，前面的字符是否是循环的字符串，如果是，输出当前位置及其循环的个数。</p>
<p>又是kmp的getnext（）函数循环节的考察</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;

using namespace std;

char  b[1000500];
int Next[1000500];

void get_next(char b[], int m)
{
    int i = 0,j = -1;
    memset(Next,0,sizeof(Next));
    Next[0] = -1;
    while (b[i])
    {
        if (j == -1 || b[i] == b[j])
        {
            ++i;
            ++j;
            Next[i] = j;
        }
        else
            j = Next[j];
    }
}

int main()
{
    int cases = 1, n, m, i, j;

    while (scanf(&quot;%d&quot;,&amp;n)!=EOF &amp;&amp; n)
    {
        scanf(&quot;%s&quot;,b);
        get_next(b, n);
        printf(&quot;Test case #%d\n&quot;,cases++);

        for (int i = 2; b[i-1]; i++)
        {
            int t = Next[i];
            int s = i - t;
            if (i % s == 0 &amp;&amp; i/s&gt;1)
            {
                printf(&quot;%d %d\n&quot;,i,i/s);
            }
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1325 &amp; poj-1308 Is It A Tree?</title>
    <url>/article/csdn/hdu-1325_&amp;_poj-1308_Is_It_A_Tree?.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43086419" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43086419</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1325" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1325
</a></p>
<p>题意：</p>
<p>判断一个图是不是说树</p>
<p>只有树的根入度为 0 ，其余结点入度均为 1;</p>
<h1><span id="is-it-a-tree">Is It A Tree?</span></h1><p><strong> Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 15503    Accepted Submission(s): 3443  
</strong>  </p>
<p>Problem Description</p>
<p>A tree is a well-known data structure that is either empty (null, void,<br>nothing) or is a set of one or more nodes connected by directed edges between<br>nodes satisfying the following properties.<br>There is exactly one node, called the root, to which no directed edges point.  </p>
<p>Every node except the root has exactly one edge pointing to it.  </p>
<p>There is a unique sequence of directed edges from the root to each node.  </p>
<p>For example, consider the illustrations below, in which nodes are represented<br>by circles and edges are represented by lines with arrowheads. The first two<br>of these are trees, but the last is not.  </p>
<p><img src="http://acm.hdu.edu.cn/data/images/1325-1.gif" alt=""><br><img src="http://acm.hdu.edu.cn/data/images/1325-2.gif" alt=""><br><img src="http://acm.hdu.edu.cn/data/images/1325-3.gif" alt="">  </p>
<p>In this problem you will be given several descriptions of collections of nodes<br>connected by directed edges. For each of these you are to determine if the<br>collection satisfies the definition of a tree or not.  </p>
<p>Input</p>
<p>The input will consist of a sequence of descriptions (test cases) followed by<br>a pair of negative integers. Each test case will consist of a sequence of edge<br>descriptions followed by a pair of zeroes Each edge description will consist<br>of a pair of integers; the first integer identifies the node from which the<br>edge begins, and the second integer identifies the node to which the edge is<br>directed. Node numbers will always be greater than zero.  </p>
<p>Output</p>
<p>For each test case display the line <code>Case k is a tree.&quot; or the line</code>Case k<br>is not a tree.”, where k corresponds to the test case number (they are<br>sequentially numbered starting with 1).  </p>
<p>Sample Input</p>
<p>6 8 5 3 5 2 6 4 5 6 0 0 8 1 7 3 6 2 8 9 7 5 7 4 7 8 7 6 0 0 3 8 6 8 6 4 5 3 5<br>6 5 2 0 0 -1 -1</p>
<p>Sample Output</p>
<p>Case 1 is a tree. Case 2 is a tree. Case 3 is not a tree.</p>
<p>Source</p>
<p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=North+Central+North+America+1997&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener"> North Central North America 1997
</a></p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;cstdio&gt;  
#include &lt;string&gt;  
#include &lt;cstring&gt;  
#include &lt;cstdlib&gt;  
#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  

using namespace std;

#define N 100010

bool used[N*10];
int queue[N];
int in[N];
int fa[N];

int findd(int x)
{
    if (fa[x] == -1)
        return x;
    else
        return fa[x] = findd(fa[x]);
}

void un(int n,int m)
{
    int fx = findd(n);
    int fy = findd(m);
    if (fx != fy)
        fa[fy] = fx;
}

int main()
{
    int n, m, cases = 1;
    memset(used,false,sizeof(used));
    memset(in,0,sizeof(in));
    memset(fa,-1,sizeof(fa));
    bool ok = true; int num = 0;

    while (scanf(&quot;%d %d&quot;, &amp;n, &amp;m) != EOF)
    {
        if (n == -1 &amp;&amp; m == -1)
            break;
        else if (n == 0 &amp;&amp; m == 0)
        {
            int num1 = 0;
            for (int i = 0; i &lt; num; i++)
            {
                if (findd(queue[i]) != findd(queue[0]))
                {
                    ok = false;
                    break;
                }
                if (in[queue[i]] == 0)
                    num1++;
                if (in[queue[i]] &gt; 1)
                {
                    ok = false;
                    break;
                }
            }

            if (num1 != 1)
                ok = false;
            if (num == 0)
                ok = true;

            if (ok)
                printf(&quot;Case %d is a tree.\n&quot;,cases++);
            else
                printf(&quot;Case %d is not a tree.\n&quot;, cases++);

            memset(used, false, sizeof(used));
            memset(in, 0, sizeof(in));
            memset(fa, -1, sizeof(fa));
            ok = true, num = 0;
        }
        else
        {
            if (!used[n])
            {
                used[n] = true;
                queue[num++] = n;
            }
            if (!used[m])
            {
                used[m] = true;
                queue[num++] = m;
            }
            if (findd(n) == findd(m))
                ok = false;
            else
            {
                in[m]++;
                un(n,m);
            }
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu-1312</title>
    <url>/article/csdn/hdu-1312.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41544271" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41544271</a></p>
<p>dfs水题</p>
<pre><code>#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;

using namespace std;

int n,m;
char a[100][100];
int num ,vis[100][100];

void dfs(int i,int j)
{
    if(!vis[i][j] &amp;&amp; ( a[i][j]==&#39;.&#39; || a[i][j]==&#39;@&#39; ))
    {
        num++;
        vis[i][j]=1;
                 dfs(i-1,j);
        dfs(i,j-1);           dfs(i,j+1);
                 dfs(i+1,j);
    }
}

int main()
{

    while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)!=EOF &amp;&amp; n &amp;&amp; m )
    {
        memset(a,&#39;#&#39;,sizeof(a));
        for(int i=0;i&lt;m;i++)
                scanf(&quot;%s&quot;,a[i]);

        memset(vis,0,sizeof(vis));
        num=0;

        for(int i=0;i&lt;m;i++)
            for(int j=0;j&lt;n;j++)
            {
                if(a[i][j]==&#39;@&#39;)
                {
                    dfs(i,j);
                }
            }
            printf(&quot;%d\n&quot;,num);
    }
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu-1465 不容易系列之一 【排错公式】</title>
    <url>/article/csdn/hdu-1465_%E4%B8%8D%E5%AE%B9%E6%98%93%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80_%E3%80%90%E6%8E%92%E9%94%99%E5%85%AC%E5%BC%8F%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43531281" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43531281</a></p>
<p><strong>问题提出：n封不同的信对应n个不同的信箱，问都装错信封的方法有多少种？</strong></p>
<p><strong> 分析：错排公式的递推式为： <img src="https://img-
blog.csdn.net/20130812154616031?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNkcmVhbWVycw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="">
</strong></p>
<h1><span id="不容易系列之一">不容易系列之一</span></h1><p><strong> Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 15670    Accepted Submission(s): 6478  
</strong>  </p>
<p>Problem Description</p>
<p>大家常常感慨，要做好一件事情真的不容易，确实，失败比成功容易多了！<br>做好“一件”事情尚且不易，若想永远成功而总从不失败，那更是难上加难了，就像花钱总是比挣钱容易的道理一样。<br>话虽这样说，我还是要告诉大家，要想失败到一定程度也是不容易的。比如，我高中的时候，就有一个神奇的女生，在英语考试的时候，竟然把40个单项选择题全部做错了！大家都学过概率论，应该知道出现这种情况的概率，所以至今我都觉得这是一件神奇的事情。如果套用一句经典的评语，我们可以这样总结：一个人做错一道选择题并不难，难的是全部做错，一个不对。  </p>
<p>不幸的是，这种小概率事件又发生了，而且就在我们身边：<br>事情是这样的——HDU有个网名叫做8006的男性同学，结交网友无数，最近该同学玩起了浪漫，同时给n个网友每人写了一封信，这都没什么，要命的是，他竟然把所有的信都装错了信封！注意了，是全部装错哟！  </p>
<p>现在的问题是：请大家帮可怜的8006同学计算一下，一共有多少种可能的错误方式呢？</p>
<p>Input</p>
<p>输入数据包含多个多个测试实例，每个测试实例占用一行，每行包含一个正整数n（1 &lt;n&lt;=20），n表示8006的网友的人数。</p>
<p>Output</p>
<p>对于每行输入请输出可能的错误方式的数量，每个实例的输出占用一行。</p>
<p>Sample Input</p>
<p>2 3</p>
<p>Sample Output</p>
<p>1 2</p>
<pre><code>#include&lt;stdio.h&gt;

#include&lt;string.h&gt;

#include&lt;stdlib.h&gt;

long long set[25];

void fun()

{

     memset(set,0,sizeof(set));

     set[1]=0;

     set[2]=1;

     for(int i=3;i&lt;25;i++)

     {

         set[i]=(i-1)*(set[i-1]+set[i-2]);

     }

}

int main()

{

    fun();

    int n;

    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)

    {

        printf(&quot;%I64d\n&quot;,set[n]);

    }

    return 0;

}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1372</title>
    <url>/article/csdn/hdu-1372.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40627317" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40627317</a></p>
<p>广度优先搜索模板题</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;

using namespace std;

char A[5],B[5];

struct node
{
    int x;
    int y;
    int num;
}s,e,p,pp;

int vis[10][10];

int x[10]={1,2,-1,-2,1,2,-1,-2};
int y[10]={2,1,2,1,-2,-1,-2,-1};

int main ()
{
    while (scanf(&quot;%s %s&quot;,A,B)!=EOF)
    {

        queue&lt;node&gt; q;

        memset (vis,0,sizeof(vis));

        s.x=A[0]-&#39;a&#39;+1;
        s.y=A[1]-&#39;0&#39;;
        e.x=B[0]-&#39;a&#39;+1;
        e.y=B[1]-&#39;0&#39;;

        vis[s.x][s.y]=1;

        q.push(s);

        while (!q.empty())
        {
            p=q.front();
            q.pop();

            if (p.x == e.x &amp;&amp; p.y == e.y)
                break;

            for (int i =0;i&lt;8;i++)
            {
                if (p.x+x[i] &gt;= 1 &amp;&amp; p.x+x[i] &lt;= 8 &amp;&amp; p.y+y[i] &gt;= 1 &amp;&amp; p.y+y[i] &lt;= 8 &amp;&amp; !vis[p.x+x[i]][p.y+y[i]])
                {
                    pp.x=p.x+x[i];
                    pp.y=p.y+y[i];
                    vis[pp.x][pp.y]=vis[p.x][p.y]+1;
                    q.push(pp);
                }
            }
        }
        printf(&quot;To get from %s to %s takes %d knight moves.\n&quot;,A,B,vis[e.x][e.y]-1);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>iostream</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu-1394 求逆序数</title>
    <url>/article/csdn/hdu-1394_%E6%B1%82%E9%80%86%E5%BA%8F%E6%95%B0.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/42213265" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/42213265</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1394" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1394</a></p>
<p>首先建立空树，将 a[i] 逐个插入</p>
<p>计算一个序列n排列的最小逆序数</p>
<p>首先用线段树算出出事序列的逆序数，然后找规律推出排列的最小逆序数。</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include &lt;sstream&gt;
#include &lt;time.h&gt;
#include &lt;utility&gt; 
#include &lt;malloc.h&gt; 

using namespace std;

#define Max 5010

int a[5010];
int n;
int ans;
int sum;

struct
{
    int left;
    int right;
    int num;
}b[4 * Max];

void build(int left, int right, int i)//建立空树
{
    b[i].right = right;
    b[i].left = left;
    b[i].num = 0;

    if (b[i].left == b[i].right)
        return;

    int mid = (left + right) / 2;
    build(left, mid, i * 2);
    build(mid + 1, right, i * 2 + 1);
}

void update(int value, int i)//更新第value个节点， 从跟节点1开始更新到叶子节点value
{
    if (b[i].left == value &amp;&amp; b[i].right == value)
    {
        b[i].num = 1;
        return;
    }
    int mid = (b[i].left + b[i].right) / 2;

    if (value &lt;= mid)
        update(value, i * 2);//左子树
    else
        update(value, i * 2 + 1);//右子树

    b[i].num = b[i * 2].num + b[i * 2 + 1].num;//更新根节点
}

int query(int id ,int n,int i)//计算有多少个
{
    if (id &lt;= b[i].left  &amp;&amp; b[i].right &lt;= n)
    {
        return b[i].num;
    }
    else
    {
        int mid = (b[i].left + b[i].right)/2;
        int ans1 = 0,ans2 =0;
        if (id &lt;= mid)
        {
            ans1 = query(id, n, i * 2);
        }
        if (mid &lt; n)
        {
            ans2 = query(id, n, i * 2 + 1);
        }
        return ans1 + ans2;
    }
}

int main()
{
    while (scanf(&quot;%d&quot;,&amp;n)!=EOF)
    {
        build(0,n-1,1);
        ans = 0; sum = 0;

        for (int i = 0; i &lt; n; i++)
        {
            scanf(&quot;%d&quot;,&amp;a[i]);
            sum += query(a[i]+1,n-1,1);//计算比a[i]大的个数
            update(a[i],1);//更新a[i]
        }

        ans = sum;
        //printf(&quot;%d\n&quot;, ans);
        for (int i = 0; i &lt; n; i++)
        {
            sum = sum + (n - a[i] -1) - (a[i]);//当把第一个数移到最后一位，
            ans = min(sum, ans);               //比他大的有 n - a[i] + 1 个，比他小的有a[i]个（下标从 0 开始）
        }

        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1515</title>
    <url>/article/csdn/hdu-1515.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41787843" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41787843</a></p>
<p>dfs</p>
<p>题意：给你两个字符串，问：第一个字符串按入栈出栈规则，能否达到第二个字符串，输出所有的方法，i表示入栈，o表示出栈。</p>
<p>用dfs模拟第一个字符串入栈出栈过程:</p>
<p>1. 当前字符入栈，就向下一层递归，即搜向下一个字符</p>
<p>2. 栈顶元素出栈，对新的栈顶元素判断</p>
<p>注意回溯的条件</p>
<pre><code>#include&lt;stdio.h&gt;    
#include&lt;iostream&gt;    
#include&lt;math.h&gt;    
#include&lt;stdlib.h&gt;    
#include&lt;ctype.h&gt;    
#include&lt;algorithm&gt;    
#include&lt;vector&gt;    
#include&lt;string.h&gt;    
#include&lt;queue&gt;    
#include&lt;stack&gt;    
#include&lt;set&gt;    
#include&lt;map&gt;    
#include&lt;sstream&gt;    
#include&lt;time.h&gt;    
#include&lt;utility&gt;    
#include&lt;malloc.h&gt;    
#include&lt;stdexcept&gt;    

using namespace std;

char a[1000], b[1000];
char str1[1000], str2[1000];
char ans[1000];

stack&lt;char&gt; q;

int l1,l2;

void dfs(int cur1,int cur2,int k)
{
    if (cur2 == l1)
    {
        for(int i=0;i &lt; k;i++)
        {
            cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;;
        }
        cout&lt;&lt;endl;
        return ;
    }

    if (cur1 &lt; l1)
    {
        ans[k] = &#39;i&#39;;
        q.push(a[cur1]);
        dfs (cur1+1,cur2,k+1);
        q.pop();
    }

    if (!q.empty() &amp;&amp; q.top() == b[cur2])
    {
        ans[k] = &#39;o&#39;;
        char c = q.top();
        q.pop();
        dfs(cur1,cur2+1,k+1);
        q.push( c );
    }
}

int main()
{
    while (scanf(&quot;%s %s&quot;,a,b)!=EOF)
    {
        while (!q.empty())
        {
            q.pop();
        }
        int ok = 1;

        l1 = strlen(a);
        l2 = strlen(b);

        if (l1 != l2)
        {
            ok = 0;
        }

        strcpy(str1,a);
        strcpy(str2,b);

        sort(str1, str1 + l1);
        sort(str2, str2 + l2);

        if (strcmp(str1, str2) != 0)
            ok = 0;
        if (!ok)
        {
            printf(&quot;[\n]\n&quot;);
        }
        else
        {
            printf(&quot;[\n&quot;);

            dfs(0,0,0);

            printf(&quot;]\n&quot;);
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1422</title>
    <url>/article/csdn/hdu-1422.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40629105" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40629105</a></p>
<p>刚开始没注意访问顺序 用的贪心 WA了 后来仔细读题</p>
<p>环形序列的最长非负连续子序列。  显然当前剩余为 非负时dp[i]=dp[i-1]+1;否则，dp[i]=0;动态地记录已经获得的最优解。  </p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;

using namespace std;

int a[200200];
int dp[200200];

int main ()
{
    int n;
    int p,pp;
    while (scanf (&quot;%d&quot;,&amp;n)!=EOF)
    {
        for (int i =1 ;i&lt;=n;i++)
        {
            scanf (&quot;%d %d&quot;,&amp;p,&amp;pp);
            a[i]=a[i+n]=p-pp;//预处理
        }

        int sum=0;//当前剩余钱
        int s = 0 ;//出发的起点
        int ans = -1;//记录最优解

        for (int i =1 ;i&lt;=n*2;i++)
        {
            if (sum + a[i] &gt;= 0)
            {
                dp[i]=dp[i-1]+1;
                sum += a[i];

                if (i - s == n)
                {
                    if (ans &lt; dp[i])
                        ans = dp[i];
                    break;
                }

            }
            else
            {
                s=i//更新起点和当前剩余钱数
                sum=0;
                dp[i]=0;
                ans = max (ans ,dp[i-1]);//更新记录最大值 
            }
        }

        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu-1506</title>
    <url>/article/csdn/hdu-1506.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40918263" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40918263</a></p>
<p>DP  找出  a[i]  的左边和右边与自己连着的比自己大的数的长度  ,  然后用这个长度乘以  a[i],  乘积最大的那个就是答案</p>
<pre><code>#include&lt;stdio.h&gt;  
#include&lt;iostream&gt;  
#include&lt;math.h&gt;  
#include&lt;stdlib.h&gt;  
#include&lt;ctype.h&gt;  
#include&lt;algorithm&gt;  
#include&lt;vector&gt;  
#include&lt;string.h&gt;  
#include&lt;queue&gt;  
#include&lt;stack&gt;  
#include&lt;set&gt;  
#include&lt;map&gt;  
#include&lt;sstream&gt;  
#include&lt;time.h&gt;  
#include&lt;utility&gt;   
#include&lt;malloc.h&gt;   
#include&lt;stdexcept&gt;  

using namespace std;

int n;
long long  a[100010];
long long  l[100010],r[100010];
int main()
{
    while (scanf (&quot;%d&quot;,&amp;n)!=EOF &amp;&amp; n)
    {
        for (int i=1 ;i&lt;=n;i++)
            scanf (&quot;%I64d&quot;,&amp;a[i]);

        l[1]=1;
        r[n]=n;

        for(int i=2 ;i&lt;=n;i++)
        {
            int t=i;
            while (t&gt;1 &amp;&amp; a[i]&lt;=a[t-1])
                t=l[t-1];
            l[i]=t;
        }
        for(int i=n-1;i&gt;=1;i--)
        {
            int t=i;
            while(t&lt;n &amp;&amp; a[i]&lt;=a[t+1])
                t=r[t+1];
            r[i]=t;
        }
        long long  ans =0;
        for (int i=1 ;i&lt;=n;i++)
        {
            ans = max (ans ,(r[i]-l[i]+1)*a[i]);
        }
        printf(&quot;%I64d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1711</title>
    <url>/article/csdn/hdu-1711.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41257907" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41257907</a></p>
<h1><span id="kmp-学习资料-httpblogcsdnnetv_july_varticledetails7041827">kmp 学习资料： [ </span></h1><p>](<a href="http://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="noopener">http://blog.csdn.net/v_july_v/article/details/7041827</a>)  </p>
<h1><span id=""> </span></h1><h1><span id="number-sequence">Number Sequence</span></h1><p><strong> Time Limit: 10000/5000 MS (Java/Others)    Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 12419    Accepted Submission(s): 5661  
</strong>  </p>
<p>Problem Description</p>
<p>Given two sequences of numbers : a[1], a[2], …… , a[N], and b[1], b[2],<br>…… , b[M] (1  &lt;= M &lt;= 10000, 1 &lt;= N &lt;= 1000000). Your task is to find a<br>number K which make a[K] = b[1], a[K + 1] = b[2], …… , a[K + M - 1] =<br>b[M]. If there are more than one K exist, output the smallest one.  </p>
<p>Input</p>
<p>The first line of input is a number T which indicate the number of cases. Each<br>case contains three lines. The first line is two numbers N and M (1 &lt;= M &lt;=<br>10000, 1 &lt;= N &lt;= 1000000). The second line contains N integers which indicate<br>a[1], a[2], …… , a[N]. The third line contains M integers which indicate<br>b[1], b[2], …… , b[M]. All integers are in the range of [-1000000,<br>1000000].  </p>
<p>Output</p>
<p>For each test case, you should output one line which only contain K described<br>above. If no such K exists, output -1 instead.  </p>
<p>Sample Input</p>
<p>2 13 5 1 2 1 2 3 1 2 3 1 3 2 1 2 1 2 3 1 3 13 5 1 2 1 2 3 1 2 3 1 3 2 1 2 1 2<br>3 2 1</p>
<p>Sample Output</p>
<p>6 -1</p>
<p>Source</p>
<p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=HDU+2007-Spring+Programming+Contest&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener"> HDU 2007-Spring Programming Contest
</a></p>
<p>kmp 模板题  求字串在母串第一次出现的位置</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;malloc.h&gt;

using namespace std;

int a[1000005],b[10005];
int next[10005];

void get_next(int b[],int m)
{
    int i=0;
    next[0]=-1;
    int j=-1;
    while(i&lt;m)
    {
     if(j==-1||b[i]==b[j])
     {
        ++i;
        ++j;
      if(b[i]==b[j])
      next[i]=next[j];
      else
      next[i]=j;
    }
    else
    j=next[j];
   }
}
int KMP(int a[],int n,int b[],int m,int next[],int pos)
{
    int i=pos;
    int j=0;
    while(i&lt;n&amp;&amp;j&lt;m)
    {
    if(j==-1||a[i]==b[j])
    {
        ++i;
        ++j;
    }
    else
    j=next[j];
    }
   if(j&gt;=m)
   return i-j+1;
   else
   return -1;
}
int main()
{
    int test,n,m,i,j;
    scanf(&quot;%d&quot;,&amp;test);
    while(test--)
    {
     scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
     for(i=0;i&lt;n;++i)
     scanf(&quot;%d&quot;,&amp;a[i]);
     for(j=0;j&lt;m;++j)
     scanf(&quot;%d&quot;,&amp;b[j]);
     get_next(b,m);
     cout&lt;&lt;KMP(a,n,b,m,next,0)&lt;&lt;endl;
    }
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
        <tag>kmp</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu-1495</title>
    <url>/article/csdn/hdu-1495.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41845187" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41845187</a></p>
<p>bfs 六种状态</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt;
#include&lt;malloc.h&gt;
#include&lt;stdexcept&gt;
#include&lt;iomanip&gt;
#include&lt;iterator&gt;

using namespace std;

int s,n,m;

struct ss
{
    int ml[4];
    int step;
};

int vis[110][110][110];

void bfs ()
{
    memset(vis,0,sizeof(vis));
    queue&lt;ss&gt; q;
    ss qq ,qqq;

    qq.ml[0] = s;
    qq.ml[1] = 0;//初始是0  不是n
    qq.ml[2] = 0;
    vis[qq.ml[0]][qq.ml[1]][qq.ml[2]] = 1;
    qq.step = 0;

    q.push(qq);

    while (!q.empty())
    {
        qq = q.front();
        q.pop();

        if ((qq.ml[0] == s/2 &amp;&amp; qq.ml[1] == s/2) || (qq.ml[0] == s/2 &amp;&amp; qq.ml[2] == s/2) || (qq.ml[1] == s/2 &amp;&amp; qq.ml[2] == s/2) )
        {
            printf(&quot;%d\n&quot;,qq.step);
            return ;
        }

        //a b ok
        {
            //a b倒不完
            if (qq.ml[0] &gt; n - qq.ml[1] )
            {
                qqq = qq;
                qqq.ml[0] = qq.ml[0] - (n- qq.ml[1]);
                qqq.ml[1] = n;
                qqq.step = qq.step + 1;
                if(!vis[qqq.ml[0]][qqq.ml[1]][qqq.ml[2]])
                {
                    vis[qqq.ml[0]][qqq.ml[1]][qqq.ml[2]] = 1;
                    q.push(qqq);
                }
            }
            else
            {
                //a b倒完
                qqq = qq;
                qqq.ml[0] = 0;
                qqq.ml[1] = qq.ml[1] + qq.ml[0] ;
                qqq.step = qq.step + 1;
                if(!vis[qqq.ml[0]][qqq.ml[1]][qqq.ml[2]])
                {
                    vis[qqq.ml[0]][qqq.ml[1]][qqq.ml[2]] = 1;
                    q.push(qqq);
                }
            }
        }
        //a c ok
        {
            //a c倒不完
            if (qq.ml[0] &gt; m - qq.ml[2] )
            {
                qqq = qq;
                qqq.ml[0] = qq.ml[0] - (m - qq.ml[2]);
                qqq.ml[2] = m;
                qqq.step = qq.step + 1;
                if(!vis[qqq.ml[0]][qqq.ml[1]][qqq.ml[2]])
                {
                    vis[qqq.ml[0]][qqq.ml[1]][qqq.ml[2]] = 1;
                    q.push(qqq);
                }
            }
            else
            {
                //a c倒完
                qqq = qq;
                qqq.ml[0] = 0;
                qqq.ml[2] = qq.ml[2] + qq.ml[0] ;
                qqq.step = qq.step + 1;
                if(!vis[qqq.ml[0]][qqq.ml[1]][qqq.ml[2]])
                {
                    vis[qqq.ml[0]][qqq.ml[1]][qqq.ml[2]] = 1;
                    q.push(qqq);
                }
            }
        }
        //b a  ok
        {

            //b a 倒不完
            if (qq.ml[1] &gt; s - qq.ml[0] )
            {
                qqq = qq;
                qqq.ml[0] = s;
                qqq.ml[1] = qq.ml[1] - (s - qq.ml[0]);
                qqq.step = qq.step + 1;
                if(!vis[qqq.ml[0]][qqq.ml[1]][qqq.ml[2]])
                {
                    vis[qqq.ml[0]][qqq.ml[1]][qqq.ml[2]] = 1;
                    q.push(qqq);
                }
            }
            else
            {
                //b a倒完
                qqq = qq;
                qqq.ml[1] = 0;
                qqq.ml[0] = qq.ml[1] + qq.ml[0] ;
                qqq.step = qq.step + 1;
                if(!vis[qqq.ml[0]][qqq.ml[1]][qqq.ml[2]])
                {
                    vis[qqq.ml[0]][qqq.ml[1]][qqq.ml[2]] = 1;
                    q.push(qqq);
                }
            }

        }
        // b c ok
        {
            //b c 倒不完
            if (qq.ml[1] &gt; m - qq.ml[2] )
            {
                qqq = qq;
                qqq.ml[1] = qq.ml[1] - (m - qq.ml[2] );
                qqq.ml[2] = m;
                qqq.step = qq.step + 1;
                if(!vis[qqq.ml[0]][qqq.ml[1]][qqq.ml[2]])
                {
                    vis[qqq.ml[0]][qqq.ml[1]][qqq.ml[2]] = 1;
                    q.push(qqq);
                }
            }
            else
            {
                //b  c 倒完
                qqq = qq;
                qqq.ml[2]= qq.ml[2] + qq.ml[1];
                qqq.ml[1] = 0;
                qqq.step = qq.step + 1;
                if(!vis[qqq.ml[0]][qqq.ml[1]][qqq.ml[2]])
                {
                    vis[qqq.ml[0]][qqq.ml[1]][qqq.ml[2]] = 1;
                    q.push(qqq);
                }
            }
        }
        //c a ok
        {
            //c a 倒不完
            if (qq.ml[2] &gt; s - qq.ml[0] )
            {
                qqq = qq;
                qqq.ml[0] = s;
                qqq.ml[2] = qq.ml[2] - (s - qq.ml[0]);
                qqq.step = qq.step + 1;
                if(!vis[qqq.ml[0]][qqq.ml[1]][qqq.ml[2]])
                {
                    vis[qqq.ml[0]][qqq.ml[1]][qqq.ml[2]] = 1;
                    q.push(qqq);
                }
            }
            else
            {
                //c a 倒完
                qqq = qq;
                qqq.ml[2] = 0;
                qqq.ml[0] = qq.ml[0] + qq.ml[2] ;
                qqq.step = qq.step + 1;
                if(!vis[qqq.ml[0]][qqq.ml[1]][qqq.ml[2]])
                {
                    vis[qqq.ml[0]][qqq.ml[1]][qqq.ml[2]] = 1;
                    q.push(qqq);
                }
            }

        }
        //c b ok
        {
            //倒不完
            if (qq.ml[2] &gt; n - qq.ml[1] )
            {
                qqq = qq;
                qqq.ml[1] = n;
                qqq.ml[2] = qq.ml[2] - (n - qq.ml[1]);
                qqq.step = qq.step + 1;
                if(!vis[qqq.ml[0]][qqq.ml[1]][qqq.ml[2]])
                {
                    vis[qqq.ml[0]][qqq.ml[1]][qqq.ml[2]] = 1;
                    q.push(qqq);
                }
            }
            else
            {
                //倒完
                qqq = qq;
                qqq.ml[2] = 0;
                qqq.ml[1] = qq.ml[1] + qq.ml[2] ;
                qqq.step = qq.step + 1;
                if(!vis[qqq.ml[0]][qqq.ml[1]][qqq.ml[2]])
                {
                    vis[qqq.ml[0]][qqq.ml[1]][qqq.ml[2]] = 1;
                    q.push(qqq);
                }
            }
        }

    }
    printf(&quot;NO\n&quot;);
    return ;
}

int main()
{
    while (scanf(&quot;%d %d %d&quot;,&amp;s,&amp;n,&amp;m) != EOF )
    {
        if (n == 0 &amp;&amp; s == 0 &amp;&amp; m ==0)
            return 0;

        if (s % 2 != 0 )
        {
            printf(&quot;NO\n&quot;);
        }
        else
        {
            bfs ();
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1505</title>
    <url>/article/csdn/hdu-1505.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41084283" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41084283</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1505" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1505
</a></p>
<p>1506的加强版</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt;
#include&lt;malloc.h&gt;
#include&lt;stdexcept&gt;

using namespace std;

int n,m;
int t,tt;
char s[5];
int p[1005][1005];
int l[1005];
int r[1005];

int main()
{
    scanf(&quot;%d&quot;,&amp;tt);
    while (tt--)
    {
        memset (p,0,sizeof(p));

        scanf (&quot;%d %d&quot;,&amp;n,&amp;m);
        for(int i=1 ;i&lt;=n;i++)
            for(int j=1 ;j&lt;=m;j++)
            {
                scanf (&quot;%s&quot;,s);
                if (s[0] == &#39;F&#39;)
                    p[i][j] = p[i-1][j] + 1;
                else
                    p[i][j] = 0;
            }

        int ans = -1;

        for(int i=1 ;i&lt;=n;i++)
        {
            for(int j=1;j&lt;=m;j++)
                l[j]=r[j]=j;

                p[i][0]=p[i][m+1]=-1;

                for(int k=2 ;k&lt;=m;k++)
                {
                    t=k;
                    while ( t &gt; 1 &amp;&amp; p[i][k] &lt;= p[i][t-1])
                        t=l[t-1];
                    l[k]=t;
                }

                for(int k=m-1 ;k&gt;=1;k--)
                {
                    t=k;
                    while ( t &lt; n &amp;&amp; p[i][k] &lt;= p[i][t+1])
                        t=r[t+1];
                    r[k]=t;
                }

                for(int j=1 ;j&lt;=m;j++)
                {
                    ans = max( ans , p[i][j] * (r[j]-l[j]+1));
                }
        }
        printf(&quot;%d\n&quot;,ans * 3);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1698</title>
    <url>/article/csdn/hdu-1698.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/42921585" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/42921585</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1698" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1698
</a></p>
<p>实现求全部区间的和 ，修改部分区间的值。</p>
<p>成段更新需要用到懒惰标记 lazy。<br>简单来说就是每次更新的时候不要更新到底，用延迟标记使得更新延迟到下次需要更新or询问到的时候。延迟标记的意思是：这个区间的左右儿子都需要被更新，但是当前区间已经更新了。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;iomanip&gt;

using namespace std;

#define ll(ind) (ind&lt;&lt;1)
#define rr(ind) (ind&lt;&lt;1|1)
#define Mid(a,b) (a+((b-a)&gt;&gt;1))

const int N = 100100;

struct node
{
    int left,right,sum;
    int mid()
    {
        return Mid(left, right);
    }

    int lazy;

    void fun(int summ)
    {
        lazy = summ; 
        sum = (right - left + 1) * lazy;
    }
};

struct segtree
{
    node tree[N*4];

    void real(int ind)//更新懒惰标记
    {
        if (tree[ind].lazy)
        {
            tree[ll(ind)].fun(tree[ind].lazy);
            tree[rr(ind)].fun(tree[ind].lazy);
            tree[ind].lazy = 0;
        }
    }

    void buildtree(int left,int right,int ind)
    {
        tree[ind].left = left;
        tree[ind].right = right;
        tree[ind].sum = right - left + 1;
        tree[ind].lazy = 1;
        if (left != right)
        {
            int mid = tree[ind].mid();
            buildtree(left, mid, ll(ind));
            buildtree(mid + 1, right, rr(ind));
        }
    }

    void update(int st, int ed, int ind, int type)
    {
        int left = tree[ind].left;
        int right = tree[ind].right;
        if (st &lt;= left &amp;&amp; right &lt;= ed)
            tree[ind].fun(type);
        else
        {
            real(ind);

            int mid = tree[ind].mid();
            if (st &lt;= mid) update(st, ed, ll(ind), type);
            if (ed &gt; mid) update(st, ed, rr(ind), type);
            tree[ind].sum = tree[ll(ind)].sum + tree[rr(ind)].sum;
        }
    }
}seg;

int main()
{
    int ca = 1;
    int t,n,m;
    int x, y, z;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        seg.buildtree(1, n, 1);


        while (m--)
        {
            scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);
            seg.update(x, y, 1, z);
        }

        printf(&quot;Case %d: The total value of the hook is %d.\n&quot;, ca++, seg.tree[1].sum);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu-1548</title>
    <url>/article/csdn/hdu-1548.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41789939" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41789939</a></p>
<p>搜索做着做着成最短路径了。。</p>
<p>dij</p>
<p>本层可以直接到达的层数距离为1 否则为无穷大</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt;
#include&lt;malloc.h&gt;
#include&lt;stdexcept&gt;

using namespace std;

int n,a,b,m;
int p[210][210];
int q[210];
int d[210];
int vis[210];
int k;

void dij(int s)
{
    for(int i=1;i&lt;=n;i++)
    {
        d[i] = p[s][i];
        vis[i] = 0;
    }

    d[s] = 0;
    vis[s] = 1;

    for(int i=1;i&lt;=n;i++)
    {
        int minn = 10000000;
        k=s;
        for(int j =1;j&lt;=n;j++)
        {
            if (!vis[j] &amp;&amp; d[j] &lt; minn)
            {
                minn = d[j];
                k=j;
            }
        }
        if (minn == 10000000)
            return ;
        vis[k] = 1;

        for(int j=1;j&lt;=n;j++)
        {
            if (!vis[j] &amp;&amp; (minn+p[k][j]) &lt; d[j])
                d[j] = minn + p[k][j];
        }
    }
}

int main ()
{
    while (scanf(&quot;%d %d %d&quot;,&amp;n,&amp;a,&amp;b)!=EOF &amp;&amp; n)
    {
        for(int i=1;i&lt;=n;i++)
        {
            for(int j=1;j&lt;=n;j++)
            {
                if (i!=j)
                    p[i][j] = p[j][i] = 10000000;
                else
                    p[i][j] = 0;
            }
        }

        for(int i=1;i&lt;=n;i++)
        {
            scanf(&quot;%d&quot;,&amp;q[i]);
            if (i + q[i] &lt;=n)
            {
                p[i][q[i]+i] = 1;
            }
            if (i-q[i] &gt;=1)
            {
                p[i][i-q[i]] = 1;
            }
        }
        dij(a);

        int anss = d[b];
        if (anss&lt;10000000)
            cout&lt;&lt;anss&lt;&lt;endl;
        else
            printf(&quot;-1\n&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1754</title>
    <url>/article/csdn/hdu-1754.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40592971" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40592971</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1166" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1166
</a>  </p>
<p>代码风格更新后：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;vector&gt;

#define Mid(a,b) ( a+((b-a)&gt;&gt;1))
#define ll(x) (x&lt;&lt;1)
#define rr(x) (x&lt;&lt;1|1)

const int N = 200010;

using namespace std;

int m,n;

int a[N];

struct node
{
    int left;
    int right;
    int sum;
    int mid() { return Mid(left, right); }
};

struct segtree
{
    node tree[N * 4];

    void buildtree(int left,int right,int ind)
    {
        tree[ind].left = left;
        tree[ind].right = right;
        tree[ind].sum = 0;

        if (left == right)
            tree[ind].sum = a[left];
        else
        {
            int mid = tree[ind].mid();

            buildtree(left,mid,ll(ind));
            buildtree(mid+1,right,rr(ind));

            tree[ind].sum = max(tree[ll(ind)].sum , tree[rr(ind)].sum);
        }
    }

    void update(int pos,int ind,int val)
    {
        if (tree[ind].left == tree[ind].right) tree[ind].sum = val;
        else
        {
            int mid = tree[ind].mid();

            if (pos &lt;= mid)
                update(pos,ll(ind),val);
            else
                update(pos,rr(ind),val);

            tree[ind].sum = max(tree[ll(ind)].sum , tree[rr(ind)].sum);
        }
    }

    int query(int st ,int ed,int ind)
    {
        int left = tree[ind].left;
        int right = tree[ind].right;

        if (st &lt;= left &amp;&amp; right &lt;= ed)
            return tree[ind].sum;

        else
        {
            int mid = tree[ind].mid();
            int sum1 = 0;
            int sum2 = 0;
            if (st &lt;= mid)
                sum1 = query(st,ed,ll(ind));
            if (ed &gt; mid)
                sum2 = query(st,ed,rr(ind));

            return max(sum1 , sum2);
        }
    }
}seg;

int main()
{
    while (scanf(&quot;%d %d&quot;,&amp;n,&amp;m)!=EOF)
    {
        for (int i = 1; i &lt;= n; i++)
            scanf(&quot;%d&quot;,&amp;a[i]);

        seg.buildtree(1,n,1);

        char opr[10];
        int c, d;
        while (m--)
        {
            scanf(&quot;%s&quot;,opr);
            scanf(&quot;%d %d&quot;,&amp;c,&amp;d);
            if (opr[0] == &#39;Q&#39;)
            {
                printf(&quot;%d\n&quot;, seg.query(c, d, 1));
            }
            else if (opr[0] == &#39;U&#39;)
            {
                seg.update(c,1,d);
            }
        }
    }
    return 0;
}
</code></pre><p>之前</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include &lt;sstream&gt;
#include &lt;time.h&gt;
#include &lt;utility&gt; 
#include &lt;malloc.h&gt; 

using namespace std;

int max (int a,int b)
{
    if (a&gt;=b)
        return a;
    else 
        return b;
}

struct node
{
    int left ;
    int right;
    int sum;
}b[5001000];

int a[5000100];

void build1(int left ,int right ,int i)//建立二叉树（用于求和）
{
    int mid;
    b[i].left =left;
    b[i].right =right ;
    if (left == right )
    {
        b[i].sum=a[left];
        return ;
    }

    mid = (left + right )/2;
    build1(left ,mid,2*i);
    build1( mid+1,right ,2*i+1);
    b[i].sum=b[i*2].sum+b[i*2+1].sum;
}

void build2(int left , int right , int i)//建立二叉树 （RMQ）
{
    int mid;
    b[i].left=left;
    b[i].right=right;
    if(left==right)
    {
        b[i].sum=a[left];
        return ;
    }

    mid=(left+right)/2;
    build2(left,mid,2*i);
    build2(mid+1,right,2*i+1);
    b[i].sum=max(b[2*i].sum , b[2*i+1].sum);

}

void add (int id,int num,int i)//加(减)节点id值num
{
    if(b[i].left == b[i].right )
    {
        b[i].sum += num;
        return ;
    }
    else 
    {
        b[i].sum=b[i].sum+num;
        if (id&lt;= b[i*2].right )
            add (id,num,i*2);
        else
            add (id,num,i*2+1);
    }
}

int query (int left,int right ,int i)//求和 left to right
{
    int mid;
    if (b[i].right  == right &amp;&amp; b[i].left ==left )
    return b[i].sum ;

    mid=(b[i].left +b[i].right )/2;    
    if (right &lt;= mid)
        return query (left ,right,2*i);
    else if (left &gt; mid)
        return query (left ,right,2*i+1);
    else
        return query (left ,mid,2*i)+query (mid+1 ,right,2*i+1);
}

int Query(int left, int right,int i)//求最值
{
    int mid;
    if(b[i].left==left &amp;&amp; b[i].right ==right) 
        return b[i].sum;
    mid=(b[i].left+b[i].right)/2;
    if(right&lt;=mid) 
        return Query(left,right,2*i);
    if (left&gt;mid ) 
        return Query(left,right,2*i+1);
    if(left&lt;=mid &amp;&amp; mid&lt;right)
        return max(Query(left,mid,2*i) , Query(mid+1,right,2*i+1));
}



void  Update(int id,int value,int i)//更新节点id值为value
{
    if(b[i].left==b[i].right)
    {
        b[i].sum=value;
        return ;
    }


        int mid =(b[i].left+b[i].right)/2;
        if(mid&gt;=id) 
            Update(id,value,2*i);
        if(id&gt;mid) 
            Update(id ,value,2*i+1);
        b[i].sum=max(b[i*2].sum , b[2*i+1].sum);//注意更新的时候不仅更新子节点，还要更新父节点

}


int main()
{
    int  n,m;
    while ( scanf  (&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF )
    {
        for (int i=1;i&lt;=n;i++)
            scanf (&quot;%d&quot;,&amp;a[i]);

        build2(1,n,1);

        char ss[10];
        int c,d;
        for (int i=0;i&lt;m;i++)
        {
            scanf (&quot;%s&quot;,ss);
            scanf (&quot;%d%d&quot;,&amp;c,&amp;d);
            if (strcmp (ss,&quot;Q&quot;) == 0)
            {
                printf(&quot;%d\n&quot;,Query (c,d,1));
            }
            else
            {
                Update (c,d,1);
            }
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1874</title>
    <url>/article/csdn/hdu-1874.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41092517" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41092517</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1874" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1874
</a></p>
<p>floyd算法就能解决</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;time.h&gt;

using namespace std;

int d[1110][1110];

int main ()    
{
    int n,m;
    while (scanf (&quot;%d %d&quot;,&amp;n,&amp;m)!=EOF)
    {
        for (int i=0;i&lt;n;i++)
            for (int j=0;j&lt;n;j++)
            {
                if (i==j)
                    d[i][j]=0;
                else 
                    d[i][j]=1000010;
            }

        int a,b,c;
        for (int i=0;i&lt;m;i++)
        {
            scanf (&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
            if (d[a][b]&gt;c)
            {
                d[a][b]=d[b][a]=c;
            }
        }

        for (int k=0;k&lt;n;k++)
            for (int i=0;i&lt;n;i++)
                for (int j=0;j&lt;n;j++)
                {
                    if (  d[i][j] &gt; ( d[i][k]+d[k][j]) )
                        d[i][j] = ( d[i][k]+d[k][j] );
                }

        int start ,end;
        scanf (&quot;%d %d&quot;,&amp;start ,&amp;end);

        if (d[start][end]==1000010)
            printf(&quot;-1\n&quot;);
        else
            printf(&quot;%d\n&quot;,d[start][end]);

    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1856</title>
    <url>/article/csdn/hdu-1856.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40210875" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40210875</a></p>
<p>并查集最大秩</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt; 
#include&lt;malloc.h&gt; 
#include&lt;stdexcept&gt;

using namespace std;

int p[10000010];
int r[10000010];
int maxx ;

int find(int x)
{
    if (x==p[x])
        return x;
    else
        return find ( p[x] );
}

void un (int a,int b)
{
    int fa = find (p[a]);
    int fb = find (p[b]);
    if(fa == fb )
        return ;

    if (r[fa]&gt;r[fb])
        {
            p[fb]=fa;
            r[fa]+=r[fb];
            if (maxx &lt; r[fa] )
                maxx = r[fa];
        }
    else
        {
            p[fa]=fb;
            r[fb]+=r[fa];
            if(maxx &lt; r[fb])
                maxx = r[fb];
        }

}

int main ()
{
    int m;
    while (scanf (&quot;%d&quot;,&amp;m) != EOF )
    {
        for (int i=1;i&lt;=10000000;i++)
        {
            p[i]=i;
            r[i]=1;
        }
        int a,b;
        maxx = 1;

        for (int i=0;i&lt;m;i++)
        {
            scanf (&quot;%d%d&quot;,&amp;a,&amp;b);
            un(a,b);
        }

        printf(&quot;%d\n&quot;,maxx);

    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1789</title>
    <url>/article/csdn/hdu-1789.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40587325" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40587325</a></p>
<p>贪心算法，把作业按照分值大到小排序，如果能完成作业，则记录其完成时间，不能完成，扣分。</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;stack&gt;

using namespace std;

struct q
{
    int time ;
    int grade;
}p[10010];

int m[10010];

bool cmp (q a ,q b)
{
    return a.grade&gt;b.grade;
}

int main()
{
    int t,n;
    scanf (&quot;%d&quot;,&amp;t);
    while (t--)
    {
        memset (m,0,sizeof (m));
        scanf (&quot;%d&quot;,&amp;n);
        for (int i =1 ;i&lt;=n;i++)
            scanf (&quot;%d&quot;,&amp;p[i].time);
        for (int i =1 ;i&lt;=n;i++)
            scanf (&quot;%d&quot;,&amp;p[i].grade);
        sort (p+1,p+1+n,cmp);

        int ans = 0;
        int day = n;
        for (int i =1 ;i&lt;=n;i++)
        {
            int j;
            for ( j = p[i].time;j&gt;=1;j--)
            {
                if (!m[j])
                {
                    m[j]=1;
                    break;
                }
            }
            if (j==0)
                ans += p[i].grade;
        }
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-2059</title>
    <url>/article/csdn/hdu-2059.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40818459" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40818459</a></p>
<p>在没学算法之前就做过这道题 ，当时不会做，也不知道动态规划算法，最近在做DP入门，碰到这个题，感觉AC萌萌哒。</p>
<pre><code>本题的主要思路：先考虑可能在任意一个加油站作为乌龟最后加油的地方。。。然后利用第推的思想卒个求和。。。。比如乌龟可能把第二个加油站作为最后加油的地点。。。由此我们需要依次求出把原点作为前一个加油站到第二个加油站的时间和把第一个加油站作为前一个加油站到第二加油站的时间。。。然后比较两种路径所用时间的多少求出把第二个作为最后加油站所用的最短时间。。。以此类推。。。以后各种情况均可由此法求得。。。。





#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;

using namespace std;

int l,n,c,t,vr,v1,v2;
int p[110];

double dp[110];

int main ()
{
    while (scanf (&quot;%d%d%d%d%d%d%d&quot;,&amp;l,&amp;n,&amp;c,&amp;t,&amp;vr,&amp;v1,&amp;v2)!=EOF)
    {
        for (int i=1 ;i&lt;=n;i++)
            scanf (&quot;%d&quot;,&amp;p[i]);

        p[0]=0;
        p[n+1]=l;
        dp[0]=0.0;

        /*for (int i=2 ;i&lt;=n;i++)
        {
            dp[i] = min ( dp[i-1] +( p[i] - p[i-1])*1.0/v2*1.0,dp[i-1] + (p[i] - p[i-1])*1.0/v1 + t*1.0 );
        }
        */
        for (int i =1 ;i&lt;=n+1;i++)
        {
            dp[i]=1000000;
            for (int j =0 ;j&lt;i;j++)
            {
                double tmp;
                double len = (p[i] - p[j])*1.0;
                if ( len &gt;= c )
                    tmp = c*1.0/v1 + (len - c)*1.0/v2;
                else
                    tmp = len*1.0/v1 ;
                if (j)
                    tmp+=t;
                dp[i] = min( dp[i],dp[j]+tmp);
            }
        }
        double t1 = l*1.0 / vr;
        if (t1 &gt; dp[n+1])
            printf(&quot;What a pity rabbit!\n&quot;);
        else
            printf(&quot;Good job,rabbit!\n&quot;);

    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-2102</title>
    <url>/article/csdn/hdu-2102.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41554129" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41554129</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2102" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=2102
</a></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;sstream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;

using namespace std;

struct pp
{
    int w,x,y;
    char r;
    int t ;
}p[3][12][12];

int vis[3][12][12];
int n,m,t,ca,ok;
int dir[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};

void bfs( int w,int x,int y )
{
    memset (vis,0,sizeof(vis));
    queue&lt;pp&gt; q;
    pp qq ;pp qqq;

    q.push( p[w][x][y] );
    p[w][x][y].t=0;
    vis[w][x][y] = 1;

    while ( !q.empty() )
    {
        qq = q.front();
        q.pop();

        if (qq.r == &#39;P&#39; )
        {
            if(qq.t &lt;= t)
                ok = 1;
            return ;
        }

        for(int i=0;i&lt;4;i++)
        {
            if (qq.x + dir[i][0] &gt;= 0 &amp;&amp; qq.x + dir[i][0] &lt; n &amp;&amp; qq.y + dir[i][1]&gt;= 0  &amp;&amp; qq.y + dir[i][1] &lt; m )
            {
                qqq = p[qq.w][ qq.x + dir[i][0] ][ qq.y + dir[i][1] ];

                if ( qqq.r == &#39;#&#39; &amp;&amp; !vis[qqq.w][qqq.x][qqq.y] )
                {
                    if (p[!qqq.w][qqq.x][qqq.y].r != &#39;*&#39; &amp;&amp; p[!qqq.w][qqq.x][qqq.y].r != &#39;#&#39; &amp;&amp; !vis[!qqq.w][qqq.x][qqq.y] )
                    {
                        vis[!qqq.w][qqq.x][qqq.y]=1;
                        qqq = p[!qqq.w][qqq.x][qqq.y];
                        qqq.t = qq.t+1;
                        q.push(qqq);
                    }

                }
                else if (qqq.r != &#39;*&#39; &amp;&amp; !vis[qqq.w][qqq.x][qqq.y] )
                {
                    vis[qqq.w][qqq.x][qqq.y]=1;
                    qqq.t = qq.t+1;
                    q.push(qqq);
                }
            }
        }

    }
}


int main ()
{
    cin&gt;&gt;ca;
    while (ca--)
    {
        cin&gt;&gt;n&gt;&gt;m&gt;&gt;t;

        for(int k=0;k&lt;2;k++)
            for(int i=0;i&lt;n;i++)
                for(int j=0;j&lt;m;j++)
                {
                    cin&gt;&gt;p[k][i][j].r;
                    p[k][i][j].w = k;
                    p[k][i][j].x = i;
                    p[k][i][j].y = j;
                }
        ok = 0;
        bfs(0,0,0);
        if (ok)
            cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;
        else 
            cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1829 &amp; poj-2492 并查集</title>
    <url>/article/csdn/hdu-1829_&amp;_poj-2492_%E5%B9%B6%E6%9F%A5%E9%9B%86.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/42870669" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/42870669</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1829" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1829
</a></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;iomanip&gt;

using namespace std;

int t, n, m;
int fa[2200];
int sex[2200];//sex[i]=j 表示i与j性别相反
int a, b;
int ok;

int findd(int x)
{
    if (x == fa[x])
        return x;
    else
        return findd(fa[x]);
}

void un(int x, int y)
{
    int fx = findd(x);
    int fy = findd(y);

    if (fx == fy)//同性的
    {
        return;
    }
    else
    {
        if (fy &gt; fx)
            fa[fy] = fx;
        else 
            fa[fx] = fy;
    }
}

int cases = 1;

int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        ok = 1;
        scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
        {
            for (int i = 1; i &lt;= n; i++)
            {
                fa[i] = i;    
            }
            memset(sex,0,sizeof(sex));

            for (int i = 1; i &lt;= m;i++)
            {
                scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
                if (!ok)
                    continue;
                if (findd(a) == findd(b))//同性的
                {
                    ok = 0;
                    continue;
                }

                if (sex[a] == 0)
                {
                    sex[a] = b;
                }
                else
                {
                    un(sex[a], b);
                }

                if (sex[b] == 0)
                {
                    sex[b] = a;
                }
                else
                {
                    un(sex[b], a);
                }
            }
        }

        if (!ok)
        {
            printf(&quot;Scenario #%d:\n&quot;,cases++);
            puts(&quot;Suspicious bugs found!&quot;);
            printf(&quot;\n&quot;);
        }
        else
        {
            printf(&quot;Scenario #%d:\n&quot;,cases++);
            puts(&quot;No suspicious bugs found!&quot;);
            printf(&quot;\n&quot;);
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-1875</title>
    <url>/article/csdn/hdu-1875.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40325685" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40325685</a></p>
<p>最小生成树 注意浮点型 ：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#define N 1100

using namespace std;

double  p[110][110];
double  low[1000];
int vis[1000];

int n;

struct qq
{
    int x;
    int y;
}q[10000];

double getdis (qq a, qq b)
{
    return (  double (a.x*1.0-b.x*1.0)*(a.x*1.0-b.x*1.0)  + (a.y*1.0-b.y*1.0)*(a.y*1.0-b.y*1.0) ) ;
}

double  prim ()
{
    int i,j,pos;
    double res,min;
    memset (vis,0,sizeof (vis));
    res=0;
    pos=1;vis[1]=1;

    for (int i=1;i&lt;=n;i++)
    {
        if (i!=pos)
            low[i]= p[i][pos];
    }
    for (int j=1 ;j&lt;n;j++)
    {
        min = 1000000;
        for (int i=1;i&lt;=n;i++)
        {
            if (!vis [i] &amp;&amp; min &gt; low[i] )
            {
                pos =i;
                min = low[i];
            }
        }
        if (min == 1000000)
            return -1;
        res+=min;
        vis[pos]=1;

        for (int i=1;i&lt;=n;i++)
        {
            if (!vis[i] &amp;&amp; low[i] &gt; p[i][pos])
            {
                low[i]= p[i][pos];
            }
        }
    }
    return res*100;
}

int main ()
{
    int t;
    cin &gt;&gt;t;
    while (t--)
    {
        cin &gt;&gt;n;
        for (int i=1;i&lt;=n;i++)
        {
            cin&gt;&gt;q[i].x&gt;&gt;q[i].y;
        }

        for (int i=1;i&lt;=n;i++)
            for (int j=1;j&lt;=n;j++)
        {
            if (i!=j)
                p[i][j] = 10000000;
            else
                p[i][j]=0;
        }

        for (int i=1;i&lt;=n;i++)
            for (int j=1;j&lt;=n;j++)
        {
            if (getdis(q[i],q[j]) &gt;=10*10 &amp;&amp; getdis(q[i],q[j])&lt;= 1000*1000)
            {
                p[i][j] = sqrt( 1.0*getdis(q[i],q[j]) ) ;
            }
        }
        if ( prim() == -1)
            printf(&quot;oh!\n&quot;);
        else
            printf(&quot;%0.1f\n&quot;,prim());
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-2063 二分图</title>
    <url>/article/csdn/hdu-2063_%E4%BA%8C%E5%88%86%E5%9B%BE.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41421077" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41421077</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2063" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=2063
</a></p>
<h1><span id="过山车">过山车</span></h1><p><strong> Time Limit: 1000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 11731    Accepted Submission(s): 5151  
</strong>  </p>
<p>Problem Description</p>
<p>RPG<br>girls今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。可是，过山车的每一排只有两个座位，而且还有条不成文的规矩，就是每个女生必须找个个男生做partner和她同坐。但是，每个女孩都有各自的想法，举个例子把，Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner。考虑到经费问题，boss刘决定只让找到partner的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。聪明的Acmer，你可以帮忙算算最多有多少对组合可以坐上过山车吗？</p>
<p>Input</p>
<p>输入数据的第一行是三个整数K , M , N，分别表示可能的组合数目，女生的人数，男生的人数。0 &lt;K&lt;=1000<br>1&lt;=N 和M&lt;=500.接下来的K行，每行有两个数，分别表示女生Ai愿意和男生Bj做partner。最后一个0结束输入。</p>
<p>Output</p>
<p>对于每组数据，输出一个整数，表示可以坐上过山车的最多组合数。</p>
<p>Sample Input</p>
<p>6 3 3 1 1 1 2 1 3 2 1 2 3 3 1 0</p>
<p>Sample Output</p>
<p>3</p>
<p>一天不AC 智商不如猪</p>
<p>今天学的二分图 ac了这个很久之前就见到的题</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;sstream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;

using namespace std;

int n,m,k;
int p[1000][1000];
int book[1000];
int match[1000];
int t,tt;
int a,b;

int dfs(int u)
{
    int i;
    for(i=1;i&lt;=k;i++)
    {
        if(book[i]==0 &amp;&amp; p[u][i] == 1)
        {
            book[i] = 1;
            if(match[i] == 0 || dfs(match[i]))
            {
                match[i]=u;
                return 1;
            }
        }
    }
    return 0;
}


int main()
{
    while (cin&gt;&gt;n &amp;&amp; n!=0)
    {
        cin&gt;&gt;m&gt;&gt;k;

        int ans = 0;
        memset(match,0,sizeof(match));
        memset(p,0,sizeof(p));

        for(int i=1;i&lt;=n;i++)
        {
            cin&gt;&gt;a&gt;&gt;b;
            p[a][b] = 1;
        }

        for(int i=1;i&lt;=m;i++)
        {
            memset(book,0,sizeof(book));
            if( dfs(i) )
                ans ++;
        }
        cout&lt;&lt;ans&lt;&lt;endl;
    }

    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu-2087 剪花布条 【kmp】</title>
    <url>/article/csdn/hdu-2087_%E5%89%AA%E8%8A%B1%E5%B8%83%E6%9D%A1_%E3%80%90kmp%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44105315" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44105315</a></p>
<h1><span id="剪花布条">剪花布条</span></h1><p><strong> Time Limit: 1000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 10026    Accepted Submission(s): 6482  
</strong>  </p>
<p>Problem Description</p>
<p>一块花布条，里面有些图案，另有一块直接可用的小饰条，里面也有一些图案。对于给定的花布条和小饰条，计算一下能从花布条中尽可能剪出几块小饰条来呢？  </p>
<p>Input</p>
<p>输入中含有一些数据，分别是成对出现的花布条和小饰条，其布条都是用可见ASCII字符表示的，可见的ASCII字符有多少个，布条的花纹也有多少种花样。花纹条和小饰条不会超过1000个字符长。如果遇见#字符，则不再进行工作。  </p>
<p>Output</p>
<p>输出能从花纹布中剪出的最多小饰条个数，如果一块都没有，那就老老实实输出0，每个结果之间应换行。  </p>
<p>Sample Input</p>
<p>abcde a3 aaaaaa aa #</p>
<p>Sample Output</p>
<p>0 3</p>
<p>Author</p>
<p>qianneng</p>
<p>Source</p>
<p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=%B6%AC%C1%B7%C8%FD%BE%C5%D6%AE%B6%FE&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener"> 冬练三九之二
</a></p>
<p>母串最多可分出几个字串</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;malloc.h&gt;

using namespace std;

char a[100000500], b[10005000];
int Next[10005000], ans;

void get_next(char b[], int m)
{
    int i = 0;
    Next[0] = -1;
    int j = -1;
    while (i&lt;m)
    {
        if (j == -1 || b[i] == b[j])
        {
            ++i;
            ++j;
            if (b[i] == b[j])
                Next[i] = Next[j];
            else
                Next[i] = j;
        }
        else
            j = Next[j];
    }
}
int KMP(char a[], int n, char b[], int m, int Next[], int pos)
{
    int i = pos;
    int j = 0;
    while (i&lt;n&amp;&amp;j&lt;m)
    {
        if (j == -1 || a[i] == b[j])
        {
            ++i;
            ++j;
        }
        else
            j = Next[j];
        if (j == m)
        {
            ans++;
            j = Next[j];
            i += j;
        }
    }
    return ans;

}
int main()
{
    int test, n, m, i, j;
    while (scanf(&quot;%s&quot;, a)!=EOF &amp;&amp; a[0] != &#39;#&#39;)
    {
        scanf(&quot;%s&quot;,b);
        ans = 0;
        n = strlen(a);
        m = strlen(b);
        get_next(b,m);
        KMP(a,n,b,m,Next,0);
        printf(&quot;%d\n&quot;,ans);
    }
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-2120</title>
    <url>/article/csdn/hdu-2120.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40210063" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40210063</a></p>
<p>并查集判环：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt; 
#include&lt;malloc.h&gt; 
#include&lt;stdexcept&gt;

using namespace std;

int n,m;
int p[1000000];
int num;

int find (int x)
{
    if (x == p[x])
        return x ;
    else return find (p[x]); 

}

void un(int a ,int b)
{
    int fa = find (a);
    int fb = find (b);
    if (fa==fb)
    {
        num++;
        return ;

    }
    else
    {
        if (fa&gt;fb)
            p[fa]=fb;
        else 
            p[fb]=fa;
    }
}

int main ()
{
    int n,m;

    while (scanf (&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF )
    {
        num=0;
        for (int i=0;i&lt;n;i++)
            p[i]=i;
        int a,b;
        for (int i=0;i&lt;m;i++)
        {
            scanf (&quot;%d%d&quot;,&amp;a,&amp;b);
            un(a,b);
        }

        printf(&quot;%d\n&quot;,num);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-2544</title>
    <url>/article/csdn/hdu-2544.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41092657" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41092657</a></p>
<p>floyd</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;time.h&gt;

using namespace std;

int d[1010][1010];

int main ()    
{
    int n,m;
    while (scanf (&quot;%d %d&quot;,&amp;n,&amp;m)!=EOF &amp;&amp; n)
    {
        for (int i=0;i&lt;=n;i++)
            for (int j=0;j&lt;=n;j++)
            {
                d[i][j]=1000001;
            }

        int a,b,c;

        for (int i=0;i&lt;m;i++)
        {
            scanf (&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
            d[a][b]=d[b][a]=c;
        }

        for (int k=1;k&lt;=n;k++)
            for (int i=1;i&lt;=n;i++)
                for (int j=1;j&lt;=n;j++)
                {
                    if (  d[i][j] &gt; ( d[i][k]+d[k][j]) )
                        d[i][j] = ( d[i][k]+d[k][j] );
                }

        printf (&quot;%d\n&quot;,d[1][n]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-2181</title>
    <url>/article/csdn/hdu-2181.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41547775" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41547775</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2181" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=2181
</a></p>
<p>dfs的应用</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;sstream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;

using namespace std;

int m;
int p[25][5];
int res[30];
int vis[30];
int ca = 1;

void dfs(int m,int len,int c)
{
    res[len] = m;
    vis[m]=1;
    for(int i=0;i&lt;3;i++)
    {
        int temp = p[m][i];
        if (temp == c &amp;&amp; len ==19)
        {
            cout&lt;&lt;ca++&lt;&lt;&quot;:  &quot;;
            for(int i=0;i&lt;=19;i++)
                cout&lt;&lt;res[i]&lt;&lt;&quot; &quot;;
            cout&lt;&lt;c&lt;&lt;endl;
        }
        if (!vis[temp])
            dfs(temp,len+1,c);
    }
    vis[m]=0;
}


int main ()
{
    for(int i=1;i&lt;=20;i++)
    {
        cin&gt;&gt;p[i][0];
        cin&gt;&gt;p[i][1];
        cin&gt;&gt;p[i][2];
    }
    while (cin&gt;&gt;m &amp;&amp; m!=0)
    {
        memset(vis,0,sizeof(vis));
        dfs (m,0,m);
    }

    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-2545</title>
    <url>/article/csdn/hdu-2545.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40535341" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40535341</a></p>
<p>并查集的扩展应用，求节点到根的距离</p>
<pre><code>//求节点到根的距离
//r[i]存储节点 i 到根的距离

#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;stdlib.h&gt;

using namespace std;

int p[100010];
int r[100010];

int findd (int x)
{
    int ans=0;
    while (x != p[x])
    {
        ans++;
        x=p[x];
    }
    return ans;
}

void un(int a ,int b)
{
    p[b]=a;
}

int main ()
{
    int n,m;
    int b,c;
    while (scanf (&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)
    {
        if (n==0 &amp;&amp; m==0)
            break;
        for (int i =0;i&lt;=n;i++)
        {
            p[i]=i;
            r[i]=0;
        }

        for (int i =1;i&lt;n;i++)
        {
            scanf (&quot;%d%d&quot;,&amp;b,&amp;c);
            un(b,c);
        }

        for (int i =1;i&lt;=m;i++)
        {
            scanf(&quot;%d %d&quot;,&amp;b,&amp;c);

            int t1=findd(b);
            int t2=findd(c);

            if (t1 &lt;= t2)
                printf(&quot;lxh\n&quot;);
            else
                printf(&quot;pfz\n&quot;);
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-2821</title>
    <url>/article/csdn/hdu-2821.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41595391" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41595391</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2821" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=2821
</a></p>
<p>不要被题目吓到 ，认真读题还是好理解的</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;

using namespace std;

int n,m;
int p[30][30];
char c;
int num = 0,ok;

int dir[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};
char dirc[5] = {&#39;U&#39;,&#39;D&#39;,&#39;L&#39;,&#39;R&#39;};

char step[1000];
char str[33];

int check (int x,int y)
{
    if (x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n)
        return 1;
    return 0;
}

int dfs (int x,int y,int s)
{
    if (s &gt;= num)
    {
        step[s]=0;
        return 1;
    }

    for(int i =0;i&lt;4;i++)
    {
        int xx = x + dir[i][0];
        int yy = y + dir[i][1];

        if ( p[ xx ][ yy ] !=0 || !check ( xx ,yy ) )
            continue;

        while (  p[ xx ][ yy  ] == 0 &amp;&amp; check ( xx ,yy ))
        {
            xx+=dir[i][0];
            yy+=dir[i][1];
        }

        if (!check(xx+dir[i][0] ,yy+dir[i][1] ))
            continue;

        int tmp = p[xx][yy];

        p[xx+dir[i][0]][yy+dir[i][1]] += (tmp-1);
        p[xx][yy] =0;

        step[s] = dirc[i];

        if ( dfs(xx,yy,s+1) )
            return 1;

        p[xx+dir[i][0]][yy+dir[i][1]] -= (tmp-1);
        p[xx][yy] = tmp;
    }
    return 0;
}


int main ()
{
    while (cin&gt;&gt;n&gt;&gt;m)
    {
        num = 0;

        for(int i=0;i&lt;m;i++)
        {
            scanf(&quot;%s&quot;,str);
            for(int j=0;j&lt;n;j++)
            {
                if(str[j]!=&#39;.&#39;)
                {
                    num += str[j]-&#39;a&#39;+1;
                    p[i][j]=str[j]-&#39;a&#39;+1;
                }
                else 
                    p[i][j]=0;
            }
         }


        ok = 0;

        for(int i=0;i&lt;m;i++)
        {
                for(int j=0;j&lt;n;j++)
                {
                    if (!p[i][j] &amp;&amp; dfs(i,j,0) )
                    {
                        ok = 1;
                        cout&lt;&lt;i&lt;&lt;endl;
                        cout&lt;&lt;j&lt;&lt;endl;
                        cout&lt;&lt;step&lt;&lt;endl;
                        break;
                    }
                }
            if (ok)
                break;
        }

    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-2571</title>
    <url>/article/csdn/hdu-2571.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40474639" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40474639</a></p>
<p>入门的DP 可是我更入门…</p>
<p>根据题目要求，<br>只能向右或者向下走，向下一次只能走一格。但是如果向右走，则每次可以走一格或者走到该行的列数是当前所在列数倍数的格子，即：如果当前格子是（x,y），下一步可以是（x+1,y），(x,y+1)或者(x,y*k)<br>其中k&gt;1。</p>
<p>由于幸运值可能为负值，所以初始化dp数组为负数</p>
<pre><code>#include &lt;algorithm&gt;
#include &lt;string.h&gt;
#include &lt;sstream&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;
#include&lt;bitset&gt;

using namespace std;

int p[25][1010];
int dp[25][1010];

int main()
{
    int t;
    scanf (&quot;%d&quot;,&amp;t);
    while (t--)
    {
        int n,m;
        scanf (&quot;%d%d&quot;,&amp;n,&amp;m);
        for (int i=1;i&lt;=n;i++)
            for (int j =1;j&lt;=m;j++)
            scanf(&quot;%d&quot;,&amp;p[i][j]);

        for (int i=0;i&lt;=n;i++)
            for (int j =0;j&lt;=m;j++)
                dp[i][j]=-99999999;

        dp[1][0]=dp[0][1]=0;

        for (int i =1;i&lt;=n;i++)
            for (int j=1;j&lt;=m;j++)
        {
            dp[i][j]=max( dp[i-1][j],dp[i][j-1] );
            for (int k=2;k&lt;=j;k++)
            {
                if (j%k==0)
                dp[i][j]=max(dp[i][j],dp[i][j/k]);
            }
            dp[i][j]+=p[i][j];
        }
        printf(&quot;%d\n&quot;,dp[n][m]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-2612 两次bfs</title>
    <url>/article/csdn/hdu-2612_%E4%B8%A4%E6%AC%A1bfs.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/42319323" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/42319323</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2612" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=2612
</a></p>
<p>两次bfs， 记录到每个KFC的最短时间。选取最短时间。  </p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;vector&gt;

using namespace std;

int n, m;

int dir[4][2] = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };

int check(int x, int y)
{
    if (x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m)
        return 1;
    return 0;
}

struct node
{
    int x;
    int y;
    int t1, t2;
    char c;
}p[210][210];

int vis[210][210];
int sx, sy;
int ex, ey;

void bfs(int x,int y)
{
    memset(vis,0,sizeof(vis)); 
    queue&lt;node&gt; q;
    node qq, qqq;
    qq.x = x;
    qq.y = y;
    qq.t1 = 0;
    p[x][y].t1 = 0;
    vis[x][y] = 1;
    q.push(qq);

    while (!q.empty())
    {
        qq = q.front();
        q.pop();

        for (int i = 0; i &lt; 4; i++)
        {
            int x = qq.x + dir[i][0];
            int y = qq.y + dir[i][1];
            if (!check(x, y) || vis[x][y] || p[x][y].c == &#39;#&#39;)
                continue;

            vis[x][y] = 1;

            qqq.x = x;
            qqq.y = y;
            qqq.t1 = qq.t1 + 1; 
            p[x][y].t1 = qqq.t1;
            q.push(qqq);
        }
    }
    return;
}

void bfs1(int x, int y)
{
    memset(vis, 0, sizeof(vis));
    queue&lt;node&gt; q;
    node qq, qqq;
    qq.x = x;
    qq.y = y;
    qq.t2 = 0;
    p[x][y].t2 = 0;
    vis[x][y] = 1;
    q.push(qq);

    while (!q.empty())
    {
        qq = q.front();
        q.pop();

        for (int i = 0; i &lt; 4; i++)
        {
            int x = qq.x + dir[i][0];
            int y = qq.y + dir[i][1];

            if (!check(x, y) || vis[x][y] || p[x][y].c == &#39;#&#39;)
                continue;

            vis[x][y] = 1;

            qqq.x = x;
            qqq.y = y;
            qqq.t2 = qq.t2 + 1;
            p[x][y].t2 = qqq.t2;
            q.push(qqq);
        }
    }
    return;
}

int main()
{
    while (cin &gt;&gt; n &gt;&gt; m)
    {
        getchar();
        for (int i = 1; i &lt;= n; i++)
        {
            for (int j = 1; j &lt;= m; j++)
            {
                cin &gt;&gt; p[i][j].c;
                if (p[i][j].c == &#39;Y&#39;)
                {
                    sx = i;
                    sy = j;
                }
                if (p[i][j].c == &#39;M&#39;)
                {
                    ex = i;
                    ey = j;
                }
            }
            getchar();
        }

        bfs(sx,sy);
        bfs1(ex,ey);

        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= m; j++)
            {
                if (p[i][j].c == &#39;@&#39;)
                {
                    p[i][j].t1 = (p[i][j].t1+p[i][j].t2);
                }
            }
        int ans = 10000000;

        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= m; j++)
            {
                if (p[i][j].c == &#39;@&#39;)
                {
                    ans = min(p[i][j].t1, ans);
                }
            }

        ans *= 11;
        cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-2715 Billboard</title>
    <url>/article/csdn/hdu-2715_Billboard.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/42378821" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/42378821</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2795" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=2795
</a></p>
<p>转：</p>
<p>题意：有一块板，规格为h<em>w，然后有n张海报，每张海报的规格为1</em>wi，选择贴海报的位置是：尽量高，同一高度，选择尽量靠左的地方。要求输出每张海报的高度位置。</p>
<p>因为最多只有二十万张海报，所以板的最大的长度不会超过二十万，但是要小心，如果板的长度小于h，我们还要用h来建树。起初在查询的时候并不直接去更新它，而是查询找出它的更新位置的后，再写个updata函数去更新，但是我们可以在查询到它的位置的时候，同时去更新当前点的剩余长度，然后回溯更新所有祖先区间。返回它的查询位置的时候，因为左儿子找到的位置是pos1，右儿子找到的位置是pos2，两者都赋初值为0，又因为每次查询只找出一个位置，也就是说pos1和pos2中只有一个被改变，另一个仍保持0，所以返回pos1+pos2是正确的。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;

#define LL(x) (x&lt;&lt;1)
#define RR(x) (x&lt;&lt;1|1)
#define MID(a,b) (a+((b-a)&gt;&gt;1))
#define INF (1&lt;&lt;30)

const int N = 200005;

struct node
{
    int lft, rht, mx;
    int mid(){ return MID(lft, rht); }
};

int y[N], n, w, h;

struct Segtree
{
    node tree[N * 4];
    void build(int lft, int rht, int ind)
    {
        tree[ind].lft = lft;    tree[ind].rht = rht;
        tree[ind].mx = w;

        if (lft != rht)
        {
            int mid = tree[ind].mid();
            build(lft, mid, LL(ind));
            build(mid + 1, rht, RR(ind));
        }
    }
    int updata(int valu, int ind)
    {
        int lft = tree[ind].lft, rht = tree[ind].rht;
        if (lft == rht)
        {
            tree[ind].mx -= valu;
            return lft;
        }
        else
        {
            int pos;
            if (tree[LL(ind)].mx &gt;= valu)
                pos = updata(valu, LL(ind));
            else
                pos = updata(valu, RR(ind));

            tree[ind].mx = max(tree[LL(ind)].mx, tree[RR(ind)].mx);

            return pos;
        }
    }
}seg;

int main()
{
    while (scanf(&quot;%d%d%d&quot;, &amp;h, &amp;w, &amp;n) != EOF)
    {
        int tmp;
        seg.build(1,min(N,h),1);

        for (int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;, &amp;tmp);
            if (seg.tree[1].mx &lt; tmp)
                puts(&quot;-1&quot;);
            else
            {
                printf(&quot;%d\n&quot;, seg.updata(tmp, 1));
            }
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-2845</title>
    <url>/article/csdn/hdu-2845.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41080193" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41080193</a></p>
<p><strong>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2845" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=2845
</a> </strong></p>
<p><strong>思路：动态规划</strong></p>
<p><strong>对于一行来说，相邻的数不可同时取，</strong> <strong>容易得到状态转移方程：</strong></p>
<p>dp[i]=max(dp[i-2]+a[i],dp[i-1]); <strong>然后取每一行的最大得b[i] ,又可看作一行相同处理</strong></p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt;
#include&lt;malloc.h&gt;
#include&lt;stdexcept&gt;

using namespace std;

int n,m;

int p[200010];
int q[200010];
int dp[200010];

int main()
{
    while (scanf (&quot;%d %d&quot;,&amp;n,&amp;m)!=EOF)
    {
        for(int i=1 ;i&lt;=n;i++)
        {
            memset(dp,0,sizeof(dp));
            for(int j=1 ;j&lt;=m;j++)
                scanf(&quot;%d&quot;,&amp;p[j]);

            dp[0]=p[0]=0;
            dp[1] = p[1];
            for(int j=2 ;j&lt;=m;j++)
                dp[j] = max ( dp[j-2] + p[j] ,dp[j-1]);

            q[i]= dp[m];
        }

        dp[0] = q[0] =0;
        dp[1] = q[1];
        for(int i=2 ;i&lt;=n;i++)
            dp[i]=max(dp[i-2] + q[i] ,dp[i-1]);

        printf(&quot;%d\n&quot;,dp[n]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-2614</title>
    <url>/article/csdn/hdu-2614.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41791415" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41791415</a></p>
<p>取得第一个是 第一个任务 ，时间0，接着进行下一个任务。</p>
<p><img src="http://static.blog.csdn.net/xheditor/xheditor_emot/default/struggle.gif" alt="奋斗">  </p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt;
#include&lt;malloc.h&gt;
#include&lt;stdexcept&gt;

using namespace std;

int n;
int p[20][20];

int vis[20];
int k;
int ans ;

void dfs (int r,int val,int nu)
{
    k=0;
    for(int i=1;i&lt;=n;i++)
    {
        if (!vis[i] &amp;&amp; (p[r][i] &gt;= val))
        {
            vis[i] = 1;
            dfs(i,p[r][i],nu+1);
            vis[i] = 0;
            k = 1;
        }
    }

    if (!k)
        if (nu &gt; ans)
            ans = nu;

    return ;
}

int main ()
{
    while (scanf(&quot;%d&quot;,&amp;n)!=EOF)
    {
        memset( p,0,sizeof(p) );
        memset(vis,0,sizeof(vis));
        ans = 0;
        for(int i=1;i&lt;=n;i++)
                for(int j=1;j&lt;=n;j++)
                {
                    scanf(&quot; %d&quot;,&amp;p[i][j]);
                }

        vis[1] = 1;
        dfs(1,0,1);

        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu-2859 Phalanx 【dp】</title>
    <url>/article/csdn/hdu-2859_Phalanx_%E3%80%90dp%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44022055" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44022055</a></p>
<h1><span id="phalanx">Phalanx</span></h1><p><strong> Time Limit: 10000/5000 MS (Java/Others)    Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 452    Accepted Submission(s): 219  
</strong>  </p>
<p>Problem Description</p>
<p>Today is army day, but the servicemen are busy with the phalanx for the<br>celebration of the 60th anniversary of the PRC.<br>A phalanx is a matrix of size n<em>n, each element is a character (a~z or A~Z),<br>standing for the military branch of the servicemen on that position.<br>For some special requirement it has to find out the size of the max<br>symmetrical sub-array. And with no doubt, the Central Military Committee gave<br>this task to ALPCs.<br>A symmetrical matrix is such a matrix that it is symmetrical by the “left-down<br>to right-up” line. The element on the corresponding place should be the same.<br>For example, here is a 3</em>3 symmetrical matrix:<br>cbx<br>cpb<br>zcc</p>
<p>Input</p>
<p>There are several test cases in the input file. Each case starts with an<br>integer n (0 &lt;n&lt;=1000), followed by n lines which has n character. There won’t<br>be any blank spaces between characters or the end of line. The input file is<br>ended with a 0.</p>
<p>Output</p>
<p>Each test case output one line, the size of the maximum symmetrical sub-<br>matrix.  </p>
<p>Sample Input</p>
<p>3 abx cyb zca 4 zaba cbab abbc cacq 0</p>
<p>Sample Output</p>
<p>3 3</p>
<p>求每个元素最上方的列和本行的最大对称长度，如果该元素的最大对称长度大于右上角的矩阵，则是右上角矩阵大小的加1，否则就是最大对称长度。</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;

using namespace std;

int n,ans;
char p[1010][1010];
int dp[1010][1010];

int main()
{
    while (cin &gt;&gt; n &amp;&amp; n)
    {
        ans = 1;
        for (int i = 0; i &lt; n; i++)
            cin &gt;&gt; p[i];
        memset(dp,0,sizeof(dp));
        for (int i = 0; i &lt; n; i++)
        {
            for (int j = 0; j &lt; n; j++)
            {
                if (i == 0 || j == n - 1)
                    dp[i][j] = 1;
                else
                {
                    int t1 = i,t2 = j;
                    while (t1 &gt;= 0 &amp;&amp; t2&lt;=n-1 &amp;&amp; p[t1][j] == p[i][t2])
                    {
                        t1--;
                        t2++;
                    }
                    int t = i - t1;
                    if (t&gt;dp[i - 1][j + 1] + 1)
                        dp[i][j] = dp[i - 1][j + 1] + 1;
                    else
                        dp[i][j] = t;
                    ans = max(ans,dp[i][j]);
                }
            }
        }
        cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-4027 Can you answer these queries?</title>
    <url>/article/csdn/hdu-4027_Can_you_answer_these_queries?.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43063261" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43063261</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=4027" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=4027
</a></p>
<p>修改操作是把区间内的所有数开根号</p>
<p>另一个操作是区间求和操作</p>
<p>2  的 63 次开方6,7 根号也就变为了 1 。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;stack&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;map&gt;

using namespace std;

#define ll(ind) (ind&lt;&lt;1)
#define rr(ind) (ind&lt;&lt;1|1)
#define Mid(a,b) (a+((b-a)&gt;&gt;1))
typedef __int64 LL;

const int N = 5020000;

LL a[N];
int n, m, b, c, d;

struct node
{
    int left, right;
    int mid() { return Mid(left, right); }
    LL num;
};

struct segtree
{
    node tree[N * 4];
    void build(int left, int right, int ind)
    {
        tree[ind].left = left;
        tree[ind].right = right;
        tree[ind].num = 0;

        if (left == right)
        {
            tree[ind].num = a[left];
        }
        else
        {
            int mid = tree[ind].mid();
            build(left, mid, ll(ind));
            build(mid + 1, right, rr(ind));
            tree[ind].num = tree[ll(ind)].num + tree[rr(ind)].num;
        }
    }

    void update(int st, int ed, int ind)
    {
        int left = tree[ind].left;
        int right = tree[ind].right;
        if (left == st &amp;&amp; right == ed &amp;&amp; tree[ind].num == (right - left + 1))
            return;
        if (left == right)
        {
            tree[ind].num = sqrt(tree[ind].num * 1.0);
            return;
        }
        int mid = tree[ind].mid();
        if (ed &lt;= mid)
            update(st, ed, ll(ind));
        else if (st &gt; mid)
            update(st, ed, rr(ind));
        else
        {
            update(st, mid, ll(ind));
            update(mid + 1, ed, rr(ind));
        }
        tree[ind].num = tree[ll(ind)].num + tree[rr(ind)].num;
    }

    LL query(int st, int ed, int ind)
    {
        int left = tree[ind].left;
        int right = tree[ind].right;
        if (left == st &amp;&amp; right == ed)
        {
            return tree[ind].num;
        }
        else
        {
            LL ans = 0;
            int mid = tree[ind].mid();
            if (ed &lt;= mid)
                ans = query(st, ed, ll(ind));
            else if (st &gt; mid)
                ans = query(st, ed, rr(ind));
            else
            {
                ans += query(st, mid, ll(ind));
                ans += query(mid + 1, ed, rr(ind));
            }
            return ans;
        }

    }
}seg;

int main()
{
    int cases = 1;
    while (scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        for (int i = 1; i &lt;= n; i++)
            scanf(&quot;%I64d&quot;, &amp;a[i]);
        seg.build(1, n, 1);
        scanf(&quot;%d&quot;, &amp;m);
        printf(&quot;Case #%d:\n&quot;, cases++);
        while (m--)
        {
            scanf(&quot;%d %d %d&quot;, &amp;b, &amp;c, &amp;d);
            if (c &gt; d)//坑
                swap(c, d);
            if (b == 0)
            {
                seg.update(c, d, 1);
            }
            else
            {
                seg.query(c, d, 1);
                printf(&quot;%I64d\n&quot;, seg.query(c, d, 1));
            }
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu-3038 带权并查集</title>
    <url>/article/csdn/hdu-3038_%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43090079" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43090079</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3038" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=3038</a></p>
<p>题意：Ai,Bi,Si 表示 Ai Bi 之间数的和是Si</p>
<p>问与前面命题冲突的命题有几个。</p>
<p>val [ i ]  表示  i 与 fa[ i ]  相差多大 。</p>
<h1><span id="how-many-answers-are-wrong">How Many Answers Are Wrong</span></h1><p>Problem Description</p>
<p>TT and FF are … friends. Uh… very very good friends -<strong>____</strong>-b  </p>
<p>FF is a bad boy, he is always wooing TT to play the following game with him.<br>This is a very humdrum game. To begin with, TT should write down a sequence of<br>integers-_-!!(bored).<br><img src="http://acm.hdu.edu.cn/data/images/exe3038-1.JPG" alt=""><br>Then, FF can choose a continuous subsequence from it(for example the<br>subsequence from the third to the fifth integer inclusively). After that, FF<br>will ask TT what the sum of the subsequence he chose is. The next, TT will<br>answer FF’s question. Then, FF can redo this process. In the end, FF must work<br>out the entire sequence of integers.  </p>
<p>Boring<del>Boring</del>a very very boring game!!! TT doesn’t want to play with FF at<br>all. To punish FF, she often tells FF the wrong answers on purpose.  </p>
<p>The bad boy is not a fool man. FF detects some answers are incompatible. Of<br>course, these contradictions make it difficult to calculate the sequence.  </p>
<p>However, TT is a nice and lovely girl. She doesn’t have the heart to be hard<br>on FF. To save time, she guarantees that the answers are all right if there is<br>no logical mistakes indeed.  </p>
<p>What’s more, if FF finds an answer to be wrong, he will ignore it when judging<br>next answers.  </p>
<p>But there will be so many questions that poor FF can’t make sure whether the<br>current answer is right or wrong in a moment. So he decides to write a program<br>to help him with this matter. The program will receive a series of questions<br>from FF together with the answers FF has received from TT. The aim of this<br>program is to find how many answers are wrong. Only by ignoring the wrong<br>answers can FF work out the entire sequence of integers. Poor FF has no time<br>to do this job. And now he is asking for your help~(Why asking trouble for<br>himself~~Bad boy)  </p>
<p>Input</p>
<p>Line 1: Two integers, N and M (1 &lt;= N &lt;= 200000, 1 &lt;= M &lt;= 40000). Means TT<br>wrote N integers and FF asked her M questions.  </p>
<p>Line 2..M+1: Line i+1 contains three integer: Ai, Bi and Si. Means TT answered<br>FF that the sum from Ai to Bi is Si. It’s guaranteed that 0 &lt; Ai &lt;= Bi &lt;= N.  </p>
<p>You can assume that any sum of subsequence is fit in 32-bit integer.  </p>
<p>Output</p>
<p>A single line with a integer denotes how many answers are wrong.</p>
<p>Sample Input</p>
<p>10 5 1 10 100 7 10 28 1 3 32 4 6 41 6 6 1</p>
<p>Sample Output</p>
<p>1</p>
<pre><code>//带权并查集

#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;

using namespace std;
#define N 200010

int n, m;

int fa[N];
int val[N];

int findd(int x)
{
    if (fa[x] == -1)
        return x;
    int tmp = findd(fa[x]);
    val[x]+=val[fa[x]];
        return fa[x] = tmp;
}

int main()
{
    int a, b, c;
    while (cin &gt;&gt; n &gt;&gt; m)
    {
        memset(fa,-1,sizeof(fa));
        memset (val,0,sizeof(val));
        int ans = 0;
        while (m--)
        {
            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
            a--;
            int fx = findd(a);
            int fy = findd(b);
            if (fx != fy)
            {
                fa[fy] = fx;
                val[fy] = val[a] - val[b] + c;
            }
            else
            {
                if (val[b] - val[a] !=c)
                    ans ++;
            }
        }
        cout&lt;&lt;ans&lt;&lt;endl;
    }
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-5019</title>
    <url>/article/csdn/hdu-5019.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40454323" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40454323</a></p>
<p>第二次做这个题了…</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;stdio.h&gt;

using namespace std;

long long gcd(long long a, long long b)
{
    long long r = a%b;
    while (r)
    {
        a = b;
        b = r;
        r = a%b;
    }
    return b;
}

long long arr[200010] = { 0 };

int main()
{
    int t;
    scanf (&quot;%d&quot;,&amp;t);
    while (t--)
    {
        long long a, b;
        long long  c;
        scanf(&quot;%I64d%I64d%I64d&quot;,&amp;a,&amp;b,&amp;c);
        long long d = gcd(a, b);
        int counter = 0;
        long long  i;

        for (i = 1; i*i &lt;=d ; ++i)
        {
            if (d%i == 0)
            {
                arr[counter++] = i;
                if (i*i!=d)
                {
                    arr[counter++] = d / i;
                }
            }
        }
        sort(arr, arr + counter);

        if (c &gt; counter)
        {
            printf(&quot;-1\n&quot;);
        }
        else
        {
            printf(&quot;%I64d\n&quot;,arr[counter - c]);
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-3068 最长回文 【Manacher算法】</title>
    <url>/article/csdn/hdu-3068_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87_%E3%80%90Manacher%E7%AE%97%E6%B3%95%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44065307" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44065307</a></p>
<p>Manacher算法学习资料： <a href="http://blog.csdn.net/dyx404514/article/details/42061017" target="_blank" rel="noopener"> http://blog.csdn.net/dyx404514/article/details/42061017
</a></p>
<h1><span id="最长回文">最长回文</span></h1><p><strong> Time Limit: 4000/2000 MS (Java/Others)    Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 9282    Accepted Submission(s): 3194  
</strong>  </p>
<p>Problem Description</p>
<p>给出一个只由小写英文字符a,b,c…y,z组成的字符串S,求S中最长回文串的长度.<br>回文就是正反读都是一样的字符串,如aba, abba等</p>
<p>Input</p>
<p>输入有多组case,不超过120组,每组输入为一行小写英文字符a,b,c…y,z组成的字符串S<br>两组case之间由空行隔开(该空行不用处理)<br>字符串长度len  &lt;= 110000</p>
<p>Output</p>
<p>每一行一个整数x,对应一组case,表示该组case的字符串中所包含的最长回文长度.  </p>
<p>Sample Input</p>
<p>aaaa abab</p>
<p>Sample Output</p>
<p>4 3</p>
<p>Source</p>
<p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2009+Multi-
University+Training+Contest+16+-+Host+by+NIT&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener"> 2009 Multi-University Training Contest 16 - Host by NIT
</a></p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;

using namespace std;

const int N = 110055;

int p[2 * N];//记录回文半径
char str0[N];//原始串
char str[2 * N];//转换后的串

void init()
{
    int i, l;
    str[0] = &#39;@&#39;; str[1] = &#39;#&#39;;
    for (i = 0, l = 2; str0[i]; i++, l += 2)
    {
        str[l] = str0[i];
        str[l + 1] = &#39;#&#39;;
    }
    str[l] = 0;
}
int solve()
{
    int ans = 0;
    int i, mx, id;
    mx = 0;//mx即为当前计算回文串最右边字符的最大值  
    for (i = 1; str[i]; i++)
    {
        if (mx&gt;i) 
            p[i] = p[2 * id - i]&gt;(mx - i) ? (mx - i) : p[2 * id - i];
        else    
            p[i] = 1;//如果i&gt;=mx，要从头开始匹配  
        while (str[i + p[i]] == str[i - p[i]])    
            p[i]++;
        if (i + p[i]&gt;mx)//若新计算的回文串右端点位置大于mx，要更新po和mx的值
        {
            mx = i + p[i];
            id = i;
        }
        ans = max(ans,p[i]);
    }
    return ans - 1;
}
int main()
{
    while (scanf(&quot;%s&quot;, str0) != -1)
    {
        init();
        printf(&quot;%d\n&quot;, solve());
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-3746 Cyclic Nacklace 【kmp】</title>
    <url>/article/csdn/hdu-3746_Cyclic_Nacklace_%E3%80%90kmp%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44114187" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44114187</a></p>
<h1><span id="cyclic-nacklace">Cyclic Nacklace</span></h1><p><strong> Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K<br>(Java/Others)<br>Total Submission(s): 3253    Accepted Submission(s): 1488  
</strong>  </p>
<p>Problem Description</p>
<p>CC always becomes very depressed at the end of this month, he has checked his<br>credit card yesterday, without any surprise, there are only 99.9 yuan left. he<br>is too distressed and thinking about how to tide over the last days. Being<br>inspired by the entrepreneurial spirit of “HDU CakeMan”, he wants to sell some<br>little things to make money. Of course, this is not an easy task.  </p>
<p>As Christmas is around the corner, Boys are busy in choosing christmas<br>presents to send to their girlfriends. It is believed that chain bracelet is a<br>good choice. However, Things are not always so simple, as is known to<br>everyone, girl’s fond of the colorful decoration to make bracelet appears<br>vivid and lively, meanwhile they want to display their mature side as college<br>students. after CC understands the girls demands, he intends to sell the chain<br>bracelet called CharmBracelet. The CharmBracelet is made up with colorful<br>pearls to show girls’ lively, and the most important thing is that it must be<br>connected by a cyclic chain which means the color of pearls are cyclic<br>connected from the left to right. And the cyclic count must be more than one.<br>If you connect the leftmost pearl and the rightmost pearl of such chain, you<br>can make a CharmBracelet. Just like the pictrue below, this CharmBracelet’s<br>cycle is 9 and its cyclic count is 2:<br><img src="http://acm.hdu.edu.cn/data/images/C319-1003-1.jpg" alt=""><br>Now CC has brought in some ordinary bracelet chains, he wants to buy minimum<br>number of pearls to make CharmBracelets so that he can save more money. but<br>when remaking the bracelet, he can only add color pearls to the left end and<br>right end of the chain, that is to say, adding to the middle is forbidden.<br>CC is satisfied with his ideas and ask you for help.</p>
<p>Input</p>
<p>The first line of the input is a single integer T ( 0  &lt; T &lt;= 100 ) which<br>means the number of test cases.<br>Each test case contains only one line describe the original ordinary chain to<br>be remade. Each character in the string stands for one pearl and there are 26<br>kinds of pearls being described by ‘a’ ~’z’ characters. The length of the<br>string Len: ( 3 &lt;= Len &lt;= 100000 ).</p>
<p>Output</p>
<p>For each case, you are required to output the minimum count of pearls added to<br>make a CharmBracelet.</p>
<p>Sample Input</p>
<p>3 aaa abca abcde</p>
<p>Sample Output</p>
<p>0 2 5</p>
<p>Author</p>
<p>possessor WC</p>
<p>Source</p>
<p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=HDU+3rd+%A1%B0Vegetable-
Birds+Cup%A1%B1+Programming+Open+Contest&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener"> HDU 3rd “Vegetable-Birds Cup” Programming Open Contest
</a></p>
<p>求循环节 <a href="http://www.cnblogs.com/wuyiqi/archive/2012/01/06/2314078.html" target="_blank" rel="noopener"> http://www.cnblogs.com/wuyiqi/archive/2012/01/06/2314078.html
</a></p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;

using namespace std;

char  b[100050];
int Next[100050];

void get_next(char b[], int m)
{
    int i = 0;
    Next[0] = -1;
    int j = -1;
    while (i&lt;m)
    {
        if (j == -1 || b[i] == b[j])
        {
            ++i;
            ++j;
            if (b[i] == b[j])
                Next[i] = Next[j];
            else
                Next[i] = j;
        }
        else
            j = Next[j];
    }
}

int main()
{
    int test, n, m, i, j;
    scanf(&quot;%d&quot;, &amp;test);
    while (test--)
    {
        scanf(&quot;%s&quot;,b);
        int m = strlen(b);
        get_next(b, m);
        int t = Next[m];
        if (t == 0)
        {
            printf(&quot;%d\n&quot;,m);
            continue;
        }
        int s = m - t;
        if (m%s == 0)
            printf(&quot;0\n&quot;);
        else
            printf(&quot;%d\n&quot;,s-m%s);
    }
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-4513 吉哥系列故事——完美队形II 【Manacher】</title>
    <url>/article/csdn/hdu-4513_%E5%90%89%E5%93%A5%E7%B3%BB%E5%88%97%E6%95%85%E4%BA%8B%E2%80%94%E2%80%94%E5%AE%8C%E7%BE%8E%E9%98%9F%E5%BD%A2II_%E3%80%90Manacher%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44103569" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44103569</a></p>
<h1><span id="吉哥系列故事完美队形ii">吉哥系列故事——完美队形II</span></h1><p><strong> Time Limit: 3000/1000 MS (Java/Others)    Memory Limit: 65535/32768 K<br>(Java/Others)<br>Total Submission(s): 1159    Accepted Submission(s): 429  
</strong>  </p>
<p>Problem Description</p>
<p>吉哥又想出了一个新的完美队形游戏！<br>假设有n个人按顺序站在他的面前，他们的身高分别是h[1], h[2] …<br>h[n]，吉哥希望从中挑出一些人，让这些人形成一个新的队形，新的队形若满足以下三点要求，则就是新的完美队形：  </p>
<p>1、挑出的人保持原队形的相对顺序不变，且必须都是在原队形中连续的；<br>2、左右对称，假设有m个人形成新的队形，则第1个人和第m个人身高相同，第2个人和第m-1个人身高相同，依此类推，当然如果m是奇数，中间那个人可以任意；<br>3、从左到中间那个人，身高需保证不下降，如果用H表示新队形的高度，则H[1]  &lt;= H[2] &lt;= H[3] …. &lt;= H[mid]。  </p>
<p>现在吉哥想知道：最多能选出多少人组成新的完美队形呢？</p>
<p>Input</p>
<p>输入数据第一行包含一个整数T，表示总共有T组测试数据(T &lt;= 20)；<br>每组数据首先是一个整数n(1 &lt;= n &lt;= 100000)，表示原先队形的人数，接下来一行输入n个整数，表示原队形从左到右站的人的身高（50 &lt;= h<br>&lt;= 250，不排除特别矮小和高大的）。</p>
<p>Output</p>
<p>请输出能组成完美队形的最多人数，每组输出占一行。</p>
<p>Sample Input</p>
<p>2 3 51 52 51 4 51 52 52 51</p>
<p>Sample Output</p>
<p>3 4</p>
<p>Source</p>
<p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2013%CC%DA%D1%B6%B1%E0%B3%CC%C2%ED%C0%AD%CB%C9%B3%F5%C8%FC%B5%DA%B6%FE%B3%A1%A3%A83%D4%C222%C8%D5%A3%A9&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener"> 2013腾讯编程马拉松初赛第二场（3月22日）
</a></p>
<p>manacher 简单变形</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;

using namespace std;

const int MAXN = 2000100;
int n, t, ans;
int s[MAXN];
int ma[MAXN * 2];
int mp[MAXN];

void manacher()
{
    int l = 0;
    ma[l++] = 99999999;
    ma[l++] = 1000000000;
    for (int i = 0; i &lt; n; i++)
    {
        ma[l++] = s[i];
        ma[l++] = 1000000000;
    }
    ma[l] = 88888888;
    int mx = 0, id = 0;
    for (int i = 0; i &lt; l; i++)
    {
        mp[i] = mx&gt;i ? min(mp[2 * id - i], mx - i) : 1;

        int m = ma[i];
        while (ma[i + mp[i]] == ma[i - mp[i]] &amp;&amp; ma[i-mp[i]] &lt;= ma[i-mp[i]+2]) mp[i]++;    
        if (i + mp[i] &gt; mx)
        {
            mx = i + mp[i];
            id = i;
        }
    }
}

int main()
{
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    {
        ans = 0;
        memset(s, 0, sizeof(s));
        memset(mp, 0, sizeof(mp));
        scanf(&quot;%d&quot;, &amp;n);
        for (int i = 0; i &lt; n; i++)
            scanf(&quot;%d&quot;, &amp;s[i]);
        manacher();
        for (int i = 0; i &lt; n*2+1;i++)
        ans = max(ans, mp[i] - 1);
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}







#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;

using namespace std;

const int MAXN = 2000100;
int n, t, ans;
int s[MAXN];
int ma[MAXN * 2];
int mp[MAXN];

void manacher()
{
    int l = 0;
    ma[l++] = 99999999;
    ma[l++] = 1000000000;
    for (int i = 0; i &lt; n; i++)
    {
        ma[l++] = s[i];
        ma[l++] = 1000000000;
    }
    ma[l] = 88888888;
    int mx = 0, id = 0;
    for (int i = 0; i &lt; l; i++)
    {
        mp[i] = mx&gt;i ? min(mp[2 * id - i], mx - i) : 1;

        int m = ma[i];
        while (ma[i + mp[i]] == ma[i - mp[i]])
        {
            if (ma[i + mp[i]] == 1000000000)
            {
                mp[i]++;
                continue;
            }
            if (m &gt;= ma[i + mp[i]])
            {
                m = ma[i + mp[i]];
                mp[i]++;//两行的顺序不能反，因为这里WA了几发
            }
            else
                break;
        }
        if (i + mp[i] &gt; mx)
        {
            mx = i + mp[i];
            id = i;
        }

    }
}

int main()
{
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    {
        ans = 0;
        memset(s, 0, sizeof(s));
        memset(mp, 0, sizeof(mp));
        scanf(&quot;%d&quot;, &amp;n);
        for (int i = 0; i &lt; n; i++)
            scanf(&quot;%d&quot;, &amp;s[i]);
        manacher();
        for (int i = 0; i &lt; n*2+1;i++)
        ans = max(ans, mp[i] - 1);
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-5104</title>
    <url>/article/csdn/hdu-5104.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41153393" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41153393</a></p>
<p>打表后，枚举出i,j,k = n-i-j 即可</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt;
#include&lt;malloc.h&gt;
#include&lt;stdexcept&gt;

using namespace std;

int is_prime(int n )
{

    for(int i=2 ;i*i&lt;=n;i++ )
    {
        if ( n % i ==0)
            return 0;
    }
    return 1;
}

int n,m;

int  main ()
{
    int prime[10005];
    memset(prime,0,sizeof(prime));
    for(int i=2 ;i&lt;=10002;i++)
    {
        if ( is_prime(i) )
            prime[i] = 1;
    }

    while (cin&gt;&gt;n)
    {
        int num =0;
        for(int i=2 ;i&lt;=n;i++)
            for(int j=i ;j&lt;=(n-i)/2;j++)
            {
                if (prime[i] &amp;&amp; prime[j]&amp;&amp; prime[n-i-j])
                {
                    num++;
                }
            }
        cout&lt;&lt;num&lt;&lt;endl;
    }

    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-5167 Fibonacci</title>
    <url>/article/csdn/hdu-5167_Fibonacci.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43354997" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43354997</a></p>
<p>链接地址： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5167" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5167
</a></p>
<h1><span id="fibonacci">Fibonacci</span></h1><p><strong> Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/65536 K<br>(Java/Others)<br>Total Submission(s): 474    Accepted Submission(s): 126  
</strong>  </p>
<p>Problem Description</p>
<p>Following is the recursive definition of Fibonacci sequence:  </p>
<p>F  i  =  ⎧  ⎩  ⎨  0  1  F  i  −  1  +  F  i  −  2  i = 0  i = 1  i  &gt; 1</p>
<p>Now we need to check whether a number can be expressed as the product of<br>numbers in the Fibonacci sequence.</p>
<p>Input</p>
<p>There is a number  T  shows there are  T  test cases below. (  T  ≤  100  ,<br>000  )<br>For each test case , the first line contains a integers n , which means the<br>number need to be checked.<br>0  ≤  n  ≤  1  ,  000  ,  000  ,  000</p>
<p>Output</p>
<p>For each case output “Yes” or “No”.</p>
<p>Sample Input</p>
<p>3 4 17 233</p>
<p>Sample Output</p>
<p>Yes No Yes</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include &lt;sstream&gt;
#include &lt;time.h&gt;
#include &lt;utility&gt;
#include &lt;malloc.h&gt;

using namespace std;

__int64 p[100];
int T;
__int64 n;

int main()
{
    p[0] = 0; p[1] = 1;
    for (int i = 2; i &lt;= 46; i++)
        p[i] = p[i - 1] + p[i - 2];

    set&lt;__int64&gt; q;
    set&lt;long long&gt; ::iterator it;
    q.clear();
    q.insert(0);
    q.insert(1);
    for(it=q.begin();it!=q.end();it++)
    {
         for(int j=3;j&lt;=45;j++)
        {
            int tt = *it;
            __int64 tmp = tt*p[j];
            if (tmp &lt;= 1000000000)
                q.insert(tmp);
        }
    }
    cin&gt;&gt;T;
    while (T--)
    {
        int ok=0;
        cin&gt;&gt;n;
        if (q.find(n) != q.end())
            cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
        else
            cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu-5122</title>
    <url>/article/csdn/hdu-5122.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41686995" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41686995</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5122" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5122
</a></p>
<p>简单题</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt;
#include&lt;malloc.h&gt;
#include&lt;stdexcept&gt;

using namespace std;

int t ;
int n;
int  k = 1;

int ans ;
int p[1000005];


int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        ans = 0;
        scanf(&quot;%d&quot;,&amp;n);
        for(int i=1;i&lt;=n;i++)
        {
            scanf(&quot;%d&quot;,&amp;p[i]);
        }

        for(int i=n-1;i&gt;=1;i--)
        {
            if (p[i+1] &lt; p[i])
                {
                    swap(p[i+1],p[i]);
                    ans++;
                }
        }

        printf(&quot;Case #%d: %d\n&quot;,k++,ans);

    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 1058 Humble Numbers【dp】</title>
    <url>/article/csdn/hdu_1058_Humble_Numbers%E3%80%90dp%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46379515" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46379515</a></p>
<p>题目链接： <a href="http://acm.acmcoder.com/showproblem.php?pid=1058" target="_blank" rel="noopener"> http://acm.acmcoder.com/showproblem.php?pid=1058
</a></p>
<p>题意：数字只有2,3,5,7素因子的数叫做Humble Number，问你第 n 个Humble Number是什么？</p>
<p>解法：枚举。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;vector&gt;  
#include &lt;string&gt;  
#include &lt;algorithm&gt;  
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;fstream&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;math.h&gt;

using namespace std;

int n;
int p[6000];
int tmp[5] = { 2, 3, 5, 7 };
set&lt;long long&gt; SET;

void init()
{
    p[1] = 1;
    int n = 1, m = 1, k = 1, l = 1;
    for (int i = 2; i &lt;= 5842; i++)
    {
        int a = p[n] * 2;
        int b = p[m] * 3;
        int c = p[k] * 5;
        int d = p[l] * 7;
        int ans = min(a,min(b,min(c,d)));
        if (ans == a) n++;
        if (ans == b) m++;
        if (ans == c) k++;
        if (ans == d) l++;
        p[i] = ans;
    }
}

int main()
{
    init();
    while (scanf(&quot;%d&quot;,&amp;n)!=EOF &amp;&amp; n)
    {
        printf(&quot;The %d&quot;,n);

        if (n % 100 == 13 || n % 100 == 12 || n % 100 == 11)
            printf(&quot;th&quot;);
        else if (n % 10 == 1) printf(&quot;st&quot;);
        else if (n % 10 == 2) printf(&quot;nd&quot;);
        else if (n % 10 == 3) printf(&quot;rd&quot;);
        else printf(&quot;th&quot;);

        printf(&quot; humble number is %d.\n&quot;,p[n]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 1054 Strategic Game 【匈牙利算法】</title>
    <url>/article/csdn/hdu_1054_Strategic_Game_%E3%80%90%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46491443" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46491443</a></p>
<p>题目链接： <a href="http://acm.acmcoder.com/showproblem.php?pid=1054" target="_blank" rel="noopener"> http://acm.acmcoder.com/showproblem.php?pid=1054
</a><br>题意：求无向图的最小顶点覆盖 = 最大匹配数 / 2;<br>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int n, m, k, num;
int p[1510][1510];
int book[1510];
int match[1510];
int t, tt;
int a, b;
char tmp;

bool dfs(int u)
{
    int i;
    for (i = 0; i &lt; n; i++)
    {
        if (book[i] == 0 &amp;&amp; p[u][i] == 1)
        {
            book[i] = 1;
            if (match[i] == 0 || dfs(match[i]))
            {
                match[i] = u;
                return true;
            }
        }
    }
    return false;
}


int main()
{
    while (scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        memset(p,0,sizeof(p));
        memset(match, 0, sizeof(match));

        for (int i = 0; i &lt; n; i++)
        {
            scanf(&quot;%d%c%c%d%c&quot;,&amp;m,&amp;tmp,&amp;tmp,&amp;k,&amp;tmp);
            for (int j = 1; j &lt;= k; j++)
            {
                scanf(&quot;%d&quot;,&amp;num);
                p[m][num] = 1;
                p[num][m] = 1;
            }
        }

        int ans = 0;

        for (int i = 0; i &lt; n; i++)
        {
            memset(book, 0, sizeof(book));
            if (dfs(i))
                ans++;
        }
        cout &lt;&lt; ans/2 &lt;&lt; endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1081 To The Max 【最大子矩阵和】</title>
    <url>/article/csdn/hdu_1081_To_The_Max_%E3%80%90%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%E5%92%8C%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44461053" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44461053</a></p>
<p>To The Max</p>
<p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 8882 Accepted Submission(s): 4288</p>
<p>Problem Description<br>Given a two-dimensional array of positive and negative integers, a sub-<br>rectangle is any contiguous sub-array of size 1 x 1 or greater located within<br>the whole array. The sum of a rectangle is the sum of all the elements in that<br>rectangle. In this problem the sub-rectangle with the largest sum is referred<br>to as the maximal sub-rectangle.</p>
<p>As an example, the maximal sub-rectangle of the array:</p>
<p>0 -2 -7 0<br>9 2 -6 2<br>-4 1 -4 1<br>-1 8 0 -2 </p>
<p>is in the lower left corner:</p>
<p>9 2<br>-4 1<br>-1 8 </p>
<p>and has a sum of 15.</p>
<p>Input<br>The input consists of an N x N array of integers. The input begins with a<br>single positive integer N on a line by itself, indicating the size of the<br>square two-dimensional array. This is followed by N 2 integers separated by<br>whitespace (spaces and newlines). These are the N 2 integers of the array,<br>presented in row-major order. That is, all numbers in the first row, left to<br>right, then all numbers in the second row, left to right, etc. N may be as<br>large as 100. The numbers in the array will be in the range [-127,127].</p>
<p>Output<br>Output the sum of the maximal sub-rectangle.</p>
<p>Sample Input<br>4<br>0 -2 -7 0 9 2 -6 2<br>-4 1 -4 1 -1<br>8 0 -2</p>
<p>Sample Output<br>15</p>
<p>Source<br>Greater New York 2001</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;  
#include&lt;iostream&gt;  
#include&lt;math.h&gt;  
#include&lt;stdlib.h&gt;  
#include&lt;ctype.h&gt;  
#include&lt;algorithm&gt;  
#include&lt;vector&gt;  
#include&lt;string.h&gt;  
#include&lt;queue&gt;  
#include&lt;stack&gt;  
#include&lt;set&gt;  
#include&lt;map&gt;  
#include&lt;sstream&gt;  
#include&lt;time.h&gt;  
#include&lt;malloc.h&gt;  

using namespace std;  

const int MAXN = 1010;
int n;
int p[MAXN][MAXN];

int longmax(int a[],int n)
{
    int b = 0;
    int ans = -10000000;
    for(int i=0;i&lt;n;i++)
    {
        if (b&gt;0)
            b+= a[i];
        else b= a[i];
        ans = max (ans,b);
    }
    return ans;
}

int work()
{
    int t[1010];
    int ans = -10000000;
    for(int i=0;i&lt;n;i++)
    {
        memset(t,0,sizeof(t));
        for(int j = i;j&lt;n;j++)//枚举第i到第j行的所有可能矩阵的和
        {
            int k;
            for(k=0;k&lt;n;k++)
            {
                t[k] += p[j][k];
            }
            int tt = longmax(t,k);
            ans = max(ans,tt);
        }
    }
    return ans;
}

int main()
{
    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)
    {
        for(int i=0;i&lt;n;i++)
            for(int j=0;j&lt;n;j++)
            {
                scanf(&quot;%d&quot;,&amp;p[i][j]);
            }
            int ans = work();
            printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 1045 Fire Net【dfs】</title>
    <url>/article/csdn/hdu_1045_Fire_Net%E3%80%90dfs%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44624189" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44624189</a></p>
<p>Fire Net</p>
<p>Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 7090 Accepted Submission(s): 4033</p>
<p>Problem Description<br>Suppose that we have a square city with straight streets. A map of a city is a<br>square board with n rows and n columns, each representing a street or a piece<br>of wall.</p>
<p>A blockhouse is a small castle that has four openings through which to shoot.<br>The four openings are facing North, East, South, and West, respectively. There<br>will be one machine gun shooting through each opening.</p>
<p>Here we assume that a bullet is so powerful that it can run across any<br>distance and destroy a blockhouse on its way. On the other hand, a wall is so<br>strongly built that can stop the bullets.</p>
<p>The goal is to place as many blockhouses in a city as possible so that no two<br>can destroy each other. A configuration of blockhouses is legal provided that<br>no two blockhouses are on the same horizontal row or vertical column in a map<br>unless there is at least one wall separating them. In this problem we will<br>consider small square cities (at most 4x4) that contain walls through which<br>bullets cannot run through.</p>
<p>The following image shows five pictures of the same board. The first picture<br>is the empty board, the second and third pictures show legal configurations,<br>and the fourth and fifth pictures show illegal configurations. For this board,<br>the maximum number of blockhouses in a legal configuration is 5; the second<br>picture shows one way to do it, but there are several other ways.</p>
<p>Your task is to write a program that, given a description of a map, calculates<br>the maximum number of blockhouses that can be placed in the city in a legal<br>configuration.</p>
<p>Input<br>The input file contains one or more map descriptions, followed by a line<br>containing the number 0 that signals the end of the file. Each map description<br>begins with a line containing a positive integer n that is the size of the<br>city; n will be at most 4. The next n lines each describe one row of the map,<br>with a ‘.’ indicating an open space and an uppercase ‘X’ indicating a wall.<br>There are no spaces in the input file.</p>
<p>Output<br>For each test case, output one line containing the maximum number of<br>blockhouses that can be placed in the city in a legal configuration.</p>
<p>Sample Input<br>4<br>.X..<br>….<br>XX..<br>….<br>2<br>XX<br>.X<br>3<br>.X.<br>X.X<br>.X.<br>3<br>…<br>.XX<br>.XX<br>4<br>….<br>….<br>….<br>….<br>0</p>
<p>Sample Output<br>5<br>1<br>5<br>2<br>4</p>
<p>Source<br>Zhejiang University Local Contest 2001</p>
<p>暴力搜就能AC。有题解说用二分匹配，但我不会构图。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;malloc.h&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;

using namespace std;

const int MAXN = 10;

char p[MAXN][MAXN];
int n,tmp;

void dfs(int num,int ans)
{
    if (num == n*n)
    {
        tmp = max(ans,tmp);
        return ;
    }
    dfs(num + 1, ans);

    int i = num / n;
    int j = num - i * n;
    if (p[i][j] == &#39;.&#39;)
    {
        int ok = 0;
        while (i &gt;= 0)
        {
            i--;
            if (p[i][j] == &#39;X&#39;)
                break;
            if (p[i][j] == &#39;o&#39;)
            {
                ok = 1; break;
            }
        }
        i = num / n;
        if (!ok) while (j &gt;= 0 &amp;&amp; p[i][j] != &#39;X&#39;)
        {
            j--;
            if (p[i][j] == &#39;X&#39;)
                break;
            if (p[i][j] == &#39;o&#39;)
            {
                ok = 1; break;
            }
        }
        i = num / n;
        j = num - i * n;
        if (!ok)
        {
            p[i][j] = &#39;o&#39;;
            dfs(num + 1, ans + 1);
            p[i][j] = &#39;.&#39;;
        }
    }
    return;
}

int main()
{
    while (scanf(&quot;%d&quot;, &amp;n) != EOF &amp;&amp; n)
    {
        for (int i = 0; i &lt; n; i++)
            scanf(&quot;%s&quot;,p[i]);
        tmp = 0;
        dfs(0,0);
        printf(&quot;%d\n&quot;,tmp);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 1078 FatMouse and Cheese【dp】</title>
    <url>/article/csdn/hdu_1078_FatMouse_and_Cheese%E3%80%90dp%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47006901" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47006901</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1078" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1078
</a><br>题意：每次只能走 横着或竖着的 1~k 个格子，求最多能吃到的奶酪。<br>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int n, k;
int a[110][110], dp[110][110];
int dir[4][2] = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };

bool is_ok(int x, int y)
{
    if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= n) return false;
    return true;
}

int res(int x, int y)
{
    int sum = 0,tmp = 0;
    if (!dp[x][y])
    {
        for (int i = 1; i &lt;= k; i++)
        {
            for (int j = 0; j &lt; 4; j++)
            {
                int xx = x + dir[j][0] * i;
                int yy = y + dir[j][1] * i;
                if (is_ok(xx,yy) &amp;&amp; a[xx][yy] &gt; a[x][y])
                {
                    sum = res(xx, yy);
                    tmp = max(tmp, sum);
                }
            }
        }
        dp[x][y] = tmp + a[x][y];
    }
    return dp[x][y];
}

int main()
{
    while (scanf(&quot;%d %d&quot;, &amp;n,&amp;k) != EOF)
    {
        if (n == -1 &amp;&amp; k == -1) break;
        for (int i = 0; i &lt; n; i++)
            for (int j = 0; j &lt; n; j++)
                scanf(&quot;%d&quot;,&amp;a[i][j]);
        memset(dp, 0, sizeof(dp));
        printf(&quot;%d\n&quot;, res(0,0));
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 1025 Constructing Roads In JGShining’s Kingdom 【dp+二分】</title>
    <url>/article/csdn/hdu_1025_Constructing_Roads_In_JGShining%E2%80%99s_Kingdom_%E3%80%90dp+%E4%BA%8C%E5%88%86%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46379469" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46379469</a></p>
<p>题目链接： <a href="http://acm.acmcoder.com/showproblem.php?pid=1025" target="_blank" rel="noopener"> http://acm.acmcoder.com/showproblem.php?pid=1025
</a></p>
<p>题意：本求最长公共子序列，但数据太多。转化为求最长不下降子序列。太NB了。复杂度n*log(n).</p>
<p>解法：dp+二分</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;vector&gt;  
#include &lt;string&gt;  
#include &lt;algorithm&gt;  
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;fstream&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;math.h&gt;

using namespace std;

const int MAXN = 500010;

int n, pos;
int a[MAXN];
int dp[MAXN];
int h, k;

int search(int num,int low,int high)
{
    int mid;
    while (low &lt;= high)
    {
        mid = (low + high) / 2;
        if (num &gt;= dp[mid]) low = mid + 1;
        else high = mid - 1;
    }
    return low;
}

int main()
{
    int cases = 1;
    while (~scanf(&quot;%d&quot;, &amp;n))
    {
        for (int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d%d&quot;, &amp;h, &amp;k);
            a[h] = k;
        }
        memset(dp, 0, sizeof(dp));
        dp[0] = -1; dp[1] = a[1];
        int len = 1;
        //  n*log(n) 求解

        for (int i = 2; i &lt;= n; i++)
        {
            if (a[i] &gt;= dp[len])
            {
                len = len + 1;
                dp[len] = a[i];
            }
            else
            {
                pos = search(a[i],1,len);
                dp[pos] = a[i];
            }
        }
        printf(&quot;Case %d:\n&quot;,cases++);
        if (len == 1)
            printf(&quot;My king, at most %d road can be built.\n\n&quot;,len);
        else 
            printf(&quot;My king, at most %d roads can be built.\n\n&quot;,len);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 1102 &amp; poj 2421 Constructing Roads</title>
    <url>/article/csdn/hdu_1102_&amp;_poj_2421_Constructing_Roads.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43115929" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43115929</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1102" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1102
</a></p>
<h1><span id="constructing-roads">Constructing Roads</span></h1><p><strong> Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 14983    Accepted Submission(s): 5715  
</strong>  </p>
<p>Problem Description</p>
<p>There are N villages, which are numbered from 1 to N, and you should build<br>some roads such that every two villages can connect to each other. We say two<br>village A and B are connected, if and only if there is a road between A and B,<br>or there exists a village C such that there is a road between A and C, and C<br>and B are connected.  </p>
<p>We know that there are already some roads between some villages and your job<br>is the build some roads such that all the villages are connect and the length<br>of all the roads built is minimum.  </p>
<p>Input</p>
<p>The first line is an integer N (3  &lt;= N &lt;= 100), which is the number of<br>villages. Then come N lines, the i-th of which contains N integers, and the<br>j-th of these N integers is the distance (the distance should be an integer<br>within [1, 1000]) between village i and village j.  </p>
<p>Then there is an integer Q (0 &lt;= Q &lt;= N * (N + 1) / 2). Then come Q lines,<br>each line contains two integers a and b (1 &lt;= a &lt; b &lt;= N), which means the<br>road between village a and village b has been built.  </p>
<p>Output</p>
<p>You should output a line contains an integer, which is the length of all the<br>roads to be built such that all the villages are connected, and this value is<br>minimum.  </p>
<p>Sample Input</p>
<p>3 0 990 692 990 0 179 692 179 0 1 1 2</p>
<p>Sample Output</p>
<p>179</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;

using namespace std;

int n,m;
int p[1005][1005];
int low [1005];
int vis[1005];

int prim ()
{
    int vis[1000];
    memset(vis,0,sizeof(vis));

    int low [1000],res=0,minn;
    int pos=1;
    vis[1]=1;

    for (int i=1;i&lt;=n;i++)
    {
        if (i!=pos)
            low [i]=p[pos][i];
    }

    for (int j=1;j&lt;n;j++)
    {
        minn=1000000;
        for (int i=1;i&lt;=n;i++)
        {
            if ( !vis[i] &amp;&amp; minn&gt;low[i] )
            {
                pos=i;
                minn=low[i];
            }
        }

        res+=minn;
        vis[pos]=1;

        for (int i=1;i&lt;=n;i++)
        {
            if ( !vis[i] &amp;&amp; low[i]&gt;p[pos][i]  )
            {
                low[i]=p[pos][i];
            }
        }
    }
    return res;
}
int main ()
{
    int kkk;
    while (scanf(&quot;%d&quot;,&amp;n)!=EOF)
    {
        memset(p,100000,sizeof(p));

        for (int i=1;i&lt;=n;i++)
        {
                for (int j=1;j&lt;=n;j++)
            {
                scanf (&quot;%d&quot;,&amp;kkk);
                    p[i][j]=kkk;
            }
        }
        int c,d;
        scanf (&quot;%d&quot;,&amp;m);
        while (m--)
        {
            scanf (&quot;%d%d&quot;,&amp;c,&amp;d);
            p[c][d]=p[d][c]=0;
        }
        int tt=prim();
        printf(&quot;%d\n&quot;,tt);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 1151 Air Raid 【DAG最小路径覆盖】</title>
    <url>/article/csdn/hdu_1151_Air_Raid_%E3%80%90DAG%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48345113" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48345113</a></p>
<p>题目： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1151" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1151
</a></p>
<p>DAG最小路径覆盖 = 结点数 - 最大匹配数</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;sstream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  

using namespace std;

int n, m;
int p[1000][1000];
int book[1000];
int match[1000];

int dfs(int u)
{
    for (int i = 1; i &lt;= n; i++)
    {
        if (book[i] == 0 &amp;&amp; p[u][i] == 1)
        {
            book[i] = 1;
            if (match[i] == 0 || dfs(match[i]))
            {
                match[i] = u;
                return 1;
            }
        }
    }
    return 0;
}

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%d %d&quot;, &amp;n, &amp;m);

        memset(match, 0, sizeof(match));
        memset(p, 0, sizeof(p));

        int u, v;
        while(m--)
        {
            scanf(&quot;%d %d&quot;, &amp;u, &amp;v);
            p[u][v] = 1;
        }

        int ans = 0;
        for (int i = 1; i &lt;= n; i++)
        {
            memset(book, 0, sizeof(book));
            if (dfs(i))
                ans++;
        }
        printf(&quot;%d\n&quot;, n - ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 1115 Lifting the Stone【求多边形重心】</title>
    <url>/article/csdn/hdu_1115_Lifting_the_Stone%E3%80%90%E6%B1%82%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%87%8D%E5%BF%83%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/50153973" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/50153973</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1115" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1115
</a></p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

double x0, y0, x1, y1, x2, y2;
double s0, s1, s2;
double x, y;

int n;

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);

    while (t--)
    {
        scanf (&quot;%d&quot;,&amp;n);
        s0 = s1 = s2 = 0;
        cin &gt;&gt; x0 &gt;&gt; y0 &gt;&gt; x1 &gt;&gt; y1;
        for (int i = 2;i &lt; n;i++)
        {
            cin &gt;&gt; x2 &gt;&gt; y2;
            x = (x0 + x1 + x2);
            y = (y0 + y1 + y2);

            double tmp = (x0*y1 + x1 * y2 + x2*y0 - x1*y0 - x2 * y1 - x0*y2);

            s0 += tmp;
            s1 += x*tmp;
            s2 += y*tmp;

            x1 = x2;
            y1 = y2;

        }
        //cout&lt;&lt;s0&lt;&lt;endl;
        if (s0 == 0)
            printf(&quot;0.00 0.00\n&quot;);
        else
            printf(&quot;%.2lf %.2lf\n&quot;, s1 / s0 / 3, s2 / s0 / 3);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 1251 统计难题 【Trie树】</title>
    <url>/article/csdn/hdu_1251_%E7%BB%9F%E8%AE%A1%E9%9A%BE%E9%A2%98_%E3%80%90Trie%E6%A0%91%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44228365" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44228365</a></p>
<p>trie树，又叫做字典数。</p>
<p>字典数学习资料： <a href="http://www.cnblogs.com/tanky_woo/archive/2010/09/24/1833717.html" target="_blank" rel="noopener"> http://www.cnblogs.com/tanky_woo/archive/2010/09/24/1833717.html
</a></p>
<h1><span id="统计难题">统计难题</span></h1><p><strong> Time Limit: 4000/2000 MS (Java/Others)    Memory Limit: 131070/65535 K<br>(Java/Others)<br>Total Submission(s): 20110    Accepted Submission(s): 8797  
</strong>  </p>
<p>Problem Description</p>
<p>Ignatius最近遇到一个难题,老师交给他很多单词(只有小写字母组成,不会有重复的单词出现),现在老师要他统计出以某个字符串为前缀的单词数量(单词本身也是自己的前缀).  </p>
<p>Input</p>
<p>输入数据的第一部分是一张单词表,每行一个单词,单词的长度不超过10,它们代表的是老师交给Ignatius统计的单词,一个空行代表单词表的结束.第二部分是一连串的提问,每行一个提问,每个提问都是一个字符串.  </p>
<p>注意:本题只有一组测试数据,处理到文件结束.  </p>
<p>Output</p>
<p>对于每个提问,给出以该字符串为前缀的单词的数量.  </p>
<p>Sample Input</p>
<p>banana band bee absolute acm ba b band abc</p>
<p>Sample Output</p>
<p>2 3 1 0</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;iostream&gt;  
#include &lt;string.h&gt;  
#include &lt;algorithm&gt;  
#include &lt;math.h&gt;  
#include &lt;ctype.h&gt;  
#include &lt;time.h&gt;  
#include &lt;queue&gt;  
#include &lt;iterator&gt; 

using namespace std;

typedef struct Trie{
    int v;
    Trie *next[26];
}Trie;

Trie root;

void createTrie(char *str)
{
    int len = strlen(str);
    Trie *p = &amp;root, *q;
    for(int i=0; i&lt;len; ++i)
    {
        int id = str[i]-&#39;a&#39;;
        if(p-&gt;next[id] == NULL)
        {
            q = (Trie *)malloc(sizeof(root));
            q-&gt;v = 1;
            for(int j=0; j&lt;26; ++j)
                q-&gt;next[j] = NULL;
            p-&gt;next[id] = q;
            p = p-&gt;next[id];
        }
        else
        {
            p-&gt;next[id]-&gt;v++;
            p = p-&gt;next[id];
        }
    }
}

int findTrie(char *str)
{
    int len = strlen(str);
    Trie *p = &amp;root;
    for(int i=0; i&lt;len; ++i)
    {
        int id = str[i]-&#39;a&#39;;
        p = p-&gt;next[id];
        if(p == NULL)
            return 0;
    }
    return p-&gt;v;
}

int main()
{
    //freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin);
    char str[15];
    int i;
    for(i=0; i&lt;26; ++i)
        root.next[i] = NULL;
    while(gets(str) &amp;&amp; str[0]!=&#39;\0&#39;)
        createTrie(str);
    memset(str, 0, sizeof(str));
    while(scanf(&quot;%s&quot;, str) != EOF)
    {
        int ans = findTrie(str);
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 1217 Arbitrage 【floyd】</title>
    <url>/article/csdn/hdu_1217_Arbitrage_%E3%80%90floyd%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46380565" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46380565</a></p>
<p>题目链接： <a href="http://acm.acmcoder.com/showproblem.php?pid=1217" target="_blank" rel="noopener"> http://acm.acmcoder.com/showproblem.php?pid=1217
</a></p>
<p>floyd传递闭包。</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;vector&gt;
#include &lt;map&gt;

using namespace std;

char a[100], b[100];
double c;
int n, m;
int f, q;
double Map[110][110];

struct
{
    int num;
    char s[110];
}p[35];

void init()
{
    memset(Map, 0, sizeof(Map));
    for (int i = 0; i &lt; n; i++)
    {
        Map[i][i] = 1;
        scanf(&quot;%s&quot;, p[i].s);
        p[i].num = i;
    }
    scanf(&quot;%d&quot;,&amp;m);
    while (m--)
    {
        scanf(&quot;%s %lf %s&quot;, a, &amp;c, b);
        for (int i = 0; i &lt; n; i++)
        {
            if (strcmp(a, p[i].s) == 0)
                f = i;
            if (strcmp(b, p[i].s) == 0)
                q = i;
        }
        Map[f][q] = c; //Map[q][f] = 1.0 / c;
    }
}

int solve()
{
    for (int k = 0; k &lt; n;k++)
        for (int i = 0; i &lt; n; i++)
            for (int j = 0; j &lt; n; j++)
            {
                if (Map[i][k] != 0 &amp;&amp; Map[k][j] != 0 &amp;&amp; Map[i][j] &lt; Map[i][k] * Map[k][j])
                {
                    Map[i][j] = Map[i][k] * Map[k][j];
                }
            }
    for (int i = 0; i &lt; n; i++)
        if (Map[i][i] &gt; 1)
                return 1;
    return 0;
}

int cases = 1;

int main()
{
    while (scanf(&quot;%d&quot;, &amp;n) != EOF &amp;&amp; n)
    {
        init();
        if (solve() == 1)
            printf(&quot;Case %d: Yes\n&quot;,cases++);
        else 
            printf(&quot;Case %d: No\n&quot;, cases++);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 1260 Tickets 【dp】</title>
    <url>/article/csdn/hdu_1260_Tickets_%E3%80%90dp%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43529219" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43529219</a></p>
<h1><span id="tickets">Tickets</span></h1><p><strong> Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 1258    Accepted Submission(s): 599  
</strong>  </p>
<p>Problem Description</p>
<p>Jesus, what a great movie! Thousands of people are rushing to the cinema.<br>However, this is really a tuff time for Joe who sells the film tickets. He is<br>wandering when could he go back home as early as possible.<br>A good approach, reducing the total time of tickets selling, is let adjacent<br>people buy tickets together. As the restriction of the Ticket Seller Machine,<br>Joe can sell a single ticket or two adjacent tickets at a time.<br>Since you are the great JESUS, you know exactly how much time needed for every<br>person to buy a single ticket or two tickets for him/her. Could you so kind to<br>tell poor Joe at what time could he go back home as early as possible? If so,<br>I guess Joe would full of appreciation for your help.  </p>
<p>Input</p>
<p>There are N(1 &lt;=N&lt;=10) different scenarios, each scenario consists of 3 lines:<br>1) An integer K(1&lt;=K&lt;=2000) representing the total number of people;<br>2) K integer numbers(0s&lt;=Si&lt;=25s) representing the time consumed to buy a<br>ticket for each person;<br>3) (K-1) integer numbers(0s&lt;=Di&lt;=50s) representing the time needed for two<br>adjacent people to buy two tickets together.  </p>
<p>Output</p>
<p>For every scenario, please tell Joe at what time could he go back home as<br>early as possible. Every day Joe started his work at 08:00:00 am. The format<br>of time is HH:MM:SS am|pm.  </p>
<p>Sample Input</p>
<p>2 2 20 25 40 1 8</p>
<p>Sample Output</p>
<p>08:00:40 am 08:00:08 am</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;

using namespace std;

int t, n;
int a[10010], b[10010],dp[2100];
char hh[4], ff[4], mm[4];
int main()
{
    scanf(&quot;%d&quot;,&amp;t);

    while (t--)
    {
        memset(dp,0,sizeof(dp));
        scanf(&quot;%d&quot;,&amp;n);
        for (int i = 1; i &lt;= n; i++)
            scanf(&quot;%d&quot;,&amp;a[i]);
        for (int i = 2; i &lt;= n; i++)
            scanf(&quot;%d&quot;,&amp;b[i]);

        dp[1] = a[1];

        for (int i = 2; i &lt;= n; i++)
            dp[i] = min(dp[i - 1] + a[i], dp[i - 2] + b[i]);
        int h = dp[n] / (60 * 60); 
        int f = (dp[n] - (3600 * h))/60;
        int m = dp[n] % 60;
        h += 8;
        hh[0] = h / 10 + &#39;0&#39;, hh[1] = h % 10 + &#39;0&#39;;
        ff[0] = f / 10 + &#39;0&#39;; ff[1] = f % 10 + &#39;0&#39;;
        mm[0] = m / 10 + &#39;0&#39;; mm[1] = m % 10 + &#39;0&#39;; 
        if (h &lt;= 12)
            printf(&quot;%s:%s:%s am\n&quot;,hh,ff,mm);
        else
            printf(&quot;%s:%s:%s pm\n&quot;, hh, ff, mm);

    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 1513 Invitation Cards【spfa翻转边】</title>
    <url>/article/csdn/hdu_1513_Invitation_Cards%E3%80%90spfa%E7%BF%BB%E8%BD%AC%E8%BE%B9%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/45113259" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/45113259</a></p>
<p>题目链接： <a href="http://acm.acmcoder.com/showproblem.php?pid=1535" target="_blank" rel="noopener"> http://acm.acmcoder.com/showproblem.php?pid=1535
</a></p>
<p>题意：有向图，求源点到各个点最短路径和+各个点到源点最短路径和。</p>
<p>spfa求单源最短路径，求各个点到源点最短路径翻转边。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;vector&gt;
#include &lt;map&gt;

using namespace std;

const int MAXN = 2000010;
const int INF = 1e9+10;

struct
{
    int a, b, c;
}Map[MAXN];

int t;
int n, m, a, b, c;

struct Edge
{
    int v;
    int cost;
    Edge(int _v = 0, int _cost = 0)
    {
        v = _v;
        cost = _cost;
    }
};
vector&lt;Edge&gt; E[MAXN];

void addedge(int u, int v, int cost)
{
    E[u].push_back(Edge(v, cost));
}

bool vis[MAXN];
int cnt[MAXN];
int dist[MAXN];

void SPFA(int start, int n)
{
    memset(vis, false, sizeof(vis));
    for (int i = 1; i &lt;= n; i++) dist[i] = INF;
    vis[start] = true;
    dist[start] = 0;
    queue&lt;int&gt; que;
    while (!que.empty()) que.pop();
    que.push(start);
    memset(cnt, 0, sizeof(cnt));
    cnt[start] = 1;
    while (!que.empty())
    {
        int u = que.front(); que.pop();
        vis[u] = false;
        for (int i = 0; i&lt;E[u].size(); i++)
        {
            int v = E[u][i].v;
            if (dist[v]&gt;dist[u] + E[u][i].cost)
            {
                dist[v] = dist[u] + E[u][i].cost;
                if (!vis[v])
                {
                    vis[v] = true;
                    que.push(v);
                    if (++cnt[v] &gt; n) return;
                }
            }
        }
    }
}

int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        for (int i = 1; i &lt;= n; i++)
            E[i].clear();
        for (int i = 1; i &lt;= m; i++)
        {
            scanf(&quot;%d%d%d&quot;, &amp;Map[i].a, &amp;Map[i].b, &amp;Map[i].c);
            addedge(Map[i].a, Map[i].b, Map[i].c);
        }
        int ans = 0;
        SPFA(1, n);
        for (int i = 1; i &lt;= n; i++)
            ans += dist[i];

        for (int i = 1; i &lt;= n; i++)
            E[i].clear();
        for (int i = 1; i &lt;= m; i++)
            addedge(Map[i].b, Map[i].a, Map[i].c);
        SPFA(1, n);
        for (int i = 1; i &lt;= n; i++)
            ans += dist[i];
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 1281 棋盘游戏【二分匹配】</title>
    <url>/article/csdn/hdu_1281_%E6%A3%8B%E7%9B%98%E6%B8%B8%E6%88%8F%E3%80%90%E4%BA%8C%E5%88%86%E5%8C%B9%E9%85%8D%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46537185" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46537185</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1281" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1281
</a></p>
<p>题意：中文题目，不描述了。</p>
<p>解法：棋盘的行x看成二分图左边的点，列y看成二分图右边的点，那么就把可以放车的位置看成是一条边，而二分图的最大匹配中x互不相同，y互不相同，所以每个匹配都是不同行不同列，所以最大匹配就是最多可以放的车的数量。而要判断有多少个点是必须放的，只要在得出最大匹配后，每次去掉一个匹配，再去运算看得出的结果是否与原来的最大匹配数相同，若相同就不是必须的，若不相同就是必须的。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

struct node
{
    int x;
    int y;
}it[10010];

int p[510][510];
int n, m, k;
int a, b;

int book[510];
int match[510];

bool dfs(int u)
{
    for (int i = 1; i &lt;= m; i++)
    {
        if (book[i] == 0 &amp;&amp; p[u][i] == 1)
        {
            book[i] = 1;
            if (match[i] == 0 || dfs(match[i]))
            {
                match[i] = u;
                return true;
            }
        }
    }
    return false;
}

int main()
{
    int ca = 1;
    while (scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k) != EOF)
    {
        memset(p, 0, sizeof(p));
        memset(match, 0, sizeof(match));
        for (int i = 0; i &lt; k; i++)
        {
            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
            it[i].x = a;
            it[i].y = b;
            p[a][b] = 1;
        }
        int ans = 0;
        for (int i = 1; i &lt;= n; i++)
        {
            memset(book, 0, sizeof(book));
            if (dfs(i))
                ans++;
        }
        int tmp = 0;
        for (int j = 0; j &lt; k; j++)
        {
            p[it[j].x][it[j].y] = 0;
            int ans1 = 0;
            memset(match, 0, sizeof(match));
            for (int i = 1; i &lt;= n; i++)
            {
                memset(book, 0, sizeof(book));
                if (dfs(i))
                    ans1++;
            }
            if (ans1 != ans)
                tmp++;
            p[it[j].x][it[j].y] = 1;
        }
        printf(&quot;Board %d have %d important blanks for %d chessmen.\n&quot;, ca++,tmp,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 1565 方格取数(1)【最大流】</title>
    <url>/article/csdn/hdu_1565_%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0(1)%E3%80%90%E6%9C%80%E5%A4%A7%E6%B5%81%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/49028635" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/49028635</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1565" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1565
</a></p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;sstream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string&gt;

using namespace std;

const int MAXN = 1010000;//点数的最大值
const int MAXM = 6001000;//边数的最大值
const int INF = 0x3f3f3f3f;

struct Edge
{
    int to, next, cap, flow;
}edge[MAXM];//注意是MAXM

int tol;
int head[MAXN];
int gap[MAXN], dep[MAXN], pre[MAXN], cur[MAXN];

void init()
{
    tol = 0;
    memset(head, -1, sizeof(head));
}
//加边，单向图三个参数，双向图四个参数
void addedge(int u, int v, int w, int rw = 0)
{
    edge[tol].to = v; edge[tol].cap = w; edge[tol].next = head[u];
    edge[tol].flow = 0; head[u] = tol++;
    edge[tol].to = u; edge[tol].cap = rw; edge[tol].next = head[v];
    edge[tol].flow = 0; head[v] = tol++;
}
//输入参数：起点、终点、点的总数
//点的编号没有影响，只要输入点的总数

int Q[MAXN];

void BFS(int start,int end)
{
    memset(dep, -1, sizeof(dep));
    memset(gap, 0, sizeof(gap));
    gap[0] = 1;
    int front = 0, rear = 0;
    dep[end] = 0;
    Q[rear++] = end;
    while (front != rear)
    {
        int u = Q[front++];
        for (int i = head[u];i != -1;i = edge[i].next)
        {
            int v = edge[i].to;
            if (dep[v] != -1) continue;
            Q[rear++] = v;
            dep[v] = dep[u] + 1;
            gap[dep[v]]++;
        }
    }
}
int S[MAXN];
int sap(int start, int end, int N)
{
    BFS(start, end);
    memcpy(cur, head, sizeof(head));
    int u = start;
    int top = 0;
    int ans = 0;
    while (dep[start] &lt; N)
    {
        if (u == end)
        {
            int Min = INF;
            int inser;
            for (int i = 0; i &lt; top; i++)
                if (Min &gt; edge[S[i]].cap - edge[S[i]].flow)
                {
                    Min = edge[S[i]].cap - edge[S[i]].flow;
                    inser = i;
                }
            for (int i = 0; i &lt; top; i++)
            {
                edge[S[i]].flow += Min;
                edge[S[i] ^ 1].flow -= Min;
            }
            ans += Min;
            top = inser;
            u = edge[S[top] ^ 1].to;
            continue;
        }
        bool flag = false;
        int v;
        for (int i = cur[u]; i != -1; i = edge[i].next)
        {
            v = edge[i].to;
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[v] + 1 == dep[u])
            {
                flag = true;
                cur[u]  = i;
                break;
            }
        }
        if (flag)
        {
            S[top++] = cur[u];
            u = v;
            continue;
        }
        int Min = N;
        for (int i = head[u]; i != -1; i = edge[i].next)
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min)
            {
                Min = dep[edge[i].to];
                cur[u] = i;
            }
        gap[dep[u]]--;
        if (!gap[dep[u]])return ans;
        dep[u] = Min + 1;
        gap[dep[u]]++;
        if (u != start) u = edge[S[--top]^1].to;
    }
    return ans;
}

int n, m;
int a[110][110];
int dir[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};

int main()
{
    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)
    {
        m = n;
        int sum = 0;
        init();
        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;=m;j++)
           {
               scanf(&quot;%d&quot;,&amp;a[i][j]);
               sum += a[i][j];
               if ((i+j) % 2 == 0)
                {
                    addedge(0,(i-1)*m+j,a[i][j]);
                }
                else
                {
                    addedge((i-1)*m+j,n*m+1,a[i][j]);
                }
           }

        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;=m;j++)
        {
            if ((i + j) % 2 == 0)
            for(int k=0;k&lt;4;k++)
            {
                int x = i + dir[k][0];
                int y = j + dir[k][1];
                if (x&gt;=1 &amp;&amp; x&lt;= n &amp;&amp;y&gt;=1 &amp;&amp; y&lt;=m)
                {
                    addedge((i-1)*m+j,(x-1)*m+y,1e9+9);
                }
            }
        }

        int ans = sum - sap(0,n*m + 1,n*m + 2);
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 1671&amp;&amp;poj 3630 Phone List 【字典树】</title>
    <url>/article/csdn/hdu_1671&amp;&amp;poj_3630_Phone_List_%E3%80%90%E5%AD%97%E5%85%B8%E6%A0%91%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46465815" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46465815</a></p>
<p>题目链接： <a href="http://acm.acmcoder.com/showproblem.php?pid=1671" target="_blank" rel="noopener"> http://acm.acmcoder.com/showproblem.php?pid=1671
</a><br>题意：问是否存在一个串是另一个串的前缀。<br>解法：建字典树，插入的串的结尾设置标志位，如果以后访问到，则存在一个串是另一个串的前缀。注意释放内存，不然超内存；（太弱，释放内存调了好久。。。<br>代码：</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;iostream&gt;  
#include &lt;string.h&gt;  
#include &lt;algorithm&gt;  
#include &lt;math.h&gt;  
#include &lt;ctype.h&gt;  
#include &lt;time.h&gt;  
#include &lt;queue&gt;  
#include &lt;iterator&gt; 

using namespace std;

typedef struct Trie
{
    int vis;
    Trie *next[10];
}Trie;

Trie *root;
int ok;

void createTrie(char str[])
{
    if (ok) return;
    int len = strlen(str);
    Trie *p = root, *q;
    int id;
    for (int i = 0; i&lt;len; ++i)
    {
        id = str[i] - &#39;0&#39;;
        if (p-&gt;next[id] == NULL)
        {
            q = new Trie;
            for (int j = 0; j&lt;10; ++j)
                q-&gt;next[j] = NULL;

            p-&gt;next[id] = q;
            p-&gt;next[id]-&gt;vis = 1;
            if (i == len-1)
                p-&gt;next[id]-&gt;vis = -1;
            p = p-&gt;next[id];
        }
        else
        {
            if (p-&gt;next[id]-&gt;vis == -1 || str[i + 1] == &#39;\0&#39;)
            {
                ok = 1;
                return;
            }
            if (i == len - 1)
                p-&gt;next[id]-&gt;vis = -1;
            p = p-&gt;next[id];
        }
    }
}

void free_memory(Trie *p)
{
    for (int i = 0; i &lt; 10; i++)
    {
        if (p-&gt;next[i] != NULL)
            free_memory(p-&gt;next[i]);
    }
    free(p);
}

char str[1001000];
int t, n;

int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        ok = 0;
        root = new Trie;
        for (int i = 0; i &lt; 10; i++)
        {
            root-&gt;next[i] = NULL;
            root-&gt;vis = 0;
        }
        scanf(&quot;%d&quot;, &amp;n);
        for (int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%s&quot;, str); 
            createTrie(str);
        }
        if (!ok)    puts(&quot;YES&quot;);
        else puts(&quot;NO&quot;);
        free_memory(root);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>代码</tag>
        <tag>内存</tag>
        <tag>插入</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 2089 不要62 【数位DP】</title>
    <url>/article/csdn/hdu_2089_%E4%B8%8D%E8%A6%8162_%E3%80%90%E6%95%B0%E4%BD%8DDP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47086635" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47086635</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2089" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=2089
</a></p>
<p>数位DP模板题，测试板子</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

#define N 12

using namespace std;
int bit[N];
int dp[N][3];

/*
      dp[i][0]:前i位不含不吉利数的个数。

　　  dp[i][1]:前i位不含不吉利数且i+1位是6的个数。

  　　dp[i][2]:前i位含不吉利数的个数。
*/

int dfs(int pos, int st, bool flag) 
{
    if (pos == 0)return st == 2;
    if (flag&amp;&amp;dp[pos][st] != -1)return dp[pos][st];
    int ans = 0;
    int u = flag ? 9 : bit[pos]; 

    for (int d = 0;d &lt;= u;d++) 
    {
        if (st == 2 || d == 4 || (st == 1 &amp;&amp; d == 2))
            ans += dfs(pos - 1, 2, flag || d&lt;u);
        else if (d == 6)
            ans += dfs(pos - 1, 1, flag || d&lt;u);
        else 
            ans += dfs(pos - 1, 0, flag || d&lt;u);
    }
    if (flag) dp[pos][st] = ans;
    return ans;
}

int solve(int n) 
{
    int len = 0;
    while (n) 
    {
        bit[++len] = n % 10;
        n /= 10;
    }
    return dfs(len, 0, 0);
}

int main() 
{
    int n, m;
    memset(dp, -1, sizeof(dp));
    while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) 
    {
        if (!(n || m))return 0;
        printf(&quot;%d\n&quot;, m - n + 1 - (solve(m) - solve(n - 1)));
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 2389 Rain on your Parade【最大匹配】</title>
    <url>/article/csdn/hdu_2389_Rain_on_your_Parade%E3%80%90%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48660071" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48660071</a></p>
<p>题目链接：<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2389" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=2389
</a></p>
<p>用 Hopcroft-Karp 算法<br>匈牙利算法会超时</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;set&gt;
#include &lt;sstream&gt;
#include &lt;time.h&gt;

using namespace std;

const int N = 3005;
const int INF = 1 &lt;&lt; 28;

int g[N][N];
int Mx[N];
int My[N];
int dx[N];
int dy[N];
bool used[N];

int Nx, Ny, dis;

bool searchP()
{
    dis = INF;
    int i, v, u;
    std::queue&lt;int&gt; Q;

    memset(dx, -1, sizeof(dx));
    memset(dy, -1, sizeof(dy));
    for (i = 0; i&lt;Nx; i++)
    {
        if (Mx[i] == -1)
        {
            Q.push(i);
            dx[i] = 0;
        }
    }
    while (!Q.empty())
    {
        u = Q.front();
        Q.pop();
        if (dx[u]&gt;dis) break;
        for (v = 0; v&lt;Ny; v++)
        {
            if (g[u][v] &amp;&amp; dy[v] == -1)
            {
                dy[v] = dx[u] + 1;
                if (My[v] == -1) dis = dy[v];
                else
                {
                    dx[My[v]] = dy[v] + 1;
                    Q.push(My[v]);
                }
            }
        }
    }
    return dis != INF;
}

bool DFS(int u)
{
    int v;
    for (v = 0; v&lt;Ny; v++)
    {
        if (g[u][v] &amp;&amp; !used[v] &amp;&amp; dy[v] == dx[u] + 1)
        {
            used[v] = true;
            if (My[v] != -1 &amp;&amp; dy[v] == dis) continue;
            if (My[v] == -1 || DFS(My[v]))
            {
                My[v] = u;
                Mx[u] = v;
                return true;
            }
        }
    }
    return false;
}

int Hungary()
{
    int u;
    int ret = 0;
    memset(Mx, -1, sizeof(Mx));
    memset(My, -1, sizeof(My));
    while (searchP())
    {
        memset(used, false, sizeof(used));
        for (u = 0; u&lt;Nx; u++)
            if (Mx[u] == -1 &amp;&amp; DFS(u))  ret++;
    }
    return ret;
}

struct Peo
{
    int x;
    int y;
    int s;
}peo[3010];

int n, m;
int main()
{
    int t, cases = 1;
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    {
        memset(g, 0, sizeof(g));
        int T, x, y;
        scanf(&quot;%d&quot;, &amp;T);
        scanf(&quot;%d&quot;, &amp;m);
        for (int i = 1;i &lt;= m;i++)
            scanf(&quot;%d%d%d&quot;, &amp;peo[i].x, &amp;peo[i].y, &amp;peo[i].s);
        scanf(&quot;%d&quot;, &amp;n);
        for (int i = 1;i &lt;= n;i++)
        {
            scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
            for (int j = 1;j &lt;= m;j++)
            {
                int Dis = ceil(sqrt((peo[j].x - x) * (peo[j].x - x) + (peo[j].y - y) * (peo[j].y - y)) * 1.0 / peo[j].s);
                if (Dis &lt;= T)
                    g[i-1][j-1] = 1;
            }
        }

        Nx = n;
        Ny = m;
        int ans = Hungary();

        printf(&quot;Scenario #%d:\n%d\n\n&quot;, cases++, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 1950 Bridging signals【LIS nlogn】</title>
    <url>/article/csdn/hdu_1950_Bridging_signals%E3%80%90LIS_nlogn%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48789059" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48789059</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1950" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=1950
</a></p>
<p>题意：LIS nlogn算法</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string&gt;
#include &lt;string.h&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;set&gt;

using namespace std;

int ans[40010];
int a[40010];
int n;

int main()
{
    int T;
    scanf(&quot;%d&quot;,&amp;T);
    while (T--)
    {
        memset(a,0,sizeof(a));
        memset(ans,0,sizeof(ans));
        scanf(&quot;%d&quot;,&amp;n);
        for(int i=1;i&lt;=n;i++)
            scanf(&quot;%d&quot;,&amp;a[i]);
        ans [1] = a[1];
        int len = 1;

        for(int i=2;i&lt;=n;i++)
        {
            if (a[i] &gt; ans[len])
                ans[++len] = a[i];
            else
            {
                int left = 1,right = len;
                while (left &lt;= right)
                {
                    int mid = (left + right)/2;
                    if (a[i] &gt;= ans[mid]) left = mid + 1;
                    else right = mid - 1;
                }
                ans [left] = a[i];
            }
        }
        printf(&quot;%d\n&quot;,len);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 2222 Keywords Search 【AC自动机】</title>
    <url>/article/csdn/hdu_2222_Keywords_Search_%E3%80%90AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44281575" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44281575</a></p>
<p>AC自动机学习资料： <a href="http://blog.csdn.net/niushuai666/article/details/7002823" target="_blank" rel="noopener"> http://blog.csdn.net/niushuai666/article/details/7002823
</a></p>
<h1><span id="keywords-search">Keywords Search</span></h1><p><strong> Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 39019    Accepted Submission(s): 12578  
</strong>  </p>
<p>Problem Description</p>
<p>In the modern time, Search engine came into the life of everybody like Google,<br>Baidu, etc.<br>Wiskey also wants to bring this feature to his image retrieval system.<br>Every image have a long description, when users type some keywords to find the<br>image, the system will match the keywords with description of image and show<br>the image which the most keywords be matched.<br>To simplify the problem, giving you a description of image, and some keywords,<br>you should tell me how many keywords will be match.  </p>
<p>Input</p>
<p>First line will contain one integer means how many cases will follow by.<br>Each case will contain two integers N means the number of keywords and N<br>keywords follow. (N  &lt;= 10000)<br>Each keyword will only contains characters ‘a’-‘z’, and the length will be not<br>longer than 50.<br>The last line is the description, and the length will be not longer than</p>
<ol start="1000000">
<li></li>
</ol>
<p>Output</p>
<p>Print how many keywords are contained in the description.</p>
<p>Sample Input</p>
<p>1 5 she he say shr her yasherhs</p>
<p>Sample Output</p>
<p>3</p>
<p>本题求给出的单词，在文本中出现了几个。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;queue&gt;

using namespace std;

struct Trie
{
    int next[500010][26], fail[500010], end[500010];
    int root, L;
    int newnode()
    {
        for (int i = 0; i &lt; 26; i++)
            next[L][i] = -1;
        end[L++] = 0;
        return L - 1;
    }
    void init()
    {
        L = 0;
        root = newnode();
    }
    void insert(char buf[])
    {
        int len = strlen(buf);
        int now = root;
        for (int i = 0; i &lt; len; i++)
        {
            if (next[now][buf[i] - &#39;a&#39;] == -1)
                next[now][buf[i] - &#39;a&#39;] = newnode();
            now = next[now][buf[i] - &#39;a&#39;];
        }
        end[now]++;
    }
    void build()
    {
        queue&lt;int&gt;Q;
        fail[root] = root;
        for (int i = 0; i &lt; 26; i++)
            if (next[root][i] == -1)
                next[root][i] = root;
            else
            {
                fail[next[root][i]] = root;
                Q.push(next[root][i]);
            }
        while (!Q.empty())
        {
            int now = Q.front();
            Q.pop();
            for (int i = 0; i &lt; 26; i++)
                if (next[now][i] == -1)
                    next[now][i] = next[fail[now]][i];
                else
                {
                    fail[next[now][i]] = next[fail[now]][i];
                    Q.push(next[now][i]);
                }
        }
    }
    int query(char buf[])
    {
        int len = strlen(buf);
        int now = root;
        int res = 0;
        for (int i = 0; i &lt; len; i++)
        {
            now = next[now][buf[i] - &#39;a&#39;];
            int temp = now;
            while (temp != root)
            {
                res += end[temp];
                end[temp] = 0;
                temp = fail[temp];
            }
        }
        return res;
    }
    void debug()
    {
        for (int i = 0; i &lt; L; i++)
        {
            printf(&quot;id = %3d,fail = %3d,end = %3d,chi = [&quot;, i, fail[i], end[i]);
            for (int j = 0; j &lt; 26; j++)
                printf(&quot;%2d&quot;, next[i][j]);
            printf(&quot;]\n&quot;);
        }
    }
}ac;

char buf[1000010];

int main()
{
    int T;
    int n;
    scanf(&quot;%d&quot;, &amp;T);
    while (T--)
    {
        scanf(&quot;%d&quot;, &amp;n);
        ac.init();
        for (int i = 0; i &lt; n; i++)
        {
            scanf(&quot;%s&quot;, buf);
            ac.insert(buf);
        }
        ac.build();
        scanf(&quot;%s&quot;, buf);
        printf(&quot;%d\n&quot;, ac.query(buf));
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 2554 N对数的排列问题 【数学】</title>
    <url>/article/csdn/hdu_2554_N%E5%AF%B9%E6%95%B0%E7%9A%84%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98_%E3%80%90%E6%95%B0%E5%AD%A6%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46380473" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46380473</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2554" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=2554
</a></p>
<p>题意：中文题目就不说了。</p>
<p>假设每个数 i 的第一次出现位置是ai ，第二次出现的位置是 bi,则可以推导出又所以解得sum of ai= n*(3n-1)/4; 要保证解为正整数。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;
#include &lt;set&gt;

using namespace std;

long long n;

int main()
{
    while (cin &gt;&gt; n &amp;&amp; n)
    {
        if (n % 4 == 0 || n*(3 * n - 1) % 4 == 0)
            puts(&quot;Y&quot;);
        else 
            puts(&quot;N&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 2255 奔小康赚大钱【最大权匹配】</title>
    <url>/article/csdn/hdu_2255_%E5%A5%94%E5%B0%8F%E5%BA%B7%E8%B5%9A%E5%A4%A7%E9%92%B1%E3%80%90%E6%9C%80%E5%A4%A7%E6%9D%83%E5%8C%B9%E9%85%8D%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46506525" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46506525</a></p>
<p>题目链接： <a href="http://acm.acmcoder.com/showproblem.php?pid=2255" target="_blank" rel="noopener"> http://acm.acmcoder.com/showproblem.php?pid=2255
</a><br>题意：中文<br>//KM算法模板题，用来测试一下模板<br>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

const int N = 310;
const int INF = 0x3f3f3f3f;

int nx, ny;

int g[N][N];
int linker[N], lx[N], ly[N];
int slack[N];
bool visx[N], visy[N];

bool dfs(int x)
{
    visx[x] = true;
    for (int y = 0; y &lt; ny; y++)
    {
        if (visy[y]) continue;
        int tmp = lx[x] + ly[y] - g[x][y];
        if (tmp == 0)
        {
            visy[y] = true;
            if (linker[y] == -1 || dfs(linker[y]))
            {
                linker[y] = x;
                return true;
            }
        }
        else if (slack[y] &gt; tmp)
            slack[y] = tmp;
    }
    return false;
}

int KM()
{
    memset(linker,-1,sizeof(linker));
    memset(ly,0,sizeof(ly));
    for (int i = 0; i &lt; nx; i++)
    {
        lx[i] = -INF;
        for (int j = 0; j &lt; ny; j++)
        {
            if (g[i][j] &gt; lx[i])
                lx[i] = g[i][j];
        }
    }
    for (int x = 0; x &lt; nx; x++)
    {
        for (int i = 0; i &lt; ny; i++)
            slack[i] = INF;
        while (true)
        {
            memset(visx, false, sizeof(visx));
            memset(visy, false, sizeof(visy));
            if (dfs(x)) break;
            int d = INF;
            for (int i = 0; i &lt; ny; i++)
                if (!visy[i] &amp;&amp; d &gt; slack[i])
                    d = slack[i];
            for (int i = 0; i &lt; nx; i++)
                if (visx[i])
                    lx[i] -= d;
            for (int i = 0; i &lt; ny; i++)
            {
                if (visy[i]) ly[i] += d;
                else slack[i] -= d;
            }
        }
    }
    int res = 0;
    for (int i = 0; i &lt; ny; i++)
    {
        if (linker[i] != -1)
            res += g[linker[i]][i];
    }
    return res;
}

int main()
{
    int n;
    while (scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        for (int i = 0; i &lt; n; i++)
            for (int j = 0; j &lt; n; j++)
                scanf(&quot;%d&quot;,&amp;g[i][j]);
        nx = ny = n;
        printf(&quot;%d\n&quot;,KM());
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 2444 The Accomodation of Students 【二分图判断+求最大匹配】</title>
    <url>/article/csdn/hdu_2444_The_Accomodation_of_Students_%E3%80%90%E4%BA%8C%E5%88%86%E5%9B%BE%E5%88%A4%E6%96%AD+%E6%B1%82%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46504889" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46504889</a></p>
<p>题目链接： <a href="http://acm.acmcoder.com/showproblem.php?pid=2444" target="_blank" rel="noopener"> http://acm.acmcoder.com/showproblem.php?pid=2444
</a></p>
<p>题意：判断所有人是否分为两个集合，每个集合里的人互不相识。</p>
<p>思路：先判断是否为二分图，是的话求最大匹配，否则输出“No”。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int n, k;
int a, b;
const int MAXN = 5010;//点
const int MAXM = 50010;//边

struct  Edge
{
    int to;
    int next;
}edge[MAXM];

int head[MAXN], tot;

void init()
{
    tot = 0;
    memset(head,-1,sizeof(head));
}

void addedge(int u,int v)
{
    edge[tot].to = v;
    edge[tot].next = head[u];
    head[u] = tot++;
}

int linker[MAXN];
bool used[MAXN];

bool dfs(int u)
{
    for (int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].to;
        if (!used[v])
        {
            used[v] = true;
            if (linker[v] == -1 || dfs(linker[v]))
            {
                linker[v] = u;
                return true;
            }
        }
    }
    return false;
}

int hungary()
{
    int ans = 0;
    memset(linker,-1,sizeof(linker));
    for (int u = 1; u &lt;= n; u++)
    {
        memset(used,false,sizeof(used));
        if (dfs(u)) ans++;
    }
    return ans;
}

int color[510];

bool bfs(int u)//染色法 判断二分图
{
    bool vis[510];
    memset(vis,false,sizeof(vis));
    for(int i=head[u];i != -1;i=edge[i].next)
    {
        int v = edge[i].to;
        if (color[v] == -1)
        {
            color[v] = !color[u];
            if (!bfs(v)) return false;
        }
        else if (color[v] == color[u])
                return false;
    }
    return true;
}

int main()
{
    while (scanf(&quot;%d%d&quot;,&amp;n,&amp;k)!=EOF)
    {
        init();
        while(k--)
        {
            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
            addedge(a,b);
            addedge(b,a);
        }
        memset(color,-1,sizeof(color));

       //染色法 判断二分图
        color[1] = 1;
        if (!bfs(1))
        {
            puts(&quot;No&quot;);
            continue;
        }

        int ans = hungary();
        printf(&quot;%d\n&quot;,ans/2);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 2594 Simpsons’ Hidden Talents 【KMP】</title>
    <url>/article/csdn/hdu_2594_Simpsons%E2%80%99_Hidden_Talents_%E3%80%90KMP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46379531" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46379531</a></p>
<p>题目链接： <a href="http://acm.acmcoder.com/showproblem.php?pid=2594" target="_blank" rel="noopener"> http://acm.acmcoder.com/showproblem.php?pid=2594
</a></p>
<p>题意：求最长的串 同时是s1的前缀又是s2的后缀。输出子串和长度。</p>
<p>思路：kmp</p>
<p>代码：</p>
<pre><code>#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

using namespace std;

char s1[500010],s2[500010];
char ANS[500010];

void get_next(char x[], int m, int Next[])
{
    int i, j;
    j = Next[0] = -1;
    i = 0;
    while (i &lt; m)
    {
        while (-1 != j &amp;&amp; x[i] != x[j]) j = Next[j];
        Next[++i] = ++j;
    }
}

int Next[1001000];
int KMP(char x[], int m, char y[], int n)//x模式串 y主串
{
    int i, j;
    i = j = 0;
    get_next(x, m, Next);
    if (n &gt; m) i = n - m;

    while (i &lt; n)
    {
         if (j == -1 || y[i] == x[j])
        {
            i++;
            j++;
        }
        else j = Next[j];
    }
    return j;
}

int main()
{
    while (cin&gt;&gt;s1&gt;&gt;s2)
    {
        int len1 = strlen(s1);
        int len2 = strlen(s2);
        int ans =  KMP(s1, len1, s2, len2);
        if (ans !=0 )
        {
            for(int i=0;i&lt;ans;i++) cout&lt;&lt;s1[i];cout&lt;&lt;&quot; &quot;;
        }
        cout&lt;&lt;ans&lt;&lt;endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 3294 Girls&#39; research【manacher】</title>
    <url>/article/csdn/hdu_3294_Girls&#39;_research%E3%80%90manacher%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/51191421" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/51191421</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=3294" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=3294
</a></p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;fstream&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;iomanip&gt;

using namespace std;


const int N = 1100550;

int p[2 * N];//记录回文半径
char str0[N];//原始串
char str[2 * N];//转换后的串

void init()
{
    int i, l;
    str[0] = &#39;@&#39;; str[1] = &#39;#&#39;;
    for (i = 0, l = 2; str0[i]; i++, l += 2)
    {
        str[l] = str0[i];
        str[l + 1] = &#39;#&#39;;
    }
    str[l] = 0;
}

int solve()
{
    int ans = 0;
    int i, mx, id;
    mx = 0;//mx即为当前计算回文串最右边字符的最大值  
    for (i = 1; str[i]; i++)
    {
        if (mx&gt;i)
            p[i] = p[2 * id - i]&gt;(mx - i) ? (mx - i) : p[2 * id - i];
        else
            p[i] = 1;//如果i&gt;=mx，要从头开始匹配  
        while (str[i + p[i]] == str[i - p[i]])
            p[i]++;
        if (i + p[i]&gt;mx)//若新计算的回文串右端点位置大于mx，要更新po和mx的值
        {
            mx = i + p[i];
            id = i;
        }
        ans = max(ans, p[i]);
    }
    return ans - 1;
}

char s1[N];

int main()
{
    while (scanf(&quot;%s %s&quot;, s1,str0) != EOF)
    {
        int tmp = s1[0] - &#39;a&#39;;
        int len = strlen(str0);
        for (int i = 0;i &lt; len;i++)
            str0[i] = &#39;a&#39; + ((str0[i] - &#39;a&#39;) - tmp + 26) % 26;

        //puts(str0);

        init();
        int ans = solve();
        if (ans &lt; 2)
        {
            puts(&quot;No solution!&quot;);
            continue;
        }

        int pos = 0;
        for (int i = 1;str[i];i++)
        {
            if (p[i] - 1 == ans)
            {
                pos = i;
                break;
            }
        }
        int pos1 = (pos - ans + 1) / 2 - 1;
        int pos2 = (pos + ans - 1) / 2 - 1;
        printf(&quot;%d %d\n&quot;, pos1, pos2);
        for (int i = pos1;i &lt;= pos2;i++)
            printf(&quot;%c&quot;, str0[i]);
        printf(&quot;\n&quot;);

    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 2686 Matrix【多线程DP】</title>
    <url>/article/csdn/hdu_2686_Matrix%E3%80%90%E5%A4%9A%E7%BA%BF%E7%A8%8BDP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/49046141" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/49046141</a></p>
<h4><span id="题目链接-httpacmhdueducnshowproblemphppid2686">题目链接： [ </span></h4><p>](<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2686" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=2686</a>)</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;

using namespace std;

int n;
int a[50][50];
int dp[35][35][35][35];

int main()
{
    while (scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        for (int i = 1;i &lt;= n;i++)
            for (int j = 1;j &lt;= n;j++)
            {
                scanf(&quot;%d&quot;, &amp;a[i][j]);
            }

        memset(dp,0,sizeof(dp));

        for (int i = 1;i &lt;= n;i++)
            for (int j = 1;j &lt;= n;j++)
                for (int k = 1;k &lt;= n;k++)
                    for (int l = 1;l &lt;= n;l++)
                    {
                        if (i == k &amp;&amp; j == l)
                        {
                            dp[i][j][k][l] = max(dp[i - 1][j][k - 1][l], max(dp[i-1][j][k][l-1],max(dp[i][j-1][k][l-1], dp[i][j-1][k-1][l]))) + a[i][j];
                        }
                        else 
                            dp[i][j][k][l] = max(dp[i - 1][j][k - 1][l], max(dp[i][j - 1][k - 1][l], max(dp[i - 1][j][k][l - 1], dp[i][j - 1][k][l - 1]))) + a[i][j] + a[k][l];

                    }
        printf(&quot;%d\n&quot;, dp[n][n][n][n]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 3488 Tour【二分图权匹配】</title>
    <url>/article/csdn/hdu_3488_Tour%E3%80%90%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9D%83%E5%8C%B9%E9%85%8D%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48339879" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48339879</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=3488" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=3488
</a></p>
<p>本题求最小权匹配，将边权值变为相反数，结果取相反数，KM即可求。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

const int N = 310;
const int INF = 0x3f3f3f3f;

int nx, ny;

int g[N][N];
int linker[N], lx[N], ly[N];
int slack[N];
bool visx[N], visy[N];

bool dfs(int x)
{
    visx[x] = true;
    for (int y = 0; y &lt; ny; y++)
    {
        if (visy[y]) continue;
        int tmp = lx[x] + ly[y] - g[x][y];
        if (tmp == 0)
        {
            visy[y] = true;
            if (linker[y] == -1 || dfs(linker[y]))
            {
                linker[y] = x;
                return true;
            }
        }
        else if (slack[y] &gt; tmp)
            slack[y] = tmp;
    }
    return false;
}

int KM()
{
    memset(linker, -1, sizeof(linker));
    memset(ly, 0, sizeof(ly));
    for (int i = 0; i &lt; nx; i++)
    {
        lx[i] = -INF;
        for (int j = 0; j &lt; ny; j++)
        {
            if (g[i][j] &gt; lx[i])
                lx[i] = g[i][j];
        }
    }
    for (int x = 0; x &lt; nx; x++)
    {
        for (int i = 0; i &lt; ny; i++)
            slack[i] = INF;
        while (true)
        {
            memset(visx, false, sizeof(visx));
            memset(visy, false, sizeof(visy));
            if (dfs(x)) break;
            int d = INF;
            for (int i = 0; i &lt; ny; i++)
                if (!visy[i] &amp;&amp; d &gt; slack[i])
                    d = slack[i];
            for (int i = 0; i &lt; nx; i++)
                if (visx[i])
                    lx[i] -= d;
            for (int i = 0; i &lt; ny; i++)
            {
                if (visy[i]) ly[i] += d;
                else slack[i] -= d;
            }
        }
    }
    int res = 0;
    for (int i = 0; i &lt; ny; i++)
    {
        if (linker[i] != -1)
            res += g[linker[i]][i];
    }
    return res;
}

int main()
{
    int t, n, m;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%d %d&quot;, &amp;n,&amp;m);
        for (int i = 0;i &lt;= n;i++)
            for (int j = 0;j &lt;= n;j++)
                g[i][j] = -INF;

        int u, v, w;
        while (m--)
        {
            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
            u--, v--;
            if (g[u][v] &lt; -w)
                g[u][v] = -1 * w;
        }
        nx = ny = n;
        printf(&quot;%d\n&quot;, -1 * KM());
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 2686 Matrix【费用流】</title>
    <url>/article/csdn/hdu_2686_Matrix%E3%80%90%E8%B4%B9%E7%94%A8%E6%B5%81%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/49099069" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/49099069</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2686" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=2686
</a></p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

using namespace std;

const int MAXN = 1010;
const int MAXM = 10010;
const int INF = 0x3f3f3f3f;

struct Edge
{
    int to,next,cap,flow,cost;
}edge[MAXM];
int head[MAXN],tol;
int pre[MAXN],dis[MAXN];
bool vis[MAXN];
int N;
void init(int n)
{
    N = n;
    tol = 0;
    memset(head,-1,sizeof(head));
}
void addedge(int u,int v,int cap,int cost)
{
    edge[tol].to = v;
    edge[tol].cap = cap;
    edge[tol].cost = cost;
    edge[tol].flow = 0;
    edge[tol].next = head[u];
    head[u] = tol++;
    edge[tol].to = u;
    edge[tol].cap = 0;
    edge[tol].cost = -cost;
    edge[tol].flow = 0;
    edge[tol].next = head[v];
    head[v] = tol++;
}
bool spfa(int s,int t)
{
    queue&lt;int&gt;q;
    for(int i = 0;i &lt; N;i++)
    {
        dis[i] = INF;
        vis[i] = false;
        pre[i] = -1;
    }
    dis[s] = 0;
    vis[s] = true;
    q.push(s);
    while(!q.empty())
    {
        int u = q.front();
        q.pop();
        vis[u] = false;
        for(int i = head[u];i != -1;i = edge[i].next)
        {
            int v = edge[i].to;
            if(edge[i].cap &gt; edge[i].flow &amp;&amp;
                    dis[v] &gt; dis[u] +edge[i].cost)
            {
                dis[v] = dis[u] + edge[i].cost;
                pre[v] = i;
                if(!vis[v])
                {
                    vis[v] = true;
                    q.push(v);
                }
            }
        }
    }
    if(pre[t] == -1)return false;
    else return true;
}
int minCostMaxflow(int s,int t,int &amp;cost)
{
    int flow = 0;
    cost = 0;
    while(spfa(s,t))
    {
        int Min = INF;
        for(int i = pre[t];i != -1 ;i = pre[edge[i^1].to])
        {
            if(Min &gt; edge[i].cap - edge[i].flow)
                Min = edge[i].cap - edge[i].flow;
        }
        for(int i = pre[t];i != -1;i = pre[edge[i^1].to])
        {
            edge[i].flow += Min;
            edge[i^1].flow -= Min;
            cost += edge[i].cost*Min;
        }
        flow += Min;
    }
    return flow;
}

int n;
int a[100][100];
bool is_ok(int x,int y)
{
    if (x&gt;=1 &amp;&amp; x &lt;= n&amp;&amp; y&gt;=1 &amp;&amp; y &lt;= n) return true;
    return false;
}
int main()
{
    while (scanf(&quot;%d&quot;,&amp;n)!=EOF)
    {
        init(n*n*2+2);
        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;=n;j++)
            {
                scanf(&quot;%d&quot;,&amp;a[i][j]);
                addedge((i-1)*n +j,(i-1)*n+j+n*n,1,-a[i][j]);
            }
        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;=n;j++)
        {
            if (is_ok(i+1,j))
            {
                addedge((i-1)*n + j+n*n,i*n +j,1,0);
            }
            if (is_ok(i,j+1))
            {
                addedge((i-1)*n + j+n*n,(i-1)*n +j+1,1,0);
            }
        }
        addedge(0,1+n*n,2,0);
        addedge(n*n,n*n*2+1,2,0);
        int ans;
        int tmp = minCostMaxflow(0,n*n*2+1,ans);
        ans = -ans;
        ans+=a[1][1] + a[n][n];
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 3336 Count the string 【kmp + dp】</title>
    <url>/article/csdn/hdu_3336_Count_the_string_%E3%80%90kmp_+_dp%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46380469" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46380469</a></p>
<p>题目链接： <a href="http://acm.acmcoder.com/showproblem.php?pid=3336" target="_blank" rel="noopener"> http://acm.acmcoder.com/showproblem.php?pid=3336
</a></p>
<p>题意：求给出的字符串的所有前缀出现的次数和。</p>
<p>dp的思想还是看的别人的题解。窝就不写啦。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;
#include &lt;set&gt;

using namespace std;

const int MOD = 10007;
int t, ans, n;
char s[200010];

void get_next(char x[], int m, int Next[])
{
    memset(Next,0,sizeof(Next));
    int i, j;
    j = Next[0] = -1;
    i = 0;
    while (i &lt; m)
    {
        while (-1 != j &amp;&amp; x[i] != x[j]) j = Next[j];
        Next[++i] = ++j;
    }
}

int Next[200010];
int dp[200010];

int main()
{
    cin &gt;&gt; t;
    while (t--)
    {
        ans = 0;
        memset(dp,0,sizeof(dp));
        cin &gt;&gt; n &gt;&gt; s;
        get_next(s, n, Next);

        for (int i = 1; i &lt;= n; i++)
        {
            dp[i] = (dp[Next[i]] + 1) % MOD;
            ans = (ans + dp[i]) % MOD;
        }
        cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 3555 Bomb 【数位DP】</title>
    <url>/article/csdn/hdu_3555_Bomb_%E3%80%90%E6%95%B0%E4%BD%8DDP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47086957" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47086957</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=3555" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=3555
</a></p>
<p>题意：上一题是不要62 这个是“不要49”</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

#define N 50

using namespace std;
int bit[N];
long long dp[N][3];

/*
      dp[i][0]:前i位不含 49 的个数。

　　  dp[i][1]:前i位不含 49 数且i+1位是4的个数。

  　　dp[i][2]:前i位含 49 的个数。
*/

long long dfs(int pos, int st, bool flag) 
{
    if (pos == 0) return st == 2;
    if (flag &amp;&amp; dp[pos][st] != -1) return dp[pos][st];
    long long ans = 0;
    int u = flag ? 9 : bit[pos]; 

    for (int d = 0;d &lt;= u;d++) 
    {
        if (st == 2 || (st == 1 &amp;&amp; d == 9))
            ans += dfs(pos - 1, 2, flag || d&lt;u);
        else if (d == 4)
            ans += dfs(pos - 1, 1, flag || d&lt;u);
        else 
            ans += dfs(pos - 1, 0, flag || d&lt;u);
    }
    if (flag) dp[pos][st] = ans;
    return ans;
}

long long solve(long long n) 
{
    int len = 0;
    while (n) 
    {
        bit[++len] = n % 10;
        n /= 10;
    }
    return dfs(len, 0, 0);
}

int main() 
{
    long long n;
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--) 
    {
        scanf(&quot;%lld&quot;, &amp;n);
        memset(dp, -1, sizeof(dp));
        printf(&quot;%lld\n&quot;, solve(n));
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 3667 Transportation【费用流 + 拆边】</title>
    <url>/article/csdn/hdu_3667_Transportation%E3%80%90%E8%B4%B9%E7%94%A8%E6%B5%81_+_%E6%8B%86%E8%BE%B9%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48219657" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48219657</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=3667" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=3667
</a></p>
<p>解法：大白书366页，拆边法</p>
<p>SPFA代码（AC）：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;sstream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;string&gt;

using namespace std;

const int MAXN = 10000;
const int MAXM = 200000;
const int INF = 0x3f3f3f3f;
struct Edge
{
    int to, next, cap, flow, cost;
}edge[MAXM];
int head[MAXN], tol;
int pre[MAXN], dis[MAXN];
bool vis[MAXN];
int N;
void init(int n)
{
    N = n;
    tol = 0;
    memset(head, -1, sizeof(head));
}
void addedge(int u, int v, int cap, int cost)
{
    edge[tol].to = v;
    edge[tol].cap = cap;
    edge[tol].cost = cost;
    edge[tol].flow = 0;
    edge[tol].next = head[u];
    head[u] = tol++;
    edge[tol].to = u;
    edge[tol].cap = 0;
    edge[tol].cost = -cost;
    edge[tol].flow = 0;
    edge[tol].next = head[v];
    head[v] = tol++;
}
bool spfa(int s, int t)
{
    queue&lt;int&gt;q;
    for (int i = 0;i &lt; N;i++)
    {
        dis[i] = INF;
        vis[i] = false;
        pre[i] = -1;
    }
    dis[s] = 0;
    vis[s] = true;
    q.push(s);
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        vis[u] = false;
        for (int i = head[u];i != -1;i = edge[i].next)
        {
            int v = edge[i].to;
            if (edge[i].cap &gt; edge[i].flow &amp;&amp;
                dis[v] &gt; dis[u] + edge[i].cost)
            {
                dis[v] = dis[u] + edge[i].cost;
                pre[v] = i;
                if (!vis[v])
                {
                    vis[v] = true;
                    q.push(v);
                }
            }
        }
    }
    if (pre[t] == -1)return false;
    else return true;
}
int minCostMaxflow(int s, int t, int &amp;cost)
{
    int flow = 0;
    cost = 0;
    while (spfa(s, t))
    {
        int Min = INF;
        for (int i = pre[t];i != -1;i = pre[edge[i ^ 1].to])
        {
            if (Min &gt; edge[i].cap - edge[i].flow)
                Min = edge[i].cap - edge[i].flow;
        }
        for (int i = pre[t];i != -1;i = pre[edge[i ^ 1].to])
        {
            edge[i].flow += Min;
            edge[i ^ 1].flow -= Min;
            cost += edge[i].cost*Min;
        }
        flow += Min;
    }
    return flow;
}

int n, m, k, ans;
int cnt[10] = { 0,1,3,5,7,9 };

int main()
{
    while (~scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k))
    {
        init(n + 2);
        addedge(0, 1, k, 0);
        addedge(n, n + 1, k, 0);

        int u, v, a, c;
        for (int i = 1;i &lt;= m;i++)
        {
            scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;a, &amp;c);
            for (int j = 1;j &lt;= c;j++)
                addedge(u, v, 1, a*cnt[j]);
        }

        int tmp = minCostMaxflow(0, n + 1, ans);
        if (ans &lt; k) puts(&quot;-1&quot;);
        else printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}
</code></pre><p>zkw费用流代码（超时）（对二分图类型效率高）：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;sstream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;string&gt;

using namespace std;

const int MAXN = 1000;
const int MAXM = 200000;
const int INF = 0x3f3f3f3f;
struct Edge
{
    int to, next, cap, flow, cost;
    Edge(int _to = 0, int _next = 0, int _cap = 0, int _flow = 0, int _cost = 0) :
        to(_to), next(_next), cap(_cap), flow(_flow), cost(_cost) {}
}edge[MAXM];

struct ZKW_MinCostMaxFlow
{
    int head[MAXN], tot;
    int cur[MAXN];
    int dis[MAXN];
    bool vis[MAXN];
    int ss, tt, N;//源点、汇点和点的总个数（编号是0~N-1）,不需要额外赋值，调用会直接赋值
    int min_cost, max_flow;
    void init()
    {
        tot = 0;
        memset(head, -1, sizeof(head));
    }
    void addedge(int u, int v, int cap, int cost)
    {
        edge[tot] = Edge(v, head[u], cap, 0, cost);
        head[u] = tot++;
        edge[tot] = Edge(u, head[v], 0, 0, -cost);
        head[v] = tot++;
    }
    int aug(int u, int flow)
    {
        if (u == tt)return flow;
        vis[u] = true;
        for (int i = cur[u];i != -1;i = edge[i].next)
        {
            int v = edge[i].to;
            if (edge[i].cap &gt; edge[i].flow &amp;&amp; !vis[v] &amp;&amp; dis[u] == dis[v] + edge[i].cost)
            {
                int tmp = aug(v, min(flow, edge[i].cap - edge[i].flow));
                edge[i].flow += tmp;
                edge[i ^ 1].flow -= tmp;
                cur[u] = i;
                if (tmp)return tmp;
            }
        }
        return 0;
    }
    bool modify_label()
    {
        int d = INF;
        for (int u = 0;u &lt; N;u++)
            if (vis[u])
                for (int i = head[u];i != -1;i = edge[i].next)
                {
                    int v = edge[i].to;
                    if (edge[i].cap&gt;edge[i].flow &amp;&amp; !vis[v])
                        d = min(d, dis[v] + edge[i].cost - dis[u]);
                }
        if (d == INF)return false;
        for (int i = 0;i &lt; N;i++)
            if (vis[i])
            {
                vis[i] = false;
                dis[i] += d;

            }
        return true;
    }
    /*
    * 直接调用获取最小费用和最大流
    * 输入: start-源点，end-汇点，n-点的总个数（编号从0开始）
    * 返回值: pair&lt;int,int&gt; 第一个是最小费用，第二个是最大流
    */
    pair&lt;int, int&gt; mincostmaxflow(int start, int end, int n)
    {
        ss = start, tt = end, N = n;
        min_cost = max_flow = 0;
        for (int i = 0;i &lt; n;i++)dis[i] = 0;
        while (1)
        {
            for (int i = 0;i &lt; n;i++)cur[i] = head[i];
            while (1)
            {
                for (int i = 0;i &lt; n;i++)vis[i] = false;
                int tmp = aug(ss, INF);
                if (tmp == 0)break;
                max_flow += tmp;
                min_cost += tmp*dis[ss];
            }
            if (!modify_label())break;
        }
        return make_pair(min_cost, max_flow);
    }
}solve;

int n, m, k;
int cnt[10] = { 0,1,3,5,7,9 };

int main()
{
    while (~scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k))
    {
        solve.init();

        solve.addedge(0, 1, k, 0);
        solve.addedge(n, n + 1, k, 0);

        int u, v, a, c;
        for (int i = 1;i &lt;= m;i++)
        {
            scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;a, &amp;c);
            for (int j = 1;j &lt;= c;j++)
                solve.addedge(u, v, 1, a*cnt[j]);
        }

        pair&lt;int, int&gt; tmp = solve.mincostmaxflow(0, n + 1, n + 2);
        int ans = tmp.second;
        if (ans &lt; k) puts(&quot;-1&quot;);
        else printf(&quot;%d\n&quot;, tmp.first);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 3829 Cat VS Dog【最大独立集】</title>
    <url>/article/csdn/hdu_3829_Cat_VS_Dog%E3%80%90%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48340789" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48340789</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=3829" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=3829
</a></p>
<p>小朋友间建立互斥关系。<br>只有一个小朋友的集合，用拆点的思想，把每个小朋友拆成2个小朋友，这样在求最大匹配的时候除以2就可以了。就必须建立双向边，比如1和2之间有矛盾，建立1-2矛盾边，2-1矛盾边。</p>
<p>最大独立集 = 点数 - 最大匹配数。</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;sstream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  

using namespace std;

int n, m, k;
int p[1000][1000];
int book[1000];
int match[1000];

int dfs(int u)
{
    int i;
    for (i = 1; i &lt;= k; i++)
    {
        if (book[i] == 0 &amp;&amp; p[u][i] == 1)
        {
            book[i] = 1;
            if (match[i] == 0 || dfs(match[i]))
            {
                match[i] = u;
                return 1;
            }
        }
    }
    return 0;
}

struct stu
{
    string like;
    string dislike;
}st[1100];

int main()
{
    while (~scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k))
    {
        int ans = 0;
        memset(match, 0, sizeof(match));
        memset(p, 0, sizeof(p));

        string u, v;
        for (int i = 1;i &lt;= k;i++)
        {
            cin &gt;&gt; u &gt;&gt; v;  
            st[i].like = u;
            st[i].dislike = v;  
        }

        for (int i = 1;i &lt;= k;i++)
            for (int j = 1;j &lt;= k;j++)
            {
                if (st[i].like == st[j].dislike || st[i].dislike == st[j].like)
                    p[i][j]  = p[j][i] = 1;
            }

        for (int i = 1; i &lt;= k; i++)
        {
            memset(book, 0, sizeof(book));
            if (dfs(i))
                ans++;
        }
        printf(&quot;%d\n&quot;, k - ans/2);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 3605 Escape【二分图多重匹配】</title>
    <url>/article/csdn/hdu_3605_Escape%E3%80%90%E4%BA%8C%E5%88%86%E5%9B%BE%E5%A4%9A%E9%87%8D%E5%8C%B9%E9%85%8D%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48933401" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48933401</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=3605" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=3605
</a></p>
<p>多重匹配</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;sstream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;string&gt;

using namespace std;

const int MAXN = 101000;//左点数
const int MAXM = 12;//右
int un, vn;

int g[MAXN][MAXM];
int linker[MAXM][MAXN];
bool used[MAXM];
int num[MAXM];

bool dfs(int u)
{
    for (int v = 0;v &lt; vn;v++)
    {
        if (g[u][v] &amp;&amp; !used[v])
        {
            used[v] = true;
            if (linker[v][0] &lt; num[v])
            {
                linker[v][++linker[v][0]] = u;
                return true;
            }
            for (int i = 1;i &lt;= num[v];i++)
            {
                if (dfs(linker[v][i]))
                {
                    linker[v][i] = u;
                    return true;
                }
            }
        }
    }
    return false;
}

bool hungry()
{
    int res = 0;
    for (int i = 0;i &lt; vn;i++)
        linker[i][0] = 0;
    for (int i = 0;i &lt; un;i++)
    {
        memset(used, false, sizeof(used));
        if (!dfs(i)) return false;
    }
    return true;
}

int main()
{
    while (scanf(&quot;%d%d&quot;, &amp;un, &amp;vn) != EOF)
    {
        memset(g, 0, sizeof(g));
        memset(num, 0, sizeof(num));
        memset(linker,0,sizeof(linker));

        for (int i = 0;i &lt; un;i++)
            for (int j = 0;j &lt; vn;j++)
                scanf(&quot;%d&quot;, &amp;g[i][j]);
        for (int i = 0;i &lt; vn;i++)
            scanf(&quot;%d&quot;, &amp;num[i]);
        if (hungry()) puts(&quot;YES&quot;);
        else puts(&quot;NO&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 3853 LOOPS 【概率DP】</title>
    <url>/article/csdn/hdu_3853_LOOPS_%E3%80%90%E6%A6%82%E7%8E%87DP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46425443" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46425443</a></p>
<p>题目链接： <a href="http://acm.acmcoder.com/showproblem.php?pid=3853" target="_blank" rel="noopener"> http://acm.acmcoder.com/showproblem.php?pid=3853
</a><br>题意：求走到终点消耗能量的期望。<br>解法：<br>dp[i][j] 表示走到 i行j列 的期望。<br>dp[i][j] 可以转移到 dp[i][j+1] 和 dp[i+1][j] 和 dp[i][j]<br>各个转移的概率已经给出，由dp[n][m] == 0倒推即可。答案为dp[1][1]<br>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;vector&gt;  
#include &lt;string&gt;  
#include &lt;algorithm&gt;  
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;fstream&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;math.h&gt;

using namespace std;

const int MAXN = 100010;
#define eps 1e-5

int n, m;
double p[1010][1010][3];
double dp[1010][1010];

int main()
{
    while (scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)
    {
        memset(p,0,sizeof p);
        memset(dp, 0, sizeof dp);
        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= m; j++)
                for (int k = 1; k &lt;= 3; k++)
                    scanf(&quot;%lf&quot;,&amp;p[i][j][k]);

        dp[n][m] = 0;
        for (int i = n; i &gt;= 1; i--)
            for (int j = m; j &gt;= 1; j--)
            {
                if (i == n &amp;&amp; j == m) continue;
                if (1 - p[i][j][1] &lt; eps) continue;//注意这里
                if (j + 1 &lt;= m ) dp[i][j] += dp[i][j+1] * p[i][j][2];
                if (i+1 &lt;= n) dp[i][j] += dp[i+1][j] * p[i][j][3];

                dp[i][j] += 2.0;

                dp[i][j] = dp[i][j] / (double(1.0) - p[i][j][1]);
            }
        printf(&quot;%.3lf\n&quot;,dp[1][1]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 4185 Oil Skimming 【最大匹配】</title>
    <url>/article/csdn/hdu_4185_Oil_Skimming_%E3%80%90%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48658549" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48658549</a></p>
<p>题目链接：<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4185" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=4185
</a></p>
<p>题意：</p>
<p>求给的矩阵中 最多有几个 横着或竖着的 两个相连的“##”</p>
<p>裸的最大匹配<br>数据较水。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;set&gt;
#include &lt;sstream&gt;
#include &lt;time.h&gt;

using namespace std;


char s[1010][1010];
int n;
int p[1010][1010];
int book[1010];
int match[1010];
bool vis[1010];
int map[1010][1010];
int tot;

bool dfs(int u)
{
    int i;
    for (i = 0; i &lt; tot; i++)
    {
        if (book[i] == 0 &amp;&amp; map[u][i] == 1)
        {
            book[i] = 1;
            if (match[i] == 0 || dfs(match[i]))
            {
                match[i] = u;
                return true;
            }
        }
    }
    return false;
}

int dir[4][2] = { {1,0},{-1,0},{0,1},{0,-1} };
bool is_ok(int x,int y)
{
    if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= n) return false;
    else return true;
}

int main()
{
    int t, cases = 1;
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    {
        memset(p, 0, sizeof(p));
        memset(match, 0, sizeof(match));
        memset(vis, 0, sizeof(vis));
        memset(map,0,sizeof(map));

        scanf(&quot;%d&quot;, &amp;n);
        for (int i = 0;i &lt; n;i++)
            scanf(&quot;%s&quot;, s[i]);

        tot = 0;
        for (int i = 0;i &lt; n;i++)
            for (int j = 0;j &lt; n;j++)
                if (s[i][j] == &#39;#&#39;) p[i][j] = tot++;

        for (int i = 0;i &lt; n;i++)
            for (int j = 0;j &lt; n;j++)
            {
                if (s[i][j] == &#39;#&#39;)
                {
                    for (int k = 0;k &lt; 4;k++)
                    {
                        int x = i + dir[k][0];
                        int y = j + dir[k][1];
                        if (!is_ok(x, y)) continue;
                        if (s[x][y] == &#39;#&#39;)
                        {
                            map[p[i][j]][p[x][y]] = 1;
                            map[p[x][y]][p[i][j]] = 1;
                        }
                    }
                }
            }

        int ans = 0;
        for (int i = 0; i &lt; tot; i++)
        {
            memset(book, 0, sizeof(book));
            if (dfs(i))
                ans++;
        }
        printf(&quot;Case %d: %d\n&quot;, cases++, ans / 2);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 3879 Base Station【最大权闭合图】</title>
    <url>/article/csdn/hdu_3879_Base_Station%E3%80%90%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%9B%BE%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48281573" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48281573</a></p>
<h4><span id="最大权闭合图学习资料">最大权闭合图学习资料： [</span></h4><p><a href="http://www.cnblogs.com/wuyiqi/archive/2012/03/12/2391960.html" target="_blank" rel="noopener">http://www.cnblogs.com/wuyiqi/archive/2012/03/12/2391960.html</a><br>](<a href="http://www.cnblogs.com/wuyiqi/archive/2012/03/12/2391960.html" target="_blank" rel="noopener">http://www.cnblogs.com/wuyiqi/archive/2012/03/12/2391960.html</a>)</p>
<p>最大权 = 正的权值的和-建图后的最小割的容量。</p>
<hr>
<p>题目连接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=3879" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=3879
</a></p>
<p>题意：有n个点，m个选择，建造n个点各自需要一定花费，每个选择有一定的获利，会选择两个点。求最大的获利</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;sstream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;string&gt;

using namespace std;

const int MAXN = 101000;//点数的最大值
const int MAXM = 4001000;//边数的最大值
const int INF = 0x3f3f3f3f;

struct Edge
{
    int to, next, cap, flow;
}edge[MAXM];//注意是MAXM

int tol;
int head[MAXN];
int gap[MAXN], dep[MAXN], pre[MAXN], cur[MAXN];

void init()
{
    tol = 0;
    memset(head, -1, sizeof(head));
}
//加边，单向图三个参数，双向图四个参数
void addedge(int u, int v, int w, int rw = 0)
{
    edge[tol].to = v; edge[tol].cap = w; edge[tol].next = head[u];
    edge[tol].flow = 0; head[u] = tol++;
    edge[tol].to = u; edge[tol].cap = rw; edge[tol].next = head[v];
    edge[tol].flow = 0; head[v] = tol++;
}
//输入参数：起点、终点、点的总数
//点的编号没有影响，只要输入点的总数
int sap(int start, int end, int N)
{
    memset(gap, 0, sizeof(gap));
    memset(dep, 0, sizeof(dep));
    memcpy(cur, head, sizeof(head));
    int u = start;
    pre[u] = -1;
    gap[0] = N;
    int ans = 0;
    while (dep[start] &lt; N)
    {
        if (u == end)
        {
            int Min = INF;
            for (int i = pre[u]; i != -1; i = pre[edge[i ^ 1].to])
                if (Min &gt; edge[i].cap - edge[i].flow)
                    Min = edge[i].cap - edge[i].flow;
            for (int i = pre[u]; i != -1; i = pre[edge[i ^ 1].to])
            {
                edge[i].flow += Min;
                edge[i ^ 1].flow -= Min;
            }
            u = start;
            ans += Min;
            continue;
        }
        bool flag = false;
        int v;
        for (int i = cur[u]; i != -1; i = edge[i].next)
        {
            v = edge[i].to;
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[v] + 1 == dep[u])
            {
                flag = true;
                cur[u] = pre[v] = i;
                break;
            }
        }
        if (flag)
        {
            u = v;
            continue;
        }
        int Min = N;
        for (int i = head[u]; i != -1; i = edge[i].next)
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min)
            {
                Min = dep[edge[i].to];
                cur[u] = i;
            }
        gap[dep[u]]--;
        if (!gap[dep[u]])return ans;
        dep[u] = Min + 1;
        gap[dep[u]]++;
        if (u != start) u = edge[pre[u] ^ 1].to;
    }
    return ans;
}

int n, m;
const int inf = 1e9;

int main()
{
    while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)
    {
        init();
        int x;
        int s = 0, t = n + m + 1;
        for (int i = 1;i &lt;= n;i++)
        {
            scanf(&quot;%d&quot;, &amp;x);
            addedge(i, t, x);
        }
        int a, b, c;
        int tmp = 0;
        for (int i = 1;i &lt;= m;i++)
        {
            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
            tmp += c;
            addedge(s, i + n, c);
            addedge(i + n, a, inf);
            addedge(i + n, b, inf);
        }
        int ans = tmp - sap(s, t, n + m + 2);
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 4280 Island Transport 【网络流+优化】</title>
    <url>/article/csdn/hdu_4280_Island_Transport_%E3%80%90%E7%BD%91%E7%BB%9C%E6%B5%81+%E4%BC%98%E5%8C%96%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48254763" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48254763</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=4280" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=4280
</a></p>
<p>题意：给你点坐标，由右下角向左上角走的最大流。卡时间</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;sstream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;string&gt;

using namespace std;

const int MAXN = 101000;//点数的最大值
const int MAXM = 400100;//边数的最大值
const int INF = 0x3f3f3f3f;

struct Edge
{
    int to, next, cap, flow;
}edge[MAXM];//注意是MAXM

int tol;
int head[MAXN];
int gap[MAXN], dep[MAXN], pre[MAXN], cur[MAXN];

void init()
{
    tol = 0;
    memset(head, -1, sizeof(head));
}
//加边，单向图三个参数，双向图四个参数
void addedge(int u, int v, int w, int rw = 0)
{
    edge[tol].to = v; edge[tol].cap = w; edge[tol].next = head[u];
    edge[tol].flow = 0; head[u] = tol++;
    edge[tol].to = u; edge[tol].cap = rw; edge[tol].next = head[v];
    edge[tol].flow = 0; head[v] = tol++;
}
//输入参数：起点、终点、点的总数
//点的编号没有影响，只要输入点的总数

int Q[MAXN];

void BFS(int start,int end)
{
    memset(dep, -1, sizeof(dep));
    memset(gap, 0, sizeof(gap));
    gap[0] = 1;
    int front = 0, rear = 0;
    dep[end] = 0;
    Q[rear++] = end;
    while (front != rear)
    {
        int u = Q[front++];
        for (int i = head[u];i != -1;i = edge[i].next)
        {
            int v = edge[i].to;
            if (dep[v] != -1) continue;
            Q[rear++] = v;
            dep[v] = dep[u] + 1;
            gap[dep[v]]++;
        }
    }
}
int S[MAXN];
int sap(int start, int end, int N)
{
    BFS(start, end);
    memcpy(cur, head, sizeof(head));
    int u = start;
    int top = 0;
    int ans = 0;
    while (dep[start] &lt; N)
    {
        if (u == end)
        {
            int Min = INF;
            int inser;
            for (int i = 0; i &lt; top; i++)
                if (Min &gt; edge[S[i]].cap - edge[S[i]].flow)
                {
                    Min = edge[S[i]].cap - edge[S[i]].flow;
                    inser = i;
                }
            for (int i = 0; i &lt; top; i++)
            {
                edge[S[i]].flow += Min;
                edge[S[i] ^ 1].flow -= Min;
            }
            ans += Min;
            top = inser;
            u = edge[S[top] ^ 1].to;
            continue;
        }
        bool flag = false;
        int v;
        for (int i = cur[u]; i != -1; i = edge[i].next)
        {
            v = edge[i].to;
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[v] + 1 == dep[u])
            {
                flag = true;
                cur[u]  = i;
                break;
            }
        }
        if (flag)
        {
            S[top++] = cur[u];
            u = v;
            continue;
        }
        int Min = N;
        for (int i = head[u]; i != -1; i = edge[i].next)
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min)
            {
                Min = dep[edge[i].to];
                cur[u] = i;
            }
        gap[dep[u]]--;
        if (!gap[dep[u]])return ans;
        dep[u] = Min + 1;
        gap[dep[u]]++;
        if (u != start) u = edge[S[--top]^1].to;
    }
    return ans;
}

int n, m;

int main()
{
    int T;
    scanf(&quot;%d&quot;,&amp;T);
    while (T--)
    {
        init();
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        int MAX = -1e9, MIN = 1e9;
        int s, t;
        int x, y, z;
        for (int i = 1;i &lt;= n;i++)
        {
            scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
            if (x &lt; MIN)
            {
                MIN = x ;
                s = i;
            }
            else if (x &gt; MAX)
            {
                MAX = x;
                t = i;
            }
        }
        while (m--)
        {
            scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);
            addedge(x, y, z, z);
        }
        int ans = sap(s, t, n);
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 4289 Control【最小割+拆点】</title>
    <url>/article/csdn/hdu_4289_Control%E3%80%90%E6%9C%80%E5%B0%8F%E5%89%B2+%E6%8B%86%E7%82%B9%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48227377" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48227377</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=4289" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=4289
</a></p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;sstream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;string&gt;

using namespace std;

#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;sstream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;string&gt;

using namespace std;

const int MAXN = 1010;//点数的最大值
const int MAXM = 400100;//边数的最大值
const int INF = 0x3f3f3f3f;

struct Edge
{
    int to, next, cap, flow;
}edge[MAXM];//注意是MAXM

int tol;
int head[MAXN];
int gap[MAXN], dep[MAXN], pre[MAXN], cur[MAXN];

void init()
{
    tol = 0;
    memset(head, -1, sizeof(head));
}
//加边，单向图三个参数，双向图四个参数
void addedge(int u, int v, int w, int rw = 0)
{
    edge[tol].to = v; edge[tol].cap = w; edge[tol].next = head[u];
    edge[tol].flow = 0; head[u] = tol++;
    edge[tol].to = u; edge[tol].cap = rw; edge[tol].next = head[v];
    edge[tol].flow = 0; head[v] = tol++;
}
//输入参数：起点、终点、点的总数
//点的编号没有影响，只要输入点的总数
int sap(int start, int end, int N)
{
    memset(gap, 0, sizeof(gap));
    memset(dep, 0, sizeof(dep));
    memcpy(cur, head, sizeof(head));
    int u = start;
    pre[u] = -1;
    gap[0] = N;
    int ans = 0;
    while (dep[start] &lt; N)
    {
        if (u == end)
        {
            int Min = INF;
            for (int i = pre[u]; i != -1; i = pre[edge[i ^ 1].to])
                if (Min &gt; edge[i].cap - edge[i].flow)
                    Min = edge[i].cap - edge[i].flow;
            for (int i = pre[u]; i != -1; i = pre[edge[i ^ 1].to])
            {
                edge[i].flow += Min;
                edge[i ^ 1].flow -= Min;
            }
            u = start;
            ans += Min;
            continue;
        }
        bool flag = false;
        int v;
        for (int i = cur[u]; i != -1; i = edge[i].next)
        {
            v = edge[i].to;
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[v] + 1 == dep[u])
            {
                flag = true;
                cur[u] = pre[v] = i;
                break;
            }
        }
        if (flag)
        {
            u = v;
            continue;
        }
        int Min = N;
        for (int i = head[u]; i != -1; i = edge[i].next)
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min)
            {
                Min = dep[edge[i].to];
                cur[u] = i;
            }
        gap[dep[u]]--;
        if (!gap[dep[u]])return ans;
        dep[u] = Min + 1;
        gap[dep[u]]++;
        if (u != start) u = edge[pre[u] ^ 1].to;
    }
    return ans;
}

int n, m;

int main()
{
    while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))
    {
        init();
        int s, t;
        scanf(&quot;%d%d&quot;, &amp;s, &amp;t);

        int x;
        for (int i = 1;i &lt;= n;i++)
        {
            scanf(&quot;%d&quot;, &amp;x);
            addedge(i, i + n, x, x);
        }
        int a, b;
        while (m--)
        {
            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
            addedge(a + n, b, 100000000);
            addedge(b + n, a, 100000000);
        }
        int ans = sap(s, t + n, n * 2);
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 4405 Aeroplane chess【概率DP求期望】</title>
    <url>/article/csdn/hdu_4405_Aeroplane_chess%E3%80%90%E6%A6%82%E7%8E%87DP%E6%B1%82%E6%9C%9F%E6%9C%9B%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46424577" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46424577</a></p>
<p>题目链接： <a href="http://acm.acmcoder.com/showproblem.php?pid=4405" target="_blank" rel="noopener"> http://acm.acmcoder.com/showproblem.php?pid=4405
</a><br>题意：棋子，从0到n，置骰子，置到几就往前走几步，前进中会有捷径，比如2和5连到一起了，那你走到2时可以直接跳到5，如果5和8连到一起了，那你还可以继续跳到8，最后问跳到n时平均置几次骰子。也就是求期望。<br>解法：普通概率ＤＰ，dp[n] == 0 ;向前递推。<br>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;vector&gt;  
#include &lt;string&gt;  
#include &lt;algorithm&gt;  
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;fstream&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;math.h&gt;

using namespace std;

const int MAXN = 100010;
int p[MAXN];
int m, n, x, y;
int ex[MAXN];
double dp[MAXN];

int main()
{
    while (cin &gt;&gt; n &gt;&gt; m)
    {
        if (n == 0 &amp;&amp; m == 0) break;
        memset(dp,0,sizeof(dp));
        memset(ex,-1,sizeof(ex));
        for (int i = 1; i &lt;= m; i++)
        {
            cin &gt;&gt; x &gt;&gt; y;
            ex[x] = y;
        }

        for (int i = n - 1; i &gt;= 0; i--)
        {
            if (ex[i] != -1) dp[i] = dp[ex[i]];
            else
            {
                for (int j = 1; j &lt;= 6; j++)
                {
                    if (i + j &gt;= n)
                        dp[i] += (1.0 / 6) * dp[n];
                    else 
                        dp[i] += (1.0/6) * dp[i + j];
                }
                dp[i] +=  1;
            }
        }
        printf(&quot;%.4lf\n&quot;,dp[0]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 4738 Caocao&#39;s Bridges【求最小权值的桥】</title>
    <url>/article/csdn/hdu_4738_Caocao&#39;s_Bridges%E3%80%90%E6%B1%82%E6%9C%80%E5%B0%8F%E6%9D%83%E5%80%BC%E7%9A%84%E6%A1%A5%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48500303" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48500303</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=4738" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=4738
</a></p>
<p>坑：<br>不连通的，输出0.<br>图有重边，需要处理。<br>如果取到的最小值是0的话，要输出1。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;ctime&gt;  
#include &lt;math.h&gt;  
#include &lt;limits.h&gt;  
#include &lt;complex&gt;  
#include &lt;string&gt;  
#include &lt;functional&gt;  
#include &lt;iterator&gt;  
#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;stack&gt;  
#include &lt;queue&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;list&gt;  
#include &lt;bitset&gt;  
#include &lt;sstream&gt;  
#include &lt;iomanip&gt;  
#include &lt;fstream&gt;  
#include &lt;iostream&gt;  
#include &lt;ctime&gt;  
#include &lt;cmath&gt;  
#include &lt;cstring&gt;  
#include &lt;cstdio&gt;  
#include &lt;time.h&gt;  
#include &lt;ctype.h&gt;  
#include &lt;string.h&gt;  
#include &lt;assert.h&gt;  
#pragma comment (linker, &quot;/STACK:102400000,102400000&quot;)

using namespace std;

int n, m, x, y;

const int MAXN = 1001000;
const int MAXM = 1000100;

int num;
char tmp;
vector&lt;pair&lt;int, int&gt; &gt; a;
int weight[1100][1100];
int cnt[1100][1100];

struct Edge
{
    int to, next;
    bool cut;//是否为桥的标记
}edge[MAXM];

int head[MAXN], tot;
int Low[MAXN], DFN[MAXN], Stack[MAXN];
int Index, top;
bool Instack[MAXN];
bool cut[MAXN];
int add_block[MAXN];//删除一个点后增加的连通块
int bridge;

void addedge(int u, int v)
{
    edge[tot].to = v; 
    edge[tot].next = head[u]; 
    edge[tot].cut = false;
    head[u] = tot++;
}


void Tarjan(int u, int pre)
{
    int v;
    Low[u] = DFN[u] = ++Index;
    Stack[top++] = u;
    Instack[u] = true;
    int son = 0;
    for (int i = head[u]; i != -1; i = edge[i].next)
    {
        v = edge[i].to;
        if (v == pre)continue;
        if (!DFN[v])
        {
            son++;
            Tarjan(v, u);
            if (Low[u] &gt; Low[v])Low[u] = Low[v];
            //桥
            //一条无向边(u,v)是桥，当且仅当(u,v)为树枝边，且满足DFS(u)&lt;Low(v)。
            if (Low[v] &gt; DFN[u])
            {
                bridge++;
                edge[i].cut = true;
                edge[i ^ 1].cut = true;
                a.push_back(make_pair(min(u, v), max(u, v)));
            }
            //割点
            //一个顶点u是割点，当且仅当满足(1)或(2) (1) u为树根，且u有多于一个子树。
            //(2) u不为树根，且满足存在(u,v)为树枝边(或称父子边，
            //即u为v在搜索树中的父亲)，使得DFS(u)&lt;=Low(v)
            if (u != pre &amp;&amp; Low[v] &gt;= DFN[u])//不是树根
            {
                cut[u] = true;
                add_block[u]++;
            }
        }
        else if (Low[u] &gt; DFN[v])
            Low[u] = DFN[v];
    }
    //树根，分支数大于1
    if (u == pre &amp;&amp; son &gt; 1)cut[u] = true;
    if (u == pre)add_block[u] = son - 1;
    Instack[u] = false;
    top--;
}

///////////////
int fa[1010];
int find(int x)
{
    if (fa[x] == -1) return x;
    else return fa[x] = find(fa[x]);
}

void un(int x, int y)
{
    int fx = find(x);
    int fy = find(y);
    if (fx != fy) fa[fx] = fy;
}
/////////////////

void solve(int N)
{
    memset(DFN, 0, sizeof(DFN));
    memset(Instack, false, sizeof(Instack));
    memset(add_block, 0, sizeof(add_block));
    memset(cut, false, sizeof(cut));
    Index = top = 0;
    bridge = 0;
    for (int i = 1; i &lt;= N; i++)
        if (!DFN[i])
            Tarjan(i, i);
    //get ans
    int ok = 1;
    for (int i = 1;i &lt;= n;i++)
        if (find(i) != find(1))
        {
            ok = 0;
            break;
        }
    if (!ok) printf(&quot;0\n&quot;);//判断是否联通
    else if (a.size() == 0) printf(&quot;-1\n&quot;);//是否存在割边
    else
    {
        int ans = 1e9;

        for (int i = 0;i &lt; a.size();i++)
        {
            int u = a[i].first;
            int v = a[i].second;
            if (cnt[u][v] == 1)//重边
                ans = min(ans, weight[u][v]);
        }
        if (ans == 0) ans = 1;//最小割为0？
        if (ans == 1e9) ans = -1;
        printf(&quot;%d\n&quot;,ans);
    }
}

void init()
{
    tot = 0;
    num = 0;
    a.clear();
    memset(head, -1, sizeof(head));
}

int main()
{
    while (~scanf(&quot;%d %d&quot;, &amp;n ,&amp;m) &amp;&amp; n)
    {
        init();
        memset(weight, 0, sizeof(weight));
        memset(fa,-1,sizeof(fa));
        memset(cnt, 0, sizeof(cnt));

        int u, v, w;
        for (int i = 1; i &lt;= m; i++)
        {
            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
            addedge(u, v);
            addedge(v, u);
            cnt[u][v]++;
            cnt[v][u]++;
            un(u, v);
            if (weight[u][v] == 0 || (weight[u][v] &gt; w))
                weight[u][v] = weight[v][u] = w;
        }
        solve(n);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 4857 逃生【反向拓扑排序】</title>
    <url>/article/csdn/hdu_4857_%E9%80%83%E7%94%9F%E3%80%90%E5%8F%8D%E5%90%91%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47620875" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47620875</a></p>
<p>题目链接：<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4857" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=4857
</a></p>
<p>题意:中文不解释</p>
<p>解法：</p>
<p>input:<br>1<br>3 1<br>3 1<br>answer:<br>3 1 2<br>而不是<br>2 3 1<br>所以逆向建边 拓扑</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;string.h&gt;

using namespace std;

int n, m;
int a, b;
int in[30010];
int ans[30010];
vector&lt;int&gt; g[30010];

struct cmp
{
    bool operator()(int &amp;a, int &amp;b)
    {
        return a &lt; b;
    }
};

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
        memset(in, 0, sizeof(in));
        for (int i = 1; i &lt;= n; i++) g[i].clear();
        while (m--)
        {
            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
            g[b].push_back(a);
            in[a]++;
        }
        priority_queue&lt;int,vector&lt;int&gt;,cmp&gt; que;
        while (!que.empty()) que.pop();
        for (int i = 1; i &lt;= n; i++)
            if (in[i] == 0) que.push(i);
        int cnt = 0;
        while (!que.empty())
        {
            int t = que.top(); que.pop();
            ans[cnt++] = t;
            for (int i = 0; i &lt; g[t].size(); i++)
            {
                in[g[t][i]] --;
                if (in[g[t][i]] == 0)
                    que.push(g[t][i]);
            }
        }
        for (int i = cnt - 1; i &gt;= 0; i--)
        {
            printf(&quot;%d&quot;,ans[i]); 
            if (i == 0) printf(&quot;\n&quot;); else printf(&quot; &quot;);
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 4292 Food【拆点网络流】</title>
    <url>/article/csdn/hdu_4292_Food%E3%80%90%E6%8B%86%E7%82%B9%E7%BD%91%E7%BB%9C%E6%B5%81%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47771109" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47771109</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=4292" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=4292
</a></p>
<p>解法：拆人</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;ctime&gt;  
#include &lt;math.h&gt;  
#include &lt;limits.h&gt;  
#include &lt;complex&gt;  
#include &lt;string&gt;  
#include &lt;functional&gt;  
#include &lt;iterator&gt;  
#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;stack&gt;  
#include &lt;queue&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;list&gt;  
#include &lt;bitset&gt;  
#include &lt;sstream&gt;  
#include &lt;iomanip&gt;  
#include &lt;fstream&gt;  
#include &lt;iostream&gt;  
#include &lt;ctime&gt;  
#include &lt;cmath&gt;  
#include &lt;cstring&gt;  
#include &lt;cstdio&gt;  
#include &lt;time.h&gt;  
#include &lt;ctype.h&gt;  
#include &lt;string.h&gt;  
#include &lt;assert.h&gt;  

using namespace std;

const int MAXN = 50010;//点数的最大值
const int MAXM = 90001000;//边数的最大值
const int INF = 0x3f3f3f3f;

struct Edge
{
    int to, next, cap, flow;
}edge[MAXM];//注意是MAXM
int tol;
int head[MAXN];
int gap[MAXN], dep[MAXN], pre[MAXN], cur[MAXN];
void init()
{
    tol = 0;
    memset(head, -1, sizeof(head));
}
//加边，单向图三个参数，双向图四个参数
void addedge(int u, int v, int w, int rw = 0)
{
    edge[tol].to = v; edge[tol].cap = w; edge[tol].next = head[u];
    edge[tol].flow = 0; head[u] = tol++;
    edge[tol].to = u; edge[tol].cap = rw; edge[tol].next = head[v];
    edge[tol].flow = 0; head[v] = tol++;
}
//输入参数：起点、终点、点的总数
//点的编号没有影响，只要输入点的总数
int sap(int start, int end, int N)
{
    memset(gap, 0, sizeof(gap));
    memset(dep, 0, sizeof(dep));
    memcpy(cur, head, sizeof(head));
    int u = start;
    pre[u] = -1;
    gap[0] = N;
    int ans = 0;
    while (dep[start] &lt; N)
    {
        if (u == end)
        {
            int Min = INF;
            for (int i = pre[u]; i != -1; i = pre[edge[i ^ 1].to])
                if (Min &gt; edge[i].cap - edge[i].flow)
                    Min = edge[i].cap - edge[i].flow;
            for (int i = pre[u]; i != -1; i = pre[edge[i ^ 1].to])
            {
                edge[i].flow += Min;
                edge[i ^ 1].flow -= Min;
            }
            u = start;
            ans += Min;
            continue;
        }
        bool flag = false;
        int v;
        for (int i = cur[u]; i != -1; i = edge[i].next)
        {
            v = edge[i].to;
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[v] + 1 == dep[u])
            {
                flag = true;
                cur[u] = pre[v] = i;
                break;
            }
        }
        if (flag)
        {
            u = v;
            continue;
        }
        int Min = N;
        for (int i = head[u]; i != -1; i = edge[i].next)
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min)
            {
                Min = dep[edge[i].to];
                cur[u] = i;
            }
        gap[dep[u]]--;
        if (!gap[dep[u]])return ans;
        dep[u] = Min + 1;
        gap[dep[u]]++;
        if (u != start) u = edge[pre[u] ^ 1].to;
    }
    return ans;
}


int n, f, d;
char s[300];
int F[300], D[300];

int main()
{
    while (~scanf(&quot;%d%d%d&quot;, &amp;n, &amp;f, &amp;d))
    {
        init();
        for (int i = 1; i &lt;= f; i++) scanf(&quot;%d&quot;, &amp;F[i]);
        for (int i = 1; i &lt;= d; i++) scanf(&quot;%d&quot;, &amp;D[i]);

        for (int i = 1; i &lt;= f; i++) addedge(0, i, F[i]);
        for (int i = 1; i &lt;= d; i++) addedge(f + n + n + i, f + n + n + d + 1, D[i]);
        for (int i = 1; i &lt;= n; i++) addedge(f + i, f + n + i, 1);

        for (int i = 1; i &lt;= n; i++)
        {

            scanf(&quot;%s&quot;, s);
            for (int k = 0; k &lt; f; k++)//食物
            {
                if (s[k] == &#39;Y&#39;)
                    addedge(k + 1, f + i , 1);
            }

        }
        for (int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%s&quot;, s);
            for (int k = 0; k &lt; d; k++)//水
            {
                if (s[k] == &#39;Y&#39;)
                    addedge(i + f + n, f + n + n + k + 1, 1);
            }
        }
        int ans = sap(0, f + d + n + n + 1, f + d + n + n + 2);
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 4846 Big Barn【dp】</title>
    <url>/article/csdn/hdu_4846_Big_Barn%E3%80%90dp%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/52691330" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/52691330</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4846" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=4846
</a></p>
<p>求矩阵中最大的仓库正方形</p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;set&gt;

using namespace std;

int n, t;
int a[1010][1010];
int b[1010][1010];

int main()
{
    while (scanf(&quot;%d %d&quot;, &amp;n, &amp;t) != EOF)
    {
        for (int i = 0;i &lt;= n;i++)
            for (int j = 0;j &lt;= n;j++)
                a[i][j] = 1;

        int u, v;
        //memset(b, 0, sizeof(b));
        while (t--)
        {
            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
            a[u][v] = 0;
        }
        for (int i = 1;i &lt;= n;i++)
        {
            b[i][1] = a[i][1];
            b[1][i] = a[1][i];
        }
        for(int i=2;i&lt;=n;i++)
            for (int j = 2;j &lt;= n;j++)
            {
                if (a[i][j] == 1)
                    b[i][j] = min(b[i - 1][j - 1], min(b[i - 1][j], b[i][j - 1])) + 1;
                else
                    b[i][j] = 0;
            }
        int ans = 0;
        for (int i = 1;i &lt;= n;i++)
            for (int j = 1;j &lt;= n;j++)
            {
                ans = max(ans, b[i][j]);
            }
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 4858 项目管理</title>
    <url>/article/csdn/hdu_4858_%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47622265" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47622265</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=4858" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=4858
</a></p>
<p>题意：中文不解释</p>
<p>解法：直接按题意模拟一遍，数据水？</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;string.h&gt;

using namespace std;

int n, m, q;
vector&lt;int&gt; g[100010];
int a[100010], b, c, d;

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
        for (int i = 0; i &lt;= n; i++) g[i].clear();
        memset(a, 0, sizeof(a));
        while (m--)
        {
            scanf(&quot;%d%d&quot;,&amp;b,&amp;c);
            g[b].push_back(c);
            g[c].push_back(b);
        }
        scanf(&quot;%d&quot;,&amp;q);
        while (q--)
        {
            scanf(&quot;%d&quot;,&amp;b);
            if (b == 0)
            {
                scanf(&quot;%d%d&quot;, &amp;c, &amp;d);
                a[c] += d;
            }
            else
            {
                int ans = 0;
                scanf(&quot;%d&quot;,&amp;c);
                for (int i = 0; i &lt; g[c].size(); i++)
                    ans += a[g[c][i]];
                printf(&quot;%d\n&quot;,ans);
            }
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 4549 M斐波那契数列 【矩阵+快速幂+欧拉定理】</title>
    <url>/article/csdn/hdu_4549_M%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97_%E3%80%90%E7%9F%A9%E9%98%B5+%E5%BF%AB%E9%80%9F%E5%B9%82+%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44631833" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44631833</a></p>
<p>M斐波那契数列</p>
<p>Time Limit: 3000/1000 MS (Java/Others) Memory Limit: 65535/32768 K<br>(Java/Others)<br>Total Submission(s): 1746 Accepted Submission(s): 503</p>
<p>Problem Description<br>M斐波那契数列F[n]是一种整数数列，它的定义如下：</p>
<p>F[0] = a<br>F[1] = b<br>F[n] = F[n-1] * F[n-2] ( n &gt; 1 )</p>
<p>现在给出a, b, n，你能求出F[n]的值吗？</p>
<p>Input<br>输入包含多组测试数据；<br>每组数据占一行，包含3个整数a, b, n（ 0 &lt;= a, b, n &lt;= 10^9 ）</p>
<p>Output<br>对每组测试数据请输出一个整数F[n]，由于F[n]可能很大，你只需输出F[n]对1000000007取模后的值即可，每组数据输出一行。</p>
<p>Sample Input<br>0 1 0<br>6 10 2</p>
<p>Sample Output<br>0<br>60</p>
<p>Source<br>2013金山西山居创意游戏程序挑战赛——初赛（2）</p>
<p>构建矩阵：<br>base.m[0][0] = 0; base.m[0][1] = 1;<br>base.m[1][0] = 1; base.m[1][1] = 1;</p>
<p>由欧拉定理：<br>A^B %C 题中C是质素，而且A，C是互质的。<br>所以C的欧拉函数值为C-1;<br>所以由欧拉定理，直接A^(B%(C-1)) %C</p>
<p>比较一般的结论是 A^B %C=A^( B%phi(C)+phi(C) ) %C B&gt;=phi(C)</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;

using namespace std;

const long long MOD = 1000000007;

struct node
{
    long long m[2][2];
}ans, base;
int  a, b, n;

node multi(node a, node b)
{
    node tmp;
    for (int i = 0; i&lt;2; i++)
        for (int j = 0; j&lt;2; j++)
        {
            tmp.m[i][j] = 0;
            for (int k = 0; k&lt;2; k++)
            {
                tmp.m[i][j] = (tmp.m[i][j] + a.m[i][k] * b.m[k][j]) % (MOD-1);//由欧拉定理
            }
        }
    return tmp;
}

void fast_mod(int n)// 求矩阵 base 的  n 次幂
{
    base.m[0][0] = 0; base.m[0][1] = 1;
    base.m[1][0] = 1; base.m[1][1] = 1;

    ans.m[0][0] = ans.m[1][1] = 1;// ans 初始化为单位矩阵
    ans.m[0][1] = ans.m[1][0] = 0;
    while (n)
    {
        if (n &amp; 1) //实现 ans *= t; 其中要先把 ans赋值给 tmp，然后用 ans = tmp * t
            ans = multi(ans, base);
        base = multi(base, base);
        n &gt;&gt;= 1;
    }
}

long long quickpow(long long m, long long n, long long k)//快速幂
{
    long long  b = 1;
    long long mm =m%k;
    while (n &gt; 0)
    {
        if (n &amp; 1)
            b = (b*mm) % k;
        n = n &gt;&gt; 1;
        mm = (mm*mm) % k;
    }
    return b;
}
//////////////////////
int main()
{
    while (scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;n) == 3)
    {
        if (n == 0)
        {
            printf(&quot;%d\n&quot;, a%MOD );
            continue;
        }
        if (n == 1)
        {
            printf(&quot;%d\n&quot;, b%MOD );
            continue;
        }
        fast_mod(n-1);

        //printf(&quot;%lld %ld\n\n&quot;,ans.m[1][0],ans.m[1][1]);

        int anss = quickpow(a, ans.m[1][0] , MOD)  *  quickpow(b, ans.m[1][1], MOD) % MOD;
        printf(&quot;%d\n&quot;, anss);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 5289 Assignment 【ST算法】</title>
    <url>/article/csdn/hdu_5289_Assignment_%E3%80%90ST%E7%AE%97%E6%B3%95%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47001889" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47001889</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5289" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5289
</a><br>题意：求满足最大值减最小值小于k的区间的数目。<br>枚举左端点，二分右端点，用st算法求区间最值<br>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int n, k, p, l, r;

int a[100010];
int s[100010][20];
int maxsum[100010][20], minsum[100010][20];
__int64 ans = 0;

int rmq(int l, int r)
{
    int k = log2((double)(r - l + 1));
    int MAX = max(maxsum[l][k], maxsum[r - (1 &lt;&lt; k) + 1][k]);
    int MIN = min(minsum[l][k], minsum[r - (1 &lt;&lt; k) + 1][k]);
    return MAX - MIN;
}

int main()
{
    int t;
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    {
        scanf(&quot;%d %d&quot;, &amp;n, &amp;k);
        for (int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;, &amp;a[i]);
            maxsum[i][0] = minsum[i][0] = a[i];
        }

        for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++)
            for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++)
            {
                maxsum[i][j] = max(maxsum[i][j - 1], maxsum[i + (1 &lt;&lt; (j - 1))][j - 1]);
                minsum[i][j] = min(minsum[i][j - 1], minsum[i + (1 &lt;&lt; (j - 1))][j - 1]);
            }

        ans = 0;
        for (int i = 1; i &lt;= n; i++)
        {
            l = i;
            r = n;

            while (l + 1 &lt; r)
            {
                p = (l + r) &gt;&gt; 1;
                if (rmq(i, p) &lt; k)
                    l = p;
                else
                    r = p;
            }
            if (rmq(i, r) &lt; k)
                ans += (__int64)(r - i + 1);
            else
                ans += (__int64)(l - i + 1);
        }
        printf(&quot;%I64d\n&quot;, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 5202 Rikka with string</title>
    <url>/article/csdn/hdu_5202_Rikka_with_string.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46380587" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46380587</a></p>
<p>题目链接： <a href="http://acm.acmcoder.com/showproblem.php?pid=5202" target="_blank" rel="noopener"> http://acm.acmcoder.com/showproblem.php?pid=5202
</a><br>题意：给你一个字符串，其中‘？’可替换为任何字符，问你是否可以替换？为字母使得字符串非回文。输出字典序最小的解。<br>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;math.h&gt;
#include &lt;stack&gt;

using namespace std;

int n;
char s[1010];
int vis[1010];

int solve()
{
    memset(vis,0,sizeof(vis));
    if (s[n/2] ==&#39;?&#39; &amp;&amp; n%2 ==1)
        s[n/2] = &#39;a&#39;;
    for(int i=0;i&lt;n;i++)
    {
        if (s[i] == &#39;?&#39;)
            vis[i]=1;
    }
    for(int i=0;i&lt;n;i++)
    {
        if (s[i]== &#39;?&#39;)
            s[i]=&#39;a&#39;;
    }
    int ok=1;
    for(int i=0;i&lt;=n/2;i++)
    {
        if (s[i] != s[n-i-1])
        {
            ok=0;
            break;
        }
    }
    if (ok)
    {
        for(int i=n-1;i&gt;=1;i--)
        {
            if (vis[i]==1)
            {
                s[i]+=1;
                ok=0;
                break;
            }
        }
    }
    if (ok)
        return 0;
    puts(s);
    return 1;
}

int main()
{
    while (scanf(&quot;%d&quot;,&amp;n)!=EOF)
    {
        scanf(&quot;%s&quot;,s);
        if (!solve())
            puts(&quot;QwQ&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 5288 OO’s Sequence</title>
    <url>/article/csdn/hdu_5288_OO%E2%80%99s_Sequence.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47178873" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47178873</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5288" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5288
</a></p>
<p>解法：<br>定义两个数组L[i],R[i],表示第i数左侧和右侧最接近它且值是a[i]因子的数字的位置，那么第i个数能贡献的答案就是(R[i]-i)*(i-L[i]),因此每个数字x都去枚举它的因子y，然后左右找到一个值是y且最接近x的数，然后用他的位置更新一下L,R数组。时间复杂度O(nsqrt(a))。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;assert.h&gt;
#pragma comment(linker,&quot;/STACK:1024000000,1024000000&quot;)

using namespace std;

const int MAXN = 100010;
const int MOD = 1e9 + 7;

int n;
int a[MAXN];
int L[MAXN], R[MAXN];
int pre[MAXN];
vector&lt;int&gt; g[MAXN];

void init()
{
    for (int i = 1; i &lt;= 10000; i++)
    {
        g[i].clear();
        for (int j = 1; j*j &lt;= i; j++)
        {
            if (i%j == 0)
            {
                g[i].push_back(j);
                if (j*j != i)
                    g[i].push_back(i / j);
            }
        }
    }
}

int main()
{
    init();
    while (~scanf(&quot;%d&quot;, &amp;n))
    {
        for (int i = 1; i &lt;= n; i++)
            scanf(&quot;%d&quot;,&amp;a[i]);

        memset(L,0,sizeof(L));
        memset(R,0,sizeof(R));
        memset(pre,0,sizeof(pre));

        for (int i = 1; i &lt;= n; i++)
        {
            int tmp = a[i];
            int pos = 0;
            for (int j = 0; j &lt; g[tmp].size(); j++)
            {
                int t2 = g[tmp][j];
                pos = max(pre[t2],pos);
            }
            pre[tmp] = i;
            L[i] = pos;
        }
        for (int i = 1; i &lt;= 10000; i++) pre[i] = 100001;

        for (int i = n; i &gt;= 1;i--)
        {
            int tmp = a[i];
            int pos = n + 1;
            for (int j = 0; j &lt; g[tmp].size(); j++)
            {
                int t2 = g[tmp][j];
                pos = min(pre[t2], pos);
            }
            pre[tmp] = i;
            R[i] = pos;
        }
        long long ans = 0;
        for (int i = 1; i &lt;= n; i++)
            ans += (long long)(R[i] - i) * (i - L[i]) % MOD;
        printf(&quot;%lld\n&quot;, ans%MOD);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 5115 Dire Wolf【区间DP】</title>
    <url>/article/csdn/hdu_5115_Dire_Wolf%E3%80%90%E5%8C%BA%E9%97%B4DP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47798407" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47798407</a></p>
<p>题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5115" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5115
</a></p>
<p>题意：<br>有n只狼，每只狼有两种属性，一种攻击力一种附加值，我们没杀一只狼，那么我们受到的伤害值为这只狼的攻击值与它旁边的两只狼的附加值的和，求把所有狼都杀光受到的最小的伤害值。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;ctime&gt;  
#include &lt;math.h&gt;  
#include &lt;limits.h&gt;  
#include &lt;complex&gt;  
#include &lt;string&gt;  
#include &lt;functional&gt;  
#include &lt;iterator&gt;  
#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;stack&gt;  
#include &lt;queue&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;list&gt;  
#include &lt;bitset&gt;  
#include &lt;sstream&gt;  
#include &lt;iomanip&gt;  
#include &lt;fstream&gt;  
#include &lt;iostream&gt;  
#include &lt;ctime&gt;  
#include &lt;cmath&gt;  
#include &lt;cstring&gt;  
#include &lt;cstdio&gt;  
#include &lt;time.h&gt;  
#include &lt;ctype.h&gt;  
#include &lt;string.h&gt;  
#include &lt;assert.h&gt;  

using namespace std;

int n;
int a[500],b[500],dp[500][500];

int main()
{
    int t, cases = 1;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%d&quot;,&amp;n);
        for (int i = 0; i &lt;= n; i++)
            for (int j = 0; j &lt;= n; j++)
                dp[i][j] = 100000000;
        memset(a,0,sizeof(a));
        memset(b,0,sizeof(b));

        for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
        for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;b[i]);
        for (int i = 1; i &lt;= n; i++) dp[i][i] = a[i] + b[i - 1] + b[i + 1];

        for (int l = 1; l &lt;= n; l++)
        {
            for (int i = 1; i + l &lt;= n; i++)
            {
                int j = i + l;
                dp[i][j] = min(dp[i+1][j] + b[i-1] + b[j+1] + a[i], dp[i][j-1] + a[j] + b[j + 1] + b[i-1]);
                for (int k = i+1; k &lt;= j; k++)
                {
                    dp[i][j] = min(dp[i][j], dp[i][k - 1] + dp[k + 1][j] + a[k] + b[i - 1] + b[j + 1]);
                }
            }
        }
        printf(&quot;Case #%d: %d\n&quot;, cases++, dp[1][n]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 5312 Sequence【数学推导】</title>
    <url>/article/csdn/hdu_5312_Sequence%E3%80%90%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47071147" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47071147</a></p>
<p>题目链接：<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5312" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5312
</a></p>
<p>解法：<br>这个题看上去是一个贪心, 但是这个贪心显然是错的.<br>事实上这道题目很简单, 先判断1个是否可以, 然后判断2个是否可以. 之后找到最小的整数k (k &gt; 2), 使得(m - k) mod 6 = 0即可.</p>
<p>证明如下:<br>3n(n-1)+1 = 6(n<em>(n-1)/2)+1, 注意到n</em>(n-1)/2是三角形数, 任意一个自然数最多只需要3个三角形数即可表示. 枚举需要k个。</p>
<p>事实上, 打个表应该也能发现规律.</p>
<h3><span id="三角形数">三角形数：</span></h3><p>1、3、6、10、15等等这些能够表示成三角形的形状的总数量的数，叫做三角形数。<br>一定数目的点或圆在等距离的排列下可以形成一个等边三角形，这样的数被称为三角形数。比如10个点可以组成一个等边三角形，因此10是一个三角形数：<br>x<br>x　x<br>x　x　x<br>x　x　x　x<br>x　x　x　x x<br>开始个18个三角形数是1、3、6、10、15、21、28、36、45、55、66、78、91、105、120、136、153、171……（OEIS中的数列A000217）<br>第n个三角形数的公式是 n<em>(n-1)/2 或 ((2</em>n+1)^2-1)/8</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 5305 Friends 【暴搜】</title>
    <url>/article/csdn/hdu_5305_Friends_%E3%80%90%E6%9A%B4%E6%90%9C%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47035305" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47035305</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5305" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5305
</a></p>
<p>题意：给一个无向图 ， 每条边可以是online边也可以是offline边，问<br>有多少种方法使得每个节点的online边和offline边一样多</p>
<p>解法：暴搜。记录每个点连接的边数，奇数的直接不可能，偶数的分成两个数组，c1[i]表示i的在线朋友数，c2[i]表示i的离线朋友数，然后一条边一条边搜就行了。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

struct
{
    int u;
    int v;
}e[100];

int c1[100], c2[100];
int num[100];
int ans;
int n, m;

void dfs(int x)
{
    if (x == m + 1)
    {
        ans++;
        return;
    }
    int u = e[x].u;
    int v = e[x].v;
    if (c1[u] &amp;&amp; c1[v])
    {
        c1[u] --;
        c1[v] --;
        dfs(x + 1);
        c1[u] ++;
        c1[v] ++;
    }
    if (c2[u] &amp;&amp; c2[v])
    {
        c2[u] --;
        c2[v] --;
        dfs(x + 1);
        c2[u] ++;
        c2[v] ++;
    }
    return;
}

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        memset(c1, 0, sizeof(c1));
        memset(c2, 0, sizeof(c2));
        memset(num, 0, sizeof(num));

        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
        for (int i = 1; i &lt;= m;i++)
        {
            scanf(&quot;%d%d&quot;,&amp;e[i].u,&amp;e[i].v);
            num[e[i].u]++;
            num[e[i].v]++;
        }
        int ok = 1;
        for (int i = 1; i &lt;= n; i++)
        {
            c1[i] = c2[i] = num[i] / 2;
            if (num[i] &amp; 1)
            {
                ok = 0;
                break;
            }
        }
        if (!ok)
        {
            printf(&quot;0\n&quot;);
            continue;
        }
        ans = 0;
        dfs(1);
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre><p>参考自： <a href="http://blog.csdn.net/Tc_To_Top/article/details/47027079" target="_blank" rel="noopener"> http://blog.csdn.net/Tc_To_Top/article/details/47027079
</a></p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 5318 The Goddess Of The Moon 【矩阵快速幂】</title>
    <url>/article/csdn/hdu_5318_The_Goddess_Of_The_Moon_%E3%80%90%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47128151" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47128151</a></p>
<p>题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5318" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5318
</a></p>
<p>题意：<br>给你n种串。，每种无限个，选择m个物品，问你可以组成几种串。<br>如果a串的后缀和b串的前缀相等，并且长度&gt;=2，则b串可以连在a串后面（注意，不用合并a，b串相同的位置）。</p>
<p>思路：输入的字符串可能有相同的，注意去重。<br>若s[i]，s[j]可以链接，则ok[i][j] = 1 ; 否则为 0 ；</p>
<p>定义dp[i][j] 表示选择i个串，一、以j串结尾的方案数。<br>则dp[i][j] = dp[i-1][k]*ok[k][j] (1&lt;= k &lt;= n)</p>
<p>res矩阵第一行初使为1，其他为 0 .</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;assert.h&gt;

using namespace std;

int n, m;
const int MOD = 1000000007;

struct node
{
    int ok[55][55];
}is;

node multi(node a, node b)
{
    node tmp;
    memset(tmp.ok,0,sizeof(tmp.ok));
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= n; j++)
            for (int k = 1; k &lt;= n; k++)
            {
                tmp.ok[i][j] += ((long long)a.ok[i][k] * (long long)b.ok[k][j]) % MOD;
                tmp.ok[i][j] %= MOD;
            }
    return tmp;
}

//////////////////
char s[100][20];

bool check(int x, int y) //判断是否符合前缀 后缀要求
{
    int lenx = strlen(s[x]), leny = strlen(s[y]);
    if (lenx == 1 || leny == 1) return false;
    for (int i = lenx - 2; i &gt;= 0; i--) 
    {
        int j = 0, ti = i;
        while (ti &lt; lenx &amp;&amp; j &lt; leny &amp;&amp; s[x][ti] == s[y][j]) ti++, j++;
        if (ti == lenx) return true;
    }
    return false;
}

void solve()
{
    int tm = m;
    node tmp = is, res;
    memset(res.ok, 0, sizeof(res.ok));
    for (int i = 1; i &lt;= n; i++) res.ok[1][i] = 1;

    tm--;
    while (tm)
    {
        if (tm &amp; 1)
            res = multi(res,tmp);
        tmp = multi(tmp, tmp);
        tm &gt;&gt;= 1;
    }
    int ans = 0;
    for (int i = 1; i &lt;= n; i++)
        ans = (ans + res.ok[1][i]) % MOD;
    printf(&quot;%d\n&quot;,ans);
}

set&lt;string&gt; vec;

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        memset(is.ok, 0, sizeof(is.ok));
        vec.clear();
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);

        for (int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%s&quot;,s[i]);
            vec.insert(s[i]);
        }
        int num = 0;
        for (auto &amp;it : vec) strcpy(s[++num],it.c_str());
        n = num;
        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= n; j++)
                if (check(i, j)) is.ok[i][j] = 1;
        solve();
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 5317 RGCDQ</title>
    <url>/article/csdn/hdu_5317_RGCDQ.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47110993" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47110993</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5317" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5317
</a></p>
<p>题意：F[i]表示i的因子的数目。 询问区间 [L,R] 中 gcd(F[i],F[j]) （L&lt;= i &lt;= R,L&lt;= j &lt;= R）的最大值</p>
<p>解法：用sum[i][j] 表示 前 i 个F值中有多少 j</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

#define N 1000000
int f[N + 7];
int sum[N][8];//sum[i][j] 表示 前 i  F 值中有多少 j

void init()
{
    memset(f, 0, sizeof(f));
    memset(sum, 0, sizeof(sum));
    for (int i = 2; i &lt;= N; i++)
    {
        if (f[i] == 0)
        {
            for (int j = i; j &lt;= N; j += i)
                f[j]++;
        }
    }
    for (int i = 1; i &lt;= N; i++)
    {
        for (int j = 1; j &lt;= 7; j++)
            sum[i][j] = sum[i - 1][j];
        sum[i][f[i]]++;
    }
}

int main()
{
    init();
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    int sb[8];
    while (T--)
    {
        int l, r;
        scanf(&quot;%d %d&quot;, &amp;l, &amp;r);
        for (int i = 1; i &lt;= 7; i++)
        {
            sb[i] = sum[r][i] - sum[l - 1][i];
        }
        int ans;
        for (int i = 1; i &lt;= 7; i++)
        {
            if (sb[i] &gt;= 2)
                ans = i;
        }
        if (sb[2] &amp;&amp; sb[4])
            ans = max(ans, 2);
        if (sb[2] &amp;&amp; sb[6])
            ans = max(ans, 2);
        if (sb[4] &amp;&amp; sb[6])
            ans = max(ans, 2);
        if (sb[3] &amp;&amp; sb[6])
            ans = max(ans, 3);
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 5323 Solve this interesting problem 【DFS】</title>
    <url>/article/csdn/hdu_5323_Solve_this_interesting_problem_%E3%80%90DFS%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47133651" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47133651</a></p>
<p>题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5323" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5323
</a></p>
<p>题意：给你一个线段树区间【L,R】问你是否有线段树出现这个区间。有的话输出满足条件的最小的n。（比赛的时候居然没看这个题！）</p>
<p>解法：暴力枚举区间</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;assert.h&gt;

//#pragma comment(linker,&quot;/STACK:1024000000,1024000000&quot;)  

using namespace std;

long long l, r;
long long ans;

void dfs(long long x, long long y)
{
    if (x == 0)
    {
        ans = min(ans, y);
        return;
    }
    if (x &lt; 0 || y &gt;= ans)
        return;
    if (x &gt; y) return;

    long long len = y - x + 1;
    if (len &gt; x) return;// 

    if (x != y) dfs(x, y + y - x);
    dfs(x, y + y - x + 1);
    dfs(x + x - y - 1, y);
    dfs(x + x - y - 2, y);
}

int main()
{
    while (~scanf(&quot;%lld%lld&quot;, &amp;l, &amp;r))
    {
        ans = 1e17;
        if (l &gt; r) printf(&quot;-1\n&quot;);
        else if (l == r) printf(&quot;%d\n&quot;, l);
        else
        {
            dfs(l, r);
            if (ans == 1e17) ans = -1;
            printf(&quot;%lld\n&quot;,ans);
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 5325 Crazy Bobo</title>
    <url>/article/csdn/hdu_5325_Crazy_Bobo.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47130531" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47130531</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5325" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5325
</a></p>
<p>题意：<br>n个点，每个点都有权值。n-1条边构成树。<br>求一个最大集合，使得集合中的所有点联通，且按照点的权值排列之后相邻两个点之间的路径上的点的权值都要比起点小。</p>
<p>思路：<br>题目转化为以一个点作为权值最小点，以权值递增的规则看它能到达多少个点。<br>将无向图建成有向图，权值小的点指向权值大的点。<br>使用dfs，进行记忆化搜索，num数组记录该点的子树节点数量。</p>
<p>代码：（需要手动扩栈）</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;assert.h&gt;
#pragma comment(linker,&quot;/STACK:1024000000,1024000000&quot;)  
using namespace std;

template &lt;class T&gt;

inline bool scan_d(T &amp;ret)
{
    char c; int sgn;
    if (c = getchar(), c == EOF) return 0; //EOF  
    while (c != &#39;-&#39; &amp;&amp; (c&lt;&#39;0&#39; || c&gt;&#39;9&#39;)) c = getchar();
    sgn = (c == &#39;-&#39;) ? -1 : 1;
    ret = (c == &#39;-&#39;) ? 0 : (c - &#39;0&#39;);
    while (c = getchar(), c &gt;= &#39;0&#39;&amp;&amp;c &lt;= &#39;9&#39;) ret = ret * 10 + (c - &#39;0&#39;);
    ret *= sgn;
    return 1;
}

const int MAXN = 500010;
int  n;
int a[MAXN];
int ans;

struct Edge
{
    int to;
    int next;
}edge[MAXN];

int head[MAXN], tot;

void addedge(int u, int v)
{
    edge[tot].to = v;
    edge[tot].next = head[u];
    head[u] = tot++;
}

int num[MAXN];// 记录点i为set最小值的时候i可以到达的点的数目

int dfs(int u)
{
    if (num[u] != 0) return num[u];
    num[u] = 1;
    for (int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].to;
        num[u] += dfs(v);
    }
    ans = max(ans, num[u]);
    return num[u];
}

int main()
{
    while (~scanf(&quot;%d&quot;, &amp;n))
    {
        tot = 0;
        for (int i = 1; i &lt;= n; i++)
        {
            scan_d(a[i]);
            head[i] = -1;
            num[i] = 0;
        }
        int x, y;
        for (int i = 1; i &lt; n; i++)
        {
            scan_d(x);
            scan_d(y);
            if (a[x] &gt; a[y])
                addedge(y, x);
            else 
                addedge(x, y);
        }
        ans = 0;
        for (int i = 1; i &lt;= n; i++)
            dfs(i);
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 5301 Buildings</title>
    <url>/article/csdn/hdu_5301_Buildings.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47036895" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47036895</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5301" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5301
</a></p>
<p>题意：<br>n*m的矩阵，删除一个格子x,y。用矩形来填充矩阵。且矩形至少有一边是在矩阵的边缘上。求满足条件的矩形填充方式中面积最大的矩形，要使得该最大矩形的面积最小。</p>
<p>解法见代码</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int n, m, x, y;

int main()
{
    while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y)
    {
        if (n &gt; m)
        {
            swap(n, m);
            swap(x, y);
        }
        int ans;
        int res = (n + 1) / 2;

        int left = y;
        int right = m - y + 1;
        int up = x - 1;
        int down = n - x;

        ans = res;
        if (min(left, right) &gt; res &amp;&amp; up != down)
            ans = min(max(up, down), min(left, right));
        if (n == m &amp;&amp; n &amp; 1 &amp;&amp; x == res &amp;&amp; x == y)
            ans = res - 1;
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 5335 Walk Out【搜索】</title>
    <url>/article/csdn/hdu_5335_Walk_Out%E3%80%90%E6%90%9C%E7%B4%A2%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47174459" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47174459</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5335" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5335
</a></p>
<p>题意：给你一个n*m的0 1矩阵，要求你从（1，1）坐标开始走到（n,m）要求是的路径的上组成的01序列二进制表示最小，前导0可以忽略。</p>
<p>思路:只能向下或右走，否则二进制表示长度增加，必然增大。首先找到从（1，1）能走到的最远的0是多远，从这个或这些点再向（n，m）走。注意：dfs会爆栈，要手动加栈。</p>
<p>code：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;assert.h&gt;
#pragma comment(linker,&quot;/STACK:1024000000,1024000000&quot;) 

using namespace std;

const int MAXN = 1010;

int n, m;
char s[MAXN][MAXN];
int tot;
int c[MAXN][MAXN];
int f[MAXN][MAXN];//标记s[i][j]是否为 0

void dfs(int x, int y)
{
    if (x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; m) return;
    if (c[x][y]) return;
    c[x][y] = 1;
    if (s[x][y] == &#39;1&#39;) return;
    f[x][y] = 1;
    tot = max(tot, x + y);
    dfs(x - 1, y);
    dfs(x + 1, y);
    dfs(x, y - 1);
    dfs(x, y + 1);
}

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        memset(c, 0, sizeof(c));
        memset(f, 0, sizeof(f));
        tot = 1;

        scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
        for (int i = 1; i &lt;= n; i++)
            scanf(&quot;%s&quot;, s[i] + 1);
        dfs(1, 1);
        //printf(&quot;tot is ：%d\n&quot;, tot);
        if (tot == n + m)
        {
            printf(&quot;0\n&quot;);
            continue;
        }
        if (tot == 1)
        {
            tot = 2;
            f[1][1] = 1;
            printf(&quot;1&quot;);
        }
        for (int i = tot; i &lt; n + m; i++)
        {
            int ok = 1;
            for (int j = max(1, i - m); j &lt;= min(n, i - 1); j++)
            {
                if (f[j][i - j])
                {
                    int x, y;
                    if (j &lt; n) x = s[j + 1][i - j] - &#39;0&#39;;//向右走
                    else x = 1;
                    if (i - j &lt; m) y = s[j][i - j + 1] - &#39;0&#39;;//向下走
                    else y = 1;
                    ok = min(ok, min(x, y));
                }
            }
            for (int j = max(1, i - m); j &lt;= min(n, i - 1); j++)
            {
                if (f[j][i - j])
                {
                    int x, y;
                    if (j &lt; n) x = s[j + 1][i - j] - &#39;0&#39;;//向右走
                    else x = 1;
                    if (i - j &lt; m) y = s[j][i - j + 1] - &#39;0&#39;;//向下走
                    else y = 1;
                    if (x == ok) f[j + 1][i - j] = 1;
                    if (y == ok) f[j][i - j + 1] = 1;
                }
            }
            printf(&quot;%d&quot;,ok);
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 5319 Painter</title>
    <url>/article/csdn/hdu_5319_Painter.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47110829" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47110829</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5319" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5319
</a></p>
<p>题意：给你一个正方形，一把刷子，两种刷色法。<br>‘ \‘ 表示沿对角刷成红色，“/” 表示沿对角刷成蓝色。蓝色红色交叉形成绿色；<br>问最少刷几次形成如图图案。</p>
<p>解法：从上到下未被刷过就直接刷。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

#define maxn 156
char maps[maxn][maxn];

int main()
{
    int T, n, i, j;
    scanf(&quot;%d&quot;, &amp;T);

    while(T--)
    {
        scanf(&quot;%d&quot;, &amp;n);
        int ans = 0;
        memset(maps, 0, sizeof(maps));
        for(i=1; i&lt;=n; i++)
        {
            scanf(&quot;%s&quot;, maps[i]+1);
            for(j=1; maps[i][j]; j++)
            {
                if( (maps[i][j] == &#39;B&#39;||maps[i][j] == &#39;G&#39;) &amp;&amp; maps[i-1][j+1] != &#39;B&#39; &amp;&amp; maps[i-1][j+1] != &#39;G&#39;)
                    ans ++;
                if( (maps[i][j] == &#39;R&#39;||maps[i][j] == &#39;G&#39;) &amp;&amp; maps[i-1][j-1] != &#39;R&#39; &amp;&amp; maps[i-1][j-1] != &#39;G&#39;)
                    ans ++;
            }
        }

        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 5326 Work【并查集】</title>
    <url>/article/csdn/hdu_5326_Work%E3%80%90%E5%B9%B6%E6%9F%A5%E9%9B%86%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47110753" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47110753</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5326" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5326
</a></p>
<p>题意：n个点 ，给你m有向条边，表示起点是终点的父亲。问子孙节点个数是K的节点有几个？</p>
<p>解法：并查集。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int is[110][110];
int p[110];
int num[110];
int n, k;

int findd(int x)
{
    if (x == p[x])
        return x;
    else 
        return  p[x] = findd(p[x]);
}

void un(int x, int y)
{
    int a, b;
    a = findd(x);
    b = findd(y);
    if (a == b) return;
    p[b] = a;
}

int main()
{
    while (scanf(&quot;%d%d&quot;, &amp;n, &amp;k) != EOF)
    {
        memset(is, 0, sizeof(is));
        memset(num, 0, sizeof(num));
        for (int i = 1; i&lt;=n; i++)
            p[i] = i;

        int x, y;
        for (int i = 1; i&lt;n; i++)
        {
            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
            un(x,y);
            is[x][y] = 1;
        }
        for (int k = 1; k &lt;= n;k++)
        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= n; j++)
            {
                if (is[i][k] == 1 &amp;&amp; is[k][j] == 1)
                {
                    is[i][j] = 1;
                }
            }
        for (int i = 1; i &lt;= n; i++)
        {
            for (int j = 1; j &lt;= n; j++)
            {
                if (p[j] == p[i] &amp;&amp; i != j &amp;&amp; is[i][j] == 1)
                    num[i]++;
            }
        }

        int ans = 0;
        for (int i = 1; i &lt;= n; i++)
            if (num[i] == k) ans++;

        printf(&quot;%d\n&quot;, ans);
    }
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 5336 XYZ and Drops 【BFS模拟】</title>
    <url>/article/csdn/hdu_5336_XYZ_and_Drops_%E3%80%90BFS%E6%A8%A1%E6%8B%9F%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47177775" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47177775</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5336" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5336
</a></p>
<p>题意：给你一个r*c的网格，有的网格为空，有的有水，再给出一个爆炸点，从这个点向四周爆出四个水滴，若碰到水则融为一体，若碰到其他水滴直接跑过去互不影响，每秒可跑一格，若水中水滴数量超过4则爆开，问T秒后网格的状态是怎样的。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;assert.h&gt;
#pragma comment(linker,&quot;/STACK:1024000000,1024000000&quot;)

using namespace std;

const int MAXN = 110;

int r, c, n, t;
int dir[][2] = { { 0,0 },{ 1,0 },{ -1,0 },{ 0,1 },{ 0,-1 } };
int s[MAXN][MAXN];// 地图，记录水滴的数目
int ans[MAXN][MAXN];// 记录（i,j）位置的爆裂时间

struct water // 询问的n个水坑
{
    int x, y;// 坐标
    int t;
}p[MAXN];

struct node// 水滴
{
    // 坐标，方向
    int x, y, dir;
    int t;
};

int sx, sy;

bool is_ok(int x, int y)
{
    if (x&lt;1 || x&gt;r || y&lt;1 || y&gt;c) return false;
    return true;
}

void bfs()
{
    queue&lt;node&gt; q;
    while (!q.empty()) q.pop();

    node tmp;
    for (int i = 1; i &lt;= 4; i++)
    {
        tmp.x = sx;
        tmp.y = sy;
        tmp.dir = i;//水滴运动的方向
        q.push(tmp);
    }

    node qq,qqq;

    for (int k = 1; k &lt;= t; k++)
    {
        int len = q.size();
        if (len == 0) break;
        for (int kk = 0; kk &lt; len;kk++)
        {
            qq = q.front();
            q.pop();
            int x = qq.x; int y = qq.y; int d = qq.dir;
            int xx = qq.x + dir[d][0];
            int yy = qq.y + dir[d][1];

            if (is_ok(xx, yy))
            {
                if (ans[xx][yy] == k) continue;

                if (s[xx][yy])//有水被吸收
                {
                    s[xx][yy]++;
                    if (s[xx][yy] &gt; 4)
                    {
                        if (ans[xx][yy] == 0)
                        {
                            ans[xx][yy] = k;
                            s[xx][yy] = 0;
                        }
                        for (int i = 1; i &lt;= 4; i++)
                        {
                            tmp.x = xx;
                            tmp.y = yy;
                            tmp.dir = i;//水滴运动的方向
                            q.push(tmp);
                        }
                    }
                }
                else //没水继续走
                {
                    tmp.x = xx;
                    tmp.y = yy;
                    tmp.dir = d;//水滴运动的方向
                    q.push(tmp);
                }
            }

        }
    }
    return;
}

int main()
{
    while (~scanf(&quot;%d%d%d%d&quot;, &amp;r, &amp;c, &amp;n, &amp;t))
    {
        memset(s, 0, sizeof(s));
        memset(ans, 0, sizeof(ans));
        int x, y, z;

        for (int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);
            p[i].x = x; p[i].y = y;
            s[x][y] = z;
        }

        scanf(&quot;%d%d&quot;, &amp;sx, &amp;sy);
        bfs();

        for (int i = 1; i &lt;= n; i++)
        {
            if (ans[p[i].x][p[i].y])
                printf(&quot;0 %d\n&quot;, ans[p[i].x][p[i].y]);
            else 
                printf(&quot;1 %d\n&quot;, s[p[i].x][p[i].y]);
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 5339 Untitled【搜索】</title>
    <url>/article/csdn/hdu_5339_Untitled%E3%80%90%E6%90%9C%E7%B4%A2%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47193089" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47193089</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5339" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5339
</a></p>
<p>题意：一个整数a 和一个数组b，问你是否能在b中取出r个元素排列组成c数组满足a%c1%c1%…..%cr == 0。输出最小的r，不能满足条件输出-1。</p>
<p>思路：b按从大到小排序，暴搜。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;assert.h&gt;

using namespace std;

int n, a, b[300],ans;

bool cmp11(int a, int b)
{
    return a &gt; b;
}

void dfs(int x,int num,int A)
{
    if (x == 0)
    {
        ans = min(ans, A); return;
    }
    if (num == n) return;

    //printf(&quot;    %d\n&quot;,x);
    dfs(x % b[num + 1], num + 1, A + 1);
    dfs(x, num + 1, A);
}

int main()
{
    //printf(&quot;3 % 7&quot;);
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%d %d&quot;, &amp;n, &amp;a);
        for (int i = 1; i &lt;= n; i++)
            scanf(&quot;%d&quot;, &amp;b[i]);
        sort(b + 1, b + 1 + n, cmp11);
        ans = 500;
        dfs(a, 0, 0);
        if (ans == 500) ans = -1;
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 5344 MZL&#39;s xor</title>
    <url>/article/csdn/hdu_5344_MZL&#39;s_xor.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47285335" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47285335</a></p>
<h1><span id="mzls-xor">MZL’s xor</span></h1><p><strong> Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/65536 K<br>(Java/Others)<br>Total Submission(s): 310    Accepted Submission(s): 225  
</strong>  </p>
<p>Problem Description</p>
<p>MZL loves xor very much.Now he gets an array A.The length of A is n.He wants<br>to know the xor of all (  A  i  +  A  j  )(  1  ≤  i  ,  j  ≤  n  )<br>The xor of an array B is defined as  B  1  xor  B  2  …xor  B  n</p>
<p>Input</p>
<p>Multiple test cases, the first line contains an integer T(no more than 20),<br>indicating the number of cases.<br>Each test case contains four integers:  n  ,  m  ,  z  ,  l<br>A  1  =  0  ,  A  i  =  (  A  i  −  1  ∗  m  +  z  )  m  o  d  l<br>1  ≤  m  ,  z  ,  l  ≤  5  ∗  10  5  ,  n  =  5  ∗  10  5  </p>
<p>Output</p>
<p>For every test.print the answer.</p>
<p>Sample Input</p>
<p>2 3 5 5 7 6 8 8 9</p>
<p>Sample Output</p>
<p>14 16</p>
<p>题意：求所有a[i]+a[j] 异或值，因为a[i]+a[j] 和a[j]+a[i] 会异或掉 所以只需考虑a[i]+a[i]</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;ctime&gt;  
#include &lt;math.h&gt;  
#include &lt;limits.h&gt;  
#include &lt;complex&gt;  
#include &lt;string&gt;  
#include &lt;functional&gt;  
#include &lt;iterator&gt;  
#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;stack&gt;  
#include &lt;queue&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;list&gt;  
#include &lt;bitset&gt;  
#include &lt;sstream&gt;  
#include &lt;iomanip&gt;  
#include &lt;fstream&gt;  
#include &lt;iostream&gt;  
#include &lt;ctime&gt;  
#include &lt;cmath&gt;  
#include &lt;cstring&gt;  
#include &lt;cstdio&gt;  
#include &lt;time.h&gt;  
#include &lt;ctype.h&gt;  
#include &lt;string.h&gt;  
#include &lt;assert.h&gt;  

using namespace std;

long long n, m, z, l;


int main()
{
    int t;
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    {
        scanf(&quot;%lld%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;z, &amp;l);
        long long ans = 0;
        long long tmp = 0;
        for (int i = 2; i &lt;= n;i++)
        {
            tmp = (tmp *m + z) % l;
            ans ^= (2 * tmp);
        }
        printf(&quot;%lld\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 5340 Three Palindromes 【Manacher】</title>
    <url>/article/csdn/hdu_5340_Three_Palindromes_%E3%80%90Manacher%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47205883" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47205883</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5340" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5340
</a></p>
<p>题意：判断一个字符串能否分为三个回文串</p>
<p>解法：manacher枚举第一第三个，判断第二个。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;assert.h&gt;

using namespace std;

int t;
int p[220100];
char s[220100], c[221000];
int pre[221000], last[221000];

int solve()
{
    int len = strlen(s);
    c[0] = &#39;$&#39;;
    for (int i = 0; i&lt;len; i++)
        c[i * 2 + 1] = &#39;#&#39;, c[i * 2 + 2] = s[i];
    c[len * 2 + 1] = &#39;#&#39;;
    len = len * 2 + 2;
    c[len] = 0;
    int mx = 0, id = 0;
    for (int i = 1; i&lt;len; i++)
    {
        if (mx&gt;i) p[i] = min(p[id * 2 - i], p[id] + id - i);
        else p[i] = 1;
        while (c[i + p[i]] == c[i - p[i]]) p[i]++;
        if (i + p[i]&gt;mx) mx = i + p[i], id = i;
    }

    int p_num = 0, l_num = 0;
    for (int i = 2; i &lt; len - 1; i++)
    {
        if (i == p[i]) pre[p_num++] = i;
        if (i + p[i] == len) last[l_num++] = i;
    }

    for (int i = 0; i &lt; p_num; i++)
    {
        for (int j = l_num - 1; j &gt;= 0; j--)
        {
            int pos1 = pre[i] + p[pre[i]];
            int pos2 = last[j] - p[last[j]];
            if (pos1 &gt; pos2) break;
            int mid = (pos1 + pos2) / 2;
            if (mid&lt;=len-4)
            if (mid - pos1 + 1  &lt;= p[mid]) return 1;
        }
    }
    return 0;
}

int main()
{
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    {
        scanf(&quot;%s&quot;, s);
        if (solve()) printf(&quot;Yes\n&quot;);
        else printf(&quot;No\n&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 5371 Hotaru&#39;s problem【manacher】</title>
    <url>/article/csdn/hdu_5371_Hotaru&#39;s_problem%E3%80%90manacher%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47487445" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47487445</a></p>
<p>题目链接：<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5371" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5371
</a></p>
<p>题意：<br>给出一个长度为n的串，要求找出一条最长连续子串。这个子串要满足：1：可以平均分成三段，2：第一段和第三段相等，3：第一段和第二段回文。求最大子串的长度。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;string.h&gt;

using namespace std;

const int N = 1100550;

int n, l, tmp;
int p[2 * N];//记录回文半径
int str0[N];//原始串
int str[2 * N];//转换后的串

void init()
{
    int i;
    str[0] = -2; str[1] = -1;
    l = 2;
    for (i = 0, l = 2; i&lt;n; i++, l += 2)
    {
        str[l] = str0[i];
        str[l + 1] = -1;
    }
    str[l] = -5;
}

int solve()
{
    int i, mx, id;
    mx = 0;//mx即为当前计算回文串最右边字符的最大值  
    for (i = 1; i &lt; l; i++)
    {
        if (mx&gt;i)
            p[i] = p[2 * id - i]&gt;(mx - i) ? (mx - i) : p[2 * id - i];
        else
            p[i] = 1;//如果i&gt;=mx，要从头开始匹配  
        while (str[i + p[i]] == str[i - p[i]])
            p[i]++;
        if (i + p[i]&gt;mx)//若新计算的回文串右端点位置大于mx，要更新po和mx的值
        {
            mx = i + p[i];
            id = i;
        }
    }

    int ans = 0;
    for (int i = 1; i &lt; l; i += 2)
        for (int j = i + p[i] - 1; j - i &gt; ans; j -= 2)
        {
            if (p[j] &gt;= j-i+1 &amp;&amp; ans &lt; j - i)
            {
                ans = j - i;
                break;
            }
        }

    return ans / 2 * 3;
}
int main()
{
    int t;
    int cases = 1;
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    {
        scanf(&quot;%d&quot;, &amp;n);

        for (int i = 0; i &lt; n; i++)
            scanf(&quot;%d&quot;,&amp;str0[i]);
        init();
        printf(&quot;Case #%d: %d\n&quot;, cases++, solve());
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 5348 MZL&#39;s endless loop</title>
    <url>/article/csdn/hdu_5348_MZL&#39;s_endless_loop.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47297889" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47297889</a></p>
<h1><span id="mzls-endless-loop">MZL’s endless loop</span></h1><p><strong> Time Limit: 3000/1500 MS (Java/Others)    Memory Limit: 131072/131072 K<br>(Java/Others)<br>Total Submission(s): 1370    Accepted Submission(s): 297<br>Special Judge  </strong>  </p>
<p>Problem Description</p>
<p>As we all kown, MZL hates the endless loop deeply, and he commands you to<br>solve this problem to end the loop.<br>You are given an undirected graph with  n  vertexs and  m  edges. Please<br>direct all the edges so that for every vertex in the graph the inequation  |<br>o  u  t  d  e  g  r  e  e  −  i  n  d  e  g  r  e  e  |  ≤  1  is satisified.<br>The graph you are given maybe contains self loops or multiple edges.</p>
<p>Input</p>
<p>The first line of the input is a single integer  T  , indicating the number of<br>testcases.<br>For each test case, the first line contains two integers  n  and  m  .<br>And the next  m  lines, each line contains two integers  u  i  and  v  i  ,<br>which describe an edge of the graph.<br>T  ≤  100  ,  1  ≤  n  ≤  10  5  ,  1  ≤  m  ≤  3  ∗  10  5  ,  ∑  n  ≤  2  ∗<br>10  5  ,  ∑  m  ≤  7  ∗  10  5  .</p>
<p>Output</p>
<p>For each test case, if there is no solution, print a single line with  −  1  ,<br>otherwise output  m  lines,.<br>In  i  th line contains a integer  1  or  0  ,  1  for direct the  i  th edge<br>to  u  i  →  v  i  ,  0  for  u  i  ←  v  i  .</p>
<p>Sample Input</p>
<p>2 3 3 1 2 2 3 3 1 7 6 1 2 1 3 1 4 1 5 1 6 1 7</p>
<p>Sample Output</p>
<p>1 1 1 0 1 0 1 0 1</p>
<p>题意 ：给你一个无向图，问你是否能把图变为有向图，且满足每个点的出度与入度的差小于1.</p>
<p>解法：无向图一定能够满足条件。度数奇数的为欧拉路径的起点或终点。偶数的为欧拉路径中间点，或环上的点。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;ctime&gt;  
#include &lt;math.h&gt;  
#include &lt;limits.h&gt;  
#include &lt;complex&gt;  
#include &lt;string&gt;  
#include &lt;functional&gt;  
#include &lt;iterator&gt;  
#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;stack&gt;  
#include &lt;queue&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;list&gt;  
#include &lt;bitset&gt;  
#include &lt;sstream&gt;  
#include &lt;iomanip&gt;  
#include &lt;fstream&gt;  
#include &lt;iostream&gt;  
#include &lt;ctime&gt;  
#include &lt;cmath&gt;  
#include &lt;cstring&gt;  
#include &lt;cstdio&gt;  
#include &lt;time.h&gt;  
#include &lt;ctype.h&gt;  
#include &lt;string.h&gt;  
#include &lt;assert.h&gt;  
#pragma comment (linker, &quot;/STACK:102400000,102400000&quot;)

using namespace std;

const int MAXN = 1e6+10;
const int MAXM = 1e6+10;

int n, m;
int x, y;

//////////////
struct Edge
{
    int to, next;
    int index;
    bool flag;
}edge[MAXM];

int head[MAXM], tot;
int sum_du[MAXN];//总度数
int du[MAXN][2];//d[i][0] 入度 d[i][1]出度
int ans[MAXM];//答案

void addedge(int u, int v, int index)
{
    edge[tot].to = v;
    edge[tot].flag = false;
    edge[tot].index = index;
    edge[tot].next = head[u];
    head[u] = tot++;
}

void init()
{
    tot = 0;
    memset(head, -1, sizeof(head));
    memset(du, 0, sizeof(du));
    memset(sum_du,0,sizeof(sum_du));
    memset(ans,-1,sizeof(ans));
}
///////////////////

void dfs(int u,int ok)
{
    for (int i = head[u]; i != -1; i = edge[i].next)
    {
        if (edge[i].flag)//访问过的边  删除
        {
            head[u] = edge[i].next;
            continue;
        }
        int v = edge[i].to;
        if (u != v &amp;&amp; du[v][ok^1] &gt; du[v][ok])
            continue;
        /////////////
        edge[i].flag = true;
        edge[i ^ 1].flag = true;
        if (i % 2  == 1)
            ans[i / 2] = ok ^ 1;
        else
            ans[i / 2] = ok;

        du[u][ok]++;
        du[v][ok ^ 1]++;
        head[u] = edge[i].next;//删边
        dfs(v,ok);
        break;
    }
}

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
        init();
        for (int i = 0; i &lt; m; i++)
        {
            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
            addedge(x, y, i);
            addedge(y, x, i);
            sum_du[x]++;
            sum_du[y]++;
        }
        for (int i = 1; i &lt;= n; i++)
        {
            while (du[i][0] + du[i][1] &lt; sum_du[i])
            {
                if (du[i][0] &lt;= du[i][1])
                    dfs(i, 0);//正向走
                else
                    dfs(i, 1);//反向走
            }
        }
        for (int i = 0; i &lt; m; i++)
            printf(&quot;%d\n&quot;,ans[i]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 5418 Victor and World【状态压缩】</title>
    <url>/article/csdn/hdu_5418_Victor_and_World%E3%80%90%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47948247" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47948247</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5418" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5418
</a></p>
<p>题意：从1出发 每个点至少经过一次 最后回到1点的最短路径</p>
<p>首先用floyd处理点之间的最短距离 再状压求解</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;ctime&gt;  
#include &lt;math.h&gt;  
#include &lt;limits.h&gt;  
#include &lt;complex&gt;  
#include &lt;string&gt;  
#include &lt;functional&gt;  
#include &lt;iterator&gt;  
#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;stack&gt;  
#include &lt;queue&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;list&gt;  
#include &lt;bitset&gt;  
#include &lt;sstream&gt;  
#include &lt;iomanip&gt;  
#include &lt;fstream&gt;  
#include &lt;iostream&gt;  
#include &lt;ctime&gt;  
#include &lt;cmath&gt;  
#include &lt;cstring&gt;  
#include &lt;cstdio&gt;  
#include &lt;time.h&gt;  
#include &lt;ctype.h&gt;  
#include &lt;string.h&gt;  
#include &lt;assert.h&gt;  

using namespace std;

const int inf = 0x3f3f3f3f;
int n, m, k, v;
int g[20][20];
int dp[(1&lt;&lt;16) + 10][20];

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        for (int i = 0;i &lt;= n;i++)
            for (int j = 0;j &lt;= n;j++)
            {
                if (i == j) g[i][i] = 0;
                else g[i][j] = inf;
            }
        int a, b, c;
        while (m--)
        {
            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
            --a; --b;
            g[a][b] = min(g[a][b], c);
            g[b][a] = min(g[b][a], c);
        }

        for (int k = 0;k &lt; n;k++)
            for (int i = 0;i &lt; n;i++)
                for (int j = 0;j &lt; n;j++)
                    g[i][j] = min(g[i][j], g[i][k] + g[k][j]);

        memset(dp,inf,sizeof(dp));
        dp[0][0] = 0;

        for (int i = 0;i &lt;= (1 &lt;&lt; n) - 1;i++)
            for (int v = 0;v &lt; n;v++)
                if (dp[i][v] != inf)
                {
                    for (int u = 0;u &lt; n;u++)
                        dp[i | (1 &lt;&lt; u)][u] = min(dp[i | (1 &lt;&lt; u)][u], dp[i][v] + g[v][u]);
                }
        printf(&quot;%d\n&quot;, dp[(1 &lt;&lt; n) - 1][0]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 5492 Find a path【dp】</title>
    <url>/article/csdn/hdu_5492_Find_a_path%E3%80%90dp%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48809987" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48809987</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5492" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5492
</a></p>
<p>原来公式（n+m-1）<em> ∑（ai - ai_ave）^2,求公式的最小值，即最小方差路径。<br>公式展开化简后可以得到 (n+m-1)</em>s1-s2<br>s1为ai平方和，s2为和的平方。<br>dp[i][j][k] 表示 到达i行，j列时，ai的和为k时的最小平方和。</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

const int inf = 0x3f3f3f3f;

int n, m;
int dp[32][32][2000];
int a[32][32];

int main()
{
    int t, cases = 1;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        memset(dp, inf, sizeof(dp));
        memset(a, 0, sizeof(a));

        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        for (int i = 0;i &lt; n;i++)
            for (int j = 0;j &lt; m;j++)
                scanf(&quot;%d&quot;, &amp;a[i][j]);

        dp[0][0][a[0][0]] = a[0][0] * a[0][0];

        for (int i = 0;i &lt; n;i++)
            for (int j = 0;j &lt; m;j++)
            {
                if (i + 1 &lt; n)
                {
                    for (int k = 0;k &lt;= 59 * 30;k++)
                        if (dp[i][j][k] != inf)
                            dp[i + 1][j][k + a[i + 1][j]] = min(dp[i + 1][j][k + a[i + 1][j]], dp[i][j][k] + a[i + 1][j] * a[i + 1][j]);
                }
                if (j + 1 &lt; m)
                {
                    for (int k = 0;k &lt;= 59 * 30;k++)
                        if (dp[i][j][k] != inf)
                            dp[i][j + 1][k + a[i][j + 1]] = min(dp[i][j + 1][k + a[i][j + 1]], dp[i][j][k] + a[i][j + 1] * a[i][j + 1]);
                }
            }
        int ans = inf;
        for (int i = 0;i &lt;= 59 * 30;i++)
            if (dp[n-1][m-1][i]!=inf)
            ans = min(ans, (n + m - 1)*dp[n - 1][m - 1][i] - i*i);
        printf(&quot;Case #%d: %d\n&quot;, cases++, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 5352 MZL&#39;s City 【二分图】</title>
    <url>/article/csdn/hdu_5352_MZL&#39;s_City_%E3%80%90%E4%BA%8C%E5%88%86%E5%9B%BE%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47306961" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47306961</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5352" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5352
</a></p>
<p>题意：<br>给你n,m,k<br>表示n个建筑 m次操作，修复操作每次最多修复k个建筑。<br>有三种操作<br>1.修复x点周围建筑（&lt;=k）<br>2.x,y建筑间建边<br>3.x,y间删边<br>修复建筑时候拆点建图。反着求最大匹配，保证字典序最小。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;ctime&gt;  
#include &lt;math.h&gt;  
#include &lt;limits.h&gt;  
#include &lt;complex&gt;  
#include &lt;string&gt;  
#include &lt;functional&gt;  
#include &lt;iterator&gt;  
#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;stack&gt;  
#include &lt;queue&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;list&gt;  
#include &lt;bitset&gt;  
#include &lt;sstream&gt;  
#include &lt;iomanip&gt;  
#include &lt;fstream&gt;  
#include &lt;iostream&gt;  
#include &lt;ctime&gt;  
#include &lt;cmath&gt;  
#include &lt;cstring&gt;  
#include &lt;cstdio&gt;  
#include &lt;time.h&gt;  
#include &lt;ctype.h&gt;  
#include &lt;string.h&gt;  
#include &lt;assert.h&gt;  
#pragma comment (linker, &quot;/STACK:102400000,102400000&quot;)

using namespace std;

template &lt;class T&gt;
inline bool scan_d(T &amp;ret)
{
    char c; int sgn;
    if (c = getchar(), c == EOF) return 0; //EOF  
    while (c != &#39;-&#39; &amp;&amp; (c&lt;&#39;0&#39; || c&gt;&#39;9&#39;)) c = getchar();
    sgn = (c == &#39;-&#39;) ? -1 : 1;
    ret = (c == &#39;-&#39;) ? 0 : (c - &#39;0&#39;);
    while (c = getchar(), c &gt;= &#39;0&#39;&amp;&amp;c &lt;= &#39;9&#39;) ret = ret * 10 + (c - &#39;0&#39;);
    ret *= sgn;
    return 1;
}

const int MAXN = 100100;
const int N = 210;
// 200 500 200
int n, m, k;

int mp[N][N];
int book[N];
int match[N];
int path[N];
int len;
int vis[N];
vector&lt;int&gt; g[MAXN];
int ans[N*3], res;
int cc;

void get_path(int u)
{
    vis[u] = 1;
    path[len++] = u;
    for (int i = 1; i &lt;= n; i++)
    {
        if (!vis[i] &amp;&amp; mp[u][i] == 1)
        {
            get_path(i);
        }
    }
}

bool dfs(int u)
{
    int i;
    for (i = 0; i &lt; g[u].size(); i++)
    {
        int v = g[u][i];
        if (book[v] == 0)
        {
            book[v] = 1;
            if (match[v] == 0 || dfs(match[v]))
            {
                match[v] = u;
                return true;
            }
        }
    }
    return false;
}

void hungry()
{
    for (int i = cc-1; i &gt;= 0; i--)//保证字典序小 优先匹配后面的
    {
        for (int j = i*k; j &lt; i*k + k; j++)
        {
            memset(book, 0, sizeof(book));
            if (dfs(j))
                ans[i]++;
        }
        res += ans[i];
    }
}

void init()
{
    cc = 0;
    res = 0;
    for (int i = 0; i &lt; 100010; i++) g[i].clear();
    memset(mp, 0, sizeof(mp));
    memset(match, 0, sizeof(match));
    memset(ans, 0, sizeof(ans));
}

int main()
{
    int t;
    scan_d(t);
    while (t--)
    {
        scan_d(n);
        scan_d(m);
        scan_d(k);
        init();
        while(m--)
        {
            int p, q;
            int x, y;
            scan_d(p);
            if (p == 1)
            {
                scan_d(x);
                memset(vis, 0, sizeof(vis));
                len = 0;
                get_path(x);
                for (int i = 0; i &lt; len; i++)
                {
                    for (int j = cc*k; j &lt; (cc + 1)*k; j++)
                        g[j].push_back(path[i]);
                }
                cc++;
            }
            else if (p == 2)
            {
                scan_d(x);
                scan_d(y);
                mp[x][y] = mp[y][x] = 1;
            }
            else if (p == 3)
            {
                scan_d(q);
                while (q--)
                {
                    scan_d(x);
                    scan_d(y);
                    mp[x][y] = mp[y][x] = 0;
                }
            }
        }

        hungry();
        printf(&quot;%d\n&quot;, res);
        for (int i = 0; i &lt; cc - 1; i++)
            printf(&quot;%d &quot;, ans[i]); printf(&quot;%d\n&quot;, ans[cc - 1]);

    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>kruskal 【MST】</title>
    <url>/article/csdn/kruskal_%E3%80%90MST%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44730343" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44730343</a></p>
<pre><code>const int MAXN = 110;//点
const int MAXM = 10000;//边

int f[MAXN];//并查集使用

struct Edge
{
    int u, v, w;
}edge[MAXN];

int tol;//边数 初始化 0

void addedge(int u,int v,int w)
{
    edge[tol].u = u;
    edge[tol].v = v;
    edge[tol++].w = w;
}

bool cmp(Edge a,Edge b)
{
    return a.w &lt; b.w;
}

int find(int x)
{
    if (f[x] == -1)
        return x;
    else
        return f[x] = find(f[x]);
}

int kruskal(int n)
{
    memset(f,-1,sizeof(f));
    sort(edge, edge+tol, cmp);
    int cnt = 0;
    int ans = 0;
    for (int i = 0; i &lt; tol; i++)
    {
        int u = edge[i].u;
        int v = edge[i].v;
        int w = edge[i].w;
        int t1 = find(u);
        int t2 = find(v);
        if (t1 != t2)
        {
            ans += w;
            f[t1] = t2;
            cnt++;
        }
        if (cnt == n - 1)
            break;
    }
    if (cnt &lt; n - 1) return -1;//不连通
    else return ans;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 5889 Barricade【最小割】</title>
    <url>/article/csdn/hdu_5889_Barricade%E3%80%90%E6%9C%80%E5%B0%8F%E5%89%B2%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/52571760" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/52571760</a></p>
<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5889" target="_blank" rel="noopener"> http://acm.hdu.edu.cn/showproblem.php?pid=5889
</a></p>
<p>解法：求最短路图上的最小割，先在图上源点和终点分别求一遍最短路。再在最短路图上求最小割。<br>最小割==最大流定理</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;

using namespace std;

const int MAXN = 10100;//点数的最大值
const int MAXM = 400010;//边数的最大值
const int INF = 0x3f3f3f3f;
struct Edge
{
    int to, next, cap, flow;
}edge[MAXM];//注意是MAXM
int tol;
int head[MAXN];
int gap[MAXN], dep[MAXN], pre[MAXN], cur[MAXN];

void init()
{
    tol = 0;
    memset(head, -1, sizeof(head));
}
//加边，单向图三个参数，双向图四个参数
void addedge(int u, int v, int w, int rw = 0)
{
    edge[tol].to = v; edge[tol].cap = w; edge[tol].next = head[u];
    edge[tol].flow = 0; head[u] = tol++;
    edge[tol].to = u; edge[tol].cap = rw; edge[tol].next = head[v];
    edge[tol].flow = 0; head[v] = tol++;
}

//输入参数：起点、终点、点的总数
//点的编号没有影响，只要输入点的总数

int sap(int start, int end, int N)
{
    memset(gap, 0, sizeof(gap));
    memset(dep, 0, sizeof(dep));
    memcpy(cur, head, sizeof(head));
    int u = start;
    pre[u] = -1;
    gap[0] = N;
    int ans = 0;
    while (dep[start] &lt; N)
    {
        if (u == end)
        {
            int Min = INF;
            for (int i = pre[u]; i != -1; i = pre[edge[i ^ 1].to])
                if (Min &gt; edge[i].cap - edge[i].flow)
                    Min = edge[i].cap - edge[i].flow;
            for (int i = pre[u]; i != -1; i = pre[edge[i ^ 1].to])
            {
                edge[i].flow += Min;
                edge[i ^ 1].flow -= Min;
            }
            u = start;
            ans += Min;
            continue;
        }
        bool flag = false;
        int v;
        for (int i = cur[u]; i != -1; i = edge[i].next)
        {
            v = edge[i].to;
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[v] + 1 == dep[u])
            {
                flag = true;
                cur[u] = pre[v] = i;
                break;
            }
        }
        if (flag)
        {
            u = v;
            continue;
        }
        int Min = N;
        for (int i = head[u]; i != -1; i = edge[i].next)
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min)
            {
                Min = dep[edge[i].to];
                cur[u] = i;
            }
        gap[dep[u]]--;
        if (!gap[dep[u]])return ans;
        dep[u] = Min + 1;
        gap[dep[u]]++;
        if (u != start) u = edge[pre[u] ^ 1].to;
    }
    return ans;
}

int n, m;
int diss[MAXN][MAXN];
bool vis[MAXN];
int d[MAXN];
int d2[MAXN];

void dijkstra(int s)
{
    for (int i = 1;i &lt;= n;i++)
    {
        vis[i] = 0;
        if (diss[s][i] == 1)
            d[i] = 1;
        else
            d[i] = INF;
    }
    d[s] = 0;

    while (1)
    {
        int min = INF, v = -1;
        for (int i = 1;i &lt;= n;i++)
            if (!vis[i] &amp;&amp; d[i]&lt;min)
            {
                v = i;
                min = d[i];
            }
        if (v == -1)
            break;
        vis[v] = 1;
        for (int i = 1;i &lt;= n;i++)
            if (diss[v][i] == 1)
                if (!vis[i] &amp;&amp; d[i] &gt; d[v] + 1)
                    d[i] = 1 + d[v];
    }
}

void dijkstra2(int s)
{
    for (int i = 1;i &lt;= n;i++)
    {
        vis[i] = 0;
        if (diss[s][i] == 1)
            d2[i] = 1;
        else
            d2[i] = INF;
    }
    d2[s] = 0;

    while (1)
    {
        int min = INF, v = -1;
        for (int i = 1;i &lt;= n;i++)
            if (!vis[i] &amp;&amp; d2[i]&lt;min)
            {
                v = i;
                min = d2[i];
            }
        if (v == -1)
            break;
        vis[v] = 1;
        for (int i = 1;i &lt;= n;i++)
            if (diss[v][i] == 1)
                if (!vis[i] &amp;&amp; d2[i] &gt; d2[v] + 1)
                    d2[i] = 1 + d2[v];
    }
}

struct Node
{
    int u, v, w;
}node[MAXM];

int main()
{
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    while (T--)
    {
        scanf(&quot;%d %d&quot;, &amp;n, &amp;m);

        int u, v, w;

        memset(diss, 0, sizeof(diss));
        for (int i = 0;i &lt; m;i++)
        {
            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);

            node[i].u = u;
            node[i].v = v;
            node[i].w = w;

            diss[u][v] = diss[v][u] = 1;
        }

        memset(d, -1, sizeof(d));
        memset(d2, -1, sizeof(d2));
        dijkstra(1);
        dijkstra2(n);

        init();
        for (int i = 0;i &lt; m;i++)
        {
            u = node[i].u;
            v = node[i].v;
            w = node[i].w;

            if (d[u] + d2[v] + 1 == d[n] &amp;&amp; d[u] !=-1 &amp;&amp; d2[v] != -1)
                addedge(u, v, w, 0);
            if ( d[v] + d2[u] + 1 == d[n] &amp;&amp; d[v] != -1 &amp;&amp; d2[u] != -1)
                addedge(v, u, w, 0);
        }
        int ans = sap(1, n, n);
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>light oj-1000</title>
    <url>/article/csdn/light_oj-1000.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40583319" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40583319</a></p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;


using namespace std;


int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    int s=1;
    while (t--)
    {
        int a ,b;
        scanf (&quot;%d%d&quot;,&amp;a,&amp;b);
        printf(&quot;Case %d: %d\n&quot;,s++,a+b);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hud-1556</title>
    <url>/article/csdn/hud-1556.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40210047" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40210047</a></p>
<p>树状数组：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt; 
#include&lt;malloc.h&gt; 
#include&lt;stdexcept&gt;

using namespace std;

int n;
int ar[100010];

int lowbit (int t)
{
    return  t&amp;(-t);
}

void add (int i,int v)
{
    while (i&lt;=n)
    {
        ar[i]+=v;
        i+=lowbit(i);
    }
}
int sum (int i)
{
    int ret =0 ;
    while (i&gt;0)
    {
        ret += ar[i];
        i-=lowbit (i);
    }
    return ret;
}


int main()
{
    while (scanf (&quot;%d&quot;,&amp;n)!=EOF &amp;&amp; n )
    {
        int a,b;
        memset (ar,0,sizeof (ar));
        int t=n;
        while (t--)
        {
            scanf (&quot;%d%d&quot;,&amp;a,&amp;b);
            add(a,1);
            add(b+1,-1);
        }

        for (int i=1;i&lt;n;i++)
            printf(&quot;%d &quot;,sum(i));
            printf(&quot;%d\n&quot;,sum(n));
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>light oj 1236 【大数分解】</title>
    <url>/article/csdn/light_oj_1236_%E3%80%90%E5%A4%A7%E6%95%B0%E5%88%86%E8%A7%A3%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44205833" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44205833</a></p>
<p>给定一个大数，分解质因数，每个质因子的个数为e1,e2,e3,……em，</p>
<p>则结果为((1+2<em>e1)</em>(1+2<em>e2)……(1+2</em>em)+1)/2.</p>
<pre><code>//light oj 1236 大数分解素因子

#include &lt;stdio.h&gt;  
#include &lt;iostream&gt;  
#include &lt;string.h&gt;  
#include &lt;algorithm&gt;  
#include &lt;math.h&gt;  
#include &lt;ctype.h&gt;  
#include &lt;time.h&gt;  
#include &lt;queue&gt;  
#include &lt;iterator&gt;  

const int MAXN = 10000200;

bool com[MAXN];
int primes;
long long prime[MAXN/10];
long long ans, t, n;

void init(int n)
{
    primes = 0;
    memset(com, false, sizeof(com));
    com[0] = com[1] = true;
    for (int i = 2; i &lt;= n; ++i)
    {
        if (!com[i])
        {
            prime[++primes] = i;
        }
        for (int j = 1; j &lt;= primes &amp;&amp; i*prime[j] &lt;= n; ++j)
        {
            com[i*prime[j]] = true;
            if (!(i % prime[j]))
                break;
        }
    }
}

long long solve(long long n)//大数分解
{
    ans = 1;
    for (int i = 1; i&lt;=primes &amp;&amp; prime[i] * prime[i] &lt;= n; i++)
    {
        if (n % prime[i] == 0)
        {
            t = 1;
            n /= prime[i];
            while (n%prime[i] == 0)
            {
                t++;
                n /= prime[i];
            }
            ans *= (1 + 2 * t);
        }
    }
    if (n &gt; 1)
        ans *= 3;
    return (1+ans) / 2;
}

int main()
{ 
    init(10000000);
    int tt, cases = 1;
    scanf(&quot;%d&quot;,&amp;tt);
    while (tt--)
    {
        scanf(&quot;%lld&quot;,&amp;n);
        long long res = solve(n);
        printf(&quot;Case %d: %lld\n&quot;,cases++,res);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>lightoj-1006</title>
    <url>/article/csdn/lightoj-1006.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40907129" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40907129</a></p>
<p>传送门： <a href="http://www.lightoj.com/volume_showproblem.php?problem=1006" target="_blank" rel="noopener"> http://www.lightoj.com/volume_showproblem.php?problem=1006
</a></p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;malloc.h&gt;
#include&lt;string.h&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;

using namespace std;

int a[10005];

int main()
{
    int  n, caseno = 0, cases;
    scanf(&quot;%d&quot;, &amp;cases);
    while( cases-- ) {
        scanf(&quot;%d %d %d %d %d %d %d&quot;, &amp;a[0], &amp;a[1],&amp;a[2],&amp;a[3],&amp;a[4],&amp;a[5], &amp;n);
        for(i=0;i&lt;=5;i++)
        a[i]=a[i]%10000007;
        for (int i=6;i&lt;=n;i++)
            a[i]=(a[i-1]+a[i-2]+a[i-3]+a[i-4]+a[i-5]+a[i-6])% 10000007;
        printf(&quot;Case %d: %d\n&quot;, ++caseno, a[n]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-1064</title>
    <url>/article/csdn/poj-1064.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40347105" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40347105</a></p>
<p>二分搜索 ：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;

using namespace std;

int n;
int k;
double p[20000];

int c (double x)
{
    int num = 0;
    for (int i=1;i&lt;=n;i++)
    {
        num+= (int)(p[i]/x);
    }
    return (num &gt;= k);
}

int main ()
{

    while (scanf (&quot;%d%d&quot;,&amp;n,&amp;k)!=EOF)
    {
        for (int i=1;i&lt;=n;i++)
            scanf (&quot;%lf&quot;,&amp;p[i]);

        double lf=0,rl=10000000;
        double mid;
        for (int i=0;i&lt;100;i++)
        {
            mid = (lf + rl)/2;
            if (c(mid))
            {
                lf=mid;
            }
            else
            {
                rl=mid;
            }
        }
        printf(&quot;%0.2lf\n&quot;,floor(lf * 100)/100);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>lightoj 1138 - Trailing Zeroes (III)【二分】</title>
    <url>/article/csdn/lightoj_1138_-_Trailing_Zeroes_(III)%E3%80%90%E4%BA%8C%E5%88%86%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47024913" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47024913</a></p>
<p>题目链接： <a href="http://lightoj.com/volume_showproblem.php?problem=1138" target="_blank" rel="noopener"> http://lightoj.com/volume_showproblem.php?problem=1138
</a></p>
<p>题意：问 N！ 末尾 0 的个数为 Q 个的数是什么?</p>
<p>解法：二分枚举Ｎ，因为０是由５×2 出现的，2的个数比5多故计算5的个数即可。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

long long count_num(long long n)
{
    long long num = 0;
    while (n)
    {
        num += n / 5;
        n /= 5;
    }
    return num;
}

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    int cases = 1;
    while (t--)
    {
        int n;
        scanf(&quot;%d&quot;,&amp;n);
        printf(&quot;Case %d: &quot;,cases++);

        long long left = 1;
        long long right = 1000000000000;
        long long mid;

        while (left &lt;= right)
        {
            mid = (right + left) / 2;
            long long tmp = count_num(mid);
            if (tmp &gt;= n)
                right = mid - 1;
            else
                left = mid + 1;
        }
        if (count_num(left) != n)
            puts(&quot;impossible&quot;);
        else
            printf(&quot;%lld\n&quot;,left);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-1182 种类并查集</title>
    <url>/article/csdn/poj-1182_%E7%A7%8D%E7%B1%BB%E5%B9%B6%E6%9F%A5%E9%9B%86.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/42874641" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/42874641</a></p>
<p>转：  用0  1   2 分别表示A B C的关系。</p>
<p>0吃1,1吃2,2吃0.</p>
<p>注意这个编号都是以根结点为参照的，不是绝对的。</p>
<p>开一个val数组，一开始这个数组为0，所有的点都是独立的，不是相连的，没有关系。</p>
<p>慢慢加入点之后，把有关系的合并在一起，并且编号的相对大小确定一个集合中的关系。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;iomanip&gt;

using namespace std;

int n, k, d, x, y;
int fa[50010];
int rankk[50010];
int ans;

int findd(int x)
{
    if (fa[x] == -1)
        return x;

    int tmp = findd(fa[x]);

    rankk[x] += rankk[fa[x]];
    rankk[x] %= 3;

    return fa[x] = tmp;
}

int main()
{
    scanf(&quot;%d %d&quot;,&amp;n,&amp;k);
    {

        memset(fa,-1,sizeof(fa));
        memset(rankk,0,sizeof(rankk));

        ans = 0;

        while (k--)
        {
            scanf(&quot;%d %d %d&quot;, &amp;d, &amp;x, &amp;y);

            if (x &gt; n || y &gt; n)
            {
                ans++;
                continue;
            }

            int fx = findd(x);
            int fy = findd(y);

            if (fx == fy)
            {
                if (d == 1 &amp;&amp; rankk[x] != rankk[y])
                    ans++;
                if (d == 2 &amp;&amp; (rankk[x] + 1) % 3 != rankk[y])
                    ans++;
            }
            else
            {
                if (d == 1)
                {
                    fa[fy] = fx;
                    rankk[fy] = rankk[x] - rankk[y];
                    rankk[fy] = (rankk[fy] + 3) % 3;
                }
                else
                {
                    fa[fy] = fx;
                    rankk[fy] = rankk[x] - rankk[y] + 1; 
                    rankk[fy] = (rankk[fy] + 3) % 3;
                }

            }
        }
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>light-1001</title>
    <url>/article/csdn/light-1001.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40583393" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40583393</a></p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;

using namespace std;

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while(t--)
    {
        int n;
        scanf(&quot;%d&quot;,&amp;n);
        int a=0,b=n;
        if(n&gt;10)
            a=10,b=n-10;
        printf(&quot;%d %d\n&quot;,a,b);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-1258 Agri-Net</title>
    <url>/article/csdn/poj-1258_Agri-Net.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43194119" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43194119</a></p>
<p><a href="http://poj.org/problem?id=1258" target="_blank" rel="noopener"> http://poj.org/problem?id=1258 </a></p>
<p>简单题</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;

#define INF 10099990

using namespace std;

int map[110][110],dis[110],v[110];

long long  prim(int n)
{
    int k;
    long long min,sum=0;
    memset(v,0,sizeof(v));
    memset(dis,0,sizeof(dis));

    for(int i=1;i&lt;=n;i++)
        dis[i]=map[1][i];

    v[1]=1;
    dis[1]=0;

    for(int i=2;i&lt;=n;i++)
    {
        k=-1;
        min = INF;
        for(int j=1;j&lt;=n;j++)
            if(!v[j]&amp;&amp;min&gt;dis[j])
            {
                k=j;
                min=dis[j];
            }

        sum += min;
        v[k]=1;

        for(int j=1;j&lt;=n;j++)
            if(!v[j] &amp;&amp; dis[j]&gt;map[k][j])
                dis[j]=map[k][j];
    }
    return sum;
}
int main()
{
    int n,m;
    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)
    {
        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;=n;j++)
            {
                if (i != j)
                    map[i][j] = INF;
                else
                    map[i][j] = 0;
            }
        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;=n;j++)
            {
                scanf(&quot;%d&quot;,&amp;m);
                if (map[i][j] &gt;= m)
                {
                    map[i][j] = m;
                    map[j][i] = m;
                }
            }
        printf(&quot;%lld\n&quot;,prim(n));
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-1195</title>
    <url>/article/csdn/poj-1195.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/42145959" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/42145959</a></p>
<p>二维树状数组应用</p>
<p><a href="http://poj.org/problem?id=1195" target="_blank" rel="noopener"> http://poj.org/problem?id=1195 </a></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;map&gt;
#include &lt;stack&gt;

using namespace std;

int s;
int p[1030][1030];

int lowbit(int x)
{
    return x &amp; -x;
}

void add(int a,int b,int d)
{
    for (int i = a; i &lt;= s; i += lowbit(i))
        for (int j = b; j &lt;= s; j += lowbit(j))
        {
            p[i][j] += d;
        }
}

int sum(int a, int b)
{
    int ans = 0;
    for (int i = a; i &gt;0; i -= lowbit(i))
        for (int j = b; j &gt;0; j -= lowbit(j))
        {
            ans += p[i][j];
        }
    return ans;
}

void init(int s)
{
    for (int i = 0; i &lt;= s; i++)
        for (int j = 0; j &lt;= s;j++)
            p[i][j] = 0;
}

int main()
{
        int d;
        while (scanf(&quot;%d&quot;, &amp;d) != EOF)
        {
            if (d == 3)
                return 0;

            if (d == 0)
            {
                scanf(&quot;%d&quot;, &amp;s);
                init(s);
            }


            if (d == 1)
            {
                int x, y, a;
                scanf(&quot;%d %d %d&quot;, &amp;x, &amp;y, &amp;a);
                {
                    add(x + 1, y + 1, a);
                }
            }

            if (d == 2)
            {
                int l, b, r, t;
                scanf(&quot;%d %d %d %d&quot;, &amp;l, &amp;b, &amp;r, &amp;t);
                l++; b++; r++; t++;
                printf(&quot;%d\n&quot;, sum(l - 1, b - 1) + sum(r, t) - sum(r, b - 1) - sum(l - 1, t));
            }
        }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>poj-1251 Jungle Roads</title>
    <url>/article/csdn/poj-1251_Jungle_Roads.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43114479" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43114479</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=1251" target="_blank" rel="noopener"> http://poj.org/problem?id=1251 </a></p>
<p>简单题</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;

using namespace std;
#define INF 10000000

int n, m;
char a[5], b[5];
int c, d;

int map[100][100], dis[100], v[100];

int prim(int n)
{
    int i, j, k, min, sum = 0;
    for (i = 1; i &lt;= n; i++)
        dis[i] = map[1][i];

    memset(v, 0, sizeof(v));
    v[1] = 1;
    dis[1] = 0;

    for (i = 2; i &lt;= n; i++)
    {
        k = 1;
        min = INF;
        for (j = 1; j &lt;= n; j++)
            if (!v[j] &amp;&amp; min&gt;dis[j])
            {
                k = j;
                min = dis[j];
            }
        sum += min;
        v[k] = 1;
        for (j = 1; j &lt;= n; j++)
            if (!v[j] &amp;&amp; dis[j]&gt;map[k][j])
                dis[j] = map[k][j];
    }
    return sum;
}

int main()
{
    while (scanf(&quot;%d&quot;,&amp;n) != EOF)
    {
        if (n == 0)
            break;

        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= n; j++)
            {
                if (i != j)
                    map[i][j] = INF;
                else
                    map[i][j]= 0;
            }
        m = n-1;
        while (m--)
        {
            scanf(&quot;%s %d&quot;,a,&amp;c);
            while (c --)
            {
                scanf(&quot;%s %d&quot;,b,&amp;d);
                if (map[a[0]-&#39;A&#39;+1][b[0]-&#39;A&#39;+1] &gt; d)
                {
                    map[a[0]-&#39;A&#39;+ 1][b[0]-&#39;A&#39;+1] = d;
                    map[b[0]-&#39;A&#39;+1][a[0]-&#39;A&#39;+1] = d;
                }
            }
        }
        printf(&quot;%d\n&quot;,prim(n));
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>poj-1287 最小生成树</title>
    <url>/article/csdn/poj-1287_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43113845" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43113845</a></p>
<p>简单题.</p>
<p>Networking</p>
<table>
<thead>
<tr>
<th><strong>Time Limit:</strong> 1000MS</th>
<th></th>
<th><strong>Memory Limit:</strong> 10000K  </th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Total Submissions:</strong> 6448</td>
<td></td>
<td><strong>Accepted:</strong> 3500  </td>
</tr>
</tbody>
</table>
<p>Description</p>
<p>You are assigned to design network connections between certain points in a<br>wide area. You are given a set of points in the area, and a set of possible<br>routes for the cables that may connect pairs of points. For each possible<br>route between two points, you are given the length of the cable that is needed<br>to connect the points over that route. Note that there may exist many possible<br>routes between two given points. It is assumed that the given possible routes<br>connect (directly or indirectly) each two points in the area.<br>Your task is to design the network for the area, so that there is a connection<br>(direct or indirect) between every two points (i.e., all the points are<br>interconnected, but not necessarily by a direct cable), and that the total<br>length of the used cable is minimal.</p>
<p>Input</p>
<p>The input file consists of a number of data sets. Each data set defines one<br>required network. The first line of the set contains two integers: the first<br>defines the number P of the given points, and the second the number R of given<br>routes between the points. The following R lines define the given routes<br>between the points, each giving three integer numbers: the first two numbers<br>identify the points, and the third gives the length of the route. The numbers<br>are separated with white spaces. A data set giving only one number P=0 denotes<br>the end of the input. The data sets are separated with an empty line.<br>The maximal number of points is 50. The maximal length of a given route is</p>
<ol start="100">
<li>The number of possible routes is unlimited. The nodes are identified with<br>integers between 1 and P (inclusive). The routes between two points i and j<br>may be given as i j or as j i.  </li>
</ol>
<p>Output</p>
<p>For each data set, print one number on a separate line that gives the total<br>length of the cable used for the entire designed network.</p>
<p>Sample Input</p>
<pre><code>1 0

2 3
1 2 37
2 1 17
1 2 68

3 7
1 2 19
2 3 11
3 1 7
1 3 5
2 3 89
3 1 91
1 2 32

5 7
1 2 5
2 3 7
2 4 8
4 5 11
3 5 10
1 5 6
4 2 12

0
</code></pre><p>Sample Output</p>
<pre><code>0
17
16
26







#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;

using namespace std;
#define INF 10000000

int n, m;
int a, b, c;

int map[100][100], dis[100], v[100];

int prim(int n)
{
    int i, j, k, min, sum = 0;
    for (i = 1; i &lt;= n; i++)
        dis[i] = map[1][i];

    memset(v, 0, sizeof(v));
    v[1] = 1;
    dis[1] = 0;

    for (i = 2; i &lt;= n; i++)
    {
        k = 1;
        min = INF;
        for (j = 1; j &lt;= n; j++)
            if (!v[j] &amp;&amp; min&gt;dis[j])
            {
                k = j;
                min = dis[j];
            }
        sum += min;
        v[k] = 1;
        for (j = 1; j &lt;= n; j++)
            if (!v[j] &amp;&amp; dis[j]&gt;map[k][j])
                dis[j] = map[k][j];
    }
    return sum;
}

int main()
{
    while (scanf(&quot;%d %d&quot;, &amp;n, &amp;m) != EOF )
    {
        if (n == 0)
            break;
        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= n; j++)
                map[i][j] = INF;

        while (m--)
        {
            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
            if (map[a][b] &gt;= c)
            {
                map[a][b] = map[b][a] = c;
            }
        }
        printf(&quot;%d\n&quot;,prim(n));
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-1611</title>
    <url>/article/csdn/poj-1611.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40209551" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40209551</a></p>
<p>寻找根节点为 0  的节点的个数</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;

using namespace std;

int p[30005];
int rankk[30005];

int findd (int x)
{
    if (x == p[x])
        return x;
    else return  p[x]=findd(p[x]);
}

void un(int x, int y)
{
    int a,b;
    a = findd(x);
    b = findd(y);
    if (a == b)
        return;
    if (rankk[a] &gt; rankk[b])
        p[b] = a;
    else {
        p[a] = b;
        if (rankk[a] == rankk[b])
            rankk[b]++;
    }
}

int main()
{
    int n,m;
    while (scanf(&quot;%d%d&quot;,&amp;n,&amp;m) &amp;&amp; (n || m) )
    {
            for (int i=0;i&lt;n;i++)
        {
            p[i]=i;
            rankk[i]=0;
        }
        int num;
        int k,kk;

        for (int i=0;i&lt;m;i++)
        {
            scanf (&quot;%d&quot;,&amp;num);

            if (num&gt;=1)
            scanf (&quot;%d&quot;,&amp;k);

            for (int j=1;j&lt;num;j++)
            {
                scanf(&quot;%d&quot;,&amp;kk);
                un(k,kk);
            }

        }

        int ans = 1 ;

        for (int i=1;i&lt;n;i++)
        {
            if ( findd(i) == findd(0) )
                ans++;
        }

        printf(&quot;%d\n&quot;,ans);
    }
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-1321棋盘摆放 DFS</title>
    <url>/article/csdn/poj-1321%E6%A3%8B%E7%9B%98%E6%91%86%E6%94%BE_DFS.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/42214607" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/42214607</a></p>
<p><a href="http://poj.org/problem?id=1321" target="_blank" rel="noopener"> http://poj.org/problem?id=1321 </a></p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include &lt;sstream&gt;
#include &lt;time.h&gt;
#include &lt;utility&gt; 
#include &lt;malloc.h&gt; 

using namespace std;

int n, k, c;
char cc;
bool p[10][10];
bool visx[10];
bool visy[10];

void dfs(int pos,int a)
{
    if (a == k)
    {
        c++;
        return;
    }
    while (pos &lt; n*n)
    {
        int x = pos / n;
        int y = pos % n;
        if (p[x][y] &amp;&amp; !visx[x] &amp;&amp; !visy[y])
        {
            visx[x] = visy[y] = true;
            dfs(pos+1,a+1);
            visx[x] = visy[y] = false;
        }
        pos++;
    }
    return;
}

int main()
{
    while (scanf(&quot;%d%d&quot;,&amp;n,&amp;k)!=EOF)
    {
        c = 0;
        if (n == -1 &amp;&amp; k == -1)
            return 0;
        getchar();
        memset(p,false,sizeof(p));
        for (int i = 0; i &lt; n; i++)
        {
            for (int j = 0; j &lt; n; j++)
            {
                cc = getchar();
                if (cc == &#39;#&#39;)
                    p[i][j] = true;
                else
                    p[i][j] = false;
            }
            getchar();
        }

        memset(visx,false,sizeof(visx));
        memset(visy, false, sizeof(visy));

        dfs(0, 0);

        printf(&quot;%d\n&quot;,c);
    }
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-1611 并查集</title>
    <url>/article/csdn/poj-1611_%E5%B9%B6%E6%9F%A5%E9%9B%86.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/42835663" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/42835663</a></p>
<p><a href="http://poj.org/problem?id=1611" target="_blank" rel="noopener"> http://poj.org/problem?id=1611 </a></p>
<p>简单并查集，假设学号是0 的学生已经是感染者，问与他同集合的人有多少个。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;iomanip&gt;

using namespace std;

int n, m, k, t, tt;
int fa[30010];
int b[510];
int num[30010];

int findd(int x)
{
    if (x == fa[x])
        return x;
    else
        return findd(fa[x]);
}

void un(int x,int y )
{
    int fx = findd(x);
    int fy = findd(y);
    if (fx == fy)
        return;
    else
    {
        if (fy &gt; fx)
        {
            num[fx] += num[fy];
            fa[fy] = fx;
        }
        else
        {
            num[fy] += num[fx];
            fa[fx] = fy;
        }
    }
}

int main()
{
    while (cin &gt;&gt; n &gt;&gt; m)
    {
        if (n == 0 &amp;&amp; m == 0)
            return 0;

        for (int i = 0; i &lt;= n; i++)
        {
            fa[i] = i;
            num[i] = 1;
        }
        while (m--)
        {
            cin &gt;&gt; k;
            if (k)
                cin &gt;&gt; tt;

            k--;
            while (k --)
            {
                cin &gt;&gt; t;
                un(t,tt);
            }
        }
        cout &lt;&lt; num[0] &lt;&lt; endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-1661 Help Jimmy 【DP】</title>
    <url>/article/csdn/poj-1661_Help_Jimmy_%E3%80%90DP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44058587" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44058587</a></p>
<p>Help Jimmy</p>
<table>
<thead>
<tr>
<th><strong>Time Limit:</strong> 1000MS</th>
<th></th>
<th><strong>Memory Limit:</strong> 10000K  </th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Total Submissions:</strong> 8955</td>
<td></td>
<td><strong>Accepted:</strong> 2871  </td>
</tr>
</tbody>
</table>
<p>Description</p>
<p>“Help Jimmy” 是在下图所示的场景上完成的游戏。<br><img src="http://poj.org/images/1661_1.jpg" alt=""><br>场景中包括多个长度和高度各不相同的平台。地面是最低的平台，高度为零，长度无限。  </p>
<p>Jimmy老鼠在时刻0从高于所有平台的某处开始下落，它的下落速度始终为1米/秒。当Jimmy落到某个平台上时，游戏者选择让它向左还是向右跑，它跑动的速度也是1米/秒。当Jimmy跑到平台的边缘时，开始继续下落。Jimmy每次下落的高度不能超过MAX米，不然就会摔死，游戏也会结束。  </p>
<p>设计一个程序，计算Jimmy到底地面时可能的最早时间。  </p>
<p>Input</p>
<p>第一行是测试数据的组数t（0  &lt;= t &lt;=<br>20）。每组测试数据的第一行是四个整数N，X，Y，MAX，用空格分隔。N是平台的数目（不包括地面），X和Y是Jimmy开始下落的位置的横竖坐标，MAX是一次下落的最大高度。接下来的N行每行描述一个平台，包括三个整数，X1[i]，X2[i]和H[i]。H[i]表示平台的高度，X1[i]和X2[i]表示平台左右端点的横坐标。1<br>&lt;= N &lt;= 1000，-20000 &lt;= X, X1[i], X2[i] &lt;= 20000，0 &lt; H[i] &lt; Y &lt;= 20000（i =<br>1..N）。所有坐标的单位都是米。  </p>
<p>Jimmy的大小和平台的厚度均忽略不计。如果Jimmy恰好落在某个平台的边缘，被视为落在平台上。所有的平台均不重叠或相连。测试数据保证问题一定有解。  </p>
<p>Output</p>
<p>对输入的每组测试数据，输出一个整数，Jimmy到底地面时可能的最早时间。</p>
<p>Sample Input</p>
<pre><code>1
3 8 17 20
0 10 8
0 10 13
4 14 3
</code></pre><p>Sample Output</p>
<pre><code>23





#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;

using namespace std;

int n, x, y, MAX, t, i, j, ok;

struct node
{
    int l, r, h;
}p[1010];

bool cmp(node a, node b)//低到高排序
{
    return a.h &lt;= b.h;
}

int dp[1010][2];

int main()
{
    cin &gt;&gt; t;
    while (t--)
    {
        cin &gt;&gt; n &gt;&gt; x &gt;&gt; y &gt;&gt; MAX;
        for (i = 0; i &lt; n; i++)
            cin &gt;&gt; p[i].l &gt;&gt; p[i].r &gt;&gt; p[i].h;
        sort(p,p+n,cmp);
        p[n].l = x; p[n].r = x; p[n].h = y;
        dp[0][0] = dp[0][1] =  p[0].h;
        //从下向上DP,dp[i][0] 左侧最短时间 / dp[i][1] 右侧最短时间
        for (i = 1; i &lt;= n; i++)
        {
            dp[i][0] = dp[i][1] = 100000000;
            ok = 0;
            for (j = i-1; j &gt;=0 ; j--)
                if (p[i].l &gt;= p[j].l &amp;&amp; p[i].l &lt;= p[j].r)//左    
                {
                    ok = 1; break;
                }
            if (ok)
            {
                if (p[i].h - p[j].h &lt;= MAX)
                    dp[i][0] = min(dp[j][0] + p[i].l - p[j].l, dp[j][1] + p[j].r - p[i].l) + p[i].h - p[j].h;
            }
            else if (p[i].h &lt;= MAX)
                    dp[i][0]  = p[i].h;
            ok = 0;
            for (j = i-1; j &gt;=0 ; j--)
                if (p[i].r &gt;= p[j].l &amp;&amp; p[i].r &lt;= p[j].r)//右
                {
                    ok = 1;
                    break;
                }
            if (ok)
            {
                if (p[i].h - p[j].h &lt;= MAX)
                    dp[i][1] = min(dp[j][0] + p[i].r - p[j].l, dp[j][1] + p[j].r - p[i].r) + p[i].h - p[j].h;
            }
            else if(p[i].h &lt;= MAX)
                dp[i][1] = p[i].h;    
        }
        cout &lt;&lt; dp[n][0] &lt;&lt; endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-1679  The Unique MST</title>
    <url>/article/csdn/poj-1679_The_Unique_MST.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43193763" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43193763</a></p>
<p><a href="http://poj.org/problem?id=1679" target="_blank" rel="noopener"> http://poj.org/problem?id=1679 </a></p>
<p>The Unique MST</p>
<table>
<thead>
<tr>
<th><strong>Time Limit:</strong> 1000MS</th>
<th></th>
<th><strong>Memory Limit:</strong> 10000K  </th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Total Submissions:</strong> 21550</td>
<td></td>
<td><strong>Accepted:</strong> 7619  </td>
</tr>
</tbody>
</table>
<p>Description</p>
<p>Given a connected undirected graph, tell if its minimum spanning tree is<br>unique.  </p>
<p>Definition 1 (Spanning Tree): Consider a connected, undirected graph G = (V,<br>E). A spanning tree of G is a subgraph of G, say T = (V’, E’), with the<br>following properties:<br>1. V’ = V.<br>2. T is connected and acyclic.  </p>
<p>Definition 2 (Minimum Spanning Tree): Consider an edge-weighted, connected,<br>undirected graph G = (V, E). The minimum spanning tree T = (V, E’) of G is the<br>spanning tree that has the smallest total cost. The total cost of T means the<br>sum of the weights on all the edges in E’.  </p>
<p>Input</p>
<p>The first line contains a single integer t (1  &lt;= t &lt;= 20), the number of test<br>cases. Each case represents a graph. It begins with a line containing two<br>integers n and m (1 &lt;= n &lt;= 100), the number of nodes and edges. Each of the<br>following m lines contains a triple (xi, yi, wi), indicating that xi and yi<br>are connected by an edge with weight = wi. For any two nodes, there is at most<br>one edge connecting them.</p>
<p>Output</p>
<p>For each input, if the MST is unique, print the total cost of it, or otherwise<br>print the string ‘Not Unique!’.</p>
<p>Sample Input</p>
<pre><code>2
3 3
1 2 1
2 3 2
3 1 3
4 4
1 2 2
2 3 2
3 4 2
4 1 2
</code></pre><p>Sample Output</p>
<pre><code>3
Not Unique!





#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;

using namespace std;
#define INF 10000000

/*
 * 次小生成树
 * 求最小生成树时，用数组Max[i][j]来表示MST中i到j最大边权
 * 求完后，直接枚举所有不在MST中的边，替换掉最大边权的边，更新答案
 * 点的编号从1开始
 */
const int MAXN=110;
bool vis[MAXN];
int lowc[MAXN];
int pre[MAXN];//记录前驱节点
int Max[MAXN][MAXN];//Max[i][j]表示在最小生成树中从i到j的路径中的最大边权
bool used[MAXN][MAXN];//是否是最小生成树的边

int Prim(int cost[][MAXN],int n)
{
    int ans=0;
    memset(vis,false,sizeof(vis));
    memset(Max,0,sizeof(Max));
    memset(used,false,sizeof(used));
    memset(lowc,0,sizeof(lowc));

    for(int i=1;i&lt;=n;i++)
    {
        lowc[i]=cost[1][i];
        pre[i]=1;
    }
    lowc[1]=0;
    vis[1]=true;
    pre[1]=-1; 

    for(int i=1;i&lt;n;i++)
    {
        int minc=INF;
        int p=-1;
        for(int j=1;j&lt;=n;j++)
            if(!vis[j] &amp;&amp; minc &gt; lowc[j])
            {
                minc = lowc[j];
                p = j;
            }
        if(minc==INF)
            return -1;

        ans += minc;
        vis[p]=true;
        used[p][pre[p]]=used[pre[p]][p]=true;

        for(int j=1;j&lt;=n;j++)
        {
            if(vis[j])
                Max[j][p]=Max[p][j]=max(Max[j][pre[p]],lowc[p]);

            if(!vis[j]&amp;&amp;lowc[j]&gt;cost[p][j])
            {
                lowc[j]=cost[p][j];
                pre[j]=p;
            }
        }
    }
    return ans;
}
int ans;
int smst(int cost[][MAXN],int n)//求次小生成树
{
    int Min=INF;
    for(int i=1;i&lt;=n;i++)
        for(int j=i+1;j&lt;=n;j++)
            if(cost[i][j]!=INF &amp;&amp; !used[i][j])
            {
                Min=min(Min,ans+cost[i][j]-Max[i][j]);
            }
    if(Min==INF)
        return -1;//不存在
    return Min;
}
int cost[MAXN][MAXN];
int main()
{
    int T;
    int n,m;
    scanf(&quot;%d&quot;,&amp;T);
    while(T--)
    {
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
        int u,v,w;
        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;=n;j++)
            {
                if(i==j)
                    cost[i][j]=0;
                else
                    cost[i][j]=INF;
            }
        while(m--)
        {
            scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);
            if (cost[u][v] &gt; w)
                cost[u][v]=cost[v][u]=w;
        }

        ans=Prim(cost,n);
        if(ans==smst(cost,n))
            printf(&quot;Not Unique!\n&quot;);//次小生成树和最小生成树一样大
        else
            printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-1703</title>
    <url>/article/csdn/poj-1703.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40261019" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40261019</a></p>
<p>并查集：种类并查集：</p>
<p>分为1~N，N~2N两类；</p>
<p>a,b第一次出现时是p[a]=a,p[b]=b;</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

using namespace std;

int p[200010];

int findd(int x)
{
    if (p[x] &lt; 0 )
        return x;
    else
        return p[x] = findd(p[x]);
}

int main ()
{
    int t;
    scanf (&quot;%d&quot;,&amp;t);
    while (t--)
    {
        int n,m;
        char b[5];
        int c,d;
        scanf (&quot;%d%d&quot;,&amp;n,&amp;m);
        memset(p,-1,sizeof(p));

        for (int i=1;i&lt;=m;i++)
        {
            scanf (&quot;%s&quot;,b);
            scanf (&quot;%d %d&quot;,&amp;c,&amp;d);
            if (!strcmp(b,&quot;A&quot;))
            {
                if (n==2)
                    printf(&quot;In different gangs.\n&quot;);
                else if (findd(c) != findd(d) &amp;&amp; findd(c)!=findd(d+n))
                    printf(&quot;Not sure yet.\n&quot;);
                else if (findd (c) == findd(d))
                    printf(&quot;In the same gang.\n&quot;);
                else
                    printf(&quot;In different gangs.\n&quot;);
            }
            else
            {
                if (findd (c)!= findd (d+n))
                {
                    p[findd (c)] = findd (d+n);
                    p[findd (d)] = findd (c+n);
                }
            }
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-1502 MPI Maelstrom</title>
    <url>/article/csdn/poj-1502_MPI_Maelstrom.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43276929" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43276929</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=1502" target="_blank" rel="noopener"> http://poj.org/problem?id=1502 </a></p>
<p>裸的最短路径。英语。。。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;

using namespace std;

#define MAXV 110
#define INF 100000

int map[MAXV][MAXV],n;
int d[MAXV],vis[MAXV];
int ans;

void dijstra()
{
    for(int i=1;i&lt;=n;i++)
    {
        d[i]=INF;
        vis[i]=0;
    }
    d[1]=0;
    for(int i=1;i&lt;=n;i++)
    {
        int min=INF,v;
        for(int j=1;j&lt;=n;j++)
        {
            if(!vis[j] &amp;&amp; d[j]&lt;min)
            {
                min=d[j];
                v=j;
            }
        }
        vis[v]=1;
        for(int j=1;j&lt;=n;j++)
            if(!vis[j] &amp;&amp; d[j] &gt; d[v]+map[v][j])
                d[j]=d[v]+map[v][j];
    }
}

int main()
{
    char s[20];
    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)
    {
        ans == -1;
        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;=n;j++)
            {
                if(i!=j) map[i][j]=INF;
                else map[i][j]=0;
            }
        for(int i=2;i&lt;=n;i++)
            for(int j=1;j&lt;i;j++)
            {
                cin&gt;&gt;s;
                if(s[0] != &#39;x&#39;)
                    map[i][j]=map[j][i]= atof(s);
            }
        dijstra();
        for(int i=1;i&lt;=n;i++) ans = max(ans,d[i]);
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-1704 nim变形</title>
    <url>/article/csdn/poj-1704_nim%E5%8F%98%E5%BD%A2.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41207341" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41207341</a></p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;malloc.h&gt;

using namespace std;

int n,m;
int  p[1030];

int main ()
{
    cin&gt;&gt;m;
    while (m--)
    {
        cin&gt;&gt;n;
        for(int i=0;i&lt;n;i++ )
            cin&gt;&gt;p[i];

        if ( n % 2 == 1 )
            p[n++]= 0;
        sort(p,p+n);
        int ans = 0;
        for (int i=0 ;i+1&lt;n;i+=2)
        {
            ans ^= (p[i+1] - p[i] -1);
        }
        if (ans !=0)
            puts(&quot;Georgia will win&quot;);
        else
            puts(&quot;Bob will win&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>poj-1751 Highways</title>
    <url>/article/csdn/poj-1751_Highways.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43196745" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43196745</a></p>
<p><a href="http://poj.org/problem?id=1751" target="_blank" rel="noopener"> http://poj.org/problem?id=1751 </a></p>
<p>最小生成树简单应用</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;

using namespace std;
#define INF 10000000

double map[1110][1110],dis[1110];
int n,m,v[1110],pre[1010],a,b,c,d[1110];

struct node
{
    double x,y;
}p[1010];

double makedis(int i,int j)
{
    return sqrt( 1.0*(p[i].x - p[j].x)*(p[i].x - p[j].x) + 1.0*(p[i].y - p[j].y)*(p[i].y - p[j].y));
}

void prim()
{
    int i, j, k;
    double min, sum = 0;memset(v, 0, sizeof(v));

    for (i = 1; i &lt;= n; i++)
        {
            dis[i] = map[1][i];
            pre[i] = 1;
        }

    v[1] = 1;dis[1] = 0;pre[1]= - 1;

    for (i = 2; i &lt;= n; i++)
    {
        k = 1;
        min = INF;
        for (j = 1; j &lt;= n; j++)
            if (!v[j] &amp;&amp; min&gt;dis[j])
            {
                k = j;
                min = dis[j];
            }

        sum += min;
        v[k] = 1;
        if (min !=0 )
            cout&lt;&lt;pre[k]&lt;&lt;&quot; &quot;&lt;&lt;k&lt;&lt;endl;

        for (j = 1; j &lt;= n; j++)
            if (!v[j] &amp;&amp; dis[j]&gt;map[k][j])
                {
                    dis[j] = map[k][j];
                    pre[j] = k;
                }
    }
}

int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    {
        for(int i=1;i&lt;=n;i++)
            scanf(&quot;%lf%lf&quot;,&amp;p[i].x,&amp;p[i].y);

        for(int i=1;i&lt;=n;i++)
            for(int j = 1;j&lt;=n;j++)
        {
            if (i == j)
                map[i][j] = 0;
            else
                map[i][j] = INF;
        }
        for(int i=1;i&lt;=n;i++)
            for(int j = 1;j&lt;=n;j++)
            {
                if (map[i][j] &gt; makedis(i,j))
                {
                    map[i][j] = makedis(i,j);
                    map[j][i] = makedis(i,j);
                }
            }
        scanf(&quot;%d&quot;,&amp;m);
        while(m--)
        {
            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
            map[a][b] = map[b][a] = 0;
        }
        prim();
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-1797 Heavy Transportation</title>
    <url>/article/csdn/poj-1797_Heavy_Transportation.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43232985" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43232985</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=1797" target="_blank" rel="noopener"> http://poj.org/problem?id=1797 </a></p>
<p>求所有路径中承载量的最小值的最大值</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
using namespace std;

const int MAXV = 4010;
const int inf = 10000000;

int map[MAXV][MAXV];
int d[MAXV];
bool vis[MAXV];
int n,m;

void dijkstra(int s)
{
    for(int i=1;i&lt;=n;i++)
    {
        vis[i]=0;
        d[i]=map[s][i];
    }
    while (1)
    {
        int minn = 0;
        int v = -1;
        for(int i=1;i&lt;=n;i++)
            if(!vis[i] &amp;&amp; d[i] &gt; minn)
            {
                v=i;
                minn=d[i];
            }
        if(v == -1)
            break;
        vis[v]=1;
        for(int i=1;i&lt;=n;i++)
            if(!vis[i] &amp;&amp; d[i] &lt; min(d[v] , map[v][i]))
                d[i] = min(map[v][i],d[v]);
    }
}

int main()
{
    int i,j,a,b,c,t;
    int cases = 1;
    scanf(&quot;%d&quot;,&amp;t);
    while(t--)
    {
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
        memset(map,0,sizeof(map));
        while (m--)
        {
            scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c);
                map[a][b] = map[b][a] = c;
        }
        dijkstra(1);
        printf(&quot;Scenario #%d:\n&quot;,cases++);
        printf(&quot;%d\n\n&quot;,d[n]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title>poj-1852</title>
    <url>/article/csdn/poj-1852.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40412759" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40412759</a></p>
<p>转换思想  两只蚂蚁碰头反转时  相当于直接从对方身上走过去 直接前进</p>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;string.h&quot;
#include &quot;math.h&quot;
#include &quot;stdlib.h&quot;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;stdlib.h&gt;
#include &lt;queue&gt;

using namespace std;

int t;
int main()
{
    cin&gt;&gt;t;
    while (t--)
    {
        int n,m,tt;
        cin&gt;&gt;n&gt;&gt;tt;
        int p;
        int an1=-1000000,an2=-1000000;
        for (int i=1;i&lt;=tt;i++)
            {
                cin&gt;&gt;m;
                an1=max( an1,min( (n-m) ,(n-(n-m)) ) );
                an2=max( an2,max( (n-m) ,(n-(n-m)) ) );
            }
        cout&lt;&lt;an1&lt;&lt;&quot; &quot;&lt;&lt;an2&lt;&lt;endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-1979</title>
    <url>/article/csdn/poj-1979.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40209481" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40209481</a></p>
<p>简单题 直接上代码</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;

using namespace std;

char a[30][30];
int ans ;

int   dfs (int x,int y)
{
    if (a[x][y] == &#39;#&#39;)
    {
       return 0;
    }


    if (a[x][y]== &#39;@&#39; || a[x][y]==&#39;.&#39;)
    {
        ans++;
        a[x][y]=&#39;#&#39;;
    }
            dfs(x-1,y);
    dfs(x,y-1); dfs(x,y+1);
            dfs(x+1,y);
}

int main ()
{
    int n,m;
    while (cin&gt;&gt;m&gt;&gt;n &amp;&amp; (n || m))
    {
        memset (a,&#39;#&#39;,sizeof (a)) ;

        for (int i=1;i&lt;=n;i++)
            for (int j=1;j&lt;=m;j++)
        {
            cin&gt;&gt;a[i][j];
        }
        ans=0;
        for (int i=1;i&lt;=n;i++)
            for (int j=1;j&lt;=m;j++)
            {
                if (a[i][j] == &#39;@&#39;)
                {
                    dfs (i,j);
                }
            }
        cout&lt;&lt;ans&lt;&lt;endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-1789 Truck History</title>
    <url>/article/csdn/poj-1789_Truck_History.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43199207" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43199207</a></p>
<p><a href="http://poj.org/problem?id=1789" target="_blank" rel="noopener"> http://poj.org/problem?id=1789 </a></p>
<p>题意理解就是裸的MST</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#define INF 0x3f3f3f3f

using namespace std;

char str[2010][10];
int dis[2010],edge[2010][2010];
bool vis[2010];
int m,ans;

int cmp(int x,int y)
{
    int cnt=0;
    for(int i=0;i&lt;7;i++)
    {
        if(str[x][i]!=str[y][i])
            cnt++;
    }
    return cnt;
}

int prim()
{
    int u=0,tmp;ans = 0;
    memset(vis,false,sizeof(vis));
    for(int i=0;i&lt;m;i++)
    {
        dis[i]=edge[u][i];
    }
    vis[u]=1;

    for(int j=1;j&lt;m;j++)
    {
        tmp=INF;
        for(int i=1;i&lt;m;i++)
        {
            if(!vis[i] &amp;&amp; dis[i]&lt;tmp)
            {
                tmp = dis[i];
                u = i;
            }
        }
        vis[u]=1;
        ans+=tmp;

        for(int i=0;i&lt;m;i++)
        {
            if(!vis[i] &amp;&amp; edge[u][i]&lt;dis[i])
                dis[i]=edge[u][i];
        }
    }
    return ans;
}

int main()
{
    while(scanf(&quot;%d&quot;,&amp;m)!=EOF)
    {
        if(m==0) break;
        for(int i=0;i&lt;m;i++)
            for(int j=0;j&lt;m;j++)
        {
            if (i == j)
                edge[i][j] = 0;
            else
                edge[i][j] = INF;
        }
        for(int i=0;i&lt;m;i++)
            scanf(&quot;%s&quot;,str[i]);

        for(int i=0;i&lt;m;i++)
        {
            for(int j=0;j&lt;m;j++)
            {
                if(i==j)
                    edge[i][j]=edge[j][i]=0;
                else
                    edge[i][j]=edge[j][i]=cmp(i,j);
            }
        }
        printf(&quot;The highest possible quality is 1/%d.\n&quot;,prim());
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-1990</title>
    <url>/article/csdn/poj-1990.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41038245" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41038245</a></p>
<p>题目大意：一群牛参加完牛的节日后都有了不同程度的耳聋，第i头牛听见别人的讲话，别人的音量必须大于v[i]，当两头牛i，j交流的时候，交流的最小声音为max{v[i],v[j]}*他们之间的距离。现在有n头牛，求他们之间两两交流最少要的音量和。</p>
<p>解题思路：一开始水水的写了一个n^2的算法，这题终究没有那么白痴。原来是用了树状数组。首先将这n头牛按照v值从小到大排序（后面说的排在谁的前面，都是基于这个排序）。这样，排在后面的牛和排在前面的牛讲话，两两之间所用的音量必定为后面的牛的v值，这样一来才有优化的余地。然后，对于某头牛i来说，只要关心跟排在他前面的牛交流就好了。我们必须快速地求出排在他前面的牛和他之间距离的绝对值只和ans，只要快速地求出ans，就大功告成。这里需要两个树状数组。树状数组可以用来快速地求出某个区间内和，利用这个性质，我们可以快速地求出对于牛i，x位置比i小牛的个数，以及这个牛的位置之和。这里就需要两个树状数组，一个记录比x小的牛的个数a，一个记录比x小的牛的位置之和b，然后，我们可以快速地求出牛i和比牛i位置小的牛的所有距离的绝对值为：a<em>x[i]-b;也可以方便地求出比牛i位置大的牛到牛i的距离和，即所有距离-b-(i-1-a)</em>x[i]；那么此题就差不多了。</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt;
#include&lt;malloc.h&gt;
#include&lt;stdexcept&gt;

using namespace std;

int n;

struct q
{
    int v;
    int x;
}p[20005];

int a[20005];
int b[20005];

bool cmp (q a,q b)
{
    if (a.v != b.v)
        return a.v &lt;= b.v;
}

int lowbit(int i)
{
    return i&amp;-i;
}

void add(int i,int v,int *a)
{
    while (i&lt;=20004)//求所有牛总和
    {
        a[i] += v;
        i+=lowbit(i);
    }
}

int sum (int i,int *a)
{
    long long ans =0;
    while (i&gt;0)
    {
        ans += a[i];
        i-=lowbit(i);
    }
    return ans;
}

int main()
{
    while ( scanf(&quot;%d&quot;,&amp;n)!=EOF )
    {
        memset (a,0,sizeof(a));
        memset (b,0,sizeof(b));

        for (int i=1;i&lt;=n;i++)
        {
            scanf(&quot;%d %d&quot;,&amp;p[i].v,&amp;p[i].x);
        }

        sort (p+1,p+1+n,cmp);

        long long  ans = 0;
        long long  dis1;
        long long num1;
        long long alldis=0;

        long long  all=0;;

        for (int i=1;i&lt;=n;i++)
        {
            dis1 = sum( p[i].x ,a);
            num1 = sum( p[i].x ,b);

            ans += p[i].v * ( num1 * p[i].x - dis1 + all- dis1-(i-num1-1)*p[i].x );

            add( p[i].x , p[i].x ,a);
            add( p[i].x , 1,b);

            all += p[i].x;
        }
        printf(&quot;%I64d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-2031 Building a Space Statio</title>
    <url>/article/csdn/poj-2031_Building_a_Space_Statio.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43194805" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43194805</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=2031" target="_blank" rel="noopener"> 点击打开链接 </a>  </p>
<p>又是一发  G++ WA , C++ AC.</p>
<p>简单题：给出基站的三围坐标及半径 。若球面距离小于 0 距离为 0 ，否则为 圆心距离减去2个半径</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;

#define INF 10000000

using namespace std;

double map[110][110],dis[110];
int v[110];

struct node
{
    double x,y,z,r;
}p[110];

double makedis(int i,int j)
{
    double ans = sqrt((p[i].x - p[j].x)*(p[i].x - p[j].x) + (p[i].y - p[j].y)*(p[i].y - p[j].y) + (p[i].z - p[j].z)*(p[i].z - p[j].z));
    ans -= (p[i].r + p[j].r);
    if (ans &lt;= 0.0000000001)
        return 0;
    else
        return ans;
}

double prim(int n)
{
    int k;
    double min,sum=0;
    memset(v,0,sizeof(v));
    memset(dis,0,sizeof(dis));

    for(int i=1;i&lt;=n;i++)
        dis[i]=map[1][i];

    v[1]=1;
    dis[1]=0;

    for(int i=2;i&lt;=n;i++)
    {
        k=-1;
        min = INF;
        for(int j=1;j&lt;=n;j++)
            if(!v[j]&amp;&amp;min&gt;dis[j])
            {
                k=j;
                min=dis[j];
            }

        sum += min;
        v[k]=1;

        for(int j=1;j&lt;=n;j++)
            if(!v[j] &amp;&amp; dis[j]&gt;map[k][j])
                dis[j]=map[k][j];
    }
    return sum;
}

int main()
{
    int n,m;
    while(cin&gt;&gt;n)
    {
        if(n == 0)
            break;

        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;=n;j++)
            {
                if (i != j)
                    map[i][j] = INF;
                else
                    map[i][j] = 0;
            }
        for(int i=1;i&lt;=n;i++)
           {
               cin&gt;&gt;p[i].x&gt;&gt;p[i].y&gt;&gt;p[i].z&gt;&gt;p[i].r;
           }
        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;=n;j++)
            {
                if (map[i][j] &gt;= makedis(i,j))
                {
                    map[i][j]  = makedis(i,j);
                    map[j][i]  = makedis(i,j);
                }
            }
        printf(&quot;%.3lf\n&quot;,prim(n));
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>poj-1847</title>
    <url>/article/csdn/poj-1847.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43307921" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43307921</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=1847" target="_blank" rel="noopener"> http://poj.org/problem?id=1847 </a></p>
<p>把第一个相连的边设为0，其余的设为1.</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

using namespace std;

const int INF = 1000000;
const int MAX = 110;

int n,a,b;
int m,f,t;
int map[MAX][MAX];

int main()
{
    while (cin&gt;&gt;n&gt;&gt;a&gt;&gt;b)
    {
        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;=n;j++)
        {
            if (i == j)
                map[i][j] = 0;
            else
                map[i][j] = INF;
        }
        for(int i=1;i&lt;=n;i++)
        {
          cin&gt;&gt; m;
          for(int j=1;j&lt;=m;j++)
          {
              cin&gt;&gt;t;
              if (j==1)
                map[i][t] = 0;
            else
                map[i][t] = 1;
          }
        }
        for(int k=1;k&lt;=n;k++)
            for(int i=1;i&lt;=n;i++)
                for(int j=1;j&lt;=n;j++)
        {
            if (map[i][j] &gt; map[i][k] + map[k][j])
                map[i][j] = map[i][k] + map[k][j];
        }

        if (map[a][b] == INF)
            cout&lt;&lt;-1&lt;&lt;endl;
        else
            cout&lt;&lt;map[a][b]&lt;&lt;endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-2155</title>
    <url>/article/csdn/poj-2155.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40706579" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40706579</a></p>
<p>今天做BC，被学长批评了，深深地自我反省中…</p>
<p>引自小媛：</p>
<p>楼教主出的二维树状数组。</p>
<p>给出矩阵左上角和右下角坐标，矩阵里的元素 1变0 ，0 变1，然后给出询问，问某个点是多少。</p>
<p>纠结好久了，一直没什么好思路，看discuss说四个角神马的，我搜了下，理解了，树状数组里记录该点的变幻次数，或者直接%2也行。</p>
<p>查询的时候Getsum得到的是该点在所有区间的总变幻次数，最后%2就是结果。</p>
<p>建图的时候死活想不通，杂四个点的坐标是那个 = =。。。刚才协会开会了，在路上想通了，我想的0,0坐标是类似坐标轴的那种，在左下角。。。而矩阵的0 0<br>应该是在左上角。。这样，什么都通了 = =。。。</p>
<p>提供坐标的图。。</p>
<p><img src="http://hi.csdn.net/attachment/201103/21/6627258_1300679141f1mR.jpg" alt="">  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

using namespace std;

int t ;
int n,m;
int a[1010][1010];
char b;

int w,x,y,z;

int low(int i)
{
    return i &amp; (-i);
}

void add (int i ,int j,int v)
{
    for (int k=i;k&lt;=n;k+=low(k))
        for (int w=j;w&lt;=n;w+=low(w))
    {
        a[k][w]+=v;
    }
}

int sum(int i,int j)
{
    int ans = 0;
    for (int k = i;k&gt;0;k-=low(k))
        for (int w =j;w&gt;0;w-=low(w))
    {
        ans+=a[k][w];
    }
    return ans ;
}


int main()
{

    scanf (&quot;%d&quot;,&amp;t);
    while (t--)
    {
        memset (a,0,sizeof(a));
        scanf (&quot;%d %d&quot;,&amp;n,&amp;m);
        getchar();
        while (m--)
        {
            scanf (&quot;%c&quot;,&amp;b);
            if (b == &#39;C&#39;)
            {
                int x1,y1,x2,y2;
                scanf (&quot;%d %d %d %d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);
                getchar();
                add(x1,y1,1);
                add(x1,y2+1,1);
                add(x2+1,y1,1);
                add(x2+1,y2+1,1);

            }

            else if ( b == &#39;Q&#39; )
            {
                scanf (&quot;%d %d&quot;,&amp;x,&amp;y);
                getchar();
                printf(&quot;%d\n&quot;, sum(x,y) % 2 );
            }
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>poj-2229</title>
    <url>/article/csdn/poj-2229.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40208871" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40208871</a></p>
<p>DP问题</p>
<p>状态转移方程：如果i%2！=0</p>
<p>dp[i]=dp[i-1]</p>
<p>否则</p>
<p>dp[i]=dp[i-1]+dp[i/2]</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;

using namespace std;

int dp[1000010];

int main ()
{
    dp[1]=1;
    dp[2]=2;
    for (int i=3;i&lt;=1000002;i++)
    {
        if (i%2 != 0)
            dp[i]=dp[i-1];
        else
        {
            dp[i]=dp[i-1]+dp[i/2];
            dp[i]=dp[i]%1000000000;
        }
    }
    int n;
    while (cin&gt;&gt;n)
    {

    cout&lt;&lt;dp[n]&lt;&lt;endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-2236</title>
    <url>/article/csdn/poj-2236.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40211197" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40211197</a></p>
<p>并查集：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;

using namespace std;

int n,t;

struct pp
{
    int x;
    int y;
}p[10000];

int makedis(pp a,pp b)//计算两点距离
{
    return (double (a.x*1.0-b.x*1.0)*(a.x*1.0-b.x*1.0)+(a.y*1.0-b.y*1.0)*(a.y*1.0-b.y*1.0) );
}

int ran[10000];
int qq[10000];
int pq[10000];

int findd (int x)
{
    if (x == pq[x])
        return x;
    else
        return pq[x]=findd(pq[x]);
}

int un(int a,int b)
{
    int fa = findd(a);
    int fb = findd(b);
    if (fa == fb )
        return 0;
    else
    {
        if (ran[fa]&gt;ran[fb])
        {
            pq[fb]=fa;
        }
        else
        {
            pq[fa]=fb;
            if (fa==fb)
                ran[fa]++;
        }
    }
}

int main ()
{
    int n,d;
    while (cin&gt;&gt;n&gt;&gt;d)
    {
        memset(ran,0,sizeof(ran));
        memset(qq,0,sizeof(qq));
        memset(pq,0,sizeof(pq));

        for (int i=1;i&lt;=n;i++)
        {
            cin&gt;&gt;p[i].x&gt;&gt;p[i].y;
            pq[i]=i;
        }

        char q[5];
        int x,y;
        while (cin&gt;&gt;q)
        {
            if (!strcmp(q,&quot;O&quot;))
            {
                cin&gt;&gt;x;
                qq[x]=1;
                for (int i=1;i&lt;=n;i++)
                {
                    if (makedis(p[i],p[x])&lt;=d*d &amp;&amp; qq[i] &amp;&amp; i!=x &amp;&amp;(  findd(x)!=findd(i) ))
                    {
                        un(i,x);
                    }
                }
            }
            else if (!strcmp(q,&quot;S&quot;))
            {
                cin&gt;&gt;x&gt;&gt;y;
                if (findd(x)==findd(y))
                    printf(&quot;SUCCESS\n&quot;);
                else
                    printf(&quot;FAIL\n&quot;);
            }
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-2251 广搜</title>
    <url>/article/csdn/poj-2251_%E5%B9%BF%E6%90%9C.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/42219151" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/42219151</a></p>
<p><a href="http://poj.org/problem?id=2251" target="_blank" rel="noopener"> http://poj.org/problem?id=2251 </a></p>
<pre><code>#include&lt;stdio.h&gt;  
#include&lt;iostream&gt;  
#include&lt;math.h&gt;  
#include&lt;stdlib.h&gt;  
#include&lt;ctype.h&gt;  
#include&lt;algorithm&gt;  
#include&lt;vector&gt;  
#include&lt;string.h&gt;  
#include&lt;queue&gt;  
#include&lt;stack&gt;  
#include&lt;set&gt;   
#include&lt;sstream&gt;  
#include&lt;time.h&gt;  
#include&lt;utility&gt;  
#include&lt;malloc.h&gt;  
#include&lt;stdexcept&gt;  
#include&lt;iomanip&gt;  
#include&lt;iterator&gt;  

using namespace std;

char map[40][40][40];
int vis[40][40][40];
int L, R, C;

struct node
{
    int z, x, y;
    int c;
};

int dir[6][3] = { { 1, 0, 0 }, { -1, 0, 0 }, { 0, -1, 0 }, { 0, 1, 0 }, { 0, 0, -1 }, { 0, 0, 1 } };

int BFS(int si, int sj, int sk)
{
    memset(vis, 0, sizeof(vis));

    queue&lt;node&gt; q;
    node cur, next;

    cur.z = si, cur.x = sj, cur.y = sk, cur.c = 0;

    vis[si][sj][sk] = 1;

    q.push(cur);

    while (!q.empty())
    {
        cur = q.front();
        q.pop();
        for (int i = 0; i &lt; 6; i++)
        {
            next.z = cur.z + dir[i][0];
            next.x = cur.x + dir[i][1];
            next.y = cur.y + dir[i][2];
            next.c = cur.c + 1;
            if (next.z&lt;1 || next.z&gt;L || next.x&lt;1 || next.x&gt;R || next.y&lt;1 || next.y&gt;C || map[next.z][next.x][next.y] == &#39;#&#39;)
                continue;
            if (map[next.z][next.x][next.y] == &#39;E&#39;)
                return next.c;
            if (!vis[next.z][next.x][next.y])
            {
                vis[next.z][next.x][next.y] = 1;
                q.push(next);
            }
        }
    }
    return 0;
}

int main()
{
    int si, sj, sk;
    while (cin &gt;&gt; L &gt;&gt; R &gt;&gt; C)
    {
        if (L == 0 &amp;&amp; R == 0 &amp;&amp; C == 0)
            break;

        for (int i = 1; i &lt;= L; i++)
            for (int j = 1; j &lt;= R; j++)
                for (int k = 1; k &lt;= C; k++)
                {
                    cin &gt;&gt; map[i][j][k];
                    if (map[i][j][k] == &#39;S&#39;)
                    {
                        si = i; sj = j; sk = k;
                    }
                }
        int ans = BFS(si, sj, sk);
        if (ans == 0)
            printf(&quot;Trapped!\n&quot;);
        else
            printf(&quot;Escaped in %d minute(s).\n&quot;, ans);

    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-2299</title>
    <url>/article/csdn/poj-2299.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40748047" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40748047</a></p>
<p>树状数组求逆序数<br>看了这位大牛的题解才茅塞顿开：<a href="http://www.cnblogs.com/shenshuyang/archive/2012/07/14/2591859.html" target="_blank" rel="noopener">http://www.cnblogs.com/shenshuyang/archive/2012/07/14/2591859.html</a></p>
<p>首先离散化，再求逆序数.</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include &lt;malloc.h&gt;

using namespace std;

struct qq
{
    int x;
    int pos;
}a[500005];

int c[500005];
int b[500005];
int n;

bool cmp(qq a ,qq b)
{
    return a.x &lt; b.x;
}

int lowbit(int i)
{
    return i&amp;-i;
}

int sum (int i)
{
    int ans = 0;
    while (i&gt;0)
    {
        ans += b[i];
        i-=lowbit(i);
    }
    return ans;
}

void updown(int i)
{
    while (i&lt;=n)
    {
        b[i] += 1;
        i+=lowbit(i);
    }
}

int main ()
{
    while (scanf (&quot;%d&quot;,&amp;n)!=EOF &amp;&amp; n!=0)
    {

        for (int i=1 ;i&lt;=n;i++)
           {
               scanf (&quot;%d&quot;,&amp;a[i].x);
               a[i].pos=i;
           }

         sort (a+1,a+1+n,cmp);

         for (int i=1 ;i&lt;=n;i++)
            c[a[i].pos]=i;

        memset (b,0,sizeof (b));

        long long  ans = 0;
        for (int i =1 ;i&lt;=n;i++)
        {
            updown(c[i]);
            ans += i-sum(c[i]);
        }

        printf(&quot;%I64d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>poj</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>poj-2253 Frogger</title>
    <url>/article/csdn/poj-2253_Frogger.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43230537" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43230537</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=2253" target="_blank" rel="noopener"> http://poj.org/problem?id=2253 </a></p>
<p>求最短路径中的最长边，修改的 d [MAXN]; 的意义即可</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
using namespace std;

const int MAXV = 4010;
const int inf = 10000000;

struct Node
{
    float x,y;
}node[10010];

float makedis(Node a ,Node b)
{
    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}

float map[MAXV][MAXV];
float d[MAXV];
bool vis[MAXV];
int n,m;

void dijkstra(int s)
{
    for(int i=1;i&lt;=n;i++)
    {
        vis[i]=0;
        d[i]=map[s][i];
    }
    d[1] = 0;

    while (1)
    {
        float min=inf;int v = -1;
        for(int i=1;i&lt;=n;i++)
            if(!vis[i] &amp;&amp; d[i]&lt;min)
            {
                v=i;
                min=d[i];
            }
        if(v == -1)
            break;
        vis[v]=1;
        if (v == 2)
            break;
        for(int i=1;i&lt;=n;i++)
            if(!vis[i] &amp;&amp; d[i] &gt; max(d[v] , map[v][i]))
                d[i] = max(map[v][i],d[v]);
    }
}

int main()
{
    int i,j,a,b,c;
    int cases = 1;
    while(scanf(&quot;%d&quot;,&amp;n) != EOF)
    {
        if(n == 0 ) break;
        for(i=1;i&lt;=n;i++)
            for(j=1;j&lt;=n;j++)
            {
                if(i==j)
                    map[i][i]=0;
                else
                    map[i][j]=map[j][i]=inf;
            }
            for(i=1;i&lt;=n;i++)
            {
                scanf(&quot;%f%f&quot;,&amp;node[i].x,&amp;node[i].y);
            }
            for(int i=1;i&lt;=n;i++)
                for(int j=1;j&lt;=n;j++)
                    {
                        if (makedis(node[i],node[j]) &lt; map[i][j])
                            map[j][i] = map[i][j] = makedis(node[i],node[j]);
                    }
        dijkstra(1);
        printf(&quot;Scenario #%d\nFrog Distance = &quot;,cases++);
        printf(&quot;%.3f\n\n&quot;,d[2]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title>poj-2348</title>
    <url>/article/csdn/poj-2348.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41207243" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41207243</a></p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;malloc.h&gt;

using namespace std;

int n,m;

int main ()
{
    while (scanf (&quot;%d %d&quot;,&amp;n,&amp;m)!=EOF &amp;&amp; m &amp;&amp; n)
    {
        int ok = 1 ;
        for(;;)
        {
            if (n&gt;m)
            swap(n,m);
            if (m % n ==0)
                break;
            if (m-n &gt; n)
                break;
            m-=n;
            ok=!ok;
        }
        if (ok)
            printf(&quot;Stan wins\n&quot;);
        else
            printf(&quot;Ollie wins\n&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>poj-2352</title>
    <url>/article/csdn/poj-2352.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40739925" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40739925</a></p>
<p>题意理解了半天，基础的树状数组</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include &lt;malloc.h&gt;

using namespace std;

int a[32010];
int b[32010];
int n,x,y;

int lowbit(int x)
{
    return x&amp;(-x);
}

void update(int i)
{
    while (i&lt;=32001)
    {
        a[i]+=1;
        i+=lowbit(i);
    }
}

int sum(int i)
{
    int ans = 0;
    while (i&gt;0)
    {
        ans += a[i];
        i -= lowbit(i);
    }
    return ans;
}

int main()
{
    while (cin&gt;&gt;n)
    {
        for (int i =0 ;i&lt;n;i++)
        {
            scanf (&quot;%d %d&quot;,&amp;x,&amp;y);
            b[sum(++x)]++;
            update(x);
        }
        for (int i=0;i&lt;n;i++)
            printf(&quot;%d\n&quot;,b[i]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-2377</title>
    <url>/article/csdn/poj-2377.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40289019" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40289019</a></p>
<p>睡不着了 起来A一题</p>
<p>最小生成树变形之 最大生成树…</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#define N 1100
int map[N][N],low[N],visited[N];
int n;

int prim()
{
    int i,j,pos,min,result=0;
    memset(visited,0,sizeof(visited));
    visited[1]=1;pos=1;
    for(i=1;i&lt;=n;i++)
        if(i!=pos) low[i]=map[pos][i];
    for(i=1;i&lt;n;i++)
    {
     min=-1;
     for(j=1;j&lt;=n;j++)
         if(visited[j]==0 &amp;&amp; min&lt;low[j])
         {
             min=low[j];
             pos=j;
         }
    if (min == -1)
        return -1;
    result+=min;
    visited[pos]=1;
    for(j=1;j&lt;=n;j++)
        if(visited[j]==0 &amp;&amp; low[j]&lt;map[pos][j])
            low[j]=map[pos][j];
    }
    return result;
}

int main()
{
    int i,v,j,ans,m;
    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)
    {
        int c,d;
        memset(map,-1,sizeof(map));
            for(j=1;j&lt;=m;j++)
            {
                scanf(&quot;%d%d%d&quot;,&amp;c,&amp;d,&amp;v);
                if(v&gt;map[c][d])
                map[c][d]=map[d][c]=v;
            }
            ans=prim();
            if (ans &lt; 0)
                printf (&quot;-1\n&quot;);
            else
                printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-2385</title>
    <url>/article/csdn/poj-2385.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40209325" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40209325</a></p>
<p>dp状态方程dp[i][j] = max(dp[i-1][j], dp[i-1][j-1])</p>
<p>dp[i][j]标示在时间i，已经来回了j次时的最大苹果数目。</p>
<p>dp方程肯定苹果数目不会变的，所以要注意，如果当前的次数刚到当前树下，dp[i][j]++;  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;

using namespace std;

int dp[1010][40];
 int a[1010];
int main ()
{
    int t,n;
    while(cin&gt;&gt;t&gt;&gt;n)
    {
        for (int i=1;i&lt;=t;i++)
        {
            cin&gt;&gt;a[i];
        }

        if (a[1]==1)
        {
            dp[1][1]=0;
            dp[1][0]=1;
        }
        else if (a[1]==2)
        {
            dp[1][1]=1;
            dp[1][0]=0;
        }
        for (int i=2;i&lt;=t;i++)
            for (int j=0;j&lt;=n;j++)
        {
            if (j==0)//初始化
            {
                dp[i][j]=dp[i-1][j]+a[i]%2;
                continue;
            }
            dp[i][j]=max(dp[i-1][j],dp[i-1][j-1]);
            if ( j%2+1 == a[i])
            {
                dp[i][j]++;
            }
        }
        int ans=-100;
        for (int i=1;i&lt;=n;i++)//寻找最值
        {
            if (ans &lt; dp[t][i])
                ans = dp[t][i];
        }
        cout&lt;&lt;ans&lt;&lt;endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-2387 Til the Cows Come Home</title>
    <url>/article/csdn/poj-2387_Til_the_Cows_Come_Home.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43228857" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43228857</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=2387" target="_blank" rel="noopener"> http://poj.org/problem?id=2387 </a></p>
<p>dij 注意判重边</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

using namespace std;

const int MAXV = 4010;
const int inf = 10000000;

int map[MAXV][MAXV];
int d[MAXV];
bool vis[MAXV];
int n,m;

void dijkstra(int s)
{
    for(int i=1;i&lt;=n;i++)
    {
        vis[i]=0;
        d[i]=map[s][i];
    }

    while (1)
    {
        int min=inf,v = -1;
        for(int i=1;i&lt;=n;i++)
            if(!vis[i] &amp;&amp; d[i]&lt;min)
            {
                v=i;
                min=d[i];
            }
        if(v == -1)
            break;
        vis[v]=1;
        for(int i=1;i&lt;=n;i++)
            if(!vis[i] &amp;&amp; d[i] &gt; d[v] + map[v][i])
                d[i]=map[v][i]+d[v];
    }
}

int main()
{
    int i,j,a,b,c;
    while(scanf(&quot;%d%d&quot;,&amp;m,&amp;n) != EOF)
    {
        for(i=1;i&lt;=n;i++)
            for(j=1;j&lt;=n;j++)
            {
                if(i==j)
                    map[i][i]=0;
                else
                    map[i][j]=map[j][i]=inf;
            }
            for(i=1;i&lt;=m;i++)
            {
                scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
                if(map[a][b]&gt;c)
                    map[a][b]=map[b][a]=c;
            }
        dijkstra(1);
        printf(&quot;%d\n&quot;,d[n]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-2393</title>
    <url>/article/csdn/poj-2393.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40399639" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40399639</a></p>
<p>简单的贪心  开始的时候考虑麻烦了</p>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;string.h&quot;
#include &quot;math.h&quot;
#include &quot;stdlib.h&quot;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;stdlib.h&gt;

using namespace std;

struct
{
    long long cost;
    long long weight;
}p[10010];

int main()
{
    int n,s;
    while (scanf (&quot;%d%d&quot;,&amp;n,&amp;s)!=EOF)
    {
        for (int i=1;i&lt;=n;i++)
            scanf(&quot;%I64d%I64d&quot;,&amp;p[i].cost,&amp;p[i].weight);

        long long ans=0;

        for (int i=2;i&lt;=n;i++)
            p[i].cost=min( p[i-1].cost+s, p[i].cost );
        for (int i=1;i&lt;=n;i++)
            ans+=p[i].cost * p[i].weight;
        printf(&quot;%I64d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-2395</title>
    <url>/article/csdn/poj-2395.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40516067" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40516067</a></p>
<p>求最小生成树的最大边 ，初始值设一千万还是WA也是醉了，看了解题报告才发现必须足够大才可以。</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;stdlib.h&gt;

using namespace std;

int vis[10010];
int low[10010];
int p[2010][2010];

int i,j,k;
int minn ,pos;

int n,m;

int prim()
{
    int ans = -0x7fffffff;
    memset (vis,0,sizeof(vis));
    pos=1;
    vis[1]=1;
    for (i =1;i&lt;=n;i++)
    {
        if (i!=pos)
            low[i] = p[i][pos];
    }
    for (i=1;i&lt;n;i++)
    {
        minn = 0x7fffffff;
        for (int i=1;i&lt;=n;i++)
        {
            if (!vis[i] &amp;&amp; minn &gt; low[i])
            {
                minn = low[i];
                pos = i;
            }
        }
        ans = max (minn,ans);
        vis[pos]=1;
        for (int i=1;i&lt;=n;i++)
        {
            if (!vis[i] &amp;&amp; low[i] &gt; p[i][pos])
                low[i]=p[pos][i];
        }
    }
    return ans;
}

int main()
{
    while (scanf (&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)
    {
        int c,d,e;

        for ( i =1;i&lt;=n;i++)
            for( j=1;j&lt;=n;j++)
        {
            if (i == j)
                p[i][j] = 0;
            else
                p[i][j] =0x7fffffff;
        }

        for (i =1;i&lt;=m;i++)
        {
            scanf (&quot;%d%d%d&quot;,&amp;c,&amp;d,&amp;e);
            if (p[c][d] &gt; e)
                p[c][d]=p[d][c]=e;
        }
        int res = prim();
        printf(&quot;%d\n&quot;,res);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-2406 Power Strings 【kmp】</title>
    <url>/article/csdn/poj-2406_Power_Strings_%E3%80%90kmp%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44116531" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44116531</a></p>
<p>Power Strings</p>
<table>
<thead>
<tr>
<th><strong>Time Limit:</strong> 3000MS</th>
<th></th>
<th><strong>Memory Limit:</strong> 65536K  </th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Total Submissions:</strong> 34716</td>
<td></td>
<td><strong>Accepted:</strong> 14367  </td>
</tr>
</tbody>
</table>
<p>Description</p>
<p>Given two strings a and b we define a<em>b to be their concatenation. For<br>example, if a = “abc” and b = “def” then a</em>b = “abcdef”. If we think of<br>concatenation as multiplication, exponentiation by a non-negative integer is<br>defined in the normal way: a^0 = “” (the empty string) and a^(n+1) = a*(a^n).</p>
<p>Input</p>
<p>Each test case is a line of input representing s, a string of printable<br>characters. The length of s will be at least 1 and will not exceed 1 million<br>characters. A line containing a period follows the last test case.</p>
<p>Output</p>
<p>For each s you should print the largest n such that s = a^n for some string a.</p>
<p>Sample Input</p>
<pre><code>abcd
aaaa
ababab
.
</code></pre><p>Sample Output</p>
<pre><code>1
4
3
</code></pre><p>Hint</p>
<p>This problem has huge input, use scanf instead of cin to avoid time limit<br>exceed.</p>
<p>Source</p>
<p><a href="http://poj.org/searchproblem?field=source&amp;key=Waterloo+local+2002.07.01" target="_blank" rel="noopener"> Waterloo local 2002.07.01
</a></p>
<p>循环节 ，求字符串的循环的最大数量。</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;

using namespace std;

char  b[1000500];
int Next[1000500];

void get_next(char b[], int m)
{
    int i = 0,j = -1;
    memset(Next,0,sizeof(Next));
    Next[0] = -1;
    while (b[i])
    {
        if (j == -1 || b[i] == b[j])
        {
            ++i;
            ++j;
            Next[i] = j;
        }
        else
            j = Next[j];
    }
}

int main()
{
    int cases = 1, n, m, i, j, ans;

    while (scanf(&quot;%s&quot;,&amp;b)!=EOF &amp;&amp; b[0]!=&#39;.&#39;)
    {
        n = strlen(b);
        get_next(b, n);

        int t = Next[n];

        int s = n - t;
        if (n % s == 0)
            ans = n / s;
        else
            ans = 1;
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-2431 贪心+优先队列</title>
    <url>/article/csdn/poj-2431_%E8%B4%AA%E5%BF%83+%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41203899" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41203899</a></p>
<p>不知道为什么原来的思路就是错的 ，那也贴上代码，希望大牛指点</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;malloc.h&gt;

using namespace std;

int n;
int pp,l;
struct qq
{
    int ps;
    int ml;
}p[10100];

bool cmp (qq a ,qq b)
{
    return a.ps &lt; b.ps;
}

int main ()
{
    while (scanf (&quot;%d&quot;,&amp;n)!=EOF)
    {
        priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q;

        for(int i=0;i&lt;n;i++)
        {
            scanf(&quot;%d %d&quot;,&amp;p[i].ps , &amp;p[i].ml );
        }

        scanf(&quot;%d %d&quot;,&amp;l,&amp;pp);

        sort(p,p+n,cmp);

        p[n].ps = l;
        p[n].ml = 0;

        int ans =0;
        int pos =0;
        int tank=pp;
        int ok=1;
        for(int i=0 ;i&lt;n;i++)
        {
            int d =p[i].ps - pos;

            while (tank - d &lt;0)
            {
                if ( q.empty() )
                {
                    ok=0;
                    break;
                }
                tank+=q.top();
                q.pop();
                ans ++;
            }

            tank-=d;
            pos = p[i].ps ;
            q.push( p[i].ml );
        }
        if (ok)
            printf(&quot;%d\n&quot;,ans);
        else
            puts(&quot;-1&quot;);

    }
    return 0;
}
</code></pre><p>正确的代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;malloc.h&gt;

using namespace std;

int n;
int pp,l;

struct qq
{
    int ps;
    int ml;
}p[10100];

bool cmp (qq a ,qq b)
{
    return a.ps &gt; b.ps;
}

int main ()
{
    while (scanf (&quot;%d&quot;,&amp;n)!=EOF)
    {
        priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q;

        for(int i=0;i&lt;n;i++)
        {
            scanf(&quot;%d %d&quot;,&amp;p[i].ps , &amp;p[i].ml );
        }

        scanf(&quot;%d %d&quot;,&amp;l,&amp;pp);

        sort(p,p+n,cmp);

        p[n].ps = l;
        p[n].ml = 0;
        int pos = 0;
        int ans = 0;
        q.push(pp);
        while ( l&gt;0 &amp;&amp; !q.empty() )
        {
            ans ++;
            int t = q.top();
            q.pop();
            l-=t;
            while ( pos &lt; n &amp;&amp; l&lt;= p[pos].ps )
            {
                q.push( p[pos++].ml );
            }

        }

        if (l&lt;=0)
            printf(&quot;%d\n&quot;,ans-1);
        else
            puts(&quot;-1&quot;);

    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-2456</title>
    <url>/article/csdn/poj-2456.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40348801" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40348801</a></p>
<p>二分搜索：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;

using namespace std;

int n,m;
int p[100100];


int c (int x)//判断是否符合条件
{
    int last = 0;
    int art;
    for (int i=1;i&lt;m;i++)
    {
        art = last + 1;
        while (art &lt; n &amp;&amp; p[art]- p[last] &lt; x)
        {
            art++;
        }
        if (art == n)
        return 0;
        last=art;
    }
    return 1;
}

int main ()
{
    while (scanf (&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)
    {
        for (int i=0;i&lt;n;i++)
            scanf (&quot;%d&quot;,&amp;p[i]);

        sort (p,p+n);

        int lf=0,ri=1000000,mid;

        for (int i=1;i&lt;1000;i++)
        {
            mid = (lf + ri)/2;
            if (c (mid) )
            {
                lf = mid;
            }
            else
            {
                ri = mid;
            }
        }
        printf(&quot;%d\n&quot;,lf);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-2481</title>
    <url>/article/csdn/poj-2481.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40889511" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40889511</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=2481" target="_blank" rel="noopener"> 点击打开链接 </a></p>
<p>又是树状数组的应用 ，花了好长时间。</p>
<p>题目大意：</p>
<p>给你很多线段的头S和尾E，问每一条线段中包含了多少个线段，（S和E相同不计在内）。这题先一看，完全不知道什么方法，感觉非常的难办。</p>
<p>但是！树状数组可以轻松解决这个问题！！！首先，将她们线段的s和e当做是(s,e)一个点，这样子把所有点画出来，你就会发现一个很神奇的现象，题目要求就会变成：问每一个点的左上角有多少个点？</p>
<p>！！！这样不就和那题最简单的stars一样吗？？？！！！</p>
<p>stars那题是问左下角有多少个点，而这题是问左上角，而且点不是有序排好的，所以有些不同，特殊处理一下就可以。</p>
<p>如果正常做，那个y是递增的，所以sum和update那个方向就会相反了，这个其实没什么所谓，一样的，排序的时候先y由大到小排，y相同时x由小到大排，这样小小的处理，就变成stars那题了！！！</p>
<p>难点在于处理相同区间，对于相同区间，只是把答案直接拷贝过来，并把其加入树状数组，不可以直接在树状数组中求和。  </p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;queue&gt;

using namespace std;

struct q
{
    int s;
    int e ;
    int id;
}p[100005];

int a[100005];
int b[100005];
int n;
int maxnum;

bool cmp (q a ,q b)
{
    if (a.e == b.e )
        return a.s &lt; b.s;
    else 
        return a.e &gt; b.e;
}

int lowbit(int i)
{
    return i &amp; (-i);
}

int sum(int i)
{
    int ans = 0;
    while (i&gt;0)
    {
        ans += b[i];
        i-=lowbit(i);
    }
    return ans;
}

void update (int i,int v)
{
    while (i &lt;= maxnum + 1)
    {
        b[i]+=v;
        i+=lowbit(i);
    }
}

int main ()
{
    while (scanf (&quot;%d&quot;,&amp;n), n)
    {
        maxnum = -1;
        memset (b,0,sizeof (b));
        memset (a,0,sizeof (a));

        for (int i=0;i&lt;n;i++)
        {
            scanf(&quot;%d %d&quot;,&amp;p[i].s,&amp;p[i].e);
            p[i].e++;
            p[i].s++;

            p[i].id=i;
            maxnum = max (maxnum,p[i].s);
        }

        sort (p,p+n,cmp);

        a[p[0].id]=sum(p[0].s);
        update(p[0].s,1);

        for (int i=1;i&lt;n;i++)
        {
            if (p[i].e == p[i-1].e &amp;&amp; p[i].s == p[i-1].s )
            {
                a[p[i].id] = a[p[i-1].id];
            }
            else 
            {
                a[p[i].id] = sum(p[i].s );
            }
            update(p[i].s ,1);
        }

        printf (&quot;%d&quot;,a[0]);
        for (int i=1 ;i&lt;n;i++)
            printf(&quot; %d&quot;,a[i]);
        printf(&quot;\n&quot;);

    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>poj</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>poj-2484</title>
    <url>/article/csdn/poj-2484.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41207197" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41207197</a></p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;malloc.h&gt;

using namespace std;

int n,m;

int main ()
{
    while ( cin&gt;&gt;n &amp;&amp; n!=0)
    {
        if (n &lt;=2 )
            printf(&quot;Alice\n&quot;);
        else
            printf(&quot;Bob\n&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-2828 Buy Tickets</title>
    <url>/article/csdn/poj-2828_Buy_Tickets.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/42397919" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/42397919</a></p>
<p><a href="http://poj.org/problem?id=2828" target="_blank" rel="noopener"> http://poj.org/problem?id=2828 </a></p>
<p>题意：有n个的排队，每一个人都有一个val来对应，每一个后来人都会插入当前队伍的某一个位置pos。要求把队伍最后的状态输出。  </p>
<p>逆向思考。这样考虑，最后一个人一定会得到当前队伍他想要的位置，如果我们往前一个阶段，倒数第二个人也一定能得到他想要的位置……，也就是说，我们可以这样处理，我们把最后一个人插入，然后忽略它，再把倒数第二个人插入。即，我们找出当前队伍他想要插入的位置pos的真正坐标就可以。然后去更新整个队伍的长度。如此循环，直到最后一个人。线段树在单点更新的时候，感觉和二分查找是很相似的，可以用它实现。</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;vector&gt;

#define Mid(a,b) ( a+((b-a)&gt;&gt;1))
#define ll(x) (x&lt;&lt;1)
#define rr(x) (x&lt;&lt;1|1)

const int N = 200010;

using namespace std;

int n;
int pos[N];
int val[N];
int ans[N];

struct node
{
    int left;
    int right;
    int sum;
    int mid() { return Mid(left, right); }
};

struct segtree
{
    node tree[N * 4];
    void buildtree(int left,int right,int ind)
    {
        tree[ind].left = left;
        tree[ind].right = right;

        tree[ind].sum = right - left + 1;

        if (left !=right)
        {
            int mid = tree[ind].mid();
            buildtree(left,mid,ll(ind));
            buildtree(mid+1,right,rr(ind));
        }
    }

    int query(int val,int pos)
    {
        int left = tree[pos].left;
        int right = tree[pos].right;

        if (left == right)
        {
            tree[pos].sum = 0;
            return left;
        }
        else
        {
            int ind;
            if (tree[ll(pos)].sum &gt;= val)
                ind = query(val, ll(pos));
            else
                ind = query(val - tree[ll(pos)].sum , rr(pos));

            tree[pos].sum = tree[ll(pos)].sum + tree[rr(pos)].sum;

            return ind;
        }
    }
}seg;

int main()
{
    while (scanf(&quot;%d&quot;,&amp;n)!=EOF)
    {
        seg.buildtree(1,n,1);

        for (int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d %d&quot;,&amp;pos[i],&amp;val[i]);
        }

        for(int i = n; i &gt;=1; i--)
        {
            int ps = seg.query(pos[i]+1,1);
            ans[ps] = val[i];
        }

        for (int i = 1; i &lt;= n; i++)
        {
            printf(&quot;%d&quot;,ans[i]);
            if (i != n)
                printf(&quot; &quot;);
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>poj-2479 Maximum sum 【最大字串和】</title>
    <url>/article/csdn/poj-2479_Maximum_sum_%E3%80%90%E6%9C%80%E5%A4%A7%E5%AD%97%E4%B8%B2%E5%92%8C%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44081955" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44081955</a></p>
<p>Maximum sum</p>
<table>
<thead>
<tr>
<th><strong>Time Limit:</strong> 1000MS</th>
<th></th>
<th><strong>Memory Limit:</strong> 65536K  </th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Total Submissions:</strong> 34697</td>
<td></td>
<td><strong>Accepted:</strong> 10752  </td>
</tr>
</tbody>
</table>
<p>Description</p>
<p>Given a set of n integers: A={a1, a2,…, an}, we define a function d(A) as<br>below:</p>
<blockquote>
</blockquote>
<p><img src="http://poj.org/formula?tex=d%28A%29%3D%5Cmax_%7B1%5Cleq+s_1%5Cleq+t_1%3Cs_2%5Cleq+t_2%5Cleq+n%7D%5Cleft%5C%7B%5Csum_%7Bi%3Ds_1%7D%5E%7Bt_1%7Da_i%2B%5Csum_%7Bj%3Ds_2%7D%5E%7Bt_2%7Da_j%5Cright%5C%7D&amp;driver=1" alt=""></p>
<p>Your task is to calculate d(A).</p>
<p>Input</p>
<p>The input consists of T( &lt;=30) test cases. The number of test cases (T) is<br>given in the first line of the input.<br>Each test case contains two lines. The first line is an integer<br>n(2&lt;=n&lt;=50000). The second line contains n integers: a1, a2, …, an. (|ai| &lt;=<br>10000).There is an empty line after each case.</p>
<p>Output</p>
<p>Print exactly one line for each test case. The line should contain the integer<br>d(A).</p>
<p>Sample Input</p>
<pre><code>1

10
1 -1 2 2 3 -3 4 -4 5 -5
</code></pre><p>Sample Output</p>
<pre><code>13
</code></pre><p>Hint</p>
<p>In the sample, we choose {2,2,3,-3,4} and {5}, then we can get the answer.  </p>
<p>Huge input,scanf is recommended.</p>
<p>Source</p>
<p><a href="http://poj.org/searchproblem?field=source&amp;key=POJ+Contest" target="_blank" rel="noopener"> POJ Contest </a><br>,Author:Mathematica@ZSU</p>
<p>求两段的最大和，前后进行两次dp；</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;

using namespace std;

int t, n, p[100010], ans[100010];

int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        memset(ans,0,sizeof(ans));
        scanf(&quot;%d&quot;,&amp;n);
        int b = 0, sum = -1000000000;
        for (int i = 0; i &lt; n; i++)
        {
            scanf(&quot;%d&quot;, &amp;p[i]);
            b += p[i];
            sum = max(b, sum);
            ans[i] = sum;
            if (b &lt; 0) 
                b = 0;    
        }

        b = 0, sum = -1000000000;
        int tmp = -1000000000;

        for (int i = n - 1; i &gt;= 1; i--)
        {
            b += p[i];
            sum = max(b, sum);
            tmp = max(tmp, ans[i - 1] + sum);
            if (b &lt; 0) 
                b = 0;
        }
        printf(&quot;%d\n&quot;,tmp);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-2533 Longest Ordered Subsequence 【最长上升子序列】</title>
    <url>/article/csdn/poj-2533_Longest_Ordered_Subsequence_%E3%80%90%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44003711" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44003711</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=2533" target="_blank" rel="noopener"> http://poj.org/problem?id=2533 </a></p>
<p>Longest Ordered Subsequence</p>
<table>
<thead>
<tr>
<th><strong>Time Limit:</strong> 2000MS</th>
<th></th>
<th><strong>Memory Limit:</strong> 65536K  </th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Total Submissions:</strong> 35929</td>
<td></td>
<td><strong>Accepted:</strong> 15778  </td>
</tr>
</tbody>
</table>
<p>Description</p>
<p>A numeric sequence of _a i  _ is ordered if _a 1  _ &lt; _a 2  _ &lt; … &lt; _a N  _<br>. Let the subsequence of the given numeric sequence ( _a 1  _ , _a 2  _ , …,<br>_a N  _ ) be any sequence ( _a i  1  _ , _a i  2  _ , …, _a i  K  _ ), where<br>1  &lt;= _i 1  _ &lt; _i 2  _ &lt; … &lt; _i K  _ &lt;= _N_ . For example, sequence (1, 7,<br>3, 5, 9, 4, 8) has ordered subsequences, e. g., (1, 7), (3, 4, 8) and many<br>others. All longest ordered subsequences are of length 4, e. g., (1, 3, 5, 8).  </p>
<p>Your program, when given the numeric sequence, must find the length of its<br>longest ordered subsequence.</p>
<p>Input</p>
<p>The first line of input file contains the length of sequence N. The second<br>line contains the elements of sequence - N integers in the range from 0 to<br>10000 each, separated by spaces. 1  &lt;= N &lt;= 1000</p>
<p>Output</p>
<p>Output file must contain a single integer - the length of the longest ordered<br>subsequence of the given sequence.</p>
<p>Sample Input</p>
<pre><code>7
1 7 3 5 9 4 8
</code></pre><p>Sample Output</p>
<pre><code>4
</code></pre><p>求最长上升子序列</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;

using namespace std;

int n,p[1010],dp[1010];

int main()
{
    while (scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        for (int i = 1; i &lt;= n; i++)
            scanf(&quot;%d&quot;,&amp;p[i]);

        for (int i = 1; i &lt;= n; i++)
        {
            dp[i] = 1;
            for (int j = 1; j &lt; i; j++)
            {
                if (p[i] &gt; p[j])
                    dp[i] = max(dp[i],dp[j] + 1);
            }
        }
        int ans = -1;
        for (int i = 1; i &lt;= n; i++)
            ans = max(ans,dp[i]);
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-3061</title>
    <url>/article/csdn/poj-3061.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40427637" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40427637</a></p>
<p>首先计算出在前 i 项的和 然后快速枚举 计算最小值 ：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;

using namespace std;

int a[100100];
int sum[100100];

int main ()
{
   int t;
   cin&gt;&gt;t;
   while (t--)
   {
        int n,m;
        cin&gt;&gt;n&gt;&gt;m;
        for (int i=1;i&lt;=n;i++)
            cin&gt;&gt;a[i];

        sum[0]= 0;
        for (int i=1;i&lt;=n;i++)
            sum[i]=sum[i-1]+a[i];

        int ans = n;
        int ok =1 ,ko;
        if ( sum[n] &lt; m )
            ok = 0;

        int i = 1;
        for (int j=1;j&lt;=n;j++)
        {
            ko=0;
            while (sum [j] - sum [i] &gt;= m)
            {
                i++;
                ko=1;
            }
            if (ko)
            ans = min (ans , j - i + 1 );
        }

        if (ok)
            printf(&quot;%d\n&quot;,ans);
        else
            printf (&quot;0\n&quot;);
   }
   return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-3069</title>
    <url>/article/csdn/poj-3069.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40411205" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40411205</a></p>
<p>贪心算法</p>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;string.h&quot;
#include &quot;math.h&quot;
#include &quot;stdlib.h&quot;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;stdlib.h&gt;
#include &lt;queue&gt;

using namespace std;

int a[1010];

int main()
{
    int r ,n,i;
    while (scanf (&quot;%d%d&quot;,&amp;r,&amp;n)!=EOF &amp;&amp; (r!=-1 &amp;&amp; n != -1) )
    {
        for (i=1;i&lt;=n;i++)
        {
            scanf (&quot;%d&quot;,&amp;a[i]);
        }
        sort(a+1,a+1+n);
        i=1;
        int ans =0 ;
        while (i&lt;=n)
        {
            int s = a[i++];//没有被覆盖最左端的点
            while (i&lt;=n &amp;&amp; a[i] &lt;= s+r)
                i++;
            int p=a[i-1];
            while (i&lt;=n &amp;&amp; a[i] &lt;= p+r)
                i++;

            ans ++;
        }
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-3067</title>
    <url>/article/csdn/poj-3067.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40778307" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40778307</a></p>
<p>与2299类似，求逆序数；</p>
<p>首先按x升序排列，再求y的逆序数；</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;stdlib.h&gt;

using namespace std;

int b[1000005];
int n,m,k;

struct q
{
    int x;
    int y;
}p[1000105];

bool cmp(q a ,q b)
{
    if (a.x != b.x)
        return a.x &lt; b.x;
    else
        return a.y &lt;= b.y;
}

int lowbit(int i)
{
    return i&amp;-i;
}

int sum(int i)
{
    long long  ans =0;
    while (i&gt;0)
    {
        ans += b[i];
        i -= lowbit(i);
    }
    return ans;
}

void update(int i,int v)
{
    while (i&lt;=m)
    {
        b[i]+=v;
        i+=lowbit(i);
    }
}

int main ()
{
    int t ;
    int ss=1;
    scanf (&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf (&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);
        for (int i=1;i&lt;=k;i++)
        {
            scanf (&quot;%d%d&quot;,&amp;p[i].x,&amp;p[i].y  );
        }

        sort (p+1,p+1+k,cmp);

        memset(b,0,sizeof(b));
        long long  ans =0 ;
        for (int i=1;i&lt;=k;i++)
        {
            update(p[i].y,1);
            ans += i-sum( p[i].y );
        }

        printf(&quot;Test case %d: &quot;,ss++);
        printf(&quot;%lld\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c语言</tag>
        <tag>poj</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>poj-3084 输出路径的BFS</title>
    <url>/article/csdn/poj-3084_%E8%BE%93%E5%87%BA%E8%B7%AF%E5%BE%84%E7%9A%84BFS.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/42266111" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/42266111</a></p>
<p><a href="http://poj.org/problem?id=3984" target="_blank" rel="noopener"> http://poj.org/problem?id=3984 </a></p>
<pre><code>#include&lt;stdio.h&gt;  
#include&lt;iostream&gt;  
#include&lt;math.h&gt;  
#include&lt;stdlib.h&gt;  
#include&lt;ctype.h&gt;  
#include&lt;algorithm&gt;  
#include&lt;vector&gt;  
#include&lt;string.h&gt;  
#include&lt;queue&gt;  
#include&lt;stack&gt;  
#include&lt;set&gt;  
#include&lt;map&gt;  
#include&lt;sstream&gt;  
#include&lt;time.h&gt;  
#include&lt;utility&gt;  
#include&lt;malloc.h&gt;  
#include&lt;stdexcept&gt;  
#include&lt;iomanip&gt;  
#include&lt;iterator&gt;  

using namespace std;

int n, m;
int p[35][35];

int vis[6][6];
int dir[4][2] = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };

struct node
{
    int x;
    int y;
};

struct node pre[30][30];//存储节点前一个位置

int check(int x, int y)
{
    if (x &gt;= 0 &amp;&amp; x &lt; 5 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; 5)
        return 1;
    return 0;
}

void printf_path()
{
    stack&lt;node&gt; path;//栈用来保存路径
    node ss;
    ss.x = 4;
    ss.y = 4;

    while (1)
    {
        path.push(ss);
        if (!ss.x &amp;&amp; !ss.y)
            break;
        ss = pre[ss.x][ss.y];


    }
    while (!path.empty())
    {
        ss = path.top();
        path.pop();

        printf(&quot;(%d, %d)\n&quot;,ss.x,ss.y);
    }
}

void bfs()
{
    memset(vis,0,sizeof(vis));

    queue &lt;node&gt; q;
    node qq, qqq;

    qq.x = 0;
    qq.y = 0;
    vis[0][0] = 1;

    q.push(qq);

    while (!q.empty())
    {
        qq = q.front();
        q.pop();

        if (qq.x == 4 &amp;&amp; qq.y == 4)
        {    
            printf_path();
            return;
        }
        for (int i = 0; i &lt; 4;i++)
        {
            int x = qq.x + dir[i][0];
            int y = qq.y + dir[i][1];

            if (!check(x,y) || vis[x][y] || p[x][y] == 1)
                continue;

            qqq = qq;
            qqq.x = x;
            qqq.y = y;

            pre[qqq.x][qqq.y] = qq;

            vis[x][y] = 1;
            q.push(qqq);
        }
    }
    return;
}


int main()
{
        for (int i = 0; i &lt; 5; i++)
        {
            for (int j = 0; j &lt; 5; j++)
            {
                cin &gt;&gt; p[i][j];
            }
        }

        bfs();

    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-2785</title>
    <url>/article/csdn/poj-2785.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40431589" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40431589</a></p>
<p>题目连接 ：<a href="http://poj.org/problem?id=2785" target="_blank" rel="noopener">http://poj.org/problem?id=2785</a>  </p>
<p>折半枚举就OK了</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;string.h&gt;
#include &lt;functional&gt;

using namespace std;

int a[4444],b[4444],c[4444],d[4444];
int p [4444 * 4444];

int main()
{
    int n ;
    while (scanf(&quot;%d&quot;,&amp;n)!=EOF)
    {
        for (int i=0;i&lt;n;i++)
            scanf (&quot;%d%d%d%d&quot;,&amp;a[i],&amp;b[i],&amp;c[i],&amp;d[i]);

        for (int i=0;i&lt;n;i++)
            for (int j=0;j&lt;n;j++)
        {
            p[i*n+j] = a[i] + b[j] ;
        }

        sort (p,p+n*n);
        long long  ans = 0;
        for (int i=0;i&lt;n;i++)
            for (int j=0;j&lt;n;j++)
        {
            int cd = -1*(c[i] + d[j]);
            ans += (upper_bound(p,p+n*n ,cd) - lower_bound(p,p+n*n,cd));
        }
        printf(&quot;%I64d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-3253</title>
    <url>/article/csdn/poj-3253.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40212451" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40212451</a></p>
<p>贪心算法：哈夫曼编码思想：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
#include &lt;sstream&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include&lt;functional&gt;

using namespace std;

priority_queue &lt; int, vector&lt;int&gt; , greater&lt;int&gt; &gt; q;

int a;
int main ()
{
    int n;
    while (cin&gt;&gt;n)
    {
        for (int i=0;i&lt;n;i++)
       {
           cin &gt;&gt;a;
           q.push(a);
       }
        long long  ans = 0;
        int m1,m2;

        while (q.size()&gt;1)
        {
            m1=q.top();
            q.pop();
            m2=q.top();
            q.pop();
            ans=ans+m1+m2;
            q.push(m1+m2);
        }

        cout&lt;&lt;ans&lt;&lt;endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-3259 Wormholes</title>
    <url>/article/csdn/poj-3259_Wormholes.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43275051" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43275051</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=3259" target="_blank" rel="noopener"> http://poj.org/problem?id=3259 </a></p>
<p>求是否存在负权环。用 bellman 判断。</p>
<p>有一些农场，这些农场里面有一些田地，田地里面有一些虫洞，田地之间有路，虫洞可以让时间倒流。问这个农民能不能看到他自己，也就是说，有没有可能利用虫洞的时间倒流的性质，让这个人能在这个点出发前回去，这样他就是能看到他自己</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

using namespace std;

const int MAX = 5500;
const int INF = 1000000;

struct node
{
    int from,to,cost;
}edge[MAX];

int E;

void addedge(int from,int to,int cost)
{
    edge[E].from = from;
    edge[E].to = to;
    edge[E++].cost = cost;
}
int t,n,m,w;
int d[MAX];

int short_path(int s)
{
    for(int i=1;i&lt;=n;i++) d[i] = INF;
    d[s] = 0;
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;E;j++)
    {
        node e = edge[j];
        if (d[e.to] &gt; d[e.from] + e.cost)
        {
            d[e.to] = d[e.from] + e.cost;
            if (i == n)
                return 1;
        }
    }
    return 0;
}

int main ()
{
    scanf(&quot;%d&quot;,&amp;t);
    int a,b,c;
    while (t--)
    {
        E = 1;
        scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;w);
        for(int i=1;i&lt;=m;i++)
        {
            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
                addedge(a,b,c);
                addedge(b,a,c);
        }
        for(int i=1;i&lt;=w;i++)
        {
            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
                addedge(a,b,-c);
        }
        if (short_path(1) == 1)
            printf(&quot;YES\n&quot;);
        else
            printf(&quot;NO\n&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title>poj-3176</title>
    <url>/article/csdn/poj-3176.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40208657" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40208657</a></p>
<p>经典数塔DP</p>
<p>自下而上DP</p>
<p>状态转移方程：</p>
<pre><code>DP[I][J]+=MAX (DP[I+1][J],DP[I+1][J+1]) 


#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;

using namespace std;

int dp[510][510];

int main ()
{
    int n;
    cin&gt;&gt;n;

        memset (dp,0,sizeof(dp));
        for (int i=1;i&lt;=n;i++)
            for (int j=1;j&lt;=i;j++)
            cin&gt;&gt;dp[i][j];

        for (int i=n-1;i&gt;=1;i--)
        {
            for (int j=1;j&lt;=i;j++)
                dp[i][j]+=max (dp[i+1][j],dp[i+1][j+1]);
        }
        cout&lt;&lt;dp[1][1]&lt;&lt;endl;

    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-3264</title>
    <url>/article/csdn/poj-3264.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43031805" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43031805</a></p>
<p><a href="http://poj.org/problem?id=3264" target="_blank" rel="noopener"> http://poj.org/problem?id=3264 </a></p>
<p>基础线段树</p>
<p>求区间最大值与最小值的差</p>
<pre><code>//poj 3264
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;


using namespace std;

#define ll(ind) (ind&lt;&lt;1)
#define rr(ind) (ind&lt;&lt;1|1)
#define Mid(a,b) (a+((b-a)&gt;&gt;1))

const int N = 50100;

int a[N];
int MAX,MIN;

struct node
{
    int left, right;
    int Max, Min;
     int mid()
    {
        return Mid(left, right);
    }
};

struct segtree
{
    node tree[N*4];

    void build(int left ,int right,int ind)
    {
        tree[ind].left = left;
        tree[ind].right = right;
        if (left == right)
        {
            tree[ind].Max = tree[ind].Min = a[left];
        }
        else
        {
            int mid = tree[ind].mid();
            build(left,mid,ll(ind));
            build(mid+1,right,rr(ind));
            tree[ind].Max = max(tree[ll(ind)].Max,tree[rr(ind)].Max);
            tree[ind].Min = min(tree[ll(ind)].Min,tree[rr(ind)].Min);
        }
    }
    void query(int st,int ed,int ind)
    {
        int left = tree[ind].left;
        int right = tree[ind].right;
        int mid = tree[ind].mid();
        if (st == left &amp;&amp; ed == right)
        {
            MAX = max(MAX,tree[ind].Max);
            MIN = min(MIN,tree[ind].Min);
        }
        else if (ed&lt;=mid)
            query(st,ed,ll(ind));
        else if (st&gt;mid)
            query(st,ed,rr(ind));
        else
        {
            query(st,mid,ll(ind));
            query(mid+1,ed,rr(ind));
        }

    }
}seg;

int main()
{
    int n, q, b, c;
    while (scanf(&quot;%d %d&quot;, &amp;n, &amp;q) != EOF)
    {
        for (int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;,&amp;a[i]);
        }
        seg.build(1,n,1);
        while (q--)
        {
            MAX = -1000000000;
            MIN = 1000000000;
            scanf(&quot;%d %d&quot;,&amp;b,&amp;c);
            seg.query(b, c, 1);
            printf(&quot;%d\n&quot;,MAX - MIN);
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-3286 Silver Cow Party</title>
    <url>/article/csdn/poj-3286_Silver_Cow_Party.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43267501" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43267501</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=3268" target="_blank" rel="noopener"> http://poj.org/problem?id=3268 </a></p>
<p>求牛参加聚会的往返最长的路径是多少。往返的时候翻转矩阵，再计算一次，两次求和。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

using namespace std;

const int MAXV = 4010;
const int inf = 10000000;

int map[MAXV][MAXV];//路径长度
int d[MAXV],re_d[MAXV];//距离
bool vis[MAXV];
int n,m,x;

void dijkstra(int s)
{
    for(int i=1;i&lt;=n;i++)
    {
        vis[i]=0;
        d[i]=map[s][i];
    }
    d[s] = 0;
    while (1)
    {
        int min=inf,v = -1;
        for(int i=1;i&lt;=n;i++)
            if(!vis[i] &amp;&amp; d[i]&lt;min)
            {
                v=i;
                min=d[i];
            }
        if(v == -1)
            break;
        vis[v]=1;
        for(int i=1;i&lt;=n;i++)
            if(!vis[i] &amp;&amp; d[i] &gt; d[v] + map[v][i])
                d[i]=map[v][i]+d[v];
    }
}
int main()
{
    int i,j,a,b,c;
    while(scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;x) != EOF)
    {
        for(i=1;i&lt;=n;i++)
            for(j=1;j&lt;=n;j++)
            {
                if(i==j)
                    map[i][i]=0;
                else
                    map[i][j] = inf;
            }
            for(i=1;i&lt;=m;i++)
            {
                scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
                if(map[a][b]&gt;c)
                    map[a][b]=c;
            }
        dijkstra(x);
        for(int i=1;i&lt;=n;i++)
            re_d[i] = d[i];
        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;i;j++)
        {
            int t = map[i][j] ;
            map[i][j]= map[j][i];
            map[j][i] = t;
        }
        dijkstra(x);
        for(int i=1;i&lt;=n;i++)
            d[i]+=re_d[i];
        int ans = -1;
        for(int i=1;i&lt;=n;i++)
            ans = max(ans,d[i]);
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title>poj-3278</title>
    <url>/article/csdn/poj-3278.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40649851" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40649851</a></p>
<p>广搜简单题</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;

using namespace std;

int n,m;
int vis[100010];

int main ()
{
    while (scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)
    {
        for (int i =0 ;i&lt;=100003;i++)
            vis[i]=0;

        queue&lt;int&gt; q ;

        q.push(n);
        vis[n]=1;

        int p;

        while (!q.empty())
        {
            p=q.front();
            q.pop();

            if (p == m )
                break;
            else
            {
                int ans1 = p-1;
                int ans2 = p+1;
                int ans3 = p*2;
                if (ans1 &gt;=0 &amp;&amp; ans1 &lt;= 100000 &amp;&amp; !vis[ans1])
                {
                    vis[ans1]=vis[p]+1;
                    q.push(ans1);
                }
                if (ans2 &gt;=0 &amp;&amp; ans2 &lt;= 100000 &amp;&amp; !vis[ans2])
                {
                    vis[ans2]=vis[p]+1;
                    q.push(ans2);
                }
                if (ans3 &gt;=0 &amp;&amp; ans3 &lt;= 100000 &amp;&amp; !vis[ans3])
                {
                    vis[ans3]=vis[p]+1;
                    q.push(ans3);
                }
            }
        }
        printf(&quot;%d\n&quot;,vis[m]-1);
    }
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>搜索</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title>poj-3468 区间操作</title>
    <url>/article/csdn/poj-3468_%E5%8C%BA%E9%97%B4%E6%93%8D%E4%BD%9C.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/42966251" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/42966251</a></p>
<p><a href="http://poj.org/problem?id=3468" target="_blank" rel="noopener"> http://poj.org/problem?id=3468 </a></p>
<p>区间求和操作 ，一个区间加操作。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;iomanip&gt;

using namespace std;

#define ll(ind) (ind&lt;&lt;1)
#define rr(ind) (ind&lt;&lt;1|1)
#define Mid(a,b) (a+((b-a)&gt;&gt;1))

typedef __int64 LL;

const int N = 100100;

int a[N];

struct node
{
    int left, right;
    LL sum, lazy;;
    int mid()
    {
        return Mid(left, right);
    }

    void fun(LL summ)
    {
        lazy += summ;
        sum += (right - left + 1) * summ;
    }
};

struct segtree
{
    node tree[N * 4];

    void real(int ind)//更新懒惰标记
    {
        if (tree[ind].lazy)
        {
            tree[ll(ind)].fun(tree[ind].lazy);
            tree[rr(ind)].fun(tree[ind].lazy);
            tree[ind].lazy = 0;
        }
    }

    void buildtree(int left, int right, int ind)//建树
    {
        tree[ind].left = left;
        tree[ind].right = right;
        tree[ind].sum = 0;
        tree[ind].lazy = 0;

        if (left == right)
        {
            tree[ind].sum = a[left];
        }

        if (left != right)
        {
            int mid = tree[ind].mid();
            buildtree(left, mid, ll(ind));
            buildtree(mid + 1, right, rr(ind));
            tree[ind].sum = tree[ll(ind)].sum + tree[rr(ind)].sum;
        }
    }

    void update(int st, int ed, int ind, int type)//更新
    {
        int left = tree[ind].left;
        int right = tree[ind].right;

        if (st &lt;= left &amp;&amp; right &lt;= ed)
            tree[ind].fun(type);

        else
        {
            real(ind);

            int mid = tree[ind].mid();
            if (st &lt;= mid) update(st, ed, ll(ind), type);
            if (ed &gt; mid) update(st, ed, rr(ind), type);
            tree[ind].sum = tree[ll(ind)].sum + tree[rr(ind)].sum;
        }
    }

    LL query(int st, int ed, int ind)//求和
    {
        int left = tree[ind].left;
        int right = tree[ind].right;

        if (st &lt;= left &amp;&amp; right &lt;= ed)
            return tree[ind].sum;
        else
        {
            real(ind);
            int mid = tree[ind].mid();

            LL s1 = 0, s2 = 0;
            if (st &lt;= mid)
                s1 = query(st, ed, ll(ind));
            if (ed &gt; mid)
                s2 = query(st, ed, rr(ind));

            return s1 + s2;
        }
    }
}seg;

int main()
{
    int n, m;
    int x, y, z;

    while (scanf(&quot;%d %d&quot;, &amp;n, &amp;m) != EOF)
    {
        for (int i = 1; i &lt;= n; i++)
            scanf(&quot;%d&quot;, &amp;a[i]);

        seg.buildtree(1, n, 1);

        char d[5];

        while (m--)
        {
            scanf(&quot;%s&quot;, d);
            if (d[0] == &#39;Q&#39;)
            {
                scanf(&quot;%d %d&quot;, &amp;x, &amp;y);
                cout &lt;&lt; seg.query(x, y, 1) &lt;&lt; endl;

            }
            else
            {
                scanf(&quot;%d %d %d&quot;, &amp;x, &amp;y, &amp;z);
                seg.update(x, y, 1, z);
            }
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-3461 Oulipo 【kmp】</title>
    <url>/article/csdn/poj-3461_Oulipo_%E3%80%90kmp%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44104571" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44104571</a></p>
<p>Oulipo</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>Time Limit:</strong> 1000MS</th>
<th></th>
<th><strong>Memory Limit:</strong> 65536K  </th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Total Submissions:</strong> 26367</td>
<td></td>
<td><strong>Accepted:</strong> 10522  </td>
</tr>
</tbody>
</table>
<p>Description</p>
<p>The French author Georges Perec (1936–1982) once wrote a book, La disparition,<br>without the letter <code>&#39;e&#39;</code> . He was a member of the Oulipo group. A quote from<br>the book:</p>
<blockquote>
<p>Tout avait Pair normal, mais tout s’affirmait faux. Tout avait Fair normal,<br>d’abord, puis surgissait l’inhumain, l’affolant. Il aurait voulu savoir où<br>s’articulait l’association qui l’unissait au roman : stir son tapis,<br>assaillant à tout instant son imagination, l’intuition d’un tabou, la vision<br>d’un mal obscur, d’un quoi vacant, d’un non-dit : la vision, l’avision d’un<br>oubli commandant tout, où s’abolissait la raison : tout avait l’air normal<br>mais…</p>
</blockquote>
<p>Perec would probably have scored high (or rather, low) in the following<br>contest. People are asked to write a perhaps even meaningful text on some<br>subject with as few occurrences of a given “word” as possible. Our task is to<br>provide the jury with a program that counts these occurrences, in order to<br>obtain a ranking of the competitors. These competitors often write very long<br>texts with nonsense meaning; a sequence of 500,000 consecutive <code>&#39;T&#39;</code> s is<br>not unusual. And they never use spaces.</p>
<p>So we want to quickly find out how often a word, i.e., a given string, occurs<br>in a text. More formally: given the alphabet { <code>&#39;A&#39;</code> , <code>&#39;B&#39;</code> , <code>&#39;C&#39;</code> ,<br>…, <code>&#39;Z&#39;</code> } and two finite strings over that alphabet, a word _W_ and a text<br>_T_ , count the number of occurrences of _W_ in _T_ . All the consecutive<br>characters of W must exactly match consecutive characters of _T_ . Occurrences<br>may overlap.</p>
<p>Input</p>
<p>The first line of the input file contains a single number: the number of test<br>cases to follow. Each test case has the following format:</p>
<ul>
<li>One line with the word _W_ , a string over { <code>&#39;A&#39;</code> , <code>&#39;B&#39;</code> , <code>&#39;C&#39;</code> , …, <code>&#39;Z&#39;</code> }, with 1 ≤ | _W_ | ≤ 10,000 (here | _W_ | denotes the length of the string _W_ ). </li>
<li>One line with the text _T_ , a string over { <code>&#39;A&#39;</code> , <code>&#39;B&#39;</code> , <code>&#39;C&#39;</code> , …, <code>&#39;Z&#39;</code> }, with | _W_ | ≤ | _T_ | ≤ 1,000,000. </li>
</ul>
<p>Output</p>
<p>For every test case in the input file, the output should contain a single<br>number, on a single line: the number of occurrences of the word _W_ in the<br>text _T_ .</p>
<p>Sample Input</p>
<pre><code>3
BAPC
BAPC
AZA
AZAZAZA
VERDI
AVERDXIVYERDIAN
</code></pre><p>Sample Output</p>
<pre><code>1
3
0
</code></pre><p>Source</p>
<p><a href="http://poj.org/searchproblem?field=source&amp;key=BAPC+2006+Qualification" target="_blank" rel="noopener"> BAPC 2006 Qualification
</a>  </p>
<p>计算字串在母串中出现的次数</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;malloc.h&gt;

using namespace std;

char a[100000500], b[10005000];
int Next[10005000],ans;

void get_next(char b[], int m)
{
    int i = 0;
    Next[0] = -1;
    int j = -1;
    while (i&lt;m)
    {
        if (j == -1 || b[i] == b[j])
        {
            ++i;
            ++j;
            if (b[i] == b[j])
                Next[i] = Next[j];
            else
                Next[i] = j;
        }
        else
            j = Next[j];
    }
}
int KMP(char a[], int n, char b[], int m, int Next[], int pos)
{
    int i = pos;
    int j = 0;
    while (i&lt;n&amp;&amp;j&lt;m)
    {
        if (j == -1 || a[i] == b[j])
        {
            ++i;
            ++j;
        }
        else
            j = Next[j];
        if (j == m)
        {
            ans++;
            j = Next[j];
        }
    }
    return ans;

}
int main()
{
    int test, n, m, i, j;
    scanf(&quot;%d&quot;, &amp;test);
    while (test--)
    {
        scanf(&quot;%s%s&quot;,a,b);
        int n = strlen(a);
        int m = strlen(b);
        get_next(a, n);
        ans = 0;
        KMP(b, m, a, n, Next, 0);
        printf(&quot;%d\n&quot;,ans);
    }
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-3614</title>
    <url>/article/csdn/poj-3614.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40263763" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40263763</a></p>
<p>贪心算法  WA了好多   我的心好痛~</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
#define  nMAX 2505
bool vs[nMAX];
struct Cow{
    int min,max;
}cow[nMAX];
struct Lot
{
    int num,cnt;
}lot[nMAX];
int cmp1(const void * a,const void * b)
{
    return (*(Cow*)a).min&lt;(*(Cow*)b).min?1:-1;
}
int cmp2(const void * a,const void * b)
{
    return (*(Lot*)a).num&lt;(*(Lot*)b).num?1:-1;
}
int main()
{
    int i,j,k,nx,ny;
    int ans;
    while(scanf(&quot;%d%d&quot;,&amp;nx,&amp;ny)!=EOF)
    {
        memset(vs,0,sizeof(vs));
        for(i=0;i&lt;nx;i++)
            scanf(&quot;%d%d&quot;,&amp;cow[i].min,&amp;cow[i].max);
        for(j=0;j&lt;ny;j++)
            scanf(&quot;%d%d&quot;,&amp;lot[j].num,&amp;lot[j].cnt);
        qsort(cow,nx,sizeof(cow[0]),cmp1);
        qsort(lot,ny,sizeof(lot[0]),cmp2);
        ans=0;
        for(i=0;i&lt;nx;i++)
            for(j=0;j&lt;ny;j++)
                if(!vs[i]&amp;&amp;lot[j].num&gt;=cow[i].min&amp;&amp;lot[j].num&lt;=cow[i].max&amp;&amp;lot[j].cnt)
                   {
                       lot[j].cnt--;
                       vs[i]=1;
                       ans++;
                   }
            printf(&quot;%d\n&quot;,ans);

    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-3616 Milking Time 【DP】</title>
    <url>/article/csdn/poj-3616_Milking_Time_%E3%80%90DP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44021503" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44021503</a></p>
<p>Milking Time</p>
<table>
<thead>
<tr>
<th><strong>Time Limit:</strong> 1000MS</th>
<th></th>
<th><strong>Memory Limit:</strong> 65536K  </th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Total Submissions:</strong> 5251</td>
<td></td>
<td><strong>Accepted:</strong> 2169  </td>
</tr>
</tbody>
</table>
<p>Description</p>
<p>Bessie is such a hard-working cow. In fact, she is so focused on maximizing<br>her productivity that she decides to schedule her next _N_ (1 ≤ _N_ ≤<br>1,000,000) hours (conveniently labeled 0.. _N_ -1) so that she produces as<br>much milk as possible.</p>
<p>Farmer John has a list of _M_ (1 ≤ _M_ ≤ 1,000) possibly overlapping intervals<br>in which he is available for milking. Each interval _i_ has a starting hour (0<br>≤ _starting_hour i  _ ≤ _N_ ), an ending hour ( _starting_hour i  _ &lt;<br>_ending_hour i  _ ≤ _N_ ), and a corresponding efficiency (1 ≤ _efficiency i<br>_ ≤ 1,000,000) which indicates how many gallons of milk that he can get out of<br>Bessie in that interval. Farmer John starts and stops milking at the beginning<br>of the starting hour and ending hour, respectively. When being milked, Bessie<br>must be milked through an entire interval.</p>
<p>Even Bessie has her limitations, though. After being milked during any<br>interval, she must rest _R_ (1 ≤ _R_ ≤ _N_ ) hours before she can start<br>milking again. Given Farmer Johns list of intervals, determine the maximum<br>amount of milk that Bessie can produce in the _N_ hours.</p>
<p>Input</p>
<ul>
<li>Line 1: Three space-separated integers: _N_ , _M_ , and _R_   </li>
<li>Lines 2.. _M_ +1: Line _i_ +1 describes FJ’s ith milking interval withthree space-separated integers: _starting_hour i  _ , _ending_hour i  _ , and _efficiency i  _</li>
</ul>
<p>Output</p>
<ul>
<li>Line 1: The maximum number of gallons of milk that Bessie can product in the _N_ hours </li>
</ul>
<p>Sample Input</p>
<pre><code>12 4 2
1 2 8
10 12 19
3 6 24
7 10 31
</code></pre><p>Sample Output</p>
<pre><code>43
</code></pre><p>按照结束时间先后排序，因为需要休息实际结束时间为结束时间加上休息时间。</p>
<p>然后DP。</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;

using namespace std;

int n, m, r, dp[1000100];

struct node
{
    int s, e, f;
}p[1000100];

bool cmp(node a, node b)
{
    return a.e &lt; b.e;
}

int main()
{
    while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; r)
    {
        for (int i = 0; i &lt; m; i++)
        {

            cin &gt;&gt; p[i].s &gt;&gt; p[i].e &gt;&gt; p[i].f;
            p[i].e += r;
        }

        sort(p,p+m,cmp);

        for (int i = 0; i &lt; m; i++)
        {
            dp[i] = p[i].f;
            for (int j = 0; j &lt; i; j++)
            {
                if (p[i].s &gt;= p[j].e)
                    dp[i] = max(dp[i] , dp[j] + p[i].f);
            }
        }
        int ans = -1;
        for (int i = 0; i &lt; m; i++)
            ans = max(ans,dp[i]);
        cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-3628 Silver Cow Party</title>
    <url>/article/csdn/poj-3628_Silver_Cow_Party.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43244317" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43244317</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=3268" target="_blank" rel="noopener"> http://poj.org/problem?id=3268 </a></p>
<p>所有的牛去一个牛的家里参加聚会，所给的路径是单向的，问往返的所有牛的路径长度中最长的是多少？</p>
<p>解法：往返时候翻转矩阵，再求一遍最短路径，两次相加后进行比较。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

using namespace std;

const int MAXV = 4010;
const int inf = 10000000;

int map[MAXV][MAXV];//路径长度
int d[MAXV],re_d[MAXV];//距离
bool vis[MAXV];
int n,m,x;

void dijkstra(int s)
{
    for(int i=1;i&lt;=n;i++)
    {
        vis[i]=0;
        d[i]=map[s][i];
    }
    d[s] = 0;
    while (1)
    {
        int min=inf,v = -1;
        for(int i=1;i&lt;=n;i++)
            if(!vis[i] &amp;&amp; d[i]&lt;min)
            {
                v=i;
                min=d[i];
            }
        if(v == -1)
            break;
        vis[v]=1;
        for(int i=1;i&lt;=n;i++)
            if(!vis[i] &amp;&amp; d[i] &gt; d[v] + map[v][i])
                d[i]=map[v][i]+d[v];
    }
}
int main()
{
    int i,j,a,b,c;
    while(scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;x) != EOF)
    {
        for(i=1;i&lt;=n;i++)
            for(j=1;j&lt;=n;j++)
            {
                if(i==j)
                    map[i][i]=0;
                else
                    map[i][j] = inf;
            }
            for(i=1;i&lt;=m;i++)
            {
                scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
                if(map[a][b]&gt;c)
                    map[a][b]=c;
            }
        dijkstra(x);
        for(int i=1;i&lt;=n;i++)
            re_d[i] = d[i];
        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;i;j++)
        {
            int t = map[i][j] ;
            map[i][j]= map[j][i];
            map[j][i] = t;
        }
        dijkstra(x);
        for(int i=1;i&lt;=n;i++)
            d[i]+=re_d[i];
        int ans = -1;
        for(int i=1;i&lt;=n;i++)
            ans = max(ans,d[i]);
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-3660 Cow Contest</title>
    <url>/article/csdn/poj-3660_Cow_Contest.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43268559" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43268559</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=3660" target="_blank" rel="noopener"> http://poj.org/problem?id=3660 </a></p>
<p>利用floyd进行闭包的传递确定胜负关系。<br>这样所有点a能走到的点都是排名在a以后的。所有能走到点a的点都是排名在a以前的。如a点，排名在它之前的和排名在它之后的点之和为n-1，那么它的排名就是确定的。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

using namespace std;

const int MAX = 110;

int n,m;
int rank[MAX][MAX];
int in[MAX] ,out[MAX];
int ans;

int main ()
{
    int a,b;
    while (cin&gt;&gt;n&gt;&gt;m)
    {
        memset(rank,0,sizeof(rank));
        memset(in,0,sizeof(in));
        memset(out,0,sizeof(out));
        ans = 0;
        while (m--)
        {
            cin&gt;&gt;a&gt;&gt;b;
            rank[a][b] = 1;
        }
        for(int k=1;k&lt;=n;k++)
            for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;=n;j++)
        {
            if (rank[i][k] == 1 &amp;&amp; rank[k][j] == 1)
                rank[i][j] =1;
        }
        for(int i=1;i&lt;=n;i++)
        {
            int res = 0;
            for(int j=1;j&lt;=n;j++)
                res += rank[i][j] + rank[j][i];
            if (res == n-1)
                ans++;
        }
        cout&lt;&lt;ans&lt;&lt;endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title>poj-3669</title>
    <url>/article/csdn/poj-3669.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41809655" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41809655</a></p>
<p><a href="http://poj.org/problem?id=3669" target="_blank" rel="noopener"> http://poj.org/problem?id=3669 </a>  </p>
<p>广搜</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt;
#include&lt;malloc.h&gt;
#include&lt;stdexcept&gt;

using namespace std;

int n;

struct ss
{
    int x;
    int y;
    int tm;
}p[50010];

int pp[333][333];//最小被砸时间 初始无穷大
int vis[333][333];
int dir[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};

bool cmp (ss a ,ss b)
{
    return a.tm &lt; b.tm;
}

int bfs ()
{
    memset(vis,0,sizeof(vis));
    queue&lt;ss&gt; q ;
    ss qq ;
    ss qqq ;
    qq.x = 0;
    qq.y = 0;
    qq.tm = 0;
    q.push(qq);

    while (!q.empty())
    {
        qqq = q.front();
        q.pop();
        for(int i=0;i&lt;4;i++)
        {
            qq = qqq;
            qq.x = qq.x + dir[i][0];
            qq.y = qq.y + dir[i][1];
            qq.tm = qq.tm+1;
            if(qq.x&gt;=0 &amp;&amp; qq.y&gt;=0 &amp;&amp; qq.tm &lt; pp[qq.x][qq.y] &amp;&amp; !vis[qq.x][qq.y] )
            {
                vis[qq.x][qq.y] = 1;
                if (pp[qq.x][qq.y] &gt; p[n-1].tm)
                {
                    return qq.tm;
                }
                q.push(qq);
            }
        }
    }
    return -1;
}

int main ()
{
    while (scanf(&quot;%d&quot;,&amp;n)!=EOF)
    {
        for(int i=0;i&lt;=322;i++)
            for(int j=0;j&lt;=322;j++)
            {
                pp[i][j] = 10000;
            }

        for(int i=0;i&lt;n;i++)
        {
            scanf(&quot;%d %d %d&quot;,&amp;p[i].x,&amp;p[i].y,&amp;p[i].tm );
        }
        //对陨石降落时间排序
        sort(p,p+n,cmp);

        for(int i=0;i&lt;n;i++)
            for(int j=0;j&lt;4;j++)
            {
                if (pp[p[i].x][p[i].y] &gt; p[i].tm)
                    pp[p[i].x][p[i].y] = p[i].tm;

                int xx = p[i].x + dir[j][0];
                int yy = p[i].y + dir[j][1];

                if (xx &gt;= 0 &amp;&amp; yy &gt;= 0 &amp;&amp; pp[xx][yy] &gt; p[i].tm)
                {
                    pp[xx][yy] = p[i].tm;
                }
            }


        if(pp[0][0] == 0)
        {
            printf(&quot;-1\n&quot;);
        }
        else
        {
            printf(&quot;%d\n&quot;,bfs());
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj-3816 Treats for the Cows 【区间DP】</title>
    <url>/article/csdn/poj-3816_Treats_for_the_Cows_%E3%80%90%E5%8C%BA%E9%97%B4DP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44064101" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44064101</a></p>
<p>Treats for the Cows</p>
<table>
<thead>
<tr>
<th><strong>Time Limit:</strong> 1000MS</th>
<th></th>
<th><strong>Memory Limit:</strong> 65536K  </th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Total Submissions:</strong> 4259</td>
<td></td>
<td><strong>Accepted:</strong> 2150  </td>
</tr>
</tbody>
</table>
<p>Description</p>
<p>FJ has purchased N (1  &lt;= N &lt;= 2000) yummy treats for the cows who get money<br>for giving vast amounts of milk. FJ sells one treat per day and wants to<br>maximize the money he receives over a given period time.  </p>
<p>The treats are interesting for many reasons:</p>
<ul>
<li>The treats are numbered 1..N and stored sequentially in single file in a long box that is open at both ends. On any day, FJ can retrieve one treat from either end of his stash of treats. </li>
<li>Like fine wines and delicious cheeses, the treats improve with age and command greater prices. </li>
<li>The treats are not uniform: some are better and have higher intrinsic value. Treat i has value v(i) (1 &lt;= v(i) &lt;= 1000). </li>
<li>Cows pay more for treats that have aged longer: a cow will pay v(i)*a for a treat of age a. </li>
</ul>
<p>Given the values v(i) of each of the treats lined up in order of the index i<br>in their box, what is the greatest value FJ can receive for them if he orders<br>their sale optimally?  </p>
<p>The first treat is sold on day 1 and has age a=1. Each subsequent day<br>increases the age by 1.</p>
<p>Input</p>
<p>Line 1: A single integer, N  </p>
<p>Lines 2..N+1: Line i+1 contains the value of treat v(i)</p>
<p>Output</p>
<p>Line 1: The maximum revenue FJ can achieve by selling the treats</p>
<p>Sample Input</p>
<pre><code>5
1
3
1
5
2
</code></pre><p>Sample Output</p>
<pre><code>43
</code></pre><p>Hint</p>
<p>Explanation of the sample:  </p>
<p>Five treats. On the first day FJ can sell either treat #1 (value 1) or treat</p>
<p>#5 (value 2).  </p>
<p>FJ sells the treats (values 1, 3, 1, 5, 2) in the following order of indices:<br>1, 5, 2, 3, 4, making 1x1 + 2x2 + 3x3 + 4x1 + 5x5 = 43.</p>
<p>Source</p>
<p><a href="http://poj.org/searchproblem?field=source&amp;key=USACO+2006+February+Gold+%26+Silver" target="_blank" rel="noopener"> USACO 2006 February Gold &amp; Silver
</a></p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;

using namespace std;

int m, n, p[10010],dp[2010][2010];

int main()
{
    while (cin &gt;&gt; n)
    {
        for (int i = 1; i &lt;= n; i++)
            cin &gt;&gt; p[i];

        for (int i = 0; i &lt;= n; i++)
            for (int j = 0; j &lt;= n; j++)
                dp[i][j] = 0;

        for (int i = 1; i &lt;= n; i++)
            dp[i][i] = p[i] * n;//初始化为最大。

        for (int len = 1; len &lt; n; len++)
        {
            for (int i = 1; i + len &lt;= n; i++)
            {
                int j = i + len; 
                dp[i][j] = max(dp[i + 1][j] + (n - len)*p[i], dp[i][j - 1] + (n - len)*p[j]);//从内向外dp,i j 代表区间范围。
            }
        }
        cout &lt;&lt; dp[1][n] &lt;&lt; endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj 1061 青蛙的约会 【扩展欧几里得】</title>
    <url>/article/csdn/poj_1061_%E9%9D%92%E8%9B%99%E7%9A%84%E7%BA%A6%E4%BC%9A_%E3%80%90%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44178903" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44178903</a></p>
<p>青蛙的约会</p>
<table>
<thead>
<tr>
<th><strong>Time Limit:</strong> 1000MS</th>
<th></th>
<th><strong>Memory Limit:</strong> 10000K  </th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Total Submissions:</strong> 93841</td>
<td></td>
<td><strong>Accepted:</strong> 17330  </td>
</tr>
</tbody>
</table>
<p>Description</p>
<p>两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。<br>我们把这两只青蛙分别叫做青蛙A和青蛙B，并且规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴。设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。青蛙A一次能跳m米，青蛙B一次能跳n米，两只青蛙跳一次所花费的时间相同。纬度线总长L米。现在要你求出它们跳了几次以后才会碰面。  </p>
<p>Input</p>
<p>输入只包括一行5个整数x，y，m，n，L，其中x≠y  &lt; 2000000000，0 &lt; m、n &lt; 2000000000，0 &lt; L &lt;<br>2100000000。</p>
<p>Output</p>
<p>输出碰面所需要的跳跃次数，如果永远不可能碰面则输出一行”Impossible”</p>
<p>Sample Input</p>
<pre><code>1 2 3 4 5
</code></pre><p>Sample Output</p>
<pre><code>4
</code></pre><p>Source</p>
<p><a href="http://poj.org/searchproblem?field=source&amp;key=%E6%B5%99%E6%B1%9F" target="_blank" rel="noopener"> 浙江 </a></p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;
#include &lt;iterator&gt;

using namespace std;

long long X, x, Y, y, m, n, l, d;

void exgcd(long long  a, long long b, long long &amp; d, long long&amp; x, long long&amp; y)
{
    if (!b)
    {
        d = a;
        x = 1;
        y = 0;
    }
    else
    {
        exgcd(b,a%b,d,y,x);
        y -= x *(a/b);
    }
}

long long gcd(long long a, long long b)
{
    if (b == 0)
        return a;
    else
        return gcd(b,a%b);
}

int main()
{
    long long a, b, c, t;
    while (scanf(&quot;%lld%lld%lld%lld%lld&quot;, &amp;X, &amp;Y, &amp;m, &amp;n, &amp;l) != EOF)
    {
        a = n - m;
        b = l;
        c = X - Y;
        exgcd(a, b, d, x, y);
        long long t = gcd(a,b);
        if (c % t != 0)
        {
            printf(&quot;Impossible\n&quot;);
            continue;
        }
        /*
        通解：x = x0 + b/t * k;
            　y = y0 - a/t * k;
        */
        x = x *(c / t);//一组解
        y = y *(c / t);

        //x0 = x + b / t * k; 任意解
        //找到k 使得 x0 最小

        long long ans = x*t / b;
        ans = x - ans*b / t;
        if (ans &lt; 0)
            ans += b / t;
        printf(&quot;%lld\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj 1088 滑雪【记忆化搜索】</title>
    <url>/article/csdn/poj_1088_%E6%BB%91%E9%9B%AA%E3%80%90%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47373061" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47373061</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=1088" target="_blank" rel="noopener"> http://poj.org/problem?id=1088 </a></p>
<p>基础题，不讲了，饿了 吃早饭去。。。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;math.h&gt;
#include &lt;map&gt;
#include &lt;string&gt;

using namespace std;

int r,c;
int a[110][110],dp[110][110];

int dfs(int i,int j)
{
    if(dp[i][j]!=0) return dp[i][j];
    dp[i][j]=1;
    if(a[i][j] &gt; a[i+1][j] &amp;&amp; i&lt;r)
        dp[i][j] = max(dp[i][j],dfs(i+1,j)+1);
    if(a[i][j] &gt; a[i][j+1] &amp;&amp; j&lt;c)
        dp[i][j] = max(dp[i][j],dfs(i,j+1)+1);
    if(a[i][j] &gt; a[i-1][j] &amp;&amp; i&gt;1)
        dp[i][j] = max(dp[i][j],dfs(i-1,j)+1);
    if(a[i][j] &gt; a[i][j-1] &amp;&amp; j&gt;1)
        dp[i][j] = max(dp[i][j],dfs(i,j-1)+1);
    return dp[i][j];
}

int main()
{
    while(cin&gt;&gt;r&gt;&gt;c)
    {
        memset(a,0,sizeof(a));
        memset(dp,0,sizeof(dp));
        for(int i=1;i&lt;=r;i++)
            for(int j=1;j&lt;=c;j++)
            cin&gt;&gt;a[i][j];
        int ans = -1;
         for(int i=1;i&lt;=r;i++)
            for(int j=1;j&lt;=c;j++)
                ans = max(ans,dfs(i,j));
            printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj 1236 Network of Schools 【Tarjan】</title>
    <url>/article/csdn/poj_1236_Network_of_Schools_%E3%80%90Tarjan%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46379683" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46379683</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=1236" target="_blank" rel="noopener"> http://poj.org/problem?id=1236 </a></p>
<p>题意：</p>
<p>本题为有向图。<br>需解决两个问题：<br>1 需要给多少个点，才能传遍所有点。<br>2 加多少条边，使得整个图变得强连通。<br>使用Tarjan进行缩点，得到一个SCC图、<br>这个图有多少个入度为0的，多少个出度为0的。<br>假设有n个入度为0，m个出度为0<br>那么第一个答案就是n,第二个答案是max(n,m)<br>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;sstream&gt;
#include &lt;time.h&gt;

using namespace std;

const int MAXN = 20010;
const int MAXM = 50010;

struct Edge
{
    int to, next;
}edge[MAXM];

int head[MAXM], tot;
int Low[MAXN], Dfn[MAXN], Stack[MAXN], Belong[MAXN];//Belong的值为 1 ~ scc
int Index, top;
int scc;//强连通个数
bool Instack[MAXN];
int num[MAXN];//各个强连通包含的点的个数

void addedge(int u, int v)
{
    edge[tot].to = v;
    edge[tot].next = head[u];
    head[u] = tot++;
}

void Tarjan(int u)
{
    int v;
    Low[u] = Dfn[u] = ++Index;
    Stack[top++] = u;
    Instack[u] = true;
    for (int i = head[u]; i != -1; i = edge[i].next)
    {
        v = edge[i].to;
        if (!Dfn[v])
        {
            Tarjan(v);
            if (Low[u] &gt; Low[v]) 
                Low[u] = Low[v];
        }
        else if (Instack[v] &amp;&amp; Low[u] &gt; Dfn[v])
            Low[u] = Dfn[v];
    }
    if (Low[u] == Dfn[u])
    {
        scc++;
        do
        {
            v = Stack[--top];
            Instack[v] = false;
            Belong[v] = scc;
            num[scc]++;
        } while (v != u);
    }
}

int in[MAXN], out[MAXN];

void solve(int N)
{
    memset(Dfn,0,sizeof(Dfn));
    memset(Instack,false,sizeof(Instack));
    memset(num,0,sizeof(num));
    Index = scc = top = 0;
    for (int i = 1; i &lt;= N; i++)
    {
        if (!Dfn[i])
            Tarjan(i);
    }
    if (scc == 1)
    {
        printf(&quot;1\n0\n&quot;);
        return;
    }
    for (int i = 1; i &lt;= scc; i++)
        in[i] = out[i] = 0;
    for (int u = 1; u &lt;= N; u++)
    {
        for (int i = head[u]; i != -1; i = edge[i].next)
        {
            int v = edge[i].to;
            if (Belong[u] != Belong[v])
            {
                in[Belong[v]]++;
                out[Belong[u]]++;
            }
        }
    }
    int ans1 = 0, ans2 = 0;
    for (int i = 1; i &lt;= scc; i++)
    {
        if (in[i] == 0) ans1++;
        if (out[i] == 0) ans2++;
    }
    //printf(&quot;%d\n&quot;,scc);
    printf(&quot;%d\n%d\n&quot;,ans1,max(ans1,ans2));
}

void init()
{
    tot = 0;
    memset(head,-1,sizeof(head));
}

int main()
{
    int n;
    int u, v;
    while (~scanf(&quot;%d&quot;, &amp;n))
    {
        init();
        for (int i = 1; i &lt;= n; i++)
        {
            while (~scanf(&quot;%d&quot;, &amp;u) &amp;&amp; u)
            {
                addedge(i,u);
            }
        }
        solve(n);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>poj 1463Strategic game【树形dp】</title>
    <url>/article/csdn/poj_1463Strategic_game%E3%80%90%E6%A0%91%E5%BD%A2dp%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/50775463" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/50775463</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=1463" target="_blank" rel="noopener"> http://poj.org/problem?id=1463 </a></p>
<p>题意：给你一棵树， 求用最小的点覆盖所有的边。</p>
<p>思路：<br>树上的dp,对于一个节点i，dp[i][1]表示以i为根节点选择i点的最优解,dp[i][0]为不选择i的解，对于所有的j是i的儿子节点，dp[i][0]<br>+= dp[j][1],dp[i][1] += min(dp[j][1],dp[j][0]);</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;

using namespace std;

struct Edge
{
    int to, next;
}edge[5010000];

int tol = 0;
int head[2010];

void init()
{
    memset(head, -1, sizeof(head));
}

void addedge(int u,int v)
{
    edge[tol].to = v;
    edge[tol].next = head[u];
    head[u] = tol++;
}

int n, vis[2010];
int dp[2010][2];

void dfs(int root)
{
    dp[root][0] = 0;
    dp[root][1] = 1;

    if (vis[root])
        return;
    vis[root] = 1;

    for (int i = head[root];i != -1;i = edge[i].next)
    {
        int v = edge[i].to;
        if (!vis[v])
        {
            dfs(v);
            dp[root][0] += dp[v][1];
            dp[root][1] += min(dp[v][0], dp[v][1]);
        }
    }
}

int main()
{
    while (scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        init();
        int root;
        memset(dp, 0, sizeof(dp));
        memset(vis, 0, sizeof(vis));

        for (int i = 1;i &lt;= n;i++)
        {
            int m, v, num;
            scanf(&quot;%d:(%d)&quot;, &amp;m, &amp;num);

            if (i == 1) root = m;

            while (num--)
            {
                scanf(&quot;%d&quot;, &amp;v);
                addedge(m, v);
                addedge(v, m);
            }
        }

        dfs(root);

        int ans = min(dp[root][0], dp[root][1]);
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj 1651 Multiplication Puzzle【区间DP】</title>
    <url>/article/csdn/poj_1651_Multiplication_Puzzle%E3%80%90%E5%8C%BA%E9%97%B4DP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47227825" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47227825</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=1651" target="_blank" rel="noopener"> http://poj.org/problem?id=1651 </a></p>
<p>题意：初使ans=0,每次消去一个值,位置在pos（pos!=1 &amp;&amp; pos !=n）<br>同时ans+=a[pos-1]<em>a[pos]</em>a[pos+1]，一直消元素直到最后剩余2个，求方案最小的ans是多少？</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;assert.h&gt;
#pragma comment(linker,&quot;/STACK:1024000000,1024000000&quot;)

using namespace std;

const long long inf = 1e18;

int n;
int a[110];
long long dp[110][110];

int main()
{
    while (cin&gt;&gt;n)
    {
        for (int i = 1; i &lt;= n; i++)
            cin &gt;&gt; a[i];
        memset(dp, 0, sizeof(dp));
        for (int k = 2; k &lt;= n - 1; k++)//区间长度
        {
            for (int i = 1; i + k &lt;= n; i++)//区间起点
            {
                int j = i + k;//区间终点
                dp[i][j] = inf;
                for (int r = i + 1; r &lt; j; r++)
                {
                    dp[i][j] = min(dp[i][j], dp[i][r] + dp[r][j] + a[i] * a[r] * a[j]);
                }
            }
        }
        cout &lt;&lt; dp[1][n] &lt;&lt; endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj 1469 COURSES 【匈牙利匹配】</title>
    <url>/article/csdn/poj_1469_COURSES_%E3%80%90%E5%8C%88%E7%89%99%E5%88%A9%E5%8C%B9%E9%85%8D%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46491871" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46491871</a></p>
<p>题目链接: <a href="http://poj.org/problem?id=1469" target="_blank" rel="noopener"> http://poj.org/problem?id=1469 </a><br>题意：最大匹配学生与课程数。<br>解法：ans == 学生数量 YES else NO<br>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int n, m, num, k;
int p[310][310];
int book[310];
int match[310];
int t;
bool vis[310];

bool dfs(int u)
{
    int i;
    for (i = 1; i &lt;= m; i++)
    {
        if (book[i] == 0 &amp;&amp; p[u][i] == 1)
        {
            book[i] = 1;
            if (match[i] == 0 || dfs(match[i]))
            {
                match[i] = u;
                return true;
            }
        }
    }
    return false;
}


int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        memset(p, 0, sizeof(p));
        memset(match, 0, sizeof(match));
        memset(vis,false,sizeof(vis));

        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);

        for (int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;,&amp;num);
            for (int j = 1; j &lt;= num; j++)
            {
                scanf(&quot;%d&quot;,&amp;k);
                p[i][k] = 1;
                //p[num][m] = 1;
            }
        }

        int ans = 0;
        for (int i = 1; i &lt;= n; i++)
        {
            memset(book, 0, sizeof(book));
            if (dfs(i))
                ans++;
        }
        if (ans == n) puts(&quot;YES&quot;);
        else puts(&quot;NO&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj 1087 A Plug for UNIX 【最大流】</title>
    <url>/article/csdn/poj_1087_A_Plug_for_UNIX_%E3%80%90%E6%9C%80%E5%A4%A7%E6%B5%81%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47349099" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47349099</a></p>
<p>题目连接： <a href="http://poj.org/problem?id=1087" target="_blank" rel="noopener"> http://poj.org/problem?id=1087 </a></p>
<p>题意：<br>n种插座 ，m个电器，f组（x，y）表示插座x可以替换插座y，问你最多能给几个电器充电。</p>
<p>解法：起点向插座建边，容量１，电器向汇点建边，容量１，插座向电器建边，容量１，可以替换的插座间建边，容量无穷大。然后套板子。。。求最大流。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;ctime&gt;  
#include &lt;math.h&gt;  
#include &lt;limits.h&gt;  
#include &lt;complex&gt;  
#include &lt;string&gt;  
#include &lt;functional&gt;  
#include &lt;iterator&gt;  
#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;stack&gt;  
#include &lt;queue&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;list&gt;  
#include &lt;bitset&gt;  
#include &lt;sstream&gt;  
#include &lt;iomanip&gt;  
#include &lt;fstream&gt;  
#include &lt;iostream&gt;  
#include &lt;ctime&gt;  
#include &lt;cmath&gt;  
#include &lt;cstring&gt;  
#include &lt;cstdio&gt;  
#include &lt;time.h&gt;  
#include &lt;ctype.h&gt;  
#include &lt;string.h&gt;  
#include &lt;assert.h&gt;  

using namespace std;

const int MAXN = 1010;//点数的最大值
const int MAXM = 400010;//边数的最大值
const int INF = 0x3f3f3f3f;
struct Edge
{
    int to, next, cap, flow;
}edge[MAXM];//注意是MAXM
int tol;
int head[MAXN];
int gap[MAXN], dep[MAXN], pre[MAXN], cur[MAXN];

void init()
{
    tol = 0;
    memset(head, -1, sizeof(head));
}
//加边，单向图三个参数，双向图四个参数
void addedge(int u, int v, int w, int rw = 0)
{
    edge[tol].to = v; edge[tol].cap = w; edge[tol].next = head[u];
    edge[tol].flow = 0; head[u] = tol++;
    edge[tol].to = u; edge[tol].cap = rw; edge[tol].next = head[v];
    edge[tol].flow = 0; head[v] = tol++;
}

//输入参数：起点、终点、点的总数
//点的编号没有影响，只要输入点的总数

int sap(int start, int end, int N)
{
    memset(gap, 0, sizeof(gap));
    memset(dep, 0, sizeof(dep));
    memcpy(cur, head, sizeof(head));
    int u = start;
    pre[u] = -1;
    gap[0] = N;
    int ans = 0;
    while (dep[start] &lt; N)
    {
        if (u == end)
        {
            int Min = INF;
            for (int i = pre[u]; i != -1; i = pre[edge[i ^ 1].to])
                if (Min &gt; edge[i].cap - edge[i].flow)
                    Min = edge[i].cap - edge[i].flow;
            for (int i = pre[u]; i != -1; i = pre[edge[i ^ 1].to])
            {
                edge[i].flow += Min;
                edge[i ^ 1].flow -= Min;
            }
            u = start;
            ans += Min;
            continue;
        }
        bool flag = false;
        int v;
        for (int i = cur[u]; i != -1; i = edge[i].next)
        {
            v = edge[i].to;
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[v] + 1 == dep[u])
            {
                flag = true;
                cur[u] = pre[v] = i;
                break;
            }
        }
        if (flag)
        {
            u = v;
            continue;
        }
        int Min = N;
        for (int i = head[u]; i != -1; i = edge[i].next)
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min)
            {
                Min = dep[edge[i].to];
                cur[u] = i;
            }
        gap[dep[u]]--;
        if (!gap[dep[u]])return ans;
        dep[u] = Min + 1;
        gap[dep[u]]++;
        if (u != start) u = edge[pre[u] ^ 1].to;
    }
    return ans;
}

int m, n, f;
map&lt;string, int&gt; Hash;
string x, y;

int main()
{
    while (cin &gt;&gt; n)
    {
        init();
        Hash.clear();

        int num1 = 2;

        int from = 0;
        int end = 1;

        for (int i = 1; i &lt;= n; i++)
        {
            cin &gt;&gt; x;
            Hash[x] = num1;
            addedge(0, num1, 1);
            num1++;
        }
        cin &gt;&gt; m;
        for (int i = 1; i &lt;= m; i++)
        {
            cin &gt;&gt; x &gt;&gt; y;
            if (Hash[x] == 0) Hash[x] = num1++;
            if (Hash[y] == 0) Hash[y] = num1++;

            addedge(Hash[x], end, 1);
            addedge(Hash[y], Hash[x], 1);
        }

        cin &gt;&gt; f;
        for (int i = 1; i &lt;= f; i++)
        {
            cin &gt;&gt; x &gt;&gt; y;
            if (Hash[x] == 0) Hash[x] = num1++;
            if (Hash[y] == 0) Hash[y] = num1++;
            addedge(Hash[y], Hash[x], 10000000);
        }

        int ans = sap(from, end, num1);
        printf(&quot;%d\n&quot;, m - ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj 2096 Collecting Bugs【概率DP】</title>
    <url>/article/csdn/poj_2096_Collecting_Bugs%E3%80%90%E6%A6%82%E7%8E%87DP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46418345" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46418345</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=2096" target="_blank" rel="noopener"> http://poj.org/problem?id=2096 </a><br>题意：<br>一个软件有s个子系统，会产生n种bug。<br>某人一天发现一个bug，这个bug属于某种bug，发生在某个子系统中。<br>求找到所有的n种bug，且每个子系统都找到bug，这样所要的天数的期望。<br>需要注意的是：bug的数量是无穷大的，所以发现一个bug，出现在某个子系统的概率是1/s，<br>属于某种类型的概率是1/n。<br>解法：<br>dp[i][j]表示已经找到i种bug，并存在于j个子系统中，要达到目标状态的天数的期望。<br>显然，dp[n][s]=0，因为已经达到目标了。而dp[0][0]就是我们要求的答案。<br>dp[i][j]状态可以转化成以下四种：<br>dp[i][j] 发现一个bug属于已经找到的i种bug和j个子系统中<br>dp[i+1][j] 发现一个bug属于新的一种bug，但属于已经找到的j种子系统<br>dp[i][j+1] 发现一个bug属于已经找到的i种bug，但属于新的子系统<br>dp[i+1][j+1]发现一个bug属于新的一种bug和新的一个子系统<br>所以：</p>
<p>dp[i][j] = i/n<em>j/s</em>dp[i][j] + (n-i)/n<em>j/s</em>dp[i+1][j] + i/n<em>(s-j)/s</em>dp[i][j+1]</p>
<ul>
<li>(n-i)/n<em>(s-j)/s</em>dp[i+1][j+1] +1</li>
</ul>
<p>移项得：</p>
<p>(1-i<em>j/n/s) _dp[i][j] = (n-i)/n</em>j/s<em>dp[i+1][j] + i/n_ (s-j)/s</em>dp[i][j+1] +<br>(n-i)/n<em>(s-j)/s</em>dp[i+1][j+1] +1</p>
<p>代码：</p>
<pre><code> #include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;vector&gt;  
#include &lt;string&gt;  
#include &lt;algorithm&gt;  
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;fstream&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;math.h&gt;

using namespace std;

double dp[1010][1010];
int n, s;

int main()
{
    while (cin &gt;&gt; n &gt;&gt; s)
    {
        memset(dp,0,sizeof(dp));

        for (int i = n; i &gt;= 0; i--)
            for (int j = s; j &gt;= 0; j--)
            {
                if (i == n &amp;&amp; j == s) continue;
                double ans1 = (double (n - i)*j)/n/s* dp[i + 1][j];
                double ans2 = (double (s - j)*i)/n/s* dp[i][j + 1];
                double ans3 = (double (n - i)*(s - j))/n/s* dp[i + 1][j + 1];
                dp[i][j] = (ans1 + ans2 + ans3 + 1) / (1.0 - (double (i)*j/n/s));
            }
        printf(&quot;%.4lf&quot;,dp[0][0]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj 1811 Prime Test【 随机素数测试与大数分解】</title>
    <url>/article/csdn/poj_1811_Prime_Test%E3%80%90_%E9%9A%8F%E6%9C%BA%E7%B4%A0%E6%95%B0%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%A4%A7%E6%95%B0%E5%88%86%E8%A7%A3%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44594219" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44594219</a></p>
<p>Prime Test<br>Time Limit: 6000MS Memory Limit: 65536K<br>Total Submissions: 29925 Accepted: 7631<br>Case Time Limit: 4000MS<br>Description</p>
<p>Given a big integer number, you are required to find out whether it’s a prime<br>number.<br>Input</p>
<p>The first line contains the number of test cases T (1 &lt;= T &lt;= 20 ), then the<br>following T lines each contains an integer number N (2 &lt;= N &lt; 254).<br>Output</p>
<p>For each test case, if N is a prime number, output a line containing the word<br>“Prime”, otherwise, output a line containing the smallest prime factor of N.<br>Sample Input</p>
<p>2<br>5<br>10<br>Sample Output</p>
<p>Prime<br>2<br>Source</p>
<p>POJ Monthly</p>
<p>直接套bin神的板子。</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;time.h&gt;
#include&lt;iostream&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;
#include&lt;algorithm&gt;

using namespace std;

//****************************************************************
// Miller_Rabin 算法进行素数测试
//速度快，而且可以判断 &lt; 2^63的数
//****************************************************************
const int S = 10;//随机算法判定次数，S越大，判错概率越小 一般8-10足够


//计算 (a*b)%c.   a,b都是long long的数，直接相乘可能溢出的
//  a,b,c &lt;2^63
long long mult_mod(long long a, long long b, long long c)
{
    a %= c;
    b %= c;
    long long ret = 0;
    while (b)
    {
        if (b &amp; 1){ ret += a; ret %= c; }
        a &lt;&lt;= 1;
        if (a &gt;= c)a %= c;
        b &gt;&gt;= 1;
    }
    return ret;
}



//计算 ret =  x^n %c
long long pow_mod(long long x, long long n, long long mod)//x^n%c
{
    if (n == 1)return x%mod;
    x %= mod;
    long long tmp = x;
    long long ret = 1;
    while (n)
    {
        if (n &amp; 1) ret = mult_mod(ret, tmp, mod);
        tmp = mult_mod(tmp, tmp, mod);
        n &gt;&gt;= 1;
    }
    return ret;
}


//通过费马小定理，即 a^(n-1)=1(mod n)  验证n是不是合数
//一定是合数返回true,不一定返回false
bool check(long long a, long long n, long long x, long long t)
{
    long long ret = pow_mod(a, x, n);
    long long last = ret;
    for (int i = 1; i &lt;= t; i++)
    {
        ret = mult_mod(ret, ret, n);
        if (ret == 1 &amp;&amp; last != 1 &amp;&amp; last != n - 1) return true;//合数
        last = ret;
    }
    if (ret != 1) return true;
    return false;
}

// Miller_Rabin()算法素数判定
//是素数返回true.(可能是伪素数，但概率极小)
//合数返回false;

bool Miller_Rabin(long long n)
{
    if (n&lt;2)return false;
    if (n == 2)return true;
    if ((n &amp; 1) == 0) return false;//偶数
    long long x = n - 1;
    long long t = 0;
    while ((x &amp; 1) == 0){ x &gt;&gt;= 1; t++; }
    for (int i = 0; i&lt;S; i++)
    {
        long long a = rand() % (n - 1) + 1;//rand()需要stdlib.h头文件
        if (check(a, n, x, t))
            return false;//合数
    }
    return true;
}


//************************************************
//pollard_rho 算法进行质因数分解
//************************************************
long long factor[100];//质因数分解结果（刚返回时是无序的）
int tol;//质因数的个数。数组下标从0~tol-1开始

long long gcd(long long a, long long b)
{
    if (a == 0)return 1;//???????
    if (a&lt;0) return gcd(-a, b);
    while (b)
    {
        long long t = a%b;
        a = b;
        b = t;
    }
    return a;
}
//找出一个因子
long long Pollard_rho(long long x, long long c)
{
    long long i = 1, k = 2;
    long long x0 = rand() % x;
    long long y = x0;
    while (1)
    {
        i++;
        x0 = (mult_mod(x0, x0, x) + c) % x;
        long long d = gcd(y - x0, x);
        if (d != 1 &amp;&amp; d != x) return d;
        if (y == x0) return x;
        if (i == k){ y = x0; k += k; }
    }
}
//对n进行素因子分解 存入factor数组
void findfac(long long n)
{
    if (Miller_Rabin(n))//素数
    {
        factor[tol++] = n;
        return;
    }
    long long p = n;
    while (p &gt;= n)p = Pollard_rho(p, rand() % (n - 1) + 1);
    findfac(p);
    findfac(n / p);
}
int main()
{
    // srand(time(NULL));//需要time.h头文件  //POJ上G++要去掉这句话
    int T;
    long long n;
    scanf(&quot;%d&quot;, &amp;T);
    while (T--)
    {
        scanf(&quot;%I64d&quot;, &amp;n);
        if (Miller_Rabin(n))
        {
            printf(&quot;Prime\n&quot;);
            continue;
        }
        tol = 0;
        findfac(n);
        long long ans = factor[0];
        for (int i = 1; i&lt;tol; i++)
            if (factor[i]&lt;ans)
                ans = factor[i];
        printf(&quot;%I64d\n&quot;, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj 2104 K-th Number【主席树】</title>
    <url>/article/csdn/poj_2104_K-th_Number%E3%80%90%E4%B8%BB%E5%B8%AD%E6%A0%91%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48869133" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48869133</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=2104" target="_blank" rel="noopener"> http://poj.org/problem?id=2104 </a></p>
<p>询问求区间第k大。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;vector&gt;

using namespace std;

const int MAXN = 100010;
const int M = MAXN * 30;
int n, q, m, tot;
int a[MAXN], t[MAXN];
int T[M], lson[M], rson[M], c[M];

void init_hash()
{
    for (int i = 1; i &lt;= n;i++)
        t[i] = a[i];
    sort(t + 1, t + 1 + n);
    m = unique(t + 1, t + 1 + n) - t - 1;
}
int build(int l, int r)
{
    int root = tot++;
    c[root] = 0;
    if (l != r)
    {
        int mid = (l + r) &gt;&gt; 1;
        lson[root] = build(l, mid);
        rson[root] = build(mid + 1, r);
    }
    return root;
}
int hash(int x)
{
    return lower_bound(t + 1, t + 1 + m, x) - t;
}
int update(int root, int pos, int val)
{
    int newroot = tot++, tmp = newroot;
    c[newroot] = c[root] + val;
    int l = 1, r = m;
    while (l &lt; r)
    {
        int mid = (l + r) &gt;&gt; 1;
        if (pos &lt;= mid)
        {
            lson[newroot] = tot++; rson[newroot] = rson[root];
            newroot = lson[newroot]; root = lson[root];
            r = mid;
        }
        else
        {
            rson[newroot] = tot++; lson[newroot] = lson[root];
            newroot = rson[newroot]; root = rson[root];
            l = mid + 1;
        }
        c[newroot] = c[root] + val;
    }
    return tmp;
}
int query(int left_root, int right_root, int k)
{
    int l = 1, r = m;
    while (l &lt; r)
    {
        int mid = (l + r) &gt;&gt; 1;
        if (c[lson[left_root]] - c[lson[right_root]] &gt;= k)
        {
            r = mid;
            left_root = lson[left_root];
            right_root = lson[right_root];
        }
        else
        {
            l = mid + 1;
            k -= c[lson[left_root]] - c[lson[right_root]];
            left_root = rson[left_root];
            right_root = rson[right_root];
        }
    }
    return l;
}

int main()
{
    while (scanf(&quot;%d %d&quot;, &amp;n, &amp;q) != EOF)
    {
        tot = 0;
        for (int i = 1;i &lt;= n;i++)
            scanf(&quot;%d&quot;, &amp;a[i]);
        init_hash();
        T[n + 1] = build(1, m);
        for (int i = n;i;i--)
        {
            int pos = hash(a[i]);
            T[i] = update(T[i + 1], pos, 1);
        }
        while (q--)
        {
            int l, r, k;
            scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;k);
            printf(&quot;%d\n&quot;, t[query(T[l], T[r + 1], k)]);
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj 2195 Going Home【zkw费用流】</title>
    <url>/article/csdn/poj_2195_Going_Home%E3%80%90zkw%E8%B4%B9%E7%94%A8%E6%B5%81%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48224263" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48224263</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=2195" target="_blank" rel="noopener"> http://poj.org/problem?id=2195 </a></p>
<p>题意：每个人都走到一个屋子的最小花费。二分图类型</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;sstream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;string&gt;

using namespace std;

const int MAXN = 1000;
const int MAXM = 200000;
const int INF = 0x3f3f3f3f;
struct Edge
{
    int to, next, cap, flow, cost;
    Edge(int _to = 0, int _next = 0, int _cap = 0, int _flow = 0, int _cost = 0) :
        to(_to), next(_next), cap(_cap), flow(_flow), cost(_cost) {}
}edge[MAXM];

struct ZKW_MinCostMaxFlow
{
    int head[MAXN], tot;
    int cur[MAXN];
    int dis[MAXN];
    bool vis[MAXN];
    int ss, tt, N;//源点、汇点和点的总个数（编号是0~N-1）,不需要额外赋值，调用会直接赋值
    int min_cost, max_flow;
    void init()
    {
        tot = 0;
        memset(head, -1, sizeof(head));
    }
    void addedge(int u, int v, int cap, int cost)
    {
        edge[tot] = Edge(v, head[u], cap, 0, cost);
        head[u] = tot++;
        edge[tot] = Edge(u, head[v], 0, 0, -cost);
        head[v] = tot++;
    }
    int aug(int u, int flow)
    {
        if (u == tt)return flow;
        vis[u] = true;
        for (int i = cur[u];i != -1;i = edge[i].next)
        {
            int v = edge[i].to;
            if (edge[i].cap &gt; edge[i].flow &amp;&amp; !vis[v] &amp;&amp; dis[u] == dis[v] + edge[i].cost)
            {
                int tmp = aug(v, min(flow, edge[i].cap - edge[i].flow));
                edge[i].flow += tmp;
                edge[i ^ 1].flow -= tmp;
                cur[u] = i;
                if (tmp)return tmp;
            }
        }
        return 0;
    }
    bool modify_label()
    {
        int d = INF;
        for (int u = 0;u &lt; N;u++)
            if (vis[u])
                for (int i = head[u];i != -1;i = edge[i].next)
                {
                    int v = edge[i].to;
                    if (edge[i].cap&gt;edge[i].flow &amp;&amp; !vis[v])
                        d = min(d, dis[v] + edge[i].cost - dis[u]);
                }
        if (d == INF)return false;
        for (int i = 0;i &lt; N;i++)
            if (vis[i])
            {
                vis[i] = false;
                dis[i] += d;

            }
        return true;
    }
    /*
    * 直接调用获取最小费用和最大流
    * 输入: start-源点，end-汇点，n-点的总个数（编号从0开始）
    * 返回值: pair&lt;int,int&gt; 第一个是最小费用，第二个是最大流
    */
    pair&lt;int, int&gt; mincostmaxflow(int start, int end, int n)
    {
        ss = start, tt = end, N = n;
        min_cost = max_flow = 0;
        for (int i = 0;i &lt; n;i++)dis[i] = 0;
        while (1)
        {
            for (int i = 0;i &lt; n;i++)cur[i] = head[i];
            while (1)
            {
                for (int i = 0;i &lt; n;i++)vis[i] = false;
                int tmp = aug(ss, INF);
                if (tmp == 0)break;
                max_flow += tmp;
                min_cost += tmp*dis[ss];
            }
            if (!modify_label())break;
        }
        return make_pair(min_cost, max_flow);
    }
}solve;

int n, m;
char s[110][110];

int main()
{
    while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))
    {
        if (n == 0 &amp;&amp; m == 0) break;

        solve.init();

        for (int i = 0;i &lt; n;i++)
        {
            scanf(&quot;%s&quot;, s[i]);
            for (int j = 0;j &lt; m;j++)
                if (s[i][j] == &#39;H&#39;)
                    solve.addedge(n*m, i*m + j, 1, 0);
                else if (s[i][j] == &#39;m&#39;)
                    solve.addedge(i*m + j, n*m + 1, 1, 0);
        }

        for (int i = 0;i &lt; n*m;i++)
            for (int j = 0;j &lt; n*m;j++)
            {
                int x1 = i / m;
                int y1 = i % m;
                int x2 = j / m;
                int y2 = j % m;
                if (s[x1][y1] == &#39;H&#39; &amp;&amp; s[x2][y2] == &#39;m&#39;)
                    solve.addedge(i, j, 1, abs(x1 - x2) + abs(y1 - y2));
            }
        pair&lt;int, int&gt; ans = solve.mincostmaxflow(n * m, n * m + 1, n*m + 2);
        printf(&quot;%d\n&quot;,ans.first);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title>poj 2229 Sumsets【DP】</title>
    <url>/article/csdn/poj_2229_Sumsets%E3%80%90DP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46380481" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46380481</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=2229" target="_blank" rel="noopener"> http://poj.org/problem?id=2229 </a></p>
<p>题意：一个数n可以表示成多少种不同的二的幂次的和。</p>
<p>比如7：</p>
<p>1) 1+1+1+1+1+1+1<br>2) 1+1+1+1+1+2<br>3) 1+1+1+2+2<br>4) 1+1+1+4<br>5) 1+2+2+2<br>6) 1+2+4</p>
<p>if (i &amp;1) dp[i] = dp[i-1] eles dp[i] = dp[i-2] + dp[i&gt;&gt;1];</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;
#include &lt;set&gt;

using namespace std;

int n;
long long dp[1000010]; 

long long MOD = 1e9;

void init()
{
    dp[1] = 1;
    dp[2] = 2;
    for (int i = 3; i &lt;= 1000000; i++)
    {
        if (i &amp; 1) dp[i] = dp[i-1];
        else  dp[i] = (dp[i - 1] + dp[i &gt;&gt; 1]) % MOD;
    }
}

int main()
{
    init();
    while (scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        printf(&quot;%lld\n&quot;,dp[n]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj 2195 Going Home【最小费用最大流】</title>
    <url>/article/csdn/poj_2195_Going_Home%E3%80%90%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47344457" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47344457</a></p>
<p>题目链接：<br><a href="http://poj.org/problem?id=2195" target="_blank" rel="noopener"> http://poj.org/problem?id=2195 </a></p>
<p>题意：给你一些人的位置，和屋子的位置，求使得所有人回到屋子的最小花费是多少。每个屋子只能装一人。人每横着或竖着走一步，花费为1。</p>
<p>解法：最小费用流。bin神板子<br>建图是原点到人 ，人到屋子， 屋子到汇点。流量均为1，人与屋子费用为距离。其他费用为0；</p>
<p>代码：</p>
<pre><code>/*
POJ 2195 Going Home
邻接矩阵形式最小费用最大流
*/

#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
using namespace std;


//************************************************************
//最小费用最大流算法
//SPFA求最短路
//邻接矩阵形式
//初始化:cap:容量，没有边为0
//cost:耗费，对称形式，没有边的也为0
//c是最小费用
//f是最大流
//*******************************************************
const int MAXN=500;
const int INF=0x3fffffff;
int cap[MAXN][MAXN];//容量，没有边为0
int flow[MAXN][MAXN];
//耗费矩阵是对称的，有i到j的费用，则j到i的费用为其相反数
int cost[MAXN][MAXN];//花费


int n;//顶点数目0~n-1
int f;//最大流
int c;//最小费用
int start,end;//源点和汇点

bool vis[MAXN];//在队列标志
int que[MAXN];
int pre[MAXN];
int dist[MAXN];//s-t路径最小耗费
bool SPFA()
{
    int front=0,rear=0;
    for(int u=0;u&lt;=n;u++)
    {
        if(u==start)
        {
            que[rear++]=u;
            dist[u]=0;
            vis[u]=true;
        }
        else
        {
            dist[u]=INF;
            vis[u]=false;
        }
    }
    while(front!=rear)
    {
        int u=que[front++];
        vis[u]=false;
        if(front&gt;=MAXN)front=0;
        for(int v=0;v&lt;=n;v++)
        {
            if(cap[u][v]&gt;flow[u][v]&amp;&amp;dist[v]&gt;dist[u]+cost[u][v])
            {
                dist[v]=dist[u]+cost[u][v];
                pre[v]=u;
                if(!vis[v])
                {
                    vis[v]=true;
                    que[rear++]=v;
                    if(rear&gt;=MAXN)rear=0;
                }
            }
        }
    }
    if(dist[end]&gt;=INF)return false;
    return true;
}

void minCostMaxflow()
{
    memset(flow,0,sizeof(flow));
    c=f=0;
    while(SPFA())
    {
        int Min=INF;
        for(int u=end;u!=start;u=pre[u])
           Min=min(Min,cap[pre[u]][u]-flow[pre[u]][u]);
        for(int u=end;u!=start;u=pre[u])
        {
            flow[pre[u]][u]+=Min;
            flow[u][pre[u]]-=Min;
        }
        c+=dist[end]*Min;
        f+=Min;
    }
}
//************************************************************

struct Node
{
    int x,y;
};

Node node1[MAXN],node2[MAXN];
char str[MAXN][MAXN];

int main()
{
    int N,M;
    while(~scanf(&quot;%d%d&quot;,&amp;N,&amp;M))
    {
        if(N==0&amp;&amp;M==0)break;

        int tol1=0,tol2=0;
        //人和房子的数目 从 1 开始

        for(int i=0;i&lt;N;i++)
        {
            scanf(&quot;%s&quot;,&amp;str[i]);

            for(int j=0;j&lt;M;j++)
            {
                if(str[i][j]==&#39;m&#39;)
                {
                    tol1++;
                    node1[tol1].x=i;
                    node1[tol1].y=j;
                }
                else if(str[i][j]==&#39;H&#39;)
                {
                    tol2++;
                    node2[tol2].x=i;
                    node2[tol2].y=j;
                }
            }
        }

        start=0;

        n=tol1+tol2+1;

        end=tol1+tol2+1;

        memset(cap,0,sizeof(cap));
        memset(cost,0,sizeof(cost));

        for(int i=1;i&lt;=tol1;i++)
        {
            cost[0][i]=cost[i][0]=0;
            cap[0][i]=1;
        }

        for(int i=1;i&lt;=tol2;i++)
        {
            cost[tol1+i][end]=0;
            cap[tol1+i][end]=1;
        }

        for(int i=1;i&lt;=tol1;i++)
          for(int j=1;j&lt;=tol2;j++)
          {
              cost[i][tol1+j]=abs(node1[i].x-node2[j].x)+abs(node1[i].y-node2[j].y);

              cost[tol1+j][i]=-cost[i][tol1+j];

              cap[i][tol1+j]=1;
          }

        minCostMaxflow();
        printf(&quot;%d\n&quot;,c);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj 2289 Jamie&#39;s Contact Groups【二分 + 最大流】</title>
    <url>/article/csdn/poj_2289_Jamie&#39;s_Contact_Groups%E3%80%90%E4%BA%8C%E5%88%86_+_%E6%9C%80%E5%A4%A7%E6%B5%81%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48324507" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48324507</a></p>
<p>题目： <a href="http://poj.org/problem?id=2289" target="_blank" rel="noopener"> http://poj.org/problem?id=2289 </a></p>
<p>二分分组容量。<br>建图：源点向人，容量1，分组向汇点，容量为二分值。人向分组，容量为1。</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;sstream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;string&gt;

using namespace std;

const int MAXN = 101000;//点数的最大值
const int MAXM = 4001000;//边数的最大值
const int INF = 0x3f3f3f3f;

struct Edge
{
    int to, next, cap, flow;
}edge[MAXM];//注意是MAXM

int tol;
int head[MAXN];
int gap[MAXN], dep[MAXN], pre[MAXN], cur[MAXN];

void init()
{
    tol = 0;
    memset(head, -1, sizeof(head));
}
//加边，单向图三个参数，双向图四个参数
void addedge(int u, int v, int w, int rw = 0)
{
    edge[tol].to = v; edge[tol].cap = w; edge[tol].next = head[u];
    edge[tol].flow = 0; head[u] = tol++;
    edge[tol].to = u; edge[tol].cap = rw; edge[tol].next = head[v];
    edge[tol].flow = 0; head[v] = tol++;
}
//输入参数：起点、终点、点的总数
//点的编号没有影响，只要输入点的总数

int Q[MAXN];

void BFS(int start, int end)
{
    memset(dep, -1, sizeof(dep));
    memset(gap, 0, sizeof(gap));
    gap[0] = 1;
    int front = 0, rear = 0;
    dep[end] = 0;
    Q[rear++] = end;
    while (front != rear)
    {
        int u = Q[front++];
        for (int i = head[u];i != -1;i = edge[i].next)
        {
            int v = edge[i].to;
            if (dep[v] != -1) continue;
            Q[rear++] = v;
            dep[v] = dep[u] + 1;
            gap[dep[v]]++;
        }
    }
}
int S[MAXN];
int sap(int start, int end, int N)
{
    BFS(start, end);
    memcpy(cur, head, sizeof(head));
    int u = start;
    int top = 0;
    int ans = 0;
    while (dep[start] &lt; N)
    {
        if (u == end)
        {
            int Min = INF;
            int inser;
            for (int i = 0; i &lt; top; i++)
                if (Min &gt; edge[S[i]].cap - edge[S[i]].flow)
                {
                    Min = edge[S[i]].cap - edge[S[i]].flow;
                    inser = i;
                }
            for (int i = 0; i &lt; top; i++)
            {
                edge[S[i]].flow += Min;
                edge[S[i] ^ 1].flow -= Min;
            }
            ans += Min;
            top = inser;
            u = edge[S[top] ^ 1].to;
            continue;
        }
        bool flag = false;
        int v;
        for (int i = cur[u]; i != -1; i = edge[i].next)
        {
            v = edge[i].to;
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[v] + 1 == dep[u])
            {
                flag = true;
                cur[u] = i;
                break;
            }
        }
        if (flag)
        {
            S[top++] = cur[u];
            u = v;
            continue;
        }
        int Min = N;
        for (int i = head[u]; i != -1; i = edge[i].next)
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min)
            {
                Min = dep[edge[i].to];
                cur[u] = i;
            }
        gap[dep[u]]--;
        if (!gap[dep[u]])return ans;
        dep[u] = Min + 1;
        gap[dep[u]]++;
        if (u != start) u = edge[S[--top] ^ 1].to;
    }
    return ans;
}

int n, m;
string s;
map&lt;string, int&gt; mp;

int a[2100][2100];

int main()
{
    while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))
    {
        if (n == 0 &amp;&amp; m == 0) break;
        memset(a, 0, sizeof(a));
        for (int i = 1;i &lt;= n;i++)
        {
            cin &gt;&gt; s;
            int x;
            while (getchar() != &#39;\n&#39;)
            {
                scanf(&quot;%d&quot;, &amp;x);
                a[i][x + n + 1] = 1;
            }
        }

        int left = 0,right = 110000;
        int ans = 1e7;

        while (left &lt;= right)
        {
            int mid = (left + right) / 2;
            init();

            for (int i = 1;i &lt;= n;i++)
                addedge(0,i,1);

            for (int i = n + 1;i &lt;= n + m;i++)
                addedge(i, n + m + 1, mid);

            for (int i = 1;i &lt;= n;i++)
                for (int j = n + 1;j &lt;= n + m;j++)
                    if (a[i][j] == 1)
                        addedge(i, j, 1);

            if (sap(0, n + m + 1, n + m + 2) == n)
            {
                right = mid - 1;
                ans = min(ans,mid);
            }
            else left = mid + 1;
        }
        printf(&quot;%d\n&quot;, ans);
    }   
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title>poj 2337 Catenyms 【欧拉路径】</title>
    <url>/article/csdn/poj_2337_Catenyms_%E3%80%90%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47056779" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47056779</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=2337" target="_blank" rel="noopener"> http://poj.org/problem?id=2337 </a></p>
<p>题意：给定一些单词，如果一个单词的尾字母与另一个的首字母相同则可以连接。问是否可以每个单词用一次，将所有单词连接，可以则输出字典序最小的序列。</p>
<p>代码：<br>（bin 神的板子）</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int t;
int n;
string s[1010];

struct Edge
{
    int to, next;
    int index;
    bool flag;
}edge[2010];

int head[300], tot;

void init()
{
    tot = 0;
    memset(head,-1,sizeof(head));
}

void addedge(int u, int v, int index)
{
    edge[tot].to = v;
    edge[tot].next = head[u];
    edge[tot].index = index;
    edge[tot].flag = false;
    head[u] = tot++;
}

int in[250], out[250];

int cnt;
int ans[1010];

void dfs(int u)
{
    for (int i = head[u]; i != -1; i = edge[i].next)
    {
        if (!edge[i].flag)
        {
            edge[i].flag = true;
            dfs(edge[i].to);
            ans[cnt++] = edge[i].index;
        }
    }
}

int main()
{
    int t;
    cin &gt;&gt; t;
    while (t--)
    {

        scanf(&quot;%d&quot;,&amp;n);
        for (int i = 0; i &lt; n; i++)
            cin &gt;&gt; s[i];
        sort(s, s + n);
        init();
        memset(in,0,sizeof(in));
        memset(out, 0, sizeof(out));
        int start = 100;
        for (int i = n - 1; i &gt;= 0; i--)
        {
            int u = s[i][0] - &#39;a&#39;;
            int v = s[i][s[i].length() - 1] - &#39;a&#39;;
            addedge(u,v,i);
            out[u]++;
            in[v]++;
            if (u &lt; start) start = u;
            if (v &lt; start) start = v;
        }
        int cc1 = 0, cc2 = 0;
        for (int i = 0; i &lt; 26; i++)
        {
            if (out[i] - in[i] == 1)
            {
                cc1++;
                start = i;
            }
            else if (out[i] - in[i] == -1)
                cc2++;
            else if (out[i] - in[i] != 0)
                cc1 = 3;
        }
        if (!((cc1 == 0 &amp;&amp; cc2 == 0) || (cc1 == 1 &amp;&amp; cc2 == 1)))
        {
            printf(&quot;***\n&quot;);
            continue;
        }
        cnt = 0;
        dfs(start);
        if (cnt != n)
        {
            printf(&quot;***\n&quot;);
            continue;
        }
        for (int i = n-1; i &gt;=0 ; i--)
        {
            cout &lt;&lt; s[ans[i]];
            if (i != 0) printf(&quot;.&quot;);
            else printf(&quot;\n&quot;);
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj 2526 Minimum Cost【最小费用最大流】</title>
    <url>/article/csdn/poj_2526_Minimum_Cost%E3%80%90%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47357771" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47357771</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=2516" target="_blank" rel="noopener"> http://poj.org/problem?id=2516 </a></p>
<p>题意：<br>n个店主 m个供应商 k种货物 给你店主对k种货物的需求及供货商k种货物的囤货量及K种运输费用。</p>
<p>解法：k次费用流，分别求每种货物的费用。源点到供应点建边，店主到汇点建边，费用均为0，容量为1。然后供应点到店主建边，费用为矩阵，容量无穷大即可。</p>
<p>代码：</p>
<pre><code>/*
POJ 2195 Going Home
邻接矩阵形式最小费用最大流
*/

#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
using namespace std;


//************************************************************
//最小费用最大流算法
//SPFA求最短路
//邻接矩阵形式
//初始化:cap:容量，没有边为0
//cost:耗费，对称形式，没有边的也为0
//c是最小费用
//f是最大流
//*******************************************************
const int MAXN = 500;
const int INF = 0x3fffffff;
int cap[MAXN][MAXN];//容量，没有边为0
int flow[MAXN][MAXN];
//耗费矩阵是对称的，有i到j的费用，则j到i的费用为其相反数
int cost[MAXN][MAXN];//花费


int n;//顶点数目0~n-1
int f;//最大流
int c;//最小费用
int start, End;//源点和汇点

bool vis[MAXN];//在队列标志
int que[MAXN];
int pre[MAXN];
int dist[MAXN];//s-t路径最小耗费
bool SPFA()
{
    int front = 0, rear = 0;
    for (int u = 0; u &lt;= n; u++)
    {
        if (u == start)
        {
            que[rear++] = u;
            dist[u] = 0;
            vis[u] = true;
        }
        else
        {
            dist[u] = INF;
            vis[u] = false;
        }
    }
    while (front != rear)
    {
        int u = que[front++];
        vis[u] = false;
        if (front &gt;= MAXN)front = 0;
        for (int v = 0; v &lt;= n; v++)
        {
            if (cap[u][v]&gt;flow[u][v] &amp;&amp; dist[v]&gt;dist[u] + cost[u][v])
            {
                dist[v] = dist[u] + cost[u][v];
                pre[v] = u;
                if (!vis[v])
                {
                    vis[v] = true;
                    que[rear++] = v;
                    if (rear &gt;= MAXN)rear = 0;
                }
            }
        }
    }
    if (dist[End] &gt;= INF)return false;
    return true;
}

void minCostMaxflow()
{
    memset(flow, 0, sizeof(flow));
    c = f = 0;
    while (SPFA())
    {
        int Min = INF;
        for (int u = End; u != start; u = pre[u])
            Min = min(Min, cap[pre[u]][u] - flow[pre[u]][u]);
        for (int u = End; u != start; u = pre[u])
        {
            flow[pre[u]][u] += Min;
            flow[u][pre[u]] -= Min;
        }
        c += dist[End] * Min;
        f += Min;
    }
}
//************************************************************

int tmp;
int a[10000][55];
int b[10000][55];


int main()
{
    int N, M, K;
    while (~scanf(&quot;%d%d%d&quot;, &amp;N, &amp;M, &amp;K))
    {
        if (N == 0 &amp;&amp; M == 0 &amp;&amp; K == 0) break;
        memset(a, 0, sizeof(a));
        memset(b, 0, sizeof(b));

        start = 0;
        n = N + M+ 2;
        End = M + N + 1;

        int need = 0;

        for (int i = 1; i &lt;= N; i++)
        {
            for (int k = 1; k &lt;= K;k++)
            {
                scanf(&quot;%d&quot;,&amp;a[i][k]);
                need += a[i][k];
            }
        }

        for (int i = 1; i &lt;= M; i++)
        {
            for (int k = 1; k &lt;= K; k++)
            {
                scanf(&quot;%d&quot;, &amp;b[i][k]);
            }
        }

        int ans = 0;
        int res = 0;

        for (int kk = 1; kk &lt;= K; kk++)
        {
            memset(cap, 0, sizeof(cap));
            memset(cost, 0, sizeof(cost));

            for (int i = 1; i &lt;= M; i++) //源点向供应点建边
                cap[start][i] = b[i][kk];
            for(int i = 1; i &lt;= N; i++) //店主向汇点建边
                cap[M + i][End] = a[i][kk];

            for (int i = 1; i &lt;= N; i++)
                for (int j = 1; j &lt;= M; j++)
                {
                    scanf(&quot;%d&quot;, &amp;tmp);
                    cost[j][i + M] = tmp;
                    cost[i + M][j] = -tmp;
                    cap[j][i + M] = 1000000;
                }
            minCostMaxflow();
            ans += c;
            res += f;
        }

        if (res == need)
            printf(&quot;%d\n&quot;, ans);
        else
            printf(&quot;-1\n&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj 2686 Traveling by Stagecoach【状态压缩】</title>
    <url>/article/csdn/poj_2686_Traveling_by_Stagecoach%E3%80%90%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47957763" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47957763</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=2686" target="_blank" rel="noopener"> http://poj.org/problem?id=2686 </a></p>
<p>题意：<br>一个人从某个城市要到另一个城市。然后有n个马车票，相邻的两个城市走的话要消耗掉一个马车票。花费的时间是马车票上有个速率值，用边/速率就是花的时间。<br>问最后这个人花费的最短时间是多少</p>
<p>dp[i][j] 表示集合 i 车票 到 j 的最优解</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;ctime&gt;  
#include &lt;math.h&gt;  
#include &lt;limits.h&gt;  
#include &lt;complex&gt;  
#include &lt;string&gt;  
#include &lt;functional&gt;  
#include &lt;iterator&gt;  
#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;stack&gt;  
#include &lt;queue&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;list&gt;  
#include &lt;bitset&gt;  
#include &lt;sstream&gt;  
#include &lt;iomanip&gt;  
#include &lt;fstream&gt;  
#include &lt;iostream&gt;  
#include &lt;ctime&gt;  
#include &lt;cmath&gt;  
#include &lt;cstring&gt;  
#include &lt;cstdio&gt;  
#include &lt;time.h&gt;  
#include &lt;ctype.h&gt;  
#include &lt;string.h&gt;  
#include &lt;assert.h&gt;  

using namespace std;

const int inf = 1e9;
int n, m, p, a, b;
int t[100];
int g[50][50];
double dp[(1&lt;&lt;15)][50];

int main()
{
    while (~scanf(&quot;%d%d%d%d%d&quot;, &amp;n, &amp;m, &amp;p, &amp;a, &amp;b))
    {
        if (!n &amp;&amp; !m &amp;&amp; !p &amp;&amp; !a &amp;&amp; !b) break;
        for (int i = 0;i &lt; n;i++) scanf(&quot;%d&quot;,&amp;t[i]);
        for (int i = 1;i &lt;= m;i++)
            for (int j = 1;j &lt;= m;j++)
            {
                if (i == j) g[i][j] = 0;
                else g[i][j] = inf;
            }
        int u, v, w;
        while (p--)
        {
            scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);
            g[u][v] = min(g[u][v], w);
            g[v][u] = min(g[v][u], w);
        }

        for (int i = 0;i &lt; (1 &lt;&lt; n);i++)
            for (int j = 0;j &lt;= m;j++)
                dp[i][j] = inf;

        dp[0][a] = 0;
        double ans = inf;

        for (int i = 0;i &lt; (1 &lt;&lt; n);i++)
        {
            for (int u = 1;u &lt;= m;u++)
                for (int j = 0;j &lt; n;j++)
                    if (!(i &amp; (1 &lt;&lt; j)))
                    {
                        for (int v = 1;v &lt;= m;v++)
                        {
                            if (g[u][v] != inf)
                                dp[i | (1 &lt;&lt; j)][v] = min(dp[i | (1 &lt;&lt; j)][v], dp[i][u] + (double)g[u][v] / t[j]);
                        }
                    }
            ans = min(ans,dp[i][b]);
        }
        if (ans == inf) puts(&quot;Impossible&quot;);
        else printf(&quot;%.3lf\n&quot;,ans);

    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>poj</tag>
        <tag>压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>poj 2752 Seek the Name, Seek the Fame 【kmp】</title>
    <url>/article/csdn/poj_2752_Seek_the_Name,_Seek_the_Fame_%E3%80%90kmp%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46380507" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46380507</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=2752" target="_blank" rel="noopener"> http://poj.org/problem?id=2752 </a></p>
<p>题意：求即是前缀有是后缀的子串有几个，输出长度。</p>
<p>思路：考察next数组的性质。具体见代码。</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;iostream&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;ctype.h&gt;  
#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;stack&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;sstream&gt;  
#include &lt;time.h&gt;   

using namespace std;

void get_next(char x[], int m, int Next[])
{
    int i, j;
    j = Next[0] = -1;
    i = 0;
    while (i &lt; m)
    {
        while (-1 != j &amp;&amp; x[i] != x[j]) j = Next[j];
        Next[++i] = ++j;
    }
}

int Next[1001000];
char a[1000100];
int ans[1000010];

int main()
{
    int t, num;
    while (scanf(&quot;%s&quot;, a) != EOF)
    {
        num = 0;
        int n = strlen(a);
        ans[num++] = n;
        get_next(a, n, Next);
        int t = Next[n - 1];
        while (t != -1)
        {
            if (a[t] == a[n - 1]) ans[num++] = t+1;
            t = Next[t];
        }
        for (int i = num - 1; i &gt;= 0; i--)
        {
            printf(&quot;%d&quot;,ans[i]);
            if (i != 0) printf(&quot; &quot;);
            else printf(&quot;\n&quot;);
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj 2955 Brackets【区间DP】</title>
    <url>/article/csdn/poj_2955_Brackets%E3%80%90%E5%8C%BA%E9%97%B4DP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46537635" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46537635</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=2955" target="_blank" rel="noopener"> http://poj.org/problem?id=2955 </a></p>
<p>题意： <strong>求回文子串的最大长度。</strong></p>
<p>解法：枚举区间长度，更新答案。</p>
<p>代码：</p>
<pre><code> #include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

char s[110];
int dp[110][110];

int main()
{
    while (scanf(&quot;%s&quot;, s+1) != EOF)
    {
        memset(dp,0,sizeof(dp));
        if (strcmp(s+1, &quot;end&quot;) == 0) break;
        int n = strlen(s + 1);

        for (int i = 1; i &lt; n; i++)
        {
            if ((s[i] == &#39;(&#39; &amp;&amp; s[i + 1] == &#39;)&#39;) || (s[i] == &#39;[&#39; &amp;&amp; s[i + 1] == &#39;]&#39;))
                dp[i][i + 1] = 2;
        }

        for (int k = 2; k &lt;= n-1; k++)
        {
            for (int i = 1; i + k &lt;= n; i++)
            {
                if ((s[i] == &#39;(&#39; &amp;&amp; s[i + k] == &#39;)&#39;) || (s[i] == &#39;[&#39; &amp;&amp; s[i + k] == &#39;]&#39;))
                    dp[i][i + k] = dp[i + 1][i + k - 1] + 2;
                for (int j = i; j &lt;= i + k;j++)
                    dp[i][i + k] = max(dp[i][i+k],dp[i][j] + dp[j][i+k]);
            }
        }
        printf(&quot;%d\n&quot;,dp[1][n]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj 2987 Firing【最大闭合子图】</title>
    <url>/article/csdn/poj_2987_Firing%E3%80%90%E6%9C%80%E5%A4%A7%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/49103561" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/49103561</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=2987" target="_blank" rel="noopener"> http://poj.org/problem?id=2987 </a></p>
<p>最大闭合子图资料： <a href="http://blog.sina.com.cn/s/blog_48f85e1d0100mxem.html" target="_blank" rel="noopener"> http://blog.sina.com.cn/s/blog_48f85e1d0100mxem.html
</a></p>
<p>最大闭合子图权值为 ： 所有点值大于0之和 - 最大流<br>闭合子图点为s能到达的点。</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;sstream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string&gt;

using namespace std;

const long long MAXN = 50000;//点数的最大值
const long long MAXM = 610000;//边数的最大值
const long long INF = 0x3f3f3f3f;

struct Edge
{
    long long to, next;
    long long cap, flow;
}edge[MAXM];//注意是MAXM

long long tol;
long long head[MAXN];
long long gap[MAXN], dep[MAXN], pre[MAXN], cur[MAXN];

void init()
{
    tol = 0;
    memset(head, -1, sizeof(head));
}
//加边，单向图三个参数，双向图四个参数
void addedge(long long u, long long v, long long w, long long rw = 0)
{
    edge[tol].to = v; edge[tol].cap = w; edge[tol].next = head[u];
    edge[tol].flow = 0; head[u] = tol++;
    edge[tol].to = u; edge[tol].cap = rw; edge[tol].next = head[v];
    edge[tol].flow = 0; head[v] = tol++;
}
//输入参数：起点、终点、点的总数
//点的编号没有影响，只要输入点的总数

int Q[MAXN];

void BFS(long long start,long long end)
{
    memset(dep, -1, sizeof(dep));
    memset(gap, 0, sizeof(gap));
    gap[0] = 1;
    long long front = 0, rear = 0;
    dep[end] = 0;
    Q[rear++] = end;
    while (front != rear)
    {
        long long u = Q[front++];
        for (int i = head[u];i != -1;i = edge[i].next)
        {
            int v = edge[i].to;
            if (dep[v] != -1) continue;
            Q[rear++] = v;
            dep[v] = dep[u] + 1;
            gap[dep[v]]++;
        }
    }
}
long long S[MAXN];

long long sap(long long start, long long end, long long N)
{
    BFS(start, end);
    memcpy(cur, head, sizeof(head));
    long long u = start;
    long long top = 0;
    long long  ans = 0;
    while (dep[start] &lt; N)
    {
        if (u == end)
        {
            long long Min = INF;
            int inser;
            for (int i = 0; i &lt; top; i++)
                if (Min &gt; edge[S[i]].cap - edge[S[i]].flow)
                {
                    Min = edge[S[i]].cap - edge[S[i]].flow;
                    inser = i;
                }
            for (int i = 0; i &lt; top; i++)
            {
                edge[S[i]].flow += Min;
                edge[S[i] ^ 1].flow -= Min;
            }
            ans += Min;
            top = inser;
            u = edge[S[top] ^ 1].to;
            continue;
        }
        bool flag = false;
        long long v;
        for (long long i = cur[u]; i != -1; i = edge[i].next)
        {
            v = edge[i].to;
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[v] + 1 == dep[u])
            {
                flag = true;
                cur[u]  = i;
                break;
            }
        }
        if (flag)
        {
            S[top++] = cur[u];
            u = v;
            continue;
        }
        long long Min = N;
        for (int i = head[u]; i != -1; i = edge[i].next)
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min)
            {
                Min = dep[edge[i].to];
                cur[u] = i;
            }
        gap[dep[u]]--;
        if (!gap[dep[u]])return ans;
        dep[u] = Min + 1;
        gap[dep[u]]++;
        if (u != start) u = edge[S[--top]^1].to;
    }
    return ans;
}

long long n,m;
long long a[100010];
long long num;
long long vis[10010];

void dfs(int x)
{
    vis[x]=1;
    if (x!=0)
       num++;
    for(int i=head[x];i!=-1;i=edge[i].next)
    {
        if (edge[i].cap-edge[i].flow&gt;0 &amp;&amp; !vis[edge[i].to])
            dfs(edge[i].to);
    }
}

int main()
{
    while (scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m)!=EOF)
    {
        init();
        long long sum = 0;
        num=0;
        memset(vis,0,sizeof(vis));

        for(long long i=1;i&lt;=n;i++)
        {
            scanf(&quot;%lld&quot;,&amp;a[i]);
            if (a[i] &gt;0)
            {
                addedge(0,i,a[i]);
                sum+=a[i];
            }
            else
            {
                addedge(i,n+1,-a[i]);
            }
        }
        long long a,b;
        while (m--)
        {
            scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b);
            addedge(a,b,1e8);
        }

        long long ans = sap(0,n+1,n+2);
        dfs(0);
        //for(int i=0;i&lt;num;i++)
        //   printf(&quot;%d &quot;,path[i]);
        printf(&quot;%lld %lld\n&quot;,num,sum - ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj 3041 Asteroids 【匈牙利算法】</title>
    <url>/article/csdn/poj_3041_Asteroids_%E3%80%90%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46503743" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46503743</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=3041" target="_blank" rel="noopener"> http://poj.org/problem?id=3041 </a></p>
<p>题意：n*n矩阵上有行星，每次只能在一行或一列放一发子弹，消灭本行或列的所有行星，求消灭所有行星的最小消耗子弹数目。</p>
<p>解法：二分图，行为一个顶点集，列为另一顶点集。题目转化成为选择最少的一些点(x或y)，使得从这些点与所有的边相邻，其实这就是最小点覆盖问题。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int p[510][510];
int n;
int k;
int a,b;

int book[510];
int match[510];

bool dfs(int u)
{
    for (int i = 1; i &lt;= n; i++)
    {
        if (book[i] == 0 &amp;&amp; p[u][i] == 1)
        {
            book[i] = 1;
            if (match[i] == 0 || dfs(match[i]))
            {
                match[i] = u;
                return true;
            }
        }
    }
    return false;
}

int main()
{
    while (scanf(&quot;%d%d&quot;,&amp;n,&amp;k)!=EOF)
    {
        memset(p,0,sizeof(p));
        memset(match,0,sizeof(match));
        while(k--)
        {
            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
            p[a][b] = 1;
        }
        int ans = 0;
        for(int i=1;i&lt;=n;i++)
        {
            memset(book, 0, sizeof(book));
            if (dfs(i))
                ans++;
        }
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj 3070 Fibonacci 【矩阵快速幂】</title>
    <url>/article/csdn/poj_3070_Fibonacci_%E3%80%90%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44554327" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44554327</a></p>
<p>Fibonacci<br>Time Limit: 1000MS Memory Limit: 65536K<br>Total Submissions: 10072 Accepted: 7191<br>Description</p>
<p>In the Fibonacci integer sequence, F0 = 0, F1 = 1, and Fn = Fn − 1 + Fn − 2<br>for n ≥ 2. For example, the first ten terms of the Fibonacci sequence are:</p>
<p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, …</p>
<p>An alternative formula for the Fibonacci sequence is</p>
<p>.</p>
<p>Given an integer n, your goal is to compute the last 4 digits of Fn.</p>
<p>Input</p>
<p>The input test file will contain multiple test cases. Each test case consists<br>of a single line containing n (where 0 ≤ n ≤ 1,000,000,000). The end-of-file<br>is denoted by a single line containing the number −1.</p>
<p>Output</p>
<p>For each test case, print the last four digits of Fn. If the last four digits<br>of Fn are all zeros, print ‘0’; otherwise, omit any leading zeros (i.e., print<br>Fn mod 10000).</p>
<p>Sample Input</p>
<p>0<br>9<br>999999999<br>1000000000<br>-1<br>Sample Output</p>
<p>0<br>34<br>626<br>6875<br>Hint</p>
<p>As a reminder, matrix multiplication is associative, and the product of two 2<br>× 2 matrices is given by</p>
<p>.</p>
<p>Also, note that raising any 2 × 2 matrix to the 0th power gives the identity<br>matrix:</p>
<p>.</p>
<p>Source</p>
<p>Stanford Local 2006</p>
<p>做的第一道矩阵，先从别人那里盗个模板。。<br>矩阵快速幂用来计算矩阵的n次方的。将时间复杂度降到log（n），原理和快速幂类似，二分的思想（想不到当年学的线性代数用到了，orz）；主要在于构造矩阵；</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;

using namespace std;

const int MOD = 10000;

struct node
{
    int m[2][2];
}ans,base;

int n;

node multi(node a,node b)
{
    node tmp;
    for(int i=0;i&lt;2;i++)
        for(int j=0;j&lt;2;j++)
    {
        tmp.m[i][j] = 0;
        for(int k=0;k&lt;2;k++)
        {
            tmp.m[i][j] +=(a.m[i][k] * b.m[k][j]);
            tmp.m[i][j] %= MOD;
        }
    }
    return tmp;
}

int fast_mod(int n)// 求矩阵 base 的  n 次幂 
{
    base.m[0][0] = base.m[0][1] = base.m[1][0] = 1;
    base.m[1][1] = 0;
    ans.m[0][0] = ans.m[1][1] = 1;// ans 初始化为单位矩阵
    ans.m[0][1] = ans.m[1][0] = 0;
    while (n)
    {
        if (n&amp;1) //实现 ans *= t; 其中要先把 ans赋值给 tmp，然后用 ans = tmp * t 
            ans = multi(ans,base);
        base = multi(base,base);
        n&gt;&gt;=1;
    }
    return ans.m[0][1];
}

int main()
{
    while (scanf(&quot;%d&quot;,&amp;n)!=EOF)
    {
        if (n == -1)
            break;
        int ans = fast_mod(n);
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj 3276 Face The Right Way【开关问题】</title>
    <url>/article/csdn/poj_3276_Face_The_Right_Way%E3%80%90%E5%BC%80%E5%85%B3%E9%97%AE%E9%A2%98%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46380525" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46380525</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=3276" target="_blank" rel="noopener"> http://poj.org/problem?id=3276 </a></p>
<p>题意：给你n头牛，要求你选择一个数k，使得每次只能翻转连续K个数，使得牛的脸都朝向前面且需要翻转的次数最少。</p>
<p>思路：vis[i]记录i是否翻转。则vis[i-k+1] + vis[i-k+2] +….+vis[i-1] 为 i<br>的前k个数的翻转次数，由于每次翻转都会导致i翻转。若和为奇数，则相当于 i 翻转了一次 ，偶数则为 i 未翻转。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;
#include &lt;set&gt;

using namespace std;

const int MAXN = 5010;
const int inf = 100000000;

int n;
char c;
int p[MAXN];
int vis[MAXN];

int solve(int k)
{
    int res = 0;
    int sum = 0;
    memset(vis, 0, sizeof(vis));

    for (int i = 0; i + k &lt;= n; i++)
    {
        if ((sum + p[i]) % 2 != 0)
        {
            res++;
            vis[i] = 1;
        }
        sum += vis[i];
        if (i - k + 1 &gt;= 0)
            sum -= vis[i - k + 1];
    }

    for (int i = n - k + 1; i&lt;n; i++)
    {
        if ((sum + p[i]) % 2 != 0)
            return -1;
        if (i - k + 1 &gt;= 0)
            sum -= vis[i - k + 1];
    }
    return res;
}

int main()
{
    while (scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        bool ok = false;
        getchar();
        for (int i = 0; i&lt;n; i++)
        {
            scanf(&quot;%c&quot;, &amp;c);
            if (c == &#39;F&#39;)
                p[i] = 0;
            else
            {
                p[i] = 1;
                ok = true;
            }
            getchar();
        }
        if (!ok)
        {
            printf(&quot;0 0\n&quot;);
            continue;
        }
        int ans = inf;
        int pos = 1;
        for (int k = 1; k &lt;= n; k++)
        {
            int tmp = solve(k);
            if (tmp &lt; ans &amp;&amp; tmp &gt;= 0)
            {
                ans = tmp;
                pos = k;
            }
        }
        printf(&quot;%d %d\n&quot;, pos, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj 3280 Cheapest Palindrome【区间DP】</title>
    <url>/article/csdn/poj_3280_Cheapest_Palindrome%E3%80%90%E5%8C%BA%E9%97%B4DP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/49003459" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/49003459</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=3280" target="_blank" rel="noopener"> http://poj.org/problem?id=3280 </a></p>
<p>题意：<br>给你一个字符串以及添加和删除每个字符的代价，求使得原串变为回文串的最小的代价。</p>
<p>解法：<br>dp[i][j]表示使得i到j变为回文的最小代价。<br>dp[i][j] =<br>min(dp[i+1][j]+add[i],dp[i+1][j]+del[i],dp[i][j-1]+add[j],dp[i][j-1]+del[j])<br>如果i j 相同 dp[i][j] = min(dp[i][j],dp[i+1][j-1]);</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;malloc.h&gt;

using namespace std;

int n, m;
char s[5010];

struct Node
{
    int add;
    int es;
}a[100];

int dp[3010][3010];

int main()
{
    while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)
    {
        scanf(&quot;%s&quot;, s + 1);
        char c[5];
        int u, v;

        memset(dp, 0, sizeof(dp));

        for (int i = 1;i &lt;= n;i++)
        {
            cin &gt;&gt; c &gt;&gt; u &gt;&gt; v;;
            a[c[0] - &#39;a&#39;].add = u;
            a[c[0] - &#39;a&#39;].es = v;
        }
        for (int i = m - 1;i &gt;= 1;i--)
        {
            for (int j = i;j &lt;= m;j++)
            {
                dp[i][j] = min(dp[i + 1][j] + a[s[i] - &#39;a&#39;].add, dp[i + 1][j] + a[s[i] - &#39;a&#39;].es);
                int tmp = min(dp[i][j - 1] + a[s[j] - &#39;a&#39;].add, dp[i][j - 1] + a[s[j] - &#39;a&#39;].es);
                dp[i][j] = min(dp[i][j], tmp);
                if (s[i] == s[j])
                    dp[i][j] = min(dp[i][j], dp[i + 1][j - 1]);
            }
        }
        printf(&quot;%d\n&quot;, dp[1][m]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title>poj 3320 Jessica’s Reading Problem 【尺取法】</title>
    <url>/article/csdn/poj_3320_Jessica%E2%80%99s_Reading_Problem_%E3%80%90%E5%B0%BA%E5%8F%96%E6%B3%95%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46380533" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46380533</a></p>
<p>题目：链接： <a href="http://poj.org/problem?id=3320" target="_blank" rel="noopener"> http://poj.org/problem?id=3320 </a></p>
<p>题意：求最短的连续区间使得全部的知识点都学到；</p>
<p>尺取法，不断推进区间的起点和终点，求解。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;string&gt;
#include &lt;map&gt;

using namespace std;

int n;
int p[1000010];

int main()
{
    while(scanf(&quot;%d&quot;, &amp;n)!=EOF)
    {
        set&lt;int&gt; SET;
        map&lt;int, int&gt; MAP;

        for (int i = 0; i &lt; n; i++)
            scanf(&quot;%d&quot;, &amp;p[i]);
        for (int i = 0; i &lt; n; i++)
            SET.insert(p[i]);

        int len = SET.size();
        int ans = n;
        int s , t , sum;
        s = t = sum = 0;
        while (1)
        {
            while (t &lt; n &amp;&amp; sum &lt; len)
            {
                if (MAP[p[t++]]++ == 0)
                    sum++;
            }
            if (sum &lt; len) break;
            ans = min(ans,t-s);
            if (--MAP[p[s++]] == 0)
                sum--;
        }
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj 3281 Dining 【最大流】</title>
    <url>/article/csdn/poj_3281_Dining_%E3%80%90%E6%9C%80%E5%A4%A7%E6%B5%81%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47340833" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47340833</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=3281" target="_blank" rel="noopener"> http://poj.org/problem?id=3281 </a></p>
<p>题意：<br>给出牛n，饮料d还有食物f的数量，每头牛给出喜欢的饮料和食物，最后求出能够满足的牛的数量</p>
<p>解法：源点到食物建边， 由食物到牛建边， 牛到饮料建边 ，饮料到汇点建边 ，求最大流。牛要拆点控制流量为1</p>
<p>全部是有向的边,而且权值全部为1<br>有2<em>n+f+d+2个顶点<br>0表示源点,2</em>n+f+d+1表示汇点<br>1到f为食物点，f+1到f+2<em>n为牛点，f+2</em>n+1到f+2*n+d为饮料点<br>代码：</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;ctime&gt;  
#include &lt;math.h&gt;  
#include &lt;limits.h&gt;  
#include &lt;complex&gt;  
#include &lt;string&gt;  
#include &lt;functional&gt;  
#include &lt;iterator&gt;  
#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;stack&gt;  
#include &lt;queue&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;list&gt;  
#include &lt;bitset&gt;  
#include &lt;sstream&gt;  
#include &lt;iomanip&gt;  
#include &lt;fstream&gt;  
#include &lt;iostream&gt;  
#include &lt;ctime&gt;  
#include &lt;cmath&gt;  
#include &lt;cstring&gt;  
#include &lt;cstdio&gt;  
#include &lt;time.h&gt;  
#include &lt;ctype.h&gt;  
#include &lt;string.h&gt;  
#include &lt;assert.h&gt;  
#pragma comment (linker, &quot;/STACK:102400000,102400000&quot;)

using namespace std;

const int MAXN = 1010;//点数的最大值
const int MAXM = 400010;//边数的最大值
const int INF = 0x3f3f3f3f;
struct Edge
{
    int to, next, cap, flow;
}edge[MAXM];//注意是MAXM
int tol;
int head[MAXN];
int gap[MAXN], dep[MAXN], pre[MAXN], cur[MAXN];

void init()
{
    tol = 0;
    memset(head, -1, sizeof(head));
}
//加边，单向图三个参数，双向图四个参数
void addedge(int u, int v, int w, int rw = 0)
{
    edge[tol].to = v; edge[tol].cap = w; edge[tol].next = head[u];
    edge[tol].flow = 0; head[u] = tol++;
    edge[tol].to = u; edge[tol].cap = rw; edge[tol].next = head[v];
    edge[tol].flow = 0; head[v] = tol++;
}

//输入参数：起点、终点、点的总数
//点的编号没有影响，只要输入点的总数

int sap(int start, int end, int N)
{
    memset(gap, 0, sizeof(gap));
    memset(dep, 0, sizeof(dep));
    memcpy(cur, head, sizeof(head));
    int u = start;
    pre[u] = -1;
    gap[0] = N;
    int ans = 0;
    while (dep[start] &lt; N)
    {
        if (u == end)
        {
            int Min = INF;
            for (int i = pre[u]; i != -1; i = pre[edge[i ^ 1].to])
                if (Min &gt; edge[i].cap - edge[i].flow)
                    Min = edge[i].cap - edge[i].flow;
            for (int i = pre[u]; i != -1; i = pre[edge[i ^ 1].to])
            {
                edge[i].flow += Min;
                edge[i ^ 1].flow -= Min;
            }
            u = start;
            ans += Min;
            continue;
        }
        bool flag = false;
        int v;
        for (int i = cur[u]; i != -1; i = edge[i].next)
        {
            v = edge[i].to;
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[v] + 1 == dep[u])
            {
                flag = true;
                cur[u] = pre[v] = i;
                break;
            }
        }
        if (flag)
        {
            u = v;
            continue;
        }
        int Min = N;
        for (int i = head[u]; i != -1; i = edge[i].next)
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min)
            {
                Min = dep[edge[i].to];
                cur[u] = i;
            }
        gap[dep[u]]--;
        if (!gap[dep[u]])return ans;
        dep[u] = Min + 1;
        gap[dep[u]]++;
        if (u != start) u = edge[pre[u] ^ 1].to;
    }
    return ans;
}

int m, n, f, d, x, y;
int a, b, c;

int main()
{
    while (scanf(&quot;%d%d%d&quot;, &amp;n, &amp;f, &amp;d) != EOF)
    {
        init();
        int tmp = f + 2*n;
        int so = 0;//源点
        int to = f + n * 2 + d + 1;//汇点
        int tot = f + n * 2 + d + 2;

        for (int i = 1; i &lt;= f; i++)//源点指向食物
            addedge(so, i, 1);
        for (int i = 1; i &lt;= d; i++)//饮料指向汇点
            addedge(tmp + i , to, 1);
        for (int i = 1; i &lt;= n; i++)//牛指向牛
            addedge(f + i, f + n + i, 1);

        for (int i = 1; i &lt;= n;i++)
        {
            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
            while (x--)
            {
                scanf(&quot;%d&quot;,&amp;m);
                addedge(m, f + i, 1);
            }
            while (y--)
            {
                scanf(&quot;%d&quot;, &amp;m);
                addedge(f + n + i, 2*n + f + m, 1);
            }
        }
        int ans = sap(so,to, tot);
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj 3666 Making the Grade 【dp】</title>
    <url>/article/csdn/poj_3666_Making_the_Grade_%E3%80%90dp%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47008443" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47008443</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=3666" target="_blank" rel="noopener"> http://poj.org/problem?id=3666 </a></p>
<p>题意：使得一个序列变为递增或递减序列的最小代价。代价为题中给的公式。</p>
<p>解法：dp[i][j]表示前i个数，以num[j]为末尾的最小代价。<br>更新的时候枚举 j<br>转移状态：</p>
<pre><code>for (int i = 2; i &lt;= n; i++)
        {
            int t = inf;
            for (int j = 1; j &lt;= n; j++)
            {
                t = min(t,dp[i-1][j]);
                dp[i][j] = t + abs(a[i] - num[j]);
            }
        }
</code></pre><p>最后只要遍历 dp [ n ] [ k ] ，其中 k 为 1 到 n ，表示的是用 num[1 ~n] 中的一个数作为单调的结尾的最小花费。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

const int inf = 1e9 + 7;
int n;
int a[2010], num[2010];
int dp[2010][2010];

int main()
{
    while (scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        for (int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;, &amp;a[i]);
            num[i] = a[i];
        }
        sort(num + 1, num + 1 + n);
        memset(dp, 0, sizeof(dp));

        for (int i = 2; i &lt;= n; i++)
        {
            int t = inf;
            for (int j = 1; j &lt;= n; j++)
            {
                t = min(t,dp[i-1][j]);
                dp[i][j] = t + abs(a[i] - num[j]);
            }
        }
        int ans = inf;
        for (int i = 1; i &lt;= n; i++)
            ans = min(ans,dp[n][i]);
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj 3687 Labeling Balls 【拓扑排序】</title>
    <url>/article/csdn/poj_3687_Labeling_Balls_%E3%80%90%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47983237" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47983237</a></p>
<p>题目链接： <a href="http://poj.org/problem?id=3687" target="_blank" rel="noopener"> http://poj.org/problem?id=3687 </a></p>
<p>注意重边</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;ctime&gt;  
#include &lt;math.h&gt;  
#include &lt;limits.h&gt;  
#include &lt;complex&gt;  
#include &lt;string&gt;  
#include &lt;functional&gt;  
#include &lt;iterator&gt;  
#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;stack&gt;  
#include &lt;queue&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;list&gt;  
#include &lt;bitset&gt;  
#include &lt;sstream&gt;  
#include &lt;iomanip&gt;  
#include &lt;fstream&gt;  
#include &lt;iostream&gt;  
#include &lt;ctime&gt;  
#include &lt;cmath&gt;  
#include &lt;cstring&gt;  
#include &lt;cstdio&gt;  
#include &lt;time.h&gt;  
#include &lt;ctype.h&gt;  
#include &lt;string.h&gt;  
#include &lt;assert.h&gt;  

using namespace std;

int in[210];
int is[210][210];
int ans[210];
int n, m;

int main()
{
    int t;
    int n, m;
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    {
        memset(in, 0, sizeof(in));
        memset(is, 0, sizeof(is));
        memset(ans, 0, sizeof(ans));

        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        int ok = 1;
        int a, b;
        while (m--)
        {
            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
            if (a == b) ok = 0;
            if (is[a][b] == 1) ok = 0;
            if (is[b][a] == 0) in[a]++;
            is[b][a] = 1;
        }
        int num = 1;
        int cnt = 0;
        if (!ok) puts(&quot;-1&quot;);
        else
        {
            for (int k = n;k &gt;= 1 ;k--)
            {
                int i = n;
                while (in[i] != 0 &amp;&amp; i&gt;=1) i--;
                in[i] = -1;ans[i] = k;

                if (i &gt;= 1) cnt++;

                for (int j = 1;j &lt;= n;j++)
                {
                    if (is[i][j])
                        in[j]--;
                }
            }
            if (cnt != n) puts(&quot;-1&quot;);
            else
            {
                for (int i = 1;i &lt; n;i++)
                    printf(&quot;%d &quot;, ans[i]);
                printf(&quot;%d\n&quot;, ans[n]);
            }
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>poj 3734 Blocks 【矩阵快速幂】</title>
    <url>/article/csdn/poj_3734_Blocks_%E3%80%90%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44724359" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44724359</a></p>
<p>Blocks<br>Time Limit: 1000MS Memory Limit: 65536K<br>Total Submissions: 4529 Accepted: 2044<br>Description</p>
<p>Panda has received an assignment of painting a line of blocks. Since Panda is<br>such an intelligent boy, he starts to think of a math problem of painting.<br>Suppose there are N blocks in a line and each block can be paint red, blue,<br>green or yellow. For some myterious reasons, Panda want both the number of red<br>blocks and green blocks to be even numbers. Under such conditions, Panda wants<br>to know the number of different ways to paint these blocks.</p>
<p>Input</p>
<p>The first line of the input contains an integer T(1≤T≤100), the number of test<br>cases. Each of the next T lines contains an integer N(1≤N≤10^9) indicating the<br>number of blocks.</p>
<p>Output</p>
<p>For each test cases, output the number of ways to paint the blocks in a single<br>line. Since the answer may be quite large, you have to module it by 10007.</p>
<p>Sample Input</p>
<p>2<br>1<br>2<br>Sample Output</p>
<p>2<br>6<br>Source</p>
<p>PKU Campus 2009 (POJ Monthly Contest – 2009.05.17), Simon</p>
<p>思路：<br>假设染色第i个方块时，红绿都为偶数方案数ai ，一个奇数一个偶数方案bi，均为奇数方案ci;<br>则 ai+1 = 2<em>ai + bi;<br>bi+1 = 2</em>ai + 2<em>bi+2</em>ci;<br>ci+1 = 2*ci + bi;<br>所以可构造矩阵：<br>2 1 0<br>2 2 2<br>0 1 2</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;

using namespace std;

const long long MOD = 10007;

struct node
{
    long long m[3][3];
}ans, base;
long long a, b;

node multi(node a, node b)
{
    node tmp;
    for (int i = 0; i&lt;3; i++)
        for (int j = 0; j&lt;3; j++)
        {
            tmp.m[i][j] = 0;
            for (int k = 0; k&lt;3; k++)
            {
                tmp.m[i][j] = ((tmp.m[i][j] + a.m[i][k] * b.m[k][j]) % MOD + MOD) % MOD;
            }
        }
    return tmp;
}

void fast_mod(int n)// 求矩阵 base 的  n 次幂
{
    base.m[0][0] = 2; base.m[0][1]=1; base.m[0][2] = 0;
    base.m[1][0] = 2; base.m[1][1]=2; base.m[1][2] = 2;
    base.m[2][0] = 0; base.m[2][1]=1; base.m[2][2] = 2;
    memset(ans.m,0,sizeof(ans.m));
    ans.m[0][0] = ans.m[1][1] = 1; ans.m[2][2] = 1;// ans 初始化为单位矩阵
    while (n)
    {
        if (n &amp; 1) //实现 ans *= t; 其中要先把 ans赋值给 tmp，然后用 ans = tmp * t
            ans = multi(ans, base);
        base = multi(base, base);
        n &gt;&gt;= 1;
    }
}

int t;
int n;

int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%d&quot;,&amp;n);
        fast_mod(n);
        long long anss = ((ans.m[0][0] % MOD) + MOD) % MOD;
        printf(&quot;%lld\n&quot;, anss);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>sizeof 计算原则</title>
    <url>/article/csdn/sizeof_%E8%AE%A1%E7%AE%97%E5%8E%9F%E5%88%99.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/50829983" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/50829983</a></p>
<h2><span id="sizeof计算类大小的一些基本原则">sizeof()计算类大小的一些基本原则：</span></h2><pre><code>   (1)类的大小为类的非静态成员数据的类型大小之和，也就是说静态成员数据不作考虑；

   (2)类的总大小也遵守类似class字节对齐的，调整规则；(参考５分钟搞定内存字节对齐)

   (3)成员函数都是不会被计算的；

   (4)如果是子类，那么父类中的成员也会被计算；

   (5)虚函数由于要维护虚函数表，所以要占据一个指针大小，也就是4字节。
</code></pre><p>总结即：一个类中，虚函数、成员函数（包括静态与非静态）和静态数据成员都不占用类对象的存储空间。</p>
<p>当我们声明该类型的实例时，必须在内存中占有一定得空间，否则无法使用这些实例。至于占多少内存，由编译器决定。在Visual<br>Studio中，每个空类型的实例占用1字节的空间。</p>
<h2><span id="例子">例子：</span></h2><pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

using namespace std;

class A
{

};

class B
{
public:
    int x;
};

class C
{
    static int x;
};

class D
{
    static int x() {};
};

class E
{
    virtual int x() {};
};

class F
{
    int x() {};
};

int main()
{
    cout &lt;&lt; sizeof(A) &lt;&lt; endl;
    cout &lt;&lt; sizeof(B) &lt;&lt; endl;
    cout &lt;&lt; sizeof(C) &lt;&lt; endl;
    cout &lt;&lt; sizeof(D) &lt;&lt; endl;
    cout &lt;&lt; sizeof(E) &lt;&lt; endl;
    cout &lt;&lt; sizeof(F) &lt;&lt; endl;
    return 0;
}
/*
输出：
1
4
1
1
4
1
*/
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>stl reverse 函数</title>
    <url>/article/csdn/stl_reverse_%E5%87%BD%E6%95%B0.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43485327" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43485327</a></p>
<p>功能：翻转字符串 ，翻转数组， 用于STL的翻转。</p>
<p>头文件： <algorithm></algorithm></p>
<p>例子：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;string&gt;
#include&lt;sstream&gt;

using namespace std;

char s[100];
int p[1000];

int main()
{
    cin &gt;&gt; s;
    cout &lt;&lt; s &lt;&lt; endl;
    for (int i = 1; i &lt;= 5; i++)
        cin &gt;&gt; p[i];
    for (int i = 1; i &lt;= 5; i++)
        cout &lt;&lt; p[i] &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;
    reverse(s,s+5);
    cout &lt;&lt; s &lt;&lt; endl;
    reverse(p+1,p+6);
    for (int i = 1; i &lt;= 5; i++)
        cout &lt;&lt; p[i] &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;

}
</code></pre><p><img src="https://img-
blog.csdn.net/20150204134901546?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQyNzE5Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>stl 之 优先队列</title>
    <url>/article/csdn/stl_%E4%B9%8B_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41186101" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41186101</a></p>
<p>priority_queue特别之处在于，允许用户为队列中存储的元素设置优先级。这种队列不是直接将新元素放置在队列尾部，而是放在比它优先级低的元素前面。标准库默认使用&lt;操作符来确定对象之间的优先级关系，所以如果要使用自定义对象，需要重载<br>&lt; 操作符。</p>
<p>优先队列有两种，一种是最大优先队列；一种是最小优先队列；每次取自队列的第一个元素分别是优先级最大和优先级最小的元素。  </p>
<p>1) 优先队列的定义</p>
<p>包含头文件：”queue.h”, “functional.h”</p>
<p>可以使用具有默认优先级的已有数据结构；也可以再定义优先队列的时候传入自定义的优先级比较对象；或者使用自定义对象(数据结构)，但是必须重载好&lt; 操作符。</p>
<p>2) 优先队列的常用操作</p>
<h2><span id="优先级队列支持的操作">优先级队列支持的操作  </span></h2><p>q.empty()         如果队列为空，则返回true，否则返回false</p>
<p>q.size()            返回队列中元素的个数</p>
<p>q.pop()             删除队首元素，但不返回其值</p>
<p>q.top()             返回具有最高优先级的元素值，但不删除该元素</p>
<p>q.push(item)     在基于优先级的适当位置插入新元素</p>
<p>其中q.top()为查找操作，在最小优先队列中搜索优先权最小的元素，在最大优先队列中搜索优先权最大的元素。q.pop()为删除该元素。优先队列插入和删除元素的复杂度都是O(lgn)，所以很快</p>
<p>下面为一些基本操作：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt;
#include&lt;malloc.h&gt;
#include&lt;stdexcept&gt;

using namespace std;

int a[10];;

struct cmp1
{
    bool operator() (int &amp;a ,int &amp;b)
    {
        return a &lt; b;//最大值优先
    }
};

struct cmp2
{
    bool operator() (int &amp;a,int &amp;b)
    {
        return a &gt; b;//最小值优先
    }
};

struct number1
{
    int x ;
    bool operator() ( const number1 &amp;a  )const
    {
        return x &gt; a.x;//最小值优先
    }
};

struct number2
{
    int x ;
    bool operator() ( const number2 &amp;a )const
    {
        return x &lt; a.x;//最大值优先
    }
};

int main ()
{
    priority_queue&lt;int&gt;q;//默认最大值优先
    //priority_queue&lt;int,vector&lt;int&gt;,cmp1&gt;q;
    //priority_queue&lt;int,vector&lt;int&gt;,cmp2&gt;q;
    //priority_queue&lt;number1&gt;q;
    //priority_queue&lt;number2&gt;q;
    //priority_queue&lt; int ,vector&lt;int&gt;,greater&lt;int &gt; &gt;q;
    //priority_queue&lt; int,vector&lt;int&gt;,less&lt;int&gt; &gt;q;

    for(int i=1 ;i&lt;=5 ;i++)
        cin&gt;&gt;a[i];

    for (int i=1 ;i&lt;=5 ;i++)
    {
        q.push(a[i]);
    }

    cout&lt;&lt;q.size()&lt;&lt;endl;

    while ( !q.empty() )
    {
        int t = q.top();
        q.pop();
        cout&lt;&lt;t&lt;&lt;&quot; &quot;;
    }
    cout&lt;&lt;endl;

    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>unique 函数 c++</title>
    <url>/article/csdn/unique_%E5%87%BD%E6%95%B0_c++.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47123227" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47123227</a></p>
<p>一 unique函数<br>作用：从序列中“删除”所有相邻的重复元素。<br>既然是删除相邻的重复元素，所以要保证序列有序，用之前要把序列排序，调用sort（）函数。</p>
<p>在STL中unique函数是一个去重函数，<br>unique的功能是去除相邻的重复元素(只保留一个),其实它并不真正把重复的元素删除，是把重复的元素移到后面去了，然后依然保存到了原数组中，然后<br>返回去重后最后一个元素的地址。</p>
<p>注意，num的大小并没有改变，依然保存着5个元素；只是这些元素的顺序改变了。调用unique“删除”了相邻的重复值。给“删除”加上引号是因为unique实际上并没有删除任何元素，而是将无重复的元素复制到序列的前段，从而覆盖相邻的重复元素。unique返回的迭代器指向超出无重复的元素范围末端的下一个位置。</p>
<p>注意：算法不直接修改容器的大小。如果需要添加或删除元素，则必须使用容器操作。<br>erase（）函数用来删除元素。</p>
<p>demo:</p>
<pre><code>int main()
{
    int num[110];
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;i&lt;n;i++)
        scanf(&quot;%d&quot;,&amp;num[i]);
    sort(num,num+n);

    printf(&quot;after sort:\n&quot;);
    for(int i=0;i&lt;n;i++)
        printf(&quot;%d &quot;,num[i]); printf(&quot;\n&quot;);

    vector&lt;int&gt; vec; vec.clear();
    for(int i=0;i&lt;n;i++) vec.push_back(num[i]);
    vector&lt;int&gt;::iterator it,it1;
    it = unique(vec.begin(),vec.end());

    unique(num,num+n);
    printf(&quot;after use unique:\n&quot;);
    for(int i=0;i&lt;n;i++)
        printf(&quot;%d &quot;,num[i]); printf(&quot;\n&quot;);


    printf(&quot;after erase:\n&quot;);
    vec.erase(it,vec.end());
    for(it1 = vec.begin();it1 !=vec.end();it1++)
       cout&lt;&lt;*it1 &lt;&lt;&quot; &quot;;cout&lt;&lt;endl;

    return 0;
}
</code></pre><p>运行结果：<br><img src="https://img-blog.csdn.net/20150729101755196" alt="这里写图片描述"></p>
<p>erase函数的原型如下：<br>（1）string&amp; erase ( size_t pos = 0, size_t n = npos );<br>（2）iterator erase ( iterator position );<br>（3）iterator erase ( iterator first, iterator last );<br>也就是说有三种用法：<br>（1）erase(pos,n); 删除从pos开始的n个字符，比如erase(0,1)就是删除第一个字符<br>（2）erase(position);删除position处的一个字符(position是个string类型的迭代器)<br>（3）erase(first,last);删除从first到last之间的字符（first和last都是迭代器）</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>uva-11624 Fire!</title>
    <url>/article/csdn/uva-11624_Fire!.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/42275651" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/42275651</a></p>
<h2><span id=""> </span></h2><h2><span id="problem-b-fire">Problem B: Fire!</span></h2><p><img src="http://uva.onlinejudge.org/external/116/p11624.png" alt=""> Joe works in a maze.<br>Unfortunately, portions of the maze have caught on fire, and the owner of the<br>maze neglected to create a fire escape plan. Help Joe escape the maze.</p>
<p>Given Joe’s location in the maze and which squares of the maze are on fire,<br>you must determine whether Joe can exit the maze before the fire reaches him,<br>and how fast he can do it.</p>
<p>Joe and the fire each move one square per minute, vertically or horizontally<br>(not diagonally). The fire spreads all four directions from each square that<br>is on fire. Joe may exit the maze from any square that borders the edge of the<br>maze. Neither Joe nor the fire may enter a square that is occupied by a wall.</p>
<h3><span id="input-specification">Input Specification</span></h3><p>The first line of input contains a single integer, the number of test cases to<br>follow. The first line of each test case contains the two integers  R  and  C<br>, separated by spaces, with 1 &lt;=  R  ,  C  &lt;= 1000. The following  R  lines<br>of the test case each contain one row of the maze. Each of these lines<br>contains exactly  C  characters, and each of these characters is one of:</p>
<ul>
<li><code>#</code> , a wall </li>
<li><code>.</code> , a passable square </li>
<li><code>J</code> , Joe’s initial position in the maze, which is a passable square </li>
<li><code>F</code> , a square that is on fire </li>
</ul>
<p>There will be exactly one  <code>J</code> in each test case.</p>
<h3><span id="sample-input">Sample Input</span></h3><pre><code>2
4 4
####
#JF#
#..#
#..#
3 3
###
#J.
#.F
</code></pre><h3><span id="output-specification">Output Specification</span></h3><p>For each test case, output a single line containing  <code>IMPOSSIBLE</code> if Joe<br>cannot exit the maze before the fire reaches him, or an integer giving the<br>earliest time Joe can safely exit the maze, in minutes.</p>
<h3><span id="output-for-sample-input">Output for Sample Input</span></h3><pre><code>3
IMPOSSIBLE





//3
#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt;
#include&lt;malloc.h&gt;
#define MAX 1010
using namespace std;

int n,m;
int t;

int dir[4][2] = {{1,0}, {-1,0}, {0,1}, {0,-1}};

char p[MAX][MAX];

int check(int x, int y)
{
    if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m)
        return 1;
    return 0;
}

int a[MAX][MAX];
queue&lt;pair&lt;int,int&gt; &gt; q;

void bfs1()
{
    while (!q.empty())
        q.pop();
    memset(a,-1,sizeof(a));
    for (int i = 0; i &lt; n; i++)
        for (int j = 0; j &lt; m; j++)
        {
            if (p[i][j] == &#39;F&#39;)
            {
                a[i][j] = 0;
                q.push(make_pair(i,j));
            }
        }

    while (!q.empty())
    {
        pair&lt;int, int&gt; tmp;
        tmp = q.front();
        q.pop();

        for (int i = 0; i &lt; 4; i++)
        {
            int x = tmp.first + dir[i][0];
            int y = tmp.second + dir[i][1];
            if ( check(x, y) == 0 || a[x][y] != -1 || p[x][y] == &#39;#&#39;)
                continue;
            a[x][y] = a[tmp.first][tmp.second] + 1;
            q.push(make_pair(x,y));
        }
    }
}

int b[MAX][MAX]; 

void bfs()
{
    while (!q.empty())
        q.pop();

    memset(b,-1,sizeof(b));
    for (int i = 0; i &lt; n; i++)
        for (int j = 0; j &lt; m; j++)
        {
            if (p[i][j] == &#39;J&#39;)
            {
                q.push(make_pair(i, j));
                b[i][j] = 0;
                break;
            }
        }

    while (!q.empty())
    {
        pair&lt;int,int&gt; tmp;
        tmp = q.front();
        q.pop();

        if ( tmp.first == 0 || tmp.first == n-1 || tmp.second == 0 || tmp.second == m-1)
        {
            printf(&quot;%d\n&quot;,b[tmp.first][tmp.second] + 1);
            return;
        }

        for (int i = 0; i &lt; 4; i++)
        {
            int x = tmp.first + dir[i][0];
            int y = tmp.second + dir[i][1];
            if (check(x, y) == 0 || b[x][y]!=-1 || p[x][y] == &#39;#&#39;)
                continue;
            if (a[x][y] != -1 &amp;&amp; b[tmp.first][tmp.second] + 1 &gt;= a[x][y])
                continue;

            b[x][y] = b[tmp.first][tmp.second] + 1;
            q.push(make_pair(x, y));
        }
    }

    printf(&quot;IMPOSSIBLE\n&quot;);
    return;
}

int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
        for (int i = 0; i &lt; n; i++)
            scanf(&quot;%s&quot;,p[i]);

        bfs1();
        bfs();

    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>uva 10305  Ordering Tasks 【拓扑排序】</title>
    <url>/article/csdn/uva_10305_Ordering_Tasks_%E3%80%90%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44705271" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44705271</a></p>
<p>10305 Ordering Tasks<br>John has n tasks to do. Unfortunately, the tasks are not independent and the<br>execution of one task is<br>only possible if other tasks have already been executed.<br>Input<br>The input will consist of several instances of the problem. Each instance<br>begins with a line containing<br>two integers, 1 ≤ n ≤ 100 and m. n is the number of tasks (numbered from 1 to<br>n) and m is the<br>number of direct precedence relations between tasks. After this, there will be<br>m lines with two integers<br>i and j, representing the fact that task i must be executed before task j.<br>An instance with n = m = 0 will finish the input.<br>Output<br>For each instance, print a line with n integers representing the tasks in a<br>possible order of execution.<br>Sample Input<br>5 4<br>1 2<br>2 3<br>1 3<br>1 5<br>0 0<br>Sample Output<br>1 4 2 5 3</p>
<pre><code>#include&lt;stdio.h&gt;  
#include&lt;iostream&gt;  
#include&lt;string.h&gt;  
#include&lt;math.h&gt;  
#include&lt;stdlib.h&gt;  
#include&lt;ctype.h&gt;  
#include&lt;algorithm&gt;  
#include&lt;vector&gt;  
#include&lt;string&gt;  
#include&lt;queue&gt;  
#include&lt;stack&gt;  
#include&lt;set&gt;

using namespace std;

int n, m, r[600], a[600][600], ans[600];

void toposort()
{
    for (int i = 1; i &lt;= n; i++)
    {
        int k = 1;
        while (r[k] != 0)
            k++;
        ans[i] = k;
        r[k] = -1;
        for (int j = 1; j &lt;= n; j++)
        {
            if (a[k][j])
                r[j]--;
        }
    }
}

int main()
{
    int x, y;


    while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)
    {
        if (n == 0 &amp;&amp; m == 0)
            return 0;
        memset(a, 0, sizeof(a));
        memset(r, 0, sizeof(r));

        for (int i = 1; i &lt;= m; i++)
        {
            scanf(&quot;%d %d&quot;, &amp;x, &amp;y);
            if (a[x][y] == 0)
            {
                a[x][y] = 1;
            }

        }

        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= n; j++)
            {
                if (a[i][j] != 0)
                    r[j]++;
            }

        toposort();

        for (int i = 1; i &lt;= n; i++)
        {
            if (i != n)
                printf(&quot;%d &quot;, ans[i]);
            else
                printf(&quot;%d\n&quot;, ans[i]);
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>uva 10689 Yet another Number Sequence【矩阵快速幂】</title>
    <url>/article/csdn/uva_10689_Yet_another_Number_Sequence%E3%80%90%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44566343" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44566343</a></p>
<p>Yet another Number Sequence<br>Time Limit:3000MS Memory Limit:0KB 64bit IO Format:%lld &amp; %llu<br>Submit</p>
<p>Status<br>Description<br>Download as PDF<br>Problem B<br>Yet another Number Sequence<br>Input: standard input<br>Output: standard output<br>Time Limit: 3 seconds</p>
<p>Let’s define another number sequence, given by the following function:<br>f(0) = a<br>f(1) = b<br>f(n) = f(n-1) + f(n-2), n &gt; 1<br>When a = 0 and b = 1, this sequence gives the Fibonacci Sequence. Changing the<br>values of a and b , you can get many different sequences. Given the values of<br>a, b, you have to find the last m digits of f(n) .<br>Input</p>
<p>The first line gives the number of test cases, which is less than 10001. Each<br>test case consists of a single line containing the integers a b n m. The<br>values of a and b range in [0,100], value of n ranges in [0, 1000000000] and<br>value of m ranges in [1, 4].</p>
<p>Output<br>For each test case, print the last m digits of f(n). However, you should NOT<br>print any leading zero.</p>
<p>Sample Input Output for Sample Input<br>4<br>0 1 11 3<br>0 1 42 4<br>0 1 22 4<br>0 1 21 4</p>
<p>89<br>4296<br>7711<br>946<br>Problem setter: Sadrul Habib Chowdhury<br>Special Thanks: Derek Kisman, Member of Elite Problem Setters’ Panel</p>
<p>矩阵快速幂；构建矩阵</p>
<pre><code>base.m[0][0] = 0;base.m[0][1] = 1;
base.m[1][0] = 1;base.m[1][1] = 1;



#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;

using namespace std;

struct node
{
    int m[2][2];
}ans, base;

int a,b,n,m;

node multi(node a, node b)
{
    node tmp;
    for (int i = 0; i&lt;2; i++)
        for (int j = 0; j&lt;2; j++)
        {
            tmp.m[i][j] = 0;
            for (int k = 0; k&lt;2; k++)
            {
                tmp.m[i][j] += (a.m[i][k] * b.m[k][j]);
                tmp.m[i][j] %= m;
            }
        }
    return tmp;
}

void fast_mod(int n)// 求矩阵 base 的  n 次幂 
{
    base.m[0][1] = base.m[1][0] = base.m[1][1] = 1;
    base.m[0][0] = 0;
    ans.m[0][0] = ans.m[1][1] = 1;// ans 初始化为单位矩阵
    ans.m[0][1] = ans.m[1][0] = 0;
    while (n)
    {
        if (n &amp; 1) //实现 ans *= t; 其中要先把 ans赋值给 tmp，然后用 ans = tmp * t 
            ans = multi(ans, base);
        base = multi(base, base);
        n &gt;&gt;= 1;
    }
}

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;n,&amp;m);      
        m = pow(10, m);
        if (n == 0)
        {
            printf(&quot;%d\n&quot;, (a%m + m) % m);
            continue;
        }
        if (n == 1)
        {
            printf(&quot;%d\n&quot;, (b%m + m) % m);
            continue;
        }
        fast_mod(n-1);
        int tmp = ((ans.m[1][0] * a + ans.m[1][1] * b) % m + m) % m;
        printf(&quot;%d\n&quot;, tmp);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>uva 1395 Silm Span 【MST-Kruskal】</title>
    <url>/article/csdn/uva_1395_Silm_Span_%E3%80%90MST-Kruskal%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44731415" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44731415</a></p>
<p>题目链接： <a href="http://uva.onlinejudge.org/external/13/1395.pdf" target="_blank" rel="noopener"> 点击链接 </a><br>题意:求生成树，使得最大边与最小边差最小，输出最小值；<br>枚举边更新答案。</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;iostream&gt;  
#include &lt;string.h&gt;  
#include &lt;algorithm&gt;  
#include &lt;math.h&gt;  
#include &lt;stack&gt;  
#include &lt;queue&gt;  

using namespace std;

const int MAXN = 110;//点
const int MAXM = 510;//边

int f[MAXM];//并查集使用

struct Edge
{
    int u, v, w;
}edge[MAXM];

int tol;//边数 初始化 0

void addedge(int u, int v, int w)
{
    edge[tol].u = u;
    edge[tol].v = v;
    edge[tol++].w = w;
}

bool cmp(Edge a, Edge b)
{
    return a.w &lt; b.w;
}

int find(int x)
{
    if (f[x] == -1)
        return x;
    else
        return f[x] = find(f[x]);
}

int kruskal(int n)
{
    sort(edge, edge + tol, cmp);
    int cnt ;
    int ans = 1e9, ok = 0;
    int MAX;
    for (int j = 0; j &lt; tol; j++)
    {
        MAX = -1;
        memset(f, -1, sizeof(f));
        cnt = 0;
        for (int i = j; i &lt; tol; i++)
        {
            int u = edge[i].u;
            int v = edge[i].v;
            int w = edge[i].w;
            MAX = max(MAX, w);
            int t1 = find(u);
            int t2 = find(v);
            if (t1 != t2)
            {
                f[t1] = t2;
                cnt++;
            }
            if (cnt == n - 1)
                break;
        }
        if (cnt == n - 1)
        {
            ok = 1;
            ans = min(ans, MAX - edge[j].w);
        }
    }
    if (ok)
        return ans;
    else
        return -1;
}

int n, m;
int u, v, w;

int main()
{
    while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)
    {
        if (n == 0 &amp;&amp; m == 0)
            break;
        tol = 0;
        for (int i = 0; i &lt; m; i++)
        {
            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
            addedge(u, v, w);
        }
        int ans = kruskal(n);
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>uva 11021 Tribles 【概率】</title>
    <url>/article/csdn/uva_11021_Tribles_%E3%80%90%E6%A6%82%E7%8E%87%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44656463" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44656463</a></p>
<p>Description<br>Tribbles<br>Input: Standard Input<br>Output: Standard Output<br>GRAVITATION, n.<br>“The tendency of all bodies to approach one another with a strength<br>proportion to the quantity of matter they contain – the quantity of<br>matter they contain being ascertained by the strength of their tendency<br>to approach one another. This is a lovely and edifying illustration of<br>how science, having made A the proof of B, makes B the proof of A.”<br>Ambrose Bierce<br>You have a population of kTribbles. This particular species of Tribbles live<br>for exactly one day and then die. Just before death, a single Tribble has the<br>probability Pi of giving birth to i more Tribbles. What is the probability<br>that after m generations, every Tribble will be dead?<br>Input<br>The first line of input gives the number of cases, N. N test cases follow.<br>Each one starts with a line containing n (1&lt;= n&lt;=1000) , k (0&lt;= k&lt;=1000) and m<br>(0&lt;= m&lt;=1000) . The next n lines will give the probabilities P0, P1, …,Pn-1.<br>Output<br>For each test case, output one line containing “Case #x:” followed by the<br>answer, correct up to an absolute or relative error of 10-6.<br>Sample Input<br>Sample Output<br>4<br>3 1 1<br>0.33<br>0.34<br>0.33<br>3 1 2<br>0.33<br>0.34<br>0.33<br>3 1 2<br>0.5<br>0.0<br>0.5<br>4 2 2<br>0.5<br>0.0<br>0.0<br>0.5<br>Case #1: 0.3300000<br>Case #2: 0.4781370<br>Case #3: 0.6250000<br>Case #4: 0.3164062</p>
<p>要求计算第m天k个生物全部死亡的概率，f[i]表示第i天全部死亡；</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;

using namespace std;

const int MAXN = 1010;
double p[MAXN], f[MAXN];
int n, k, m;
int cases = 1;

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while(t--)
    {
        scanf(&quot;%d%d%d&quot;,&amp;n,&amp;k,&amp;m);
        for (int i = 0; i &lt; n; i++)
            scanf(&quot;%lf&quot;,&amp;p[i]);
        f[0] = 0; f[1] = p[0];//f[i]表示第i天全部死亡的概率；
        for (int i = 2; i &lt;= m; i++)
        {
            f[i] = 0;
            for (int j = 0; j &lt; n; j++)
            {
                f[i] += p[j] * pow(f[i-1],j);//j个全部死亡，乘法原理
            }
        }
        printf(&quot;Case #%d: %.7lf\n&quot;,cases++,pow(f[m],k));
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>wustoj 1593 Count Zeros【线段树】</title>
    <url>/article/csdn/wustoj_1593:_Count_Zeros%E3%80%90%E7%BA%BF%E6%AE%B5%E6%A0%91%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/51243730" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/51243730</a></p>
<p>题目： <a href="http://acm.wust.edu.cn/problem.php?id=1593&amp;soj=0" target="_blank" rel="noopener"> http://acm.wust.edu.cn/problem.php?id=1593&amp;soj=0
</a></p>
<p>解法：线段树维护因子2 5存在的个数。并判断是不是存在0</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;vector&gt;

const int N = 200010;

using namespace std;

int m, n;
int a[N];

struct node
{
    int left;
    int right;
    int sum2, sum5;
    bool is;
};

struct segtree
{
    node tree[N * 4];

    void buildtree(int left, int right, int ind)
    {
        tree[ind].left = left;
        tree[ind].right = right;
        tree[ind].sum2 = tree[ind].sum5 = 0;
        tree[ind].is = false;

        if (left == right)
        {
            if (a[left] == 0)
            {
                tree[ind].is = true;
                return;
            }

            int tmp1 = a[left];
            while (tmp1 != 0 &amp;&amp; tmp1 % 2 == 0)
            {
                tree[ind].sum2++;
                tmp1 /= 2;
            }

            tmp1 = a[left];
            while (tmp1 != 0 &amp;&amp; tmp1 % 5 == 0)
            {
                tree[ind].sum5++;
                tmp1 /= 5;
            }
        }
        else
        {
            int mid = (tree[ind].left + tree[ind].right) / 2;

            buildtree(left, mid, 2*(ind));
            buildtree(mid + 1, right,2*(ind) + 1);

            tree[ind].sum2 = (tree[2*(ind)].sum2 + tree[2*(ind) + 1].sum2);
            tree[ind].sum5 = (tree[2*(ind)].sum5 + tree[2*(ind) + 1].sum5);
            tree[ind].is = (tree[2*(ind)].is || tree[2*(ind) + 1].is);
        }
    }

    void update(int pos, int ind, int val)
    {
        if (tree[ind].left == tree[ind].right)
        {
            if (val == 0)
                tree[ind].is = true;
            else
                tree[ind].is = false;

            int tmp1;
            tree[ind].sum2 = 0;
            tmp1 = val;
            while (tmp1 != 0 &amp;&amp; tmp1 % 2 == 0)
            {
                tree[ind].sum2++;
                tmp1 /= 2;
            }

            tree[ind].sum5 = 0;
            tmp1 = val;
            while (tmp1 != 0 &amp;&amp; tmp1 % 5 == 0)
            {
                tree[ind].sum5++;
                tmp1 /= 5;
            }
        }
        else
        {
            int mid = (tree[ind].left + tree[ind].right)/2;
            if (pos &lt;= mid)
                update(pos, 2*(ind), val);
            else
                update(pos, 2*(ind) + 1, val);
            tree[ind].sum2 = (tree[2*(ind)].sum2 + tree[2*(ind)+1].sum2);
            tree[ind].sum5 = (tree[2*(ind)].sum5 + tree[2*(ind) + 1].sum5);
            tree[ind].is = (tree[2*(ind)].is || tree[2*(ind) + 1].is);
        }
    }

    int query2(int st, int ed, int ind)
    {
        int left = tree[ind].left;
        int right = tree[ind].right;

        if (st &lt;= left &amp;&amp; right &lt;= ed)
        {
            return tree[ind].sum2;
        }
        else
        {
            int mid = (tree[ind].left + tree[ind].right) / 2;
            int sum1 = 0;
            int sum2 = 0;
            if (st &lt;= mid)
                sum1 = query2(st, ed, 2*(ind));
            if (ed &gt; mid)
                sum2 = query2(st, ed, 2*(ind) + 1);
            return (sum1 + sum2);
        }
    }
    int query5(int st, int ed, int ind)
    {
        int left = tree[ind].left;
        int right = tree[ind].right;

        if (st &lt;= left &amp;&amp; right &lt;= ed)
            return tree[ind].sum5;
        else
        {
            int mid = (tree[ind].left + tree[ind].right) / 2;
            int sum1 = 0;
            int sum2 = 0;
            if (st &lt;= mid)
                sum1 = query5(st, ed, 2*(ind));
            if (ed &gt; mid)
                sum2 = query5(st, ed, 2*(ind) + 1);
            return (sum1 + sum2);
        }
    }
    bool query0(int st, int ed, int ind)
    {
        int left = tree[ind].left;
        int right = tree[ind].right;

        if (st &lt;= left &amp;&amp; right &lt;= ed)
        {
            if (tree[ind].is == false)
                return false;
            else
                return true;
        }
        else
        {
            int mid = (tree[ind].left + tree[ind].right) / 2;
            int sum1 = 0;
            int sum2 = 0;
            if (st &lt;= mid)
                sum1 = query0(st, ed, 2*(ind));
            if (ed &gt; mid)
                sum2 = query0(st, ed, 2*(ind) + 1);
            return (sum1 || sum2);
        }
    }
}seg;

int main()
{
    while (scanf(&quot;%d %d&quot;, &amp;n, &amp;m) != EOF)
    {
        for (int i = 1; i &lt;= n; i++)
            scanf(&quot;%d&quot;, &amp;a[i]);

        seg.buildtree(1, n, 1);

        int opr, c, d;
        while (m--)
        {
            scanf(&quot;%d&quot;, &amp;opr);
            scanf(&quot;%d %d&quot;, &amp;c, &amp;d);
            if (opr == 0)
            {
                int s2, s5;
                bool s0 = seg.query0(c, d, 1);
                s2 = seg.query2(c, d, 1);
                s5 = seg.query5(c, d, 1);

                int ans = min(s2, s5);
                if (s0)
                    ans = 1;
                printf(&quot;%d\n&quot;, ans);
            }
            else if (opr == 1)
            {
                seg.update(c, 1, d);
            }
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>zkw费用流模板</title>
    <url>/article/csdn/zkw%E8%B4%B9%E7%94%A8%E6%B5%81%E6%A8%A1%E6%9D%BF.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48219707" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48219707</a></p>
<p>模板：<br>对二分图类型效率高</p>
<pre><code>// hdu 3667
#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;sstream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;string&gt;

using namespace std;

const int MAXN = 1000;
const int MAXM = 200000;
const int INF = 0x3f3f3f3f;
struct Edge
{
    int to, next, cap, flow, cost;
    Edge(int _to = 0, int _next = 0, int _cap = 0, int _flow = 0, int _cost = 0) :
        to(_to), next(_next), cap(_cap), flow(_flow), cost(_cost) {}
}edge[MAXM];

struct ZKW_MinCostMaxFlow
{
    int head[MAXN], tot;
    int cur[MAXN];
    int dis[MAXN];
    bool vis[MAXN];
    int ss, tt, N;//源点、汇点和点的总个数（编号是0~N-1）,不需要额外赋值，调用会直接赋值
    int min_cost, max_flow;
    void init()
    {
        tot = 0;
        memset(head, -1, sizeof(head));
    }
    void addedge(int u, int v, int cap, int cost)
    {
        edge[tot] = Edge(v, head[u], cap, 0, cost);
        head[u] = tot++;
        edge[tot] = Edge(u, head[v], 0, 0, -cost);
        head[v] = tot++;
    }
    int aug(int u, int flow)
    {
        if (u == tt)return flow;
        vis[u] = true;
        for (int i = cur[u];i != -1;i = edge[i].next)
        {
            int v = edge[i].to;
            if (edge[i].cap &gt; edge[i].flow &amp;&amp; !vis[v] &amp;&amp; dis[u] == dis[v] + edge[i].cost)
            {
                int tmp = aug(v, min(flow, edge[i].cap - edge[i].flow));
                edge[i].flow += tmp;
                edge[i ^ 1].flow -= tmp;
                cur[u] = i;
                if (tmp)return tmp;
            }
        }
        return 0;
    }
    bool modify_label()
    {
        int d = INF;
        for (int u = 0;u &lt; N;u++)
            if (vis[u])
                for (int i = head[u];i != -1;i = edge[i].next)
                {
                    int v = edge[i].to;
                    if (edge[i].cap&gt;edge[i].flow &amp;&amp; !vis[v])
                        d = min(d, dis[v] + edge[i].cost - dis[u]);
                }
        if (d == INF)return false;
        for (int i = 0;i &lt; N;i++)
            if (vis[i])
            {
                vis[i] = false;
                dis[i] += d;

            }
        return true;
    }
    /*
    * 直接调用获取最小费用和最大流
    * 输入: start-源点，end-汇点，n-点的总个数（编号从0开始）
    * 返回值: pair&lt;int,int&gt; 第一个是最小费用，第二个是最大流
    */
    pair&lt;int, int&gt; mincostmaxflow(int start, int end, int n)
    {
        ss = start, tt = end, N = n;
        min_cost = max_flow = 0;
        for (int i = 0;i &lt; n;i++)dis[i] = 0;
        while (1)
        {
            for (int i = 0;i &lt; n;i++)cur[i] = head[i];
            while (1)
            {
                for (int i = 0;i &lt; n;i++)vis[i] = false;
                int tmp = aug(ss, INF);
                if (tmp == 0)break;
                max_flow += tmp;
                min_cost += tmp*dis[ss];
            }
            if (!modify_label())break;
        }
        return make_pair(min_cost, max_flow);
    }
}solve;

int n, m, k;
int cnt[10] = { 0,1,3,5,7,9 };

int main()
{
    while (~scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k))
    {
        solve.init();

        solve.addedge(0, 1, k, 0);
        solve.addedge(n, n + 1, k, 0);

        int u, v, a, c;
        for (int i = 1;i &lt;= m;i++)
        {
            scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;a, &amp;c);
            for (int j = 1;j &lt;= c;j++)
                solve.addedge(u, v, 1, a*cnt[j]);
        }

        pair&lt;int, int&gt; tmp = solve.mincostmaxflow(0, n + 1, n + 2);
        int ans = tmp.second;
        if (ans &lt; k) puts(&quot;-1&quot;);
        else printf(&quot;%d\n&quot;, tmp.first);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>中国剩余定理</title>
    <url>/article/csdn/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44678937" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44678937</a></p>
<p>前面许多人讲过一些性质与证明，我来讲一讲解法，也是为了以后自己回过头来看。<br>中国剩余定理介绍<br>在《孙子算经》中有这样一个问题：“今有物不知其数，三三数之剩二（除以3余2），五五数之剩三（除以5余3），七七数之剩二（除以7余2），问物几何？”这个问题称为“孙子问题”，该问题的一般解法国际上称为“中国剩余定理”。具体解法分三步：</p>
<p>找出三个数：从3和5的公倍数中找出被7除余1的最小数15，从3和7的公倍数中找出被5除余1 的最小数21，最后从5和7的公倍数中找出除3余1的最小数70。<br>用15乘以2（2为最终结果除以7的余数），用21乘以3（3为最终结果除以5的余数），同理，用70乘以2（2为最终结果除以3的余数），然后把三个乘积相加（15<em>2+21</em>3+70*2）得到和233。<br>用233除以3，5，7三个数的最小公倍数105，得到余数23，即233%105=23。这个余数23就是符合条件的最小数。</p>
<p>具体的求解公式：<br>假如：<br>x= b1(mod m1)<br>x= b2(mod m2)<br>……..<br>x= bn(mod mn)<br>(m1<em>m2 …mn)^(-1)为(m1</em>m2 …mn)的逆元<br>则x = b1<em>（m2</em>m3<em>… <em>mn）</em> （m2</em>m3<em>… <em>mn）^(-1) + b2</em> （m1</em>m3<em>… <em>mn）</em> （m1</em>m3<em>…<br><em>mn）^(-1)+….+bn</em> （m1</em>m2<em>… <em>mn-1）</em> （m1</em>m2<em>…</em>mn-1）^(-1)</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>zoj -1586 QS Network</title>
    <url>/article/csdn/zoj_-1586_QS_Network.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43194991" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43194991</a></p>
<h2><span id=""> </span></h2><p><a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1586" target="_blank" rel="noopener"> http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1586
</a>  </p>
<p>简单题</p>
<h2><span id="sunny-cup-2003-preliminary-round">Sunny Cup 2003 - Preliminary Round</span></h2><p>April 20th, 12:00 - 17:00</p>
<h3><span id="problem-e-qs-network">Problem E: QS Network</span></h3><p>In the planet w-503 of galaxy cgb, there is a kind of intelligent creature<br>named QS. QScommunicate with each other via networks. If two QS want to get<br>connected, they need to buy two network adapters (one for each QS) and a<br>segment of network cable. Please be advised that ONE NETWORK ADAPTER CAN ONLY<br>BE USED IN A SINGLE CONNECTION.(ie. if a QS want to setup four connections, it<br>needs to buy four adapters). In the procedure of communication, a QS<br>broadcasts its message to all the QS it is connected with, the group of QS who<br>receive the message broadcast the message to all the QS they connected with,<br>the procedure repeats until all the QS’s have received the message.</p>
<p>A sample is shown below:</p>
<p><img src="http://acm.zju.edu.cn/onlinejudge/showImage.do?name=0000%2F1586%2F1586.gif" alt=""></p>
<p>A sample QS network, and QS A want to send a message.  </p>
<p>Step 1. QS A sends message to QS B and QS C;  </p>
<p>Step 2. QS B sends message to QS A ; QS C sends message to QS A and QS D;  </p>
<p>Step 3. the procedure terminates because all the QS received the message.</p>
<p>Each QS has its favorate brand of network adapters and always buys the brand<br>in all of its connections. Also the distance between QS vary. Given the price<br>of each QS’s favorate brand of network adapters and the price of cable between<br>each pair of QS, your task is to write a program to determine the minimum cost<br>to setup a QS network.</p>
<p><strong>Input</strong></p>
<p>The 1st line of the input contains an integer t which indicates the number of<br>data sets.  </p>
<p>From the second line there are t data sets.  </p>
<p>In a single data set,the 1st line contains an interger n which indicates the<br>number of QS.  </p>
<p>The 2nd line contains n integers, indicating the price of each QS’s favorate<br>network adapter.  </p>
<p>In the 3rd line to the n+2th line contain a matrix indicating the price of<br>cable between ecah pair of QS.</p>
<p>Constrains:</p>
<p>all the integers in the input are non-negative and not more than 1000.</p>
<p><strong>Output</strong></p>
<p>for each data set,output the minimum cost in a line. NO extra empty lines<br>needed.</p>
<p><strong>Sample Input</strong></p>
<p>1<br>3<br>10 20 30<br>0 100 200<br>100 0 300<br>200 300 0</p>
<p><strong>Sample Output</strong></p>
<p>370</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;

using namespace std;
#define INF 10000000

int n, m;
int a,b,c,d[1110];

int map[1110][1110], dis[1110], v[1110];

int prim(int n)
{
    int i, j, k, min, sum = 0;
    for (i = 1; i &lt;= n; i++)
        dis[i] = map[1][i];

    memset(v, 0, sizeof(v));
    v[1] = 1;
    dis[1] = 0;

    for (i = 2; i &lt;= n; i++)
    {
        k = 1;
        min = INF;
        for (j = 1; j &lt;= n; j++)
            if (!v[j] &amp;&amp; min&gt;dis[j])
            {
                k = j;
                min = dis[j];
            }
        sum += min;
        v[k] = 1;
        for (j = 1; j &lt;= n; j++)
            if (!v[j] &amp;&amp; dis[j]&gt;map[k][j])
                dis[j] = map[k][j];
    }
    return sum;
}

int main()
{
    int t;
    cin&gt;&gt;t;
    while (t--)
    {
        cin&gt;&gt;n;
        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= n; j++)
            {
                if (i != j)
                    map[i][j] = INF;
                else
                    map[i][j]= 0;
            }
        for(int i=1;i&lt;=n;i++)
            cin&gt;&gt;d[i];
        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= n; j++)
        {
            cin&gt;&gt;a;
            if (map[i][j] &gt; a)
            {
                map[i][j] = a + d[i] + d[j];
                map[j][i] = a + d[i] + d[j];
            }
            else
            {
                map[i][j] = map[i][j] + d[i] + d[j];
                map[j][i] = map[i][j] + d[i] + d[j];
            }
        }
        printf(&quot;%d\n&quot;,prim(n));
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图多重匹配问题</title>
    <url>/article/csdn/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%A4%9A%E9%87%8D%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48319639" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48319639</a></p>
<p>转自： <a href="http://www.cppblog.com/MatoNo1/archive/2011/03/26/142766.html" target="_blank" rel="noopener"> http://www.cppblog.com/MatoNo1/archive/2011/03/26/142766.html
</a></p>
<p>在二分图最大匹配中，每个点（不管是X方点还是Y方点）最多只能和一条匹配边相关联，然而，我们经常遇到这种问题，即二分图匹配中一个点可以和多条匹配边相关联，但有上限，或者说，Li表示点i最多可以和多少条匹配边相关联。</p>
<p>二分图多重匹配分为二分图多重最大匹配与二分图多重最优匹配两种，分别可以用最大流与最大费用最大流解决。</p>
<p>（1）二分图多重最大匹配：<br>在原图上建立源点S和汇点T，S向每个X方点连一条容量为该X方点L值的边，每个Y方点向T连一条容量为该Y方点L值的边，原来二分图中各边在新的网络中仍存在，容量为1（若该边可以使用多次则容量大于1），求该网络的最大流，就是该二分图多重最大匹配的值。</p>
<p>（2）二分图多重最优匹配：<br>在原图上建立源点S和汇点T，S向每个X方点连一条容量为该X方点L值、费用为0的边，每个Y方点向T连一条容量为该Y方点L值、费用为0的边，原来二分图中各边在新的网络中仍存在，容量为1（若该边可以使用多次则容量大于1），费用为该边的权值。求该网络的最大费用最大流，就是该二分图多重最优匹配的值。</p>
<p>例题：<br>【1】POJ1698 Alice’s Chance<br>将电影作为X方点，每一天作为Y方点（最多50周，每周7天，所以共设350个Y方点），若第i个电影可以在第j天搞就连边(i,<br>j)。每个X方点的L值为该电影总共要搞多少天，每个Y方点的L值为1（每天最多只能搞一个电影），然后求二分图多重最大匹配，若能使所有从源点连向X方点的边都满流，则输出Yes，否则输出No。<br>【2】POJ2112 Optimal Milking<br>先预处理求出每两个点（包括挤奶点和牛）间的最短距离，然后将所有挤奶点作为X方点（L值为该挤奶点最多可以容纳多少牛），所有牛作为Y方点（L值为1），Xi和Yj间边的权值为这两个点之间的最短距离（若这两点间不存在路径则此处无边），然后问题就变成了求一个多重匹配，使得每个Y方点都有匹配点且匹配边中权值的最大值最小。<br>可以枚举最大边权值S，然后，原图中所有权值大于S的边都要删去。若此时图中存在符合要求的多重匹配，则S合法否则S不合法。由于S的合法性是单调的，所以可以二分枚举S。</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>为什么构造函数不能为虚函数(转)</title>
    <url>/article/csdn/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0(%E8%BD%AC).html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/49533865" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/49533865</a></p>
<h2><span id="1">1</span></h2><p>从存储空间角度<br>虚函数对应一个vtable，这大家都知道，可是这个vtable其实是存储在对象的内存空间的。问题出来了，如果构造函数是虚的，就需要通过<br>vtable来调用，可是对象还没有实例化，也就是内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。</p>
<h2><span id="2">2</span></h2><p>从实现上看，vbtl在构造函数调用后才建立，因而构造函数不可能成为虚函数<br>从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数</p>
<h2><span id="3">3</span></h2><p>当一个构造函数被调用时，它做的首要的事情之一是初始化它的V P T<br>R。因此，它只能知道它是“当前”类的，而完全忽视这个对象后面是否还有继承者。当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码-<br>-既不是为基类，也不是为它的派生类</p>
<h2><span id="4">4</span></h2><p>构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过实验室的基类的指针或引用去访问它。但析构却不一定，我们往往通过基类的指针来销毁对象。这时候如果析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。</p>
<h2><span id="5">5</span></h2><p>从使用角度<br>虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。<br>虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。</p>
<p>转自： <a href="http://blog.sina.com.cn/s/blog_620882f401016ri2.html" target="_blank" rel="noopener"> http://blog.sina.com.cn/s/blog_620882f401016ri2.html
</a></p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>二分图的判断</title>
    <url>/article/csdn/%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E5%88%A4%E6%96%AD.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46504429" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46504429</a></p>
<p>判断二分图,染色法，选取某个点作为起点并染为某种颜色、同时把与它相邻的元素染为对立的颜色，进行BFS，如果到那步发现当前点和相邻点的颜色一样，那么就出现了矛盾，就不是二分图。</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>二分法求最大化平均值</title>
    <url>/article/csdn/%E4%BA%8C%E5%88%86%E6%B3%95%E6%B1%82%E6%9C%80%E5%A4%A7%E5%8C%96%E5%B9%B3%E5%9D%87%E5%80%BC.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46380489" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46380489</a></p>
<p>有n个物品，每个物品分别对应一个重量和价值。要求选出k个，使得平均每单位重量的价值最大。</p>
<p>思路：</p>
<p>设k的集合是S ，使得平均值最大，即 Vs/Ws 最大。枚举答案x，Vs/Ws&gt;=x，即 Vs – Ws*x&gt;=0 成立。二分x即可。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;
#include &lt;set&gt;

using namespace std;

const int MAXN = 100000;
const double INF = 1e9;
int n, k;

struct node
{
    double w;
    double v;   
}p[MAXN];

bool cmp2(double a, double b)
{
    return a &gt; b;
}

double tmp[MAXN];

int c(double x)
{
    for (int i = 0; i &lt; n; i++)
    {
        tmp[i] = p[i].v - x*p[i].w;
    }
    sort(tmp,tmp+n,cmp2);
    double sum = 0;
    for (int i = 0; i &lt; k; i++)
        sum += tmp[i];
    if (sum &gt;= 0) return 1;
    return 0;
}

void solve()
{
    double down = 0, up = INF;
    for (int i = 0; i &lt; 100; i++)
    {
        double mid = (up + down)/2;
        if (c(mid)) down = mid;
        else up = mid;
    }
    printf(&quot;%.3lf&quot;,down);
}

int main()
{
    while (cin &gt;&gt; n &gt;&gt; k)
    {
        for (int i = 0; i&lt;n; i++)
            cin &gt;&gt; p[i].w &gt;&gt; p[i].v;
        solve();
    }
    return 0;   
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树层序前序中序后序遍历，深度</title>
    <url>/article/csdn/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%8C%E6%B7%B1%E5%BA%A6.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40357285" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40357285</a></p>
<p>层序利用队列：</p>
<pre><code>void PrintFromTopToBottom(BinaryTreeNode *pTreeRoot)
{
    if(!pTreeRoot)
        return;

    std::queue&lt;BinaryTreeNode*&gt; queTreeNode;

    dequeTreeNode.push_back(pTreeRoot);

    while(!queTreeNode.empty())
    {
        BinaryTreeNode *pNode = queTreeNode.front();
        queTreeNode.pop_front();

        printf(&quot;%d &quot; , pNode-&gt;m_nValue);

        if(pNode-&gt;m_pLeft)
            queTreeNode.push_back(pNode-&gt;m_pLeft);

        if(pNode-&gt;m_pRight)
            queTreeNode.push_back(pNode-&gt;m_pRight);
    }
}
</code></pre><p>前中后序遍历：  </p>
<pre><code>void vis(char a)  
{  
    printf(&quot;%c  &quot;,a);  
}  

void pinor(binode *curr,void vis(char a ))//前序遍历  
{  
    if (curr!=NULL)  
    {  
        vis(curr-&gt;data);  
        pinor(curr-&gt;left,vis);  
        pinor(curr-&gt;right,vis);  
    }  
}  

void inor(binode *curr,void vis(char a ))//中序遍历  
{  
    if (curr!=NULL)  
    {  
        inor(curr-&gt;left,vis);  
        vis(curr-&gt;data);  
        inor(curr-&gt;right,vis);  
    }  
}  

void poinor(binode *curr,void vis(char a ))//后序遍历  
{  
    if (curr!=NULL)  
    {  
        poinor(curr-&gt;left,vis);  
        poinor(curr-&gt;right,vis);  
        vis(curr-&gt;data);  
    }  
}  
</code></pre><p>深度：</p>
<pre><code>int GetDepth(tagBiNode *pRoot)  
{  
    if (pRoot == NULL)  
    {  
        return 0;  
    }  

    return GetDepth(pRoot-&gt;left) &gt; GetDepth(pRoot-&gt;right) ?   
        (GetDepth(pRoot-&gt;left) + 1) : (GetDepth(pRoot-&gt;right) + 1);  
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>信息论与编码 上机</title>
    <url>/article/csdn/%E4%BF%A1%E6%81%AF%E8%AE%BA%E4%B8%8E%E7%BC%96%E7%A0%81_%E4%B8%8A%E6%9C%BA.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46383595" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46383595</a></p>
<p>香农：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;bitset&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;
#include &lt;map&gt;
#include &lt;set&gt;

using namespace std;

const int MAXN = 11000;

double p[MAXN], sump[MAXN], li[MAXN];
int n, LI[MAXN];
char code[MAXN][100];
bool cmp(double a, double b)
{
    return a &gt; b;
}
void init()
{
    cout &lt;&lt; &quot;请依次输入信源符号的概率：&quot;;
    memset(p, 0, sizeof(p));
    memset(sump, 0, sizeof(sump));
    for (int i = 1; i &lt;= n; i++)
        cin &gt;&gt; p[i];
    sort(p + 1, p + 1 + n, cmp);
    for (int i = 2; i &lt;= n; i++)
        sump[i] = sump[i - 1] + p[i - 1];
}

void solve()
{
    for (int i = 1; i &lt;= n; i++)
    {
        li[i] = (-1)*(log10(p[i]) / log10(2));
        LI[i] = ceil(li[i]);
    }

    for (int i = 1; i &lt;= n; i++)
    {
        for (int j = 0; j &lt; LI[i]; j++)
        {
            sump[i] *= 2;

            if (sump[i] - 1 &gt;= 0)
            {
                code[i][j] = &#39;1&#39;;
                sump[i] -= 1;
            }
            else
                code[i][j] = &#39;0&#39;;
        }
    }
    cout &lt;&lt; &quot;编码为：&quot; &lt;&lt; endl;
    for (int i = 1; i &lt;= n; i++)
        cout &lt;&lt; code[i] &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;
}

int main()
{
    cout &lt;&lt; &quot;请输入信源符号个数n：&quot;;
    cin &gt;&gt; n;
    {
        init();
        solve();
    }
    return 0;
}
/*
测试数据：
7
0.20 0.19 0.18 0.17 015 0.10 0.01
*/
</code></pre><p>费诺：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;bitset&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;iomanip&gt;

using namespace std;

int n;
double p[10000];
string *code;

void fano(int a, int b)     
{
    if ((b - a) &gt;= 1)       
    {
        double sum = 0;
        for (int i = a; i &lt;= b; i++)
            sum += p[i];
        double s1 = 0, *s = new double[10];
        for (int i = a; i &lt;= b; i++)
        {
            s1 += p[i]; s[i] = fabs(2 * s1 - sum) / sum;
        }
        double min = s[a];  int c;
        for (int i = a; i &lt;= b; i++)
            if (s[i] &lt;= min)
            {
                min = s[i];     c = i;      
            }
        for (int i = a; i &lt;= b; i++)
        {
            if (i &lt;= c) code[i] += &quot;0&quot;; 
            else code[i] += &quot;1&quot;;        
        }

        if (c == a)
            fano(c + 1, b);
        else if (c == b - 1)
            fano(a, c);
        else
        {
            fano(a, c); fano(c + 1, b);
        }
    }
}
void init()
{
    cout &lt;&lt; &quot;请输入信源符号个数n：&quot;;
    cin &gt;&gt; n;
    code = new string[n];
    cout &lt;&lt; &quot;请依次输入信源符号的概率：&quot;;
    for (int i = 0; i&lt;n; i++) cin &gt;&gt; p[i];
    for (int i = 0; i&lt;n - 1; i++)
        for (int j = i + 1; j&lt;n; j++)
            if (p[i] &lt; p[j])
            {
                double temp = p[i]; p[i] = p[j]; p[j] = temp;
            }
}

void solve()
{
    fano(0, n - 1);
    cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; setw(8) &lt;&lt; &quot;概率&quot; &lt;&lt; setw(8) &lt;&lt; &quot;码字&quot;  &lt;&lt; endl;
    for (int i = 0; i&lt;n; i++)
        cout &lt;&lt; setw(8) &lt;&lt; p[i] &lt;&lt; setw(8) &lt;&lt; code[i] &lt;&lt; setw(8) &lt;&lt; endl;
    delete[]code;
}

int main()
{
    init();
    solve();
    return 0;
}

/*
测试数据：
6
0.32 0.22 0.18 0.16 0.08 0.04
8
0.25 0.25 0.125 0.125 0.0625 0.0625 0.0625 0.0625
*/
</code></pre><p>尾随后缀：</p>
<pre><code>//代码：
#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string.h&gt;
#include &lt;string&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;sstream&gt;
#include &lt;time.h&gt;

using namespace std;

int n, ok, num;
char s[100000][100], tmp[100];
char F[100000][100];
set&lt;string&gt; Ftmp;

void input()
{
    puts(&quot;请输入码字的个数：&quot;);
    cin &gt;&gt; n;
    puts(&quot;请输入码字：&quot;);
    for (int i = 1; i &lt;= n; i++)
        scanf(&quot;%s&quot;, s[i]);
}

void Sort()
{
    for (int i = 1; i &lt;= n; i++)
    {
        for (int j = i; j &lt;= n; j++)
        {
            int len1 = strlen(s[i]);
            int len2 = strlen(s[j]);
            if (len1 &gt; len2)
            {
                strcpy(tmp, s[i]);
                strcpy(s[i], s[j]);
                strcpy(s[j], tmp);
            }
        }
    }
}

bool isok(char a[], char b[])
{
    int len1 = strlen(a);
    int len2 = strlen(b);
    for (int i = 0; i &lt; len1; i++)
    {
        if (a[i] != b[i])
            return false;
    }
    return true;
}

void init()
{
    Ftmp.clear();
    ok = 0;
    num = 0;
    for (int i = 1; i &lt; n; i++)
    {
        for (int j = i + 1; j &lt;= n; j++)
        {
            int len1 = strlen(s[i]);
            int len2 = strlen(s[j]);
            if (isok(s[i], s[j]))
            {
                strcpy(tmp, s[j] + len1);
                strcpy(F[num++], tmp);
            }
        }
    }
    for (int i = 0; i &lt; num; i++)
        Ftmp.insert(F[i]);
}

void solve()
{
    int pos = 0;
    for (int i = 0; i &lt; num; i++)
    {
        for (int j = 1; j &lt;= n; j++)
        {
            int len1 = strlen(F[i]);
            int len2 = strlen(s[j]);
            if (len1 &lt; len2)
            {
                if (isok(F[i], s[j]))
                {
                    strcpy(tmp, s[j] + len1);
                    strcpy(F[num++], tmp);

                    int size = Ftmp.size();
                    Ftmp.insert(tmp);
                    if (Ftmp.size() == size)
                        num -= 1;
                }

            }
        }
    }
}

void test()
{
    puts(&quot;检验结果：&quot;);
    int ok = 0;
    for (int i = 0; i &lt; num; i++)
    {
        if (ok) break;
        for (int j = 1; j &lt;= n; j++)
        {
            if (!strcmp(F[i], s[j]))
            {
                puts(&quot;非唯一可译码&quot;);
                ok = 1;
                break;
            }
        }
    }
    if (!ok) puts(&quot;是唯一可译码&quot;);
    printf(&quot;\n&quot;);
    puts(&quot;尾随后缀集合是：&quot;);
    for (int i = 0; i &lt; num; i++)
        Ftmp.insert(F[i]);
    set&lt;string&gt; ::iterator it;
    for (it = Ftmp.begin(); it != Ftmp.end(); it++)
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;

}

int main()
{
    input();
    Sort();
    init();
    solve();
    test();
    return 0;
}


//测试数据
/*
6
0 10 1100 1110 1011 1101

5
110 11 100 00 10
*/
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>内存分配算法</title>
    <url>/article/csdn/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/52485388" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/52485388</a></p>
<p>（1）首次适应算法。使用该算法进行内存分配时，从空闲分区链首开始查找，直至找到一个能满足其大小要求的空闲分区为止。然后再按照作业的大小，从该分区中划出一块内存分配给请求者，余下的空闲分区仍留在空闲分区链中。<br>该算法倾向于使用内存中低地址部分的空闲分区，在高地址部分的空闲分区很少被利用，从而保留了高地址部分的大空闲区。显然为以后到达的大作业分配大的内存空间创造了条件。缺点在于低址部分不断被划分，留下许多难以利用、很小的空闲区，而每次查找又都从低址部分开始，这无疑会增加查找的开销。  </p>
<p>（2）循环首次适应算法。该算法是由首次适应算法演变而成的。在为进程分配内存空间时，不再每次从链首开始查找，而是从上次找到的空闲分区开始查找，直至找到一个能满足要求的空闲分区，并从中划出一块来分给作业。该算法能使空闲中的内存分区分布得更加均匀，但将会缺乏大的空闲分区。</p>
<p>（3）最佳适应算法。该算法总是把既能满足要求，又是最小的空闲分区分配给作业。<br>为了加速查找，该算法要求将所有的空闲区按其大小排序后，以递增顺序形成一个空白链。这样每次找到的第一个满足要求的空闲区，必然是最优的。孤立地看，该算法似乎是最优的，但事实上并不一定。因为每次分配后剩余的空间一定是最小的，在存储器中将留下许多难以利用的小空闲区。同时每次分配后必须重新排序，这也带来了一定的开销。</p>
<p>4）最差适应算法。最差适应算法中，该算法按大小递减的顺序形成空闲区链，分配时直接从空闲区链的第一个空闲分区中分配（不能满足需要则不分配）。很显然，如果第一个空闲分区不能满足，那么再没有空闲分区能满足需要。这种分配方法初看起来不太合理，但它也有很强的直观吸引力：在大空闲区中放入程序后，剩下的空闲区常常也很大，于是还能装下一个较大的新程序。</p>
<p>最坏适应算法与最佳适应算法的排序正好相反，它的队列指针总是指向最大的空闲区，在进行分配时，总是从最大的空闲区开始查寻。<br>该算法克服了最佳适应算法留下的许多小的碎片的不足，但保留大的空闲区的可能性减小了，而且空闲区回收也和最佳适应算法一样复杂。</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>内存分配函数（C语言）</title>
    <url>/article/csdn/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%87%BD%E6%95%B0%EF%BC%88C%E8%AF%AD%E8%A8%80%EF%BC%89.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/52568029" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/52568029</a></p>
<p>C 标准函数库提供了许多函数来实现对堆上内存管理<br>malloc函数：malloc函数可以从堆上获得指定字节的内存空间（必须初始化）<br>free函数：释放内存，防止内存泄露<br>calloc函数：与 malloc类似，但不需要初始化<br>realloc函数：重新分配内存</p>
<p>头文件stdlib.h</p>
<h1><span id="malloc">malloc</span></h1><p>malloc函数可以从堆上获得指定字节的内存空间，其函数原型如下：</p>
<p>void * malloc(int n)</p>
<p>其中，形参n为要求分配的字节数。如果函数执行成功，malloc返回获得内存空间的首地址；如果函数执行失败，那么返回值为NULL。由于malloc函数值的类型为void型指针，因此，可以将其值类型转换后赋给任意类型指针，这样就可以通过操作该类型指针来操作从堆上获得的内存空间。</p>
<p>需要注意的是,malloc函数分配得到的内存空间是未初始化的。因此，一般在使用该内存空间时，要调用另一个函数memset来将其初始化为全0。memset函数的声明如下：<br>void <em> memset (void </em> p,int c,int n)<br>该函数可以将指定的内存空间按字节单位置为指定的字符c。其中，p为要清零的内存空间的首地址，c为要设定的值，n为被操作的内存空间的字节长度。如果要用memset清0，变量c实参要为0。malloc函数和memset函数的操作语句一般如下：</p>
<pre><code>int * p=NULL;
p=(int *)malloc(sizeof(int));
if(p==NULL)
    printf(&quot;Can&#39;t get memory!\n&quot;);
memset(p,0,siezeof(int));
</code></pre><p>通过malloc函数得到的堆内存必须使用memset函数来初始化</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main() {

     int * p=NULL;
     p=(int *)malloc(sizeof(int));
     if(NULL==p){
         printf(&quot;Can&#39;t get memory!\n&quot;);
         return -1;
     }

     printf(&quot;%d\n&quot;,*p);           //输出分配的空间上的值
     memset(p,0,sizeof(int));     //将p指向的空间清0
     printf(&quot;%d\n&quot;,*p);           //输出调用memset函数后的结果

     *p=2;
     printf(&quot;%d\n&quot;,*p);
     return 0;
}
</code></pre><h1><span id="free函数">free函数</span></h1><p>从堆上获得的内存空间在程序结束以后，系统不会将其自动释放，需要程序员来自己管理。一个程序结束时，必须保证所有从堆上获得的内存空间已被安全释放，否则，会导致内存泄露。例如上面的demo就会发生内存泄露。</p>
<p>free函数可以实现释放内存的功能。其函数声明为：</p>
<p>void free (void * p)</p>
<p>由于形参为void指针，free函数可以接受任意类型的指针实参。但是，free函数只是释放指针指向的内容，而该指针仍然指向原来指向的地方，此时，指针为野指针，如果此时操作该指针会导致不可预期的错误。安全做法是：在使用free函数释放指针指向的空间之后，将指针的值置为NULL。因此，对于上面的demo，需要在return语句前加入以下两行语句：</p>
<pre><code>free(p);
p=NULL;
</code></pre><h1><span id="calloc函数">calloc函数</span></h1><p>calloc函数的功能与malloc函数的功能相似，都是从堆分配内存。其函数声明如下：</p>
<p>void *calloc(int n,int size)</p>
<p>函数返回值为void型指针。如果执行成功，函数从堆上获得size X<br>n的字节空间，并返回该空间的首地址。如果执行失败，函数返回NULL。该函数与malloc函数的一个显著不同时是，calloc函数得到的内存空间是经过初始化的，其内容全为0。calloc函数适合为数组申请空间，可以将size设置为数组元素的空间长度，将n设置为数组的容量。</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define SIZE 5

int main() {
     int * p=NULL;
     int i=0;
     //为p从堆上分配SIZE个int型空间
     p=(int *)calloc(SIZE,sizeof(int));
    if(NULL==p){
         printf(&quot;Error in calloc.\n&quot;);
         return -1;
     }

     //为p指向的SIZE个int型空间赋值
     for(i=0;i&lt;SIZE;i++)
         p[i]=i;
     //输出各个空间的值
     for(i=0;i&lt;SIZE;i++)
         printf(&quot;p[%d]=%d\n&quot;,i,p[i]);
     free(p);
     p=NULL;
     return 0;
}
</code></pre><h1><span id="realloc函数">realloc函数</span></h1><p>realloc函数的功能比malloc函数和calloc函数的功能更为丰富，可以实现内存分配和内存释放的功能，其函数声明如下：</p>
<p>void <em> realloc(void </em> p,int n)</p>
<p>其中，指针p必须为指向堆内存空间的指针，即由malloc函数、calloc函数或realloc函数分配空间的指针。realloc函数将指针p指向的内存块的大小改变为n字节。如果n小于或等于p之前指向的空间大小，那么。保持原有状态不变。如果n大于原来p之前指向的空间大小，那么，系统将重新为p从堆上分配一块大小为n的内存空间，同时，将原来指向空间的内容依次复制到新的内存空间上，p之前指向的空间被释放。relloc函数分配的空间也是未初始化的。</p>
<p>注意：使用malloc函数，calloc函数和realloc函数分配的内存空间都要使用free函数或指针参数为NULL的realloc函数来释放。</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
     int * p=NULL;
     p=(int *)malloc(sizeof(int));
     *p=3;
     printf(&quot;p=%p\n&quot;,p);
     printf(&quot;*p=%d\n&quot;,*p);
     p=(int *)realloc(p,sizeof(int));
     printf(&quot;p=%p\n&quot;,p);
     printf(&quot;*p=%d\n&quot;,*p);

     p=(int *)realloc(p,3*sizeof(int));
     printf(&quot;p=%p\n&quot;,p);
     printf(&quot;*p=%d&quot;,*p);
    //释放p指向的空间
     realloc(p,0);
     p=NULL;

     return 0;
</code></pre><p>转自： <a href="http://github.thinkingbar.com/allocate-memroy/" target="_blank" rel="noopener"> http://github.thinkingbar.com/allocate-memroy/
</a></p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>判断互质数的方法</title>
    <url>/article/csdn/%E5%88%A4%E6%96%AD%E4%BA%92%E8%B4%A8%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40442785" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40442785</a></p>
<p>一、概念判断法</p>
<p>公约数只有1的两个数叫做互质的数。根据互质数的概念。可以对一组数进行判断。如，4和9的公约数只有1，所以它们是互质数。 　　二、规律判断法</p>
<p>根据互质数的定义，可总结出一些规律，利用这些规律可迅速判断一组数是否互质。</p>
<p>（1）两个不相同的质数一定是互质数。例如，19和13是互质数。</p>
<p>（2）两个连续的自然数一定是互质数。例如，14和15是互质数。</p>
<p>（3）相邻的两个奇数一定是互质数。例如，91和93是互质数</p>
<p>（4）1和其它所有自然数一定是互质数。例如，1和4，1和13等。</p>
<p>（5）两个数中较大数为质数，这两个数一定是互质数。例如16和97是互质数。</p>
<p>（6）两个数中的较小一个是质数，较大数是合数且不是较小数的倍数，这两个数一定是互质数。例如，7和54是互质数。</p>
<p>（7）较大数比较小数的2倍多1或少1，这两个数一定是互质数，例如，13和27是互质数，13和25是互质数。</p>
<p>三、分解判断法</p>
<p>如果两个数都是合数，可先将两个数分别分解质因数，再看两个数是否含有相同的质因数，如果没有，这两个数是互质数。</p>
<p>例如：130和231，先将它们分解质因数：130＝2×5×13，231＝3×7×11,分解后，发现它们没有相同的质因数，所以130和231是互质数。</p>
<p>四、求差判断法</p>
<p>如果两个数相差不大。可先求出它们的差，再看差与其中较小数是否互质。如果是互质数，则原来两个数一定是互质数。</p>
<p>例如：194和201，先求出它们的差，201－194＝7，因为7和194互质，所以194和201是互质数。</p>
<p>五、求商判断法</p>
<p>用大数除以小数，如果除得的余数与其中较小数互质，则原来两个数是互质数。例如，317和52，317÷52＝6……5，因为余数5与52互质，所以317和52是互质数</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>利用1~7的随机数，产生一个1~10的随机数</title>
    <url>/article/csdn/%E5%88%A9%E7%94%A81~7%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%8C%E4%BA%A7%E7%94%9F%E4%B8%80%E4%B8%AA1~10%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40357517" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40357517</a></p>
<p>##</p>
<h2><span id="必须是等概率的">必须是等概率的。</span></h2><pre><code>int rand10()
{
    int i = rand7() - 1;
    int j = rand7() - 1;
    int num = rand7()*i + j;
    if ( num &gt;= 40 ) return rand10();
    else return num%10 + 1;
}
</code></pre><h3><span id="">[</span></h3><p>](<a href="https://github.com/ybai62868/Interview/blob/master/rand7\(\)-%3Erand10\(\).md#%E8%BF%99%E9%A2%98%E4%B8%80%E5%BC%80%E5%A7%8B%E6%88%91%E5%81%9A%E7%9A%84%E6%97%B6%E5%80%99%E6%88%91%E4%BB%A5%E4%B8%BA%E7%9B%B4%E6%8E%A5%E5%AF%B9%E8%BF%99%E4%B8%AArand7%E4%B9%989%E7%84%B6%E5%90%8E%E9%99%A4%E4%BB%A57%E5%86%8D%E5%8A%A0%E4%B8%80%E5%8F%91%E7%8E%B0%E8%BF%99%E7%A7%8D%E6%96%B9%E6%B3%95%E5%B9%B6%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81rand10%E6%98%AF%E7%AD%89%E6%A6%82%E4%BA%A7%E7%94%9F%E7%9A%84" target="_blank" rel="noopener">https://github.com/ybai62868/Interview/blob/master/rand7\(\)-%3Erand10\(\).md#%E8%BF%99%E9%A2%98%E4%B8%80%E5%BC%80%E5%A7%8B%E6%88%91%E5%81%9A%E7%9A%84%E6%97%B6%E5%80%99%E6%88%91%E4%BB%A5%E4%B8%BA%E7%9B%B4%E6%8E%A5%E5%AF%B9%E8%BF%99%E4%B8%AArand7%E4%B9%989%E7%84%B6%E5%90%8E%E9%99%A4%E4%BB%A57%E5%86%8D%E5%8A%A0%E4%B8%80%E5%8F%91%E7%8E%B0%E8%BF%99%E7%A7%8D%E6%96%B9%E6%B3%95%E5%B9%B6%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81rand10%E6%98%AF%E7%AD%89%E6%A6%82%E4%BA%A7%E7%94%9F%E7%9A%84</a>)<br>这题一开始我做的时候，我以为直接对这个rand7()乘9然后除以7再加一，，，发现这种方法并不能保证rand10()是等概产生的。</p>
<p>具体的过程是由于我们要得到的是[1,10]的随机数，那么我们可以先对这个区间减去1，得到[0,9]的随机数，然后我们现在的目标就是怎么把这个[0,9]的随机</p>
<p>数生成出来。那怎么得到这个[0,9]的随机数呢，我们发现这个随机数是对一个大于等于10的数字mod10后产生的结果，那么，既然我们知道这个的话，我们就</p>
<p>可以先将rand7()-1,得到[0,6]的随机数，然后将[0,6]的随机数都乘上7得到0,7,14,21,28,35,42.<br>然后可以对这个7个数字都加上一个rand7()-1,得到一个</p>
<p>[0,48]的数字，得到这个[0,48]的的数字后，我们在每次产生大于等于40的数字后，我们就可以再次调用rand10(),那么实际上就是一个[0,39]的数字</p>
<p>对这个区间中的数字mod10，我们就可以得到4个[0,9]的数字，这个区间的数字刚刚好就是我们想要的了。</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>匈牙利算法</title>
    <url>/article/csdn/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46491253" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46491253</a></p>
<p>匈牙利算法用于二分图的最大匹配，核心问题就是找增广路径。匈牙利算法的时间复杂度为O(VE)，其中V为二分图左边的顶点数，E为二分图中边的数目。</p>
<h4><span id="增广路性质">增广路性质：</span></h4><p>(1)有奇数条边。<br>(2)起点在二分图的左半边，终点在右半边。<br>(3)路径上的点一定是一个在左半边，一个在右半边，交替出现。<br>(4)整条路径上没有重复的点。<br>(5)起点和终点都是目前还没有配对的点，而其它所有点都是已经配好对的。<br>(6)路径上的所有第奇数条边都不在原匹配中，所有第偶数条边都出现在原匹配中。<br>(7)最后，也是最重要的一条，把增广路径上的所有第奇数条边加入到原匹配中去，并把增广路径中的所有第偶数条边从原<br>匹配中删除（这个操作称为增广路径的取反），则新的匹配数就比原匹配数增加了1个。</p>
<p>匹配开始时我们任意选择一边的所有未匹配的点为起始点找增广路径，由增广路的性质可以看出，每找到一条增广路径，匹配数增加1。</p>
<h3><span id="二分图匹配模型几种常见变形">二分图匹配模型,几种常见变形：</span></h3><p>(1)二分图的最小顶点覆盖<br>最小顶点覆盖要求用最少的点（X或Y中都行），让每条边都至少和其中一个点关联。<br>Knoig定理：二分图的最小顶点覆盖数等于二分图的最大匹配数。</p>
<p>(2)DAG图的最小路径覆盖<br>用尽量少的不相交简单路径覆盖有向无环图(DAG)G的所有顶点，这就是DAG图的最小路径覆盖问题。<br>结论：DAG图的最小路径覆盖数 = 节点数（n）- 最大匹配数（m）</p>
<p>(3)二分图的最大独立集<br>最大独立集问题： 在Ｎ个点的图G中选出m个点，使这m个点两两之间没有边．求m最大值<br>结论：二分图的最大独立集数 = 节点数（n）— 最大匹配数（m）</p>
<h3><span id="总结">总结：</span></h3><p>简单点说，就是你从二分图中找出一条路径来，让路径的起点和终点都是还没有匹配过的点，并且路径经过的连线是一条没被匹配、一条已经匹配过，再下一条又没匹配这样交替地出现。找到这样的路径后，显然路径里没被匹配的连线比已经匹配了的连线多一条，于是修改匹配图，把路径里所有匹配过的连线去掉匹配关系，把没有匹配的连线变成匹配的，这样匹配数就比原来多1个。不断执行上述操作，直到找不到这样的路径为止。</p>
<h3><span id="伪代码">伪代码：</span></h3><pre><code>bool 寻找从k出发的对应项出的可增广路
{
    while (从邻接表中列举k能关联到顶点j)
    {
        if (j不在增广路上)
        {
            把j加入增广路;
            if (j是未盖点 或者 从j的对应项出发有可增广路)
            {
                修改j的对应项为k;
                则从k的对应项出有可增广路,返回true;
            }
        }
    }
    则从k的对应项出没有可增广路,返回false;
}

void 匈牙利hungary()
{
    for i-&gt;1 to n
    {
        if (则从i的对应项出有可增广路)
            匹配数++;
    }
    输出 匹配数;
}
</code></pre><h3><span id="邻接矩阵模板">邻接矩阵模板：</span></h3><pre><code>int n, m;
int p[1510][1510];//图
int book[1510];
int match[1510];//保存匹配边

bool dfs(int u)
{
    int i;
    for (i = 0; i &lt; n; i++)
    {
        if (book[i] == 0 &amp;&amp; p[u][i] == 1)
        {
            book[i] = 1;
            if (match[i] == 0 || dfs(match[i]))
            {
                match[i] = u;
                return true;
            }
        }
    }
    return false;
}
int gungary()
{
    int ans = 0;
    memset(match, 0, sizeof(match));
    for (int i = 0; i &lt; n; i++)
    {
        memset(book, 0, sizeof(book));
        if (dfs(i))
            ans++;
    }
    return ans;
}
</code></pre><h3><span id="邻接表模板">邻接表模板：</span></h3><pre><code>const int MAXN = 5010;//点
const int MAXM = 50010;//边

struct  Edge
{
    int to;
    int next;
}edge[MAXM];

int head[MAXN], tot;

void init()
{
    tot = 0;
    memset(head,-1,sizeof(head));
}

void addedge(int u,int v)
{
    edge[tot].to = v;
    edge[tot].next = head[u];
    head[u] = tot++;
}

int linker[MAXN];
bool used[MAXN];
int uN;

bool dfs(int u)
{
    for (int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].to;
        if (!used[v])
        {
            used[v] = true;
            if (linker[v] == -1 || dfs(linker[v]))
            {
                linker[v] = u;
                return true;
            }
        }
    }
    return false;
}

int hungary()
{
    int ans = 0;
    memset(linker,-1,sizeof(linker));
    for (int u = 0; u &lt; uN; u++)
    {
        memset(used,false,sizeof(used));
        if (dfs(u)) ans++;
    }
    return ans;
}
</code></pre><p>转自：<br><a href="https://www.byvoid.com/blog/hungary/" target="_blank" rel="noopener"> https://www.byvoid.com/blog/hungary/ </a><br><a href="http://blog.csdn.net/acdreamers/article/details/8621130" target="_blank" rel="noopener"> http://blog.csdn.net/acdreamers/article/details/8621130
</a></p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>区间DP</title>
    <url>/article/csdn/%E5%8C%BA%E9%97%B4DP.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46383345" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46383345</a></p>
<p>区间动态规划问题一般都是考虑，对于每段区间，他们的最优值都是由几段更小区间的最优值得到，是分治思想的一种应用，将一个区间问题不断划分为更小的区间直至一个元素组成的区间，枚举他们的组合，求合并后的最优值。<br>1 设F[i,j]（1&lt;=i&lt;=j&lt;=n）表示区间[i,j]内的数字相加的最小代价<br>2 最小区间F[i,i]=0（一个数字无法合并)∴代价为0</p>
<pre><code>     3  每次用变量k（i&lt;=k&lt;=j-1）将区间分为[i,k]和[k+1,j]两段

     4《区间DP模板，代码》



for (int p = 1; p &lt;= n; p++)//p是区间的长度，作为阶段
{
    for (int i = 1; i &lt;= n - p; i++)//i是穷举区间的起点
    {       
        int j = i + p;//j为区间的终点
        for (int k = i + 1; k &lt; j; k++)//状态转移
            dp[i][j] = min{ dp[i][k] + dp[k + 1][j] + w[i][j] };//这个是看具体的状态转移方程

        或 dp[i][j] = max{ dp[i][k] + dp[k + 1][j] + w[i][j] };//求最大

        或  dp[i][j] = min{ dp[i][k] + dp[k][j] + w[i][j] }//有的是要从k开始不是k+1

    }
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>变形金刚 【并查集】</title>
    <url>/article/csdn/%E5%8F%98%E5%BD%A2%E9%87%91%E5%88%9A_%E3%80%90%E5%B9%B6%E6%9F%A5%E9%9B%86%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44319309" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44319309</a></p>
<p>变形金刚<br>Description<br>有一天Stubird买了一台变形金刚，店员说，这台变形金刚和其他那种骗小孩子的不一样 他真的能变形。<br>这台变形金刚有n个部件，他们能互相连接，组成机器人，当然，也可以变形。 但是有一天，The tesseract<br>的能量突然消失了，部件散落一地，当然有些部件还连接着。 现在你只有把部件全部连接起来，他就能变回原样，例如，有4个部件，1,2是连接的，3,4也是连接着的<br>，你只需要把1和3连接起来（1,4或者2,3或者2,4）他就能变回原样啦。 他现在问你最少需要多少次连接才能把它变回原样？</p>
<p>Input<br>第一行一个T，表示有T个测试样例 接下来一个n和m(n&lt;=10^5,0&lt;=m&lt;=10^5)，n表示部件个数，m表示有多少个部件还连接着<br>下面m行，每行u，v表示部件u，v是连接着的。(1&lt;=u,v&lt;=n)</p>
<p>Output<br>求最小的连接次数</p>
<p>Sample Input<br>2<br>1 0<br>5 2<br>1 2<br>3 4<br>Sample Output<br>0<br>2</p>
<p>题意：判断有几个不相交集合</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;algorithm&gt;  
#include &lt;string.h&gt;  

using namespace std;

int p[30005];
int rankk[30005];

int findd(int x)
{
    if (x == p[x])
        return x;
    else return  p[x] = findd(p[x]);
}

void un(int x, int y)
{
    int a, b;
    a = findd(x);
    b = findd(y);
    if (a == b)
        return;
    p[b] = a;
}

int main()
{
    int n, m, t, a, b;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
        for (int i = 1; i&lt;=n; i++)
        {
            p[i] = i;
            rankk[i] = 0;
        }

        for (int i = 0; i&lt;m; i++)
        {
            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
            un(a,b);
        }

        int ans = 0;
        int f1 = findd(1);
        for (int i = 2; i &lt;= n; i++)
        {
            int fi = findd(i);
            if (fi != f1)
            {
                p[fi] = f1;
                ans++;
            }
        }
        printf(&quot;%d\n&quot;, ans);
    }
}
</code></pre><p>或</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;algorithm&gt;  
#include &lt;string.h&gt;  

using namespace std;

int p[30005];
int rankk[30005];
int vis[30000];

int findd(int x)
{
    if (x == p[x])
        return x;
    else return  p[x] = findd(p[x]);
}

void un(int x, int y)
{
    int a, b;
    a = findd(x);
    b = findd(y);
    if (a == b)
        return;
    p[b] = a;
}

int main()
{
    int n, m, t, a, b;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
        for (int i = 1; i&lt;=n; i++)
        {
            p[i] = i;
            rankk[i] = 0;
            vis[i] = 0;
        }

        for (int i = 0; i&lt;m; i++)
        {
            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
            un(a,b);
        }

        int ans = 0;
        for (int i = 1; i &lt;= n; i++)
        {
            int fa = findd(i);
            if (!vis[fa])
            {
                vis[fa] = 1;
                ans++;
            }
        }

        printf(&quot;%d\n&quot;, ans-1);
    }
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>原根（最小）</title>
    <url>/article/csdn/%E5%8E%9F%E6%A0%B9%EF%BC%88%E6%9C%80%E5%B0%8F%EF%BC%89.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46380515" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46380515</a></p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;math.h&gt;

using namespace std;

const int MAXN = 100000;

int prime[MAXN+1];

void getPrime()
{
    memset(prime,0,sizeof(prime));
    for (int i = 2; i &lt;= MAXN; i++)
    {
        if (!prime[i]) prime[++prime[0]] = i;
        for (int j = 1; j &lt;= prime[0] &amp;&amp; prime[j] &lt;= MAXN / i; j++)
        {
            prime[prime[j] * i] = 1;
            if (i%prime[j] == 0) break;
        }
    }
}
long long factor[100][2];
int fatcnt;
int getFactor(long long x)
{
    fatcnt = 0;
    long long tmp = x;
    for (int i = 1; prime[i] &lt;= tmp / prime[i]; i++)
    {
        factor[fatcnt][1] = 0;
        if (tmp%prime[i] == 0)
        {
            factor[fatcnt][0] = prime[i];
            while (tmp%prime[i] == 0)
            {
                factor[fatcnt][1]++;
                tmp /= prime[i];
            }
            fatcnt++;
        }
    }
    if (tmp != 1)
    {
        factor[fatcnt][0] = tmp;
        factor[fatcnt++][1] = 1;
    }
    return fatcnt;
}
long long pow_m(long long m, long long n, long long  k)
{
    long long  b = 1;
    while (n)
    {
        if (n &amp; 1)
            b = (b*m) % k;
        n = n &gt;&gt; 1;
        m = (m*m) % k;
    }
    return b;
}

void solve(int p)
{
    if (p == 2)
    {
        printf(&quot;1\n&quot;);
        return;
    }
    getFactor(p-1);
    for (int g = 2; g &lt; p; g++)
    {
        bool flag = true;
        for (int i = 0; i &lt; fatcnt; i++)
        {
            int t = (p - 1) / factor[i][0];
            if (pow_m(g, t, p) == 1)
            {
                flag = false;
                break;
            }
        }
        if (flag)
        {
            printf(&quot;%d\n&quot;,g);
            return;//若求所有原根去掉return即可。
        }
    }
}

int main()
{
    getPrime();
    int p;
    while (scanf(&quot;%d&quot;, &amp;p)!=EOF)
    {
        solve(p);
    }
    return 0;
}
</code></pre><p>ACdreamer 对原根的详解： <a href="http://blog.csdn.net/acdreamers/article/details/8883285" target="_blank" rel="noopener"> http://blog.csdn.net/acdreamers/article/details/8883285
</a></p>
<p>百度百科： <a href="http://baike.baidu.com/link?url=15SrOU2zwh6ZV1hYBI7QR9VrbSPpzXP0iUYWkLR9oWHJhWKmlI69ObQ1H_29FE19sXbpGUN9RHFVBaIz7jgfaa" target="_blank" rel="noopener"><br>http://baike.baidu.com/link?url=15SrOU2zwh6ZV1hYBI7QR9VrbSPpzXP0iUYWkLR9oWHJhWKmlI69ObQ1H_29FE19sXbpGUN9RHFVBaIz7jgfaa
</a></p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>合法字符串 【动态规划】</title>
    <url>/article/csdn/%E5%90%88%E6%B3%95%E5%AD%97%E7%AC%A6%E4%B8%B2_%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46760729" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46760729</a></p>
<p>字符串只有可能有A、B、C三个字母组成，如果任何紧邻的三个字母相同，就非法。求长度为n的合法字符串有多少个？比如：<br>ABBBCA是非法，ACCBCCA是合法的。</p>
<p>动态规划的思路——真的要枚举么？<br>dp[i][0] : 长度为i的、最后两位不同的合法串的个数<br>dp[i][1]: 长度为 i的、最后两位相同的合法串的个数<br>递推: dp[i][0] = (dp[i-1][0] <em> 2 + dp[i-1][1] </em> 2)<br>dp[i][1] = dp[i-1][0]</p>
<p>初值<br>dp[1][0] = 3, dp[1][1] = 0<br>结果<br>dp[n][0] + dp[n][1]<br>空间优化<br>dp[i][0,1]只与dp[i-1][0,1]相关，可以省掉高维<br>时间复杂度<br>O(n)</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>四种GCC内置位运算函数</title>
    <url>/article/csdn/%E5%9B%9B%E7%A7%8DGCC%E5%86%85%E7%BD%AE%E4%BD%8D%E8%BF%90%E7%AE%97%E5%87%BD%E6%95%B0.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46384019" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46384019</a></p>
<p>int <strong>builtin_ffs (unsigned int x)<br>返回x的最后一位1的是从后向前第几位，比如7368（1110011001000）返回4。<br>int </strong>builtin_clz (unsigned int x)<br>返回前导的0的个数。<br>int <strong>builtin_ctz (unsigned int x)<br>返回后面的0个个数，和</strong>builtin_clz相对。<br>int <strong>builtin_popcount (unsigned int x)<br>返回二进制表示中1的个数。<br>int </strong>builtin_parity (unsigned int x)<br>返回x的奇偶校验位，也就是x的1的个数模2的结果。<br>此外，这些函数都有相应的usigned long和usigned long long版本，只需要在函数名后面加上l或ll就可以了，比如int<br>__builtin_clzll。</p>
<p>转自： <a href="http://rchardx.is-
programmer.com/posts/14719.html" target="_blank" rel="noopener"> http://rchardx.is-programmer.com/posts/14719.html </a></p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>哈希表VS红黑树</title>
    <url>/article/csdn/%E5%93%88%E5%B8%8C%E8%A1%A8VS%E7%BA%A2%E9%BB%91%E6%A0%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/52558993" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/52558993</a></p>
<h2><span id="hash">Hash</span></h2><p>Hash，也可以称为“散列”，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。这是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出（也就是多对一的关系）。</p>
<h3><span id="哈希表的构造">哈希表的构造</span></h3><p>在所有的线性数据结构中，数组的定位速度最快，因为它可通过数组下标直接定位到相应的数组空间，就不需要一个个查找。而哈希表就是利用数组这个能够快速定位数据的结构解决以上的问题的。<br>“数组可以通过下标直接定位到相应的空间”，对就是这句，哈希表的做法其实很简单，就是把Key通过一<br>个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标<br>的数组空间里，而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分<br>利用到数组的定位性能进行数据定位。</p>
<p>通过关键字除以槽数m将关键字映射到槽里的方法。哈希函数是H(k)=k Mod m。<br>举个例子，m=12，k=100，H(100)=4。<br>而如果m=2k，那么无论k是什么，H(K)的值都是一个0和奇数，也即是说只要奇数槽和0槽被占用，其他的偶数槽都是浪费掉了。如果m=2^r，那么H(k)的值就是k的低r位（化成二进制）。这样造成的后果是某一个槽有很多的关键字。所以来说一般的m取值尽量不要接近2的整数幂，而且还要是质数。</p>
<p>虽然我们不希望发生冲突（同一个key有多个value），但实际上发生冲突的可能性仍是存在的。当关键字值域远大于哈希表的长度，而且事先并不知道关键字的具体取值时。冲突就难免会发生。另外，当关键字的实际取值大于哈希表的长度时，而且表中已装满了记录，如果插入一个新记录，不仅发生冲突，而且还会发生溢出。因此，处理冲突和溢出是哈希技术中的两个重要问题。一般有开放地址法、链地址法。</p>
<h3><span id="适用范围">适用范围</span></h3><p>快速查找，删除的基本数据结构，通常需要总数据量可以放入内存。</p>
<h2><span id="map">Map</span></h2><p>Map是C++标准库STL提供的一类关联式容器，提供key-value的存储和查找功能。<br>Map是基于红黑树的（同样set也是），那么它的查找速度是log(n)级别的。<br>它的优点是占用内存小。</p>
<h2><span id="hash与map的区别">Hash与Map的区别</span></h2><p>权衡三个因素: 查找速度, 数据量, 内存使用，可扩展性，有序性。<br>总体来说，hash查找速度会比RB树快，而且查找速度基本和数据量大小无关，属于常数级别;而RB树的查找速度是log(n)级别。并不一定常数就比log(n)<br>小，因为hash还有hash函数的耗时。当元素达到一定数量级时，考虑hash。但若你对内存使用特别严格，<br>希望程序尽可能少消耗内存，那么hash可能会让你陷入尴尬，特别是当你的hash对象特别多时，你就更无法控制了，而且 hash的构造速度较慢。<br>红黑树并不适应所有应用树的领域。如果数据基本上是静态的，那么让他们待在他们能够插入，并且不影响平衡的地方会具有更好的性能。如果数据完全是静态的，例如，做一个哈希表，性能可能会更好一些。</p>
<p>在实际的系统中，例如，需要使用动态规则的防火墙系统，使用红黑树而不是散列表被实践证明具有更好的伸缩性。Linux内核在管理vm_area_struct时就是采用了红黑树来维护内存块的。</p>
<h2><span id="总结">总结：</span></h2><p>红黑树是有序的，Hash是无序的，根据需求来选择。<br>红黑树占用的内存更小（仅需要为其存在的节点分配内存），而Hash事先就应该分配足够的内存存储散列表（即使有些槽可能遭弃用）。<br>红黑树查找和删除的时间复杂度都是O(logn)，Hash查找和删除的时间复杂度都是O(1)。<br>补充：<br>如果只需要判断Map中某个值是否存在之类的操作，当然是Hash实现的要更加高效。<br>如果是需要将两个Map求并集交集差集等大量比较操作，就是红黑树实现的Map更加高效。</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>图论——并查集</title>
    <url>/article/csdn/%E5%9B%BE%E8%AE%BA%E2%80%94%E2%80%94%E5%B9%B6%E6%9F%A5%E9%9B%86.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43087169" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43087169</a></p>
<pre><code>/*
    并查集模板
        by：mfcheer
*/

#include &lt;iostream&gt;  
#include &lt;cstdio&gt;  
#include &lt;string&gt;  
#include &lt;cstring&gt;  
#include &lt;cstdlib&gt;  
#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  

using namespace std;
#define N 100010

int n, m;
int fa[N];

int findd(int x)
{
    if (fa[x] == -1)
        return x;
    else
        return fa[x] = findd(fa[x]);
}

void un(int x, int y)
{
    int fx = findd(x);
    int fy = findd(y);
    if (fx == fy)
        return;
    fa[fx] = fy;
}

int main()
{
    memset(fa, -1, sizeof(fa));
    while (cin &gt;&gt; n &gt;&gt; m)
    {
        un(n,m);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>图论——最小生成树</title>
    <url>/article/csdn/%E5%9B%BE%E8%AE%BA%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43114029" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43114029</a></p>
<p>通过：poj-1287</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;

using namespace std;
#define INF 10000000

int n, m;
int a, b, c;

int map[100][100], dis[100], v[100];

int prim(int n)
{
    int i, j, k, min, sum = 0;
    for (i = 1; i &lt;= n; i++)
        dis[i] = map[1][i];

    memset(v, 0, sizeof(v));
    v[1] = 1;
    dis[1] = 0;

    for (i = 2; i &lt;= n; i++)
    {
        k = 1;
        min = INF;
        for (j = 1; j &lt;= n; j++)
            if (!v[j] &amp;&amp; min&gt;dis[j])
            {
                k = j;
                min = dis[j];
            }
        sum += min;
        v[k] = 1;
        for (j = 1; j &lt;= n; j++)
            if (!v[j] &amp;&amp; dis[j]&gt;map[k][j])
                dis[j] = map[k][j];
    }
    return sum;
}

int main()
{
    while (scanf(&quot;%d %d&quot;, &amp;n, &amp;m) != EOF )
    {
        if (n == 0)
            break;
        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= n; j++)
                map[i][j] = INF;

        while (m--)
        {
            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
            if (map[a][b] &gt;= c)
            {
                map[a][b] = map[b][a] = c;
            }
        }
        printf(&quot;%d\n&quot;,prim(n));
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title>图论——最短路径——dij</title>
    <url>/article/csdn/%E5%9B%BE%E8%AE%BA%E2%80%94%E2%80%94%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E2%80%94%E2%80%94dij.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43228887" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43228887</a></p>
<p>dij 模板</p>
<p>通过 poj 2387 求去点1 -点 n 的最短路径</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

using namespace std;

const int MAXV = 4010;
const int inf = 10000000;

int map[MAXV][MAXV];//路径长度
int d[MAXV];//距离
bool vis[MAXV];
int n,m;

void dijkstra(int s)
{
    for(int i=1;i&lt;=n;i++)
    {
        vis[i]=0;
        d[i]=map[s][i];
    }

    while (1)
    {
        int min=inf,v = -1;
        for(int i=1;i&lt;=n;i++)
            if(!vis[i] &amp;&amp; d[i]&lt;min)
            {
                v=i;
                min=d[i];
            }
        if(v == -1)
            break;
        vis[v]=1;
        for(int i=1;i&lt;=n;i++)
            if(!vis[i] &amp;&amp; d[i] &gt; d[v] + map[v][i])
                d[i]=map[v][i]+d[v];
    }
}

int main()
{
    int i,j,a,b,c;
    while(scanf(&quot;%d%d&quot;,&amp;m,&amp;n) != EOF)
    {
        for(i=1;i&lt;=n;i++)
            for(j=1;j&lt;=n;j++)
            {
                if(i==j)
                    map[i][i]=0;
                else
                    map[i][j]=map[j][i]=inf;
            }
            for(i=1;i&lt;=m;i++)
            {
                scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
                if(map[a][b]&gt;c)
                    map[a][b]=map[b][a]=c;
            }
        dijkstra(1);
        printf(&quot;%d\n&quot;,d[n]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>图论——最短路径——floyd</title>
    <url>/article/csdn/%E5%9B%BE%E8%AE%BA%E2%80%94%E2%80%94%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E2%80%94%E2%80%94floyd.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43230613" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43230613</a></p>
<p>floyd 模板</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;time.h&gt;

using namespace std;

int d[1110][1110];

int main ()    
{
    int n,m;
    while (scanf (&quot;%d %d&quot;,&amp;n,&amp;m)!=EOF)
    {
        for (int i=0;i&lt;n;i++)
            for (int j=0;j&lt;n;j++)
            {
                if (i==j)
                    d[i][j]=0;
                else 
                    d[i][j]=1000010;
            }

        int a,b,c;
        for (int i=0;i&lt;m;i++)
        {
            scanf (&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
            if (d[a][b]&gt;c)
            {
                d[a][b]=d[b][a]=c;
            }
        }

        for (int k=0;k&lt;n;k++)
            for (int i=0;i&lt;n;i++)
                for (int j=0;j&lt;n;j++)
                {
                    if (  d[i][j] &gt;  d[i][k]+d[k][j] )
                        d[i][j] =  d[i][k]+d[k][j] ;
                }

        int start ,end;
        scanf (&quot;%d %d&quot;,&amp;start ,&amp;end);

        if (d[start][end]==1000010)
            printf(&quot;-1\n&quot;);
        else
            printf(&quot;%d\n&quot;,d[start][end]);

    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>基于Socket的网络聊天室</title>
    <url>/article/csdn/%E5%9F%BA%E4%BA%8ESocket%E7%9A%84%E7%BD%91%E7%BB%9C%E8%81%8A%E5%A4%A9%E5%AE%A4.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/52373859" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/52373859</a></p>
<pre><code>from asyncore import dispatcher
from asynchat import async_chat
import socket, asyncore

PORT = 5005
NAME = &quot;ChatRoom&quot;

class EndSession(Exception):pass

class CommandHandler:
    def unknow(self, session, cmd):
        session.push(&#39;Unknow commans %s\r\n &#39;% cmd)

    def handle(self, session, line):
        if not line.strip(): return
        parts = line.split(&#39; &#39;,1)
        cmd = parts[0]
        try:line = parts[1].strip()
        except IndexError :line = &#39; &#39;

        meth = getattr(self, &#39;do_&#39;+cmd, None)

        try:
            meth(session, line)
        except TypeError:
            self.unknow(session, cmd)

class Room(CommandHandler):

    def __init__(self, server):
        self.server = server
        self.sessions =[]

    def add(self,session):
        self.sessions.append(session)

    def remove(self, session):
        self.sessions.remove(session)

    def broadcast(self, line):
        for session in self.sessions:
            session.push(line)

    def do_logout(self, session, line):
        raise EndSession

class LoginRoom(Room):
    def add(self, session):
        Room.add(self,session)
        self.broadcast(&#39;welcome to %s \r\n &#39;% self.server.name)
    def unknow(self, session, cmd):
        session.push(&#39;Please log in \nuse &quot;login &lt;nick&gt;&quot;\r\n&#39;)

    def do_login(self, session, line):
        name = line.strip()
        if not name:
            session.push(&#39;please enter a name\r\n&#39;)
        elif name in self.server.users:
            session.push(&#39;The name &quot;%s&quot; is taken.\r\n&#39; % name)
            session.push(&#39;Please try again&#39;)
        else:
            session.name = name
            session.enter(self.server.main_room)

class ChatRoom(Room):
    def add(self,session):
        self.broadcast(session.name + &#39; has entered the room\r\n&#39;)
        self.server.users[session.name] = session
        Room.add(self, session)
    def remove(self, session):
        Room.remove(self, session)
        self.broadcast(session.name + &#39; has left the room&#39;)
    def do_say(self, session, line):
        self.broadcast(session.name+&#39;: &#39; + line + &#39;\r\n&#39;)

    def do_look(self, session, line):
        session.push(&#39;The following are in room:\r\n&#39;)
        for other in self.sessions:
            session.push(other.name + &#39; \r\n&#39;)
    def do_who(self,session, line):
        session.push(&#39;The Following are loffed in: \r\n&#39;)
        for name in self.server.users:
            session.push(name + &#39;\r\n&#39;)
class LogoutRoom(Room):
    def add(self,session):
        try:del self.server.users[session.name]
        except KeyError:pass

class ChatSession(async_chat):
    def __init__(self, server , sock):
        async_chat.__init__(self,sock)
        self.server = server
        self.set_terminator(&quot;\r\n&quot;)
        self.data = []
        self.name = None
        self.enter(LoginRoom(server))

    def enter(self, room):
        try: cur = self.room
        except AttributeError:pass
        else: cur.remove(self)
        self.room = room
        room.add(self)

    def collect_incoming_data(self, data):
        self.data.append(data)

    def found_terminator(self):
        line = &#39;&#39;.join(self.data)
        self.data = []
        try: self.room.handle(self,line)
        except EndSession:
            self.handle_close()
    def handle_close(self):
        async_chat.handle_close(self)
        self.enter(LoginRoom(self.server))

class ChatServer(dispatcher):
    def __init__(self,port ,name):
        dispatcher.__init__(self)
        self.create_socket(socket.AF_INET,socket.SOCK_STREAM)
        self.set_reuse_addr()
        self.bind((&#39;&#39;,port))
        self.listen(5)
        self.name = name
        self.users ={}
        self.main_room = ChatRoom(self)

    def handle_accept(self):
        conn, addr = self.accept()
        ChatSession(self, conn)

if __name__ == &#39;__main__&#39;:
    s = ChatServer(PORT,NAME)
    try:asyncore.loop()
    except KeyboardInterrupt: print
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>图论——次小生成树</title>
    <url>/article/csdn/%E5%9B%BE%E8%AE%BA%E2%80%94%E2%80%94%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/43193753" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/43193753</a></p>
<p>次小生成树模板</p>
<p>通过poj 1679</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;

using namespace std;
#define INF 10000000

/*
 * 次小生成树
 * 求最小生成树时，用数组Max[i][j]来表示MST中i到j最大边权
 * 求完后，直接枚举所有不在MST中的边，替换掉最大边权的边，更新答案
 * 点的编号从1开始
 */
const int MAXN=110;
bool vis[MAXN];
int lowc[MAXN];
int pre[MAXN];//记录前驱节点
int Max[MAXN][MAXN];//Max[i][j]表示在最小生成树中从i到j的路径中的最大边权
bool used[MAXN][MAXN];//是否是最小生成树的边

int Prim(int cost[][MAXN],int n)
{
    int ans=0;
    memset(vis,false,sizeof(vis));
    memset(Max,0,sizeof(Max));
    memset(used,false,sizeof(used));
    memset(lowc,0,sizeof(lowc));

    for(int i=1;i&lt;=n;i++)
    {
        lowc[i]=cost[1][i];
        pre[i]=1;
    }
    lowc[1]=0;
    vis[1]=true;
    pre[1]=-1; 

    for(int i=1;i&lt;n;i++)
    {
        int minc=INF;
        int p=-1;
        for(int j=1;j&lt;=n;j++)
            if(!vis[j] &amp;&amp; minc &gt; lowc[j])
            {
                minc = lowc[j];
                p = j;
            }
        if(minc==INF)
            return -1;

        ans += minc;
        vis[p]=true;
        used[p][pre[p]]=used[pre[p]][p]=true;

        for(int j=1;j&lt;=n;j++)
        {
            if(vis[j])
                Max[j][p]=Max[p][j]=max(Max[j][pre[p]],lowc[p]);

            if(!vis[j]&amp;&amp;lowc[j]&gt;cost[p][j])
            {
                lowc[j]=cost[p][j];
                pre[j]=p;
            }
        }
    }
    return ans;
}
int ans;
int smst(int cost[][MAXN],int n)//求次小生成树
{
    int Min=INF;
    for(int i=1;i&lt;=n;i++)
        for(int j=i+1;j&lt;=n;j++)
            if(cost[i][j]!=INF &amp;&amp; !used[i][j])
            {
                Min=min(Min,ans+cost[i][j]-Max[i][j]);
            }
    if(Min==INF)
        return -1;//不存在
    return Min;
}
int cost[MAXN][MAXN];
int main()
{
    int T;
    int n,m;
    scanf(&quot;%d&quot;,&amp;T);
    while(T--)
    {
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
        int u,v,w;
        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;=n;j++)
            {
                if(i==j)
                    cost[i][j]=0;
                else
                    cost[i][j]=INF;
            }
        while(m--)
        {
            scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);
            if (cost[u][v] &gt; w)
                cost[u][v]=cost[v][u]=w;
        }

        ans=Prim(cost,n);
        if(ans==smst(cost,n))
            printf(&quot;Not Unique!\n&quot;);//次小生成树和最小生成树一样大
        else
            printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>士兵杀敌 三 【ST算法】</title>
    <url>/article/csdn/%E5%A3%AB%E5%85%B5%E6%9D%80%E6%95%8C_%E4%B8%89_%E3%80%90ST%E7%AE%97%E6%B3%95%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47007631" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47007631</a></p>
<p>题目链接：<br><a href="http://acm.nyist.net/JudgeOnline/problem.php?pid=119" target="_blank" rel="noopener"> http://acm.nyist.net/JudgeOnline/problem.php?pid=119
</a></p>
<p>解法：　RMQ问题。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctime&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;list&gt;
#include &lt;bitset&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

using namespace std;

int n, k, p, l, r;

int a[100010];
int s[100010][20];
int maxsum[100010][20], minsum[100010][20];

int rmq(int l, int r)
{
    int k = log2((double)(r - l + 1));
    int MAX = max(maxsum[l][k], maxsum[r - (1 &lt;&lt; k) + 1][k]);
    int MIN = min(minsum[l][k], minsum[r - (1 &lt;&lt; k) + 1][k]);
    return MAX - MIN;
}

int main()
{
    int t;
    int q;
    while (scanf(&quot;%d %d&quot;, &amp;n, &amp;q)!=EOF)
    { 
        for (int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;, &amp;a[i]); 
            maxsum[i][0] = minsum[i][0] = a[i];
        }

        for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++)
            for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++)
                {
                    maxsum[i][j] = max(maxsum[i][j - 1], maxsum[i + (1 &lt;&lt; (j - 1))][j - 1]);
                    minsum[i][j] = min(minsum[i][j - 1], minsum[i + (1 &lt;&lt; (j - 1))][j - 1]);
                }

        int s, t;
        while (q--)
        {
            scanf(&quot;%d%d&quot;,&amp;s,&amp;t);
            printf(&quot;%d\n&quot;, rmq(s, t));
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>奇怪的排序 【简单题】</title>
    <url>/article/csdn/%E5%A5%87%E6%80%AA%E7%9A%84%E6%8E%92%E5%BA%8F_%E3%80%90%E7%AE%80%E5%8D%95%E9%A2%98%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44156865" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44156865</a></p>
<h2><span id="奇怪的排序">奇怪的排序</span></h2><p>Time Limit:  1 Sec  Memory Limit:  128 MB<br>Submit:  60  Solved:  39<br>[ <a href="http://www.homeforaoge.com/submitpage.php?id=1002" target="_blank" rel="noopener"> Submit </a> ][ <a href="http://www.homeforaoge.com/problemstatus.php?id=1002" target="_blank" rel="noopener"> Status
</a> ][ <a href="http://www.homeforaoge.com/bbs.php?pid=1002" target="_blank" rel="noopener"> Web Board
</a> ]</p>
<h2><span id="description">Description</span></h2><p>最近，Dr. Kong<br>新设计一个机器人Bill。这台机器人很聪明，会做许多事情。惟独对自然数的理解与人类不一样,它是从右往左读数。比如，它看到123时，会理解成321。让它比较23与15哪一个大，它说15大。原因是它的大脑会以为是32与51在进行比较。再比如让它比较29与30，它说29大。</p>
<p>给定Bill两个自然数A和B，让它将 [A，B] 区间中的所有数按从小到大排序出来。你会认为它如何排序？</p>
<h2><span id="input">Input</span></h2><p>第一行： <strong>N</strong> 表示有多少组测试数据。</p>
<p>接下来有N行，    每一行有两个正整数A B  表示待排序元素的区间范围。</p>
<h2><span id="output">Output</span></h2><p>对于每一行测试数据，输出一行，为所有排好序的元素，元素之间有一个空格。</p>
<h2><span id="sample-input">Sample Input</span></h2><pre><code> 2


8 15


22 39
</code></pre><h2><span id="sample-output">Sample Output</span></h2><pre><code>10 8 9 11 12 13 14 15


30 31 22 32 23 33 24 34 25 35 26 36 27 37 28 38 29 39
</code></pre><h2><span id="hint">HINT</span></h2><p>2&lt;=N&lt;=5      1&lt;=A&lt;=B&lt;=200000  B-A&lt;=50。</p>
<h2><span id="source">Source</span></h2><p><a href="http://www.homeforaoge.com/problemset.php?search=%E7%AC%AC%E4%BA%94%E5%B1%8A%E6%B2%B3%E5%8D%97%E7%9C%81%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B" target="_blank" rel="noopener"> 第五届河南省大学生程序设计竞赛
</a></p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;

using namespace std;

int t, x;
int n, m;
char q[100000];

struct node
{
    int x;
    int rx;
}p[10000000];

bool cmp(node a,node b)
{
    return a.rx &lt;= b.rx;
}

int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
        for (int i = n; i &lt;= m; i++)
        {
            p[i].x = i;
            sprintf(q,&quot;%d&quot;,i);
            int len = strlen(q);
            p[i].rx = 0;
            for (int j = len - 1; j &gt;= 0; j--)
            {
                p[i].rx += pow(10,j) * (int )(q[j] - &#39;0&#39;);
            }
        }
        sort(p + n, p + m + 1,cmp);
        for (int i = n; i &lt;= m; i++)
        {
            printf(&quot;%d&quot;, p[i].x);
            if (i != m)
                printf(&quot; &quot;);
            else
                printf(&quot;\n&quot;);
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>字符串匹配 【kmp】</title>
    <url>/article/csdn/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D_%E3%80%90kmp%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44758395" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44758395</a></p>
<p>字符串匹配<br>Time Limit: 1 Sec Memory Limit: 128 MB<br>Submit: 214 Solved: 81<br>Description<br>给你两个字符串A，B，请输出B字符串在A字符串中出现了几次。</p>
<p>Input<br>多组测试数据，每组输入两个字符串。字符串的长度 &lt;= 1000000.</p>
<p>Output<br>输出B在A中出现的次数。</p>
<p>Sample Input<br>aaa aa<br>Sample Output<br>1</p>
<p>子串在母串中出现的次数，串不重叠</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;iostream&gt;  
#include &lt;math.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;ctype.h&gt;  
#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;stack&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;sstream&gt;  
#include &lt;time.h&gt;  
#include &lt;malloc.h&gt;  

using namespace std;

void get_next(char x[], int m,int Next[])
{
    int i, j;
    j = Next[0] = -1;
    i = 0;
    while (i &lt; m)
    {
        while (-1 != j &amp;&amp; x[i] != x[j]) j = Next[j];
        Next[++i] = ++j;
    }
}

int Next[1001000];
int KMP(char x[], int m, char y[], int n)//x模式串 y主串 
{
    int i, j, ans = 0;
    i = j = 0;
    get_next(x, m, Next);
    while(i &lt; n)
    {
        while (-1 != j &amp;&amp; y[i] != x[j])
            j = Next[j];
        i++; j++;
        if (j &gt;= m)
        {
            ans++;
            j = 0;
        }
    }
    return ans;
}
char a[1000100], b[1000100];

int main()
{
    while (scanf(&quot;%s&quot;, a)!=EOF)
    {
        scanf(&quot;%s&quot;, b);
        int n = strlen(a);
        int m = strlen(b);
        //KMP(b, m, a, n);
        printf(&quot;%d\n&quot;, KMP(b, m, a, n));
    }
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>字符串循环左移</title>
    <url>/article/csdn/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BE%AA%E7%8E%AF%E5%B7%A6%E7%A7%BB.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46547793" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46547793</a></p>
<p>题目描述：<br>给定一个字符串S[0…N-1]，要求把S的前k<br>个字符移动到S的尾部，如把字符串“abcdef”<br>前面的2个字符‘a’、‘b’移动到字符串的尾部，<br>得到新字符串“cdefab”：即字符串循环左移k。<br>多说一句：循环左移k位等价于循环右移n-k位。</p>
<p>算法要求：<br> 时间复杂度为 O(n)，空间复杂度为 O(1)。</p>
<p>问题分析：<br> 暴力移位法<br>每次循环左移1位，调用k次即可<br>时间复杂度O(kN)，空间复杂度O(1)<br> 三次拷贝<br>S[0…k] → T[0…k]<br>S[k+1…N-1] → S[0…N-k-1]<br>T[0…k] →S[N-k…N-1]<br>时间复杂度O(N)，空间复杂度O(k)</p>
<p>优雅一点的算法:<br> (X’Y’)’=YX<br> 如：abcdef<br> X=ab X’=ba<br> Y=cdef Y’=fedc<br> (X’Y’)’=(bafedc)’=cdefab<br> 时间复杂度O(N)，空间复杂度O(1)</p>
<p>代码：</p>
<pre><code>void reverse(char* s,int from,int to)
{
    while (from &lt; to)
    {
        char t = s[from];
        s[from++] = s[to];
        s[to--] = t;
    }
}

void leftrotatestring(char* s, int n, int m)
{
    m %= n;
    reverse(s,0,m-1);
    reverse(s, m, n - 1);
    reverse(s, 0, n - 1);
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>字符</tag>
      </tags>
  </entry>
  <entry>
    <title>容斥原理</title>
    <url>/article/csdn/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46383261" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46383261</a></p>
<p>百度百科：</p>
<p>在计数时，必须注意无一重复，无一遗漏。为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。</p>
<p>两个集合的容斥关系公式：A∪B = A+B – A∩B (∩：重合的部分）<br>三个集合的容斥关系公式：A∪B∪C = A+B+C – A∩B – B∩C – C∩A +A∩B∩C<br>详细推理如下：<br>1、 等式右边改造 = {[（A+B – A∩B）+C – B∩C] – C∩A }+ A∩B∩C<br>2、文氏图分块标记如右图图：1245构成A，2356构成B，4567构成C<br>3、等式右边（）里指的是下图的1+2+3+4+5+6六部分：<br>那么A∪B∪C还缺部分7。<br>4、等式右边[]号里+C（4+5+6+7）后，相当于A∪B∪C多加了4+5+6三部分，<br>减去B∩C（即5+6两部分）后，还多加了部分4。<br>5、等式右边{}里减去C∩A （即4+5两部分）后，A∪B∪C又多减了部分5，<br>则加上A∩B∩C（即5）刚好是A∪B∪C。<br>简单应用：</p>
<p>由0 到9 数字组成排列，要求第一个数大于1，最一个数小于8，一共有几种排列。<br>思路：<br>求逆问题，第一个数&lt;=1,最后一个数&gt;=8<br>由容斥原理，<br>则有 事件A（第一个数&lt;=1） = 2<em>9!， 事件B（最后一个数&gt;=8） = 2</em>9!， 事件C（A交B） C= 2<em>2</em>8!<br>所以逆问题的结果是 A+B-C<br>则问题的答案是 10！-（A+B-C）</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>小Z的袜子【莫队算法】</title>
    <url>/article/csdn/%E5%B0%8FZ%E7%9A%84%E8%A2%9C%E5%AD%90%E3%80%90%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/50598165" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/50598165</a></p>
<p>[2009国家集训队]小Z的袜子(hose)</p>
<p>Time Limit: 20 Sec Memory Limit: 259 MB<br>Submit: 5259 Solved: 2426<br>[Submit][Status][Discuss]<br>Description</p>
<p>作为一个生活散漫的人，小Z每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小Z再也无法忍受这恼人的找袜子过程，于是他决定听天由命……<br>具体来说，小Z把这N只袜子从1到N编号，然后从编号L到R(L<br>尽管小Z并不在意两只袜子是不是完整的一双，甚至不在意两只袜子是否一左一右，他却很在意袜子的颜色，毕竟穿两只不同色的袜子会很尴尬。<br>你的任务便是告诉小Z，他有多大的概率抽到两只颜色相同的袜子。当然，小Z希望这个概率尽量高，所以他可能会询问多个(L,R)以方便自己选择。</p>
<p>Input</p>
<p>输入文件第一行包含两个正整数N和M。N为袜子的数量，M为小Z所提的询问的数量。接下来一行包含N个正整数Ci，其中Ci表示第i只袜子的颜色，相同的颜色用相同的数字表示。再接下来M行，每行两个正整数L，R表示一个询问。</p>
<p>Output</p>
<p>包含M行，对于每个询问在一行中输出分数A/B表示从该询问的区间[L,R]中随机抽出两只袜子颜色相同的概率。若该概率为0则输出0/1，否则输出的A/B必须为最简分数。（详见样例）</p>
<p>Sample Input</p>
<p>6 4</p>
<p>1 2 3 3 3 2</p>
<p>2 6</p>
<p>1 3</p>
<p>3 5</p>
<p>1 6</p>
<p>Sample Output</p>
<p>2/5</p>
<p>0/1</p>
<p>1/1</p>
<p>4/15</p>
<p>【样例解释】</p>
<p>询问1：共C(5,2)=10种可能，其中抽出两个2有1种可能，抽出两个3有3种可能，概率为(1+3)/10=4/10=2/5。</p>
<p>询问2：共C(3,2)=3种可能，无法抽到颜色相同的袜子，概率为0/3=0/1。</p>
<p>询问3：共C(3,2)=3种可能，均为抽出两个3，概率为3/3=1/1。</p>
<p>注：上述C(a, b)表示组合数，组合数C(a, b)等价于在a个不同的物品中选取b个的选取方案数。</p>
<p>【数据规模和约定】</p>
<p>30%的数据中 N,M ≤ 5000；</p>
<p>60%的数据中 N,M ≤ 25000；</p>
<p>100%的数据中 N,M ≤ 50000，1 ≤ L &lt; R ≤ N，Ci ≤ N。</p>
<p>莫队算法：<br>分块的思想，时间复杂度为nsqrt(n)，适用于无修改的区间查询，将长度为n的区间分为sqrt(n)块，如果知道了[L,R]的答案可以在O(1)的时间内知道[L-1,R]，[L,R-1]，[L+1,R]，[L,R+1]的答案。首先按照查询的区间对询问进行排序。</p>
<p>代码：</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;

using namespace std;

int c[50010], pos[50010];;
int n, m;
long long ans, aa, bb, cc, s[50010];

long long gcd(long long a, long long b)
{
    if (b == 0) return a;
    else return gcd(b ,a%b);
}

struct Query
{
    int L, R;
    int num;

    long long ans1, ans2;

}q[50010];

bool cmp1(Query a, Query b)
{
    if (pos[a.L] == pos[b.L])
        return a.R &lt; b.R;
    else
        return a.L &lt; b.L;
}


bool cmp2(Query a, Query b)
{
    return a.num &lt; b.num;
}

void update(int p, int add)
{
    ans -= s[c[p]] * s[c[p]];
    s[c[p]] += add;
    ans += s[c[p]] * s[c[p]];
}

int main()
{
    while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)
    {
        int SQ = sqrt(n);
        ans = 0;
        memset(s, 0, sizeof(s));

        for (int i = 1;i &lt;= n;i++)
        {
            scanf(&quot;%d&quot;, &amp;c[i]);
            pos[i] = (i - 1) / SQ + 1;
        }

        for (int i = 1;i &lt;= m;i++)
        {
            scanf(&quot;%d%d&quot;, &amp;q[i].L, &amp;q[i].R);
            q[i].num = i;
        }

        sort(q + 1, q + 1 + m,cmp1);

        int pl = 1, pr = 0;

        for (int i = 1;i &lt;= m;i++)
        {
            if (q[i].L == q[i].R)
            {
                q[i].ans1 = 0;
                q[i].ans2 = 1;
                continue;
            }

            if (pr &lt; q[i].R)
            {
                for (int j = pr + 1;j &lt;= q[i].R;j++)
                    update(j, 1);
            }
            else
            {
                for (int j = pr ;j &gt; q[i].R;j--)
                    update(j, -1);
            }
            pr = q[i].R;
            if (pl &lt; q[i].L)
            {
                for (int j = pl;j &lt; q[i].L;j++)
                    update(j,-1);
            }
            else
            {
                for (int j = pl - 1;j &gt;= q[i].L;j--)
                    update(j, 1);
            }
            pl = q[i].L;

            aa = ans - (q[i].R - q[i].L + 1);
            bb = (long long)(q[i].R - q[i].L + 1)*(q[i].R - q[i].L);

            long long tmp = gcd(aa, bb);
            aa /= tmp;
            bb /= tmp;
            q[i].ans1 = aa;
            q[i].ans2 = bb;
        }

        sort(q + 1, q + 1 + m, cmp2);

        for (int i = 1;i &lt;= m;i++)
            printf(&quot;%lld/%lld\n&quot;, q[i].ans1, q[i].ans2);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>差分约束</title>
    <url>/article/csdn/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46380559" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46380559</a></p>
<p>转载自： <a href="http://www.cnblogs.com/void/archive/2011/08/26/2153928.html" target="_blank" rel="noopener"> http://www.cnblogs.com/void/archive/2011/08/26/2153928.html
</a></p>
<p>一直不知道差分约束是什么类型题目，最近在写最短路问题就顺带看了下，原来就是给出一些形如x-y&lt;=b不等式的约束，问你是否满足有解的问题</p>
<p>好神奇的是这类问题竟然可以转换成图论里的最短路径问题，下面开始详细介绍下</p>
<p>比如给出三个不等式,b-a&lt;=k1,c-b&lt;=k2,c-a&lt;=k3,求出c-a的最大值,我们可以把a,b,c转换成三个点，k1，k2，k3是边上的权，如图</p>
<p>由题我们可以得知，这个有向图中，由题b-a&lt;=k1,c-b&lt;=k2,得出c-a&lt;=k1+k2,因此比较k1+k2和k3的大小，求出最小的就是c-a的最大值了</p>
<p>根据以上的解法，我们可能会猜到求解过程实际就是求从a到c的最短路径，没错的….简单的说就是从a到c沿着某条路径后把所有权值和k求出就是c -a&lt;=k的一个</p>
<p>推广的不等式约束，既然这样，满足题目的肯定是最小的k，也就是从a到c最短距离…</p>
<p>理解了这里之后，想做题还是比较有困难的，因为题目需要变形一下，不能单纯的算..</p>
<p>首先以poj3159为例,这个比较简单，就是给出两个点的最大差，然后让你求1到n的最大差，直接建图后用bellman或者spfa就可以过了</p>
<p>稍微难点的就是poj1364，因为他给出的不等式不是x-y&lt;=k形式，有时候是大于号，这样需要我们去变形一下，并且给出的还是&gt;,&lt;没有等于，都要变形</p>
<p>再有就是poj1201，他要求出的是最长距离，那就要把形式变换成x-y&gt;=k的标准形式</p>
<p>注意点:</p>
<ol>
<li>如果要求最大值想办法把每个不等式变为标准x-y&lt;=k的形式,然后建立一条从y到x权值为k的边,变得时候注意x-y</li>
</ol>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>平面分割问题</title>
    <url>/article/csdn/%E5%B9%B3%E9%9D%A2%E5%88%86%E5%89%B2%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40650731" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40650731</a></p>
<p>(1) n条直线最多分平面问题</p>
<p>题目大致如:n条直线，最多可以把平面分为多少个区域。</p>
<p>析:可能你以前就见过这题目，这充其量是一道初中的思考题。但一个类型的题目还是从简单的入手，才容易发现规律。当有n-<br>1条直线时，平面最多被分成了f（n-1）个区域。则第n条直线要是切成的区域数最多，就必须与每条直线相交且不能有同一交点。 这样就会得到n-1个交点<br>。这些交点将第n条直线分为2条射线和n-2条线断。而每条射线和线断将以有的区域一分为二。这样就多出了2+（n-2）个区域。</p>
<p>故：f(n)=f(n-1)+n</p>
<p>=f(n-2)+(n-1)+n</p>
<p>……</p>
<p>=f(1)+1+2+……+n</p>
<p>=n(n+1)/2+1</p>
<p>(2) 折线分平面（hdu2050）</p>
<p>根据直线分平面可知，由交点决定了射线和线段的条数，进而决定了新增的区域数。当n-1条折线时，区域数为f（n-1）。为了使增加的区域最多<br>，则折线的两边的线段要和n-<br>1条折线的边，即2<em>（n-1）条线段相交。那么新增的线段数为4</em>（n-1），射线数为2。但要注意的是，折线本身相邻的两线段只能增加一个区域。</p>
<p>故：f(n)=f(n-1)+4(n-1)+2-1</p>
<p>=f(n-1)+4(n-1)+1</p>
<p>=f(n-2)+4(n-2)+4(n-1)+2</p>
<p>……</p>
<p>=f(1)+4+4*2+……+4(n-1)+(n-1)</p>
<p>=2n^2-n+1</p>
<p>(3) 封闭曲线分平面问题</p>
<p>题目大致如设有n条封闭曲线画在平面上，而任何两条封闭曲线恰好相交于两点，且任何三条封闭曲线不相交于同一点，问这些封闭曲线把平面分割成的区域个数。</p>
<p>析：当n-1个圆时，区域数为f(n-1).那么第n个圆就必须与前n-1个圆相交，则第n个圆被分为2（n-1）段线段，增加了2（n-1）个区域。</p>
<p>故： f(n)=f(n-1)+2(n-1)</p>
<p>=f(1)+2+4+……+2(n-1)</p>
<p>=n^2-n+2</p>
<p>(4)平面分割空间问题（hdu1290）</p>
<p>由二维的分割问题可知，平面分割与线之间的交点有关，即交点决定射线和线段的条数，从而决定新增的区域数。试想在三维中则是否与平面的交线有关呢？当有n-<br>1个平面时，分割的空间数为f（n-1）。要有最多的空间数，则第n个平面需与前n-1个平面相交，且不能有共同的交线。即最多有n-1 条交线。而这n-<br>1条交线把第n个平面最多分割成g（n-1）个区域。（g（n）为（1）中的直线分平面的个数 ）此平面将原有的空间一分为二，则最多增加g（n-1）个空间。</p>
<p>故：f=f(n-1)+g(n-1) ps:g(n)=n(n+1)/2+1</p>
<p>=f(n-2)+g(n-2)+g(n-1)</p>
<p>……</p>
<p>=f(1)+g(1)+g(2)+……+g(n-1)</p>
<p>=2+(1<em>2+2</em>3+3*4+……+(n-1)n)/2+（n-1）</p>
<p>=(1+2^2+3^2+4^2+……+n^2-1-2-3-……-n )/2+n+1</p>
<p>=(n^3+5n)/6+1</p>
<hr>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>并发和并行的区别</title>
    <url>/article/csdn/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41623857" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41623857</a></p>
<p>所有的并发处理都有等待，就绪，执行至少三个这样的步骤.所以并发肯定是宏观概念，在微观上他们都是序列被处理的，只不过资源不会在某一个上被阻塞(一般是通过时间片轮转)，所以在宏观上看多个几乎同时到达的请求同时在被处理。如果是同一时刻到达的请求也会根据优先级的不同，而先后进入队列排队等候执行。</p>
<p>并发与并行是两个既相似而又不相同的概念：并发性，又称共行性，是指能处理多个同时性活动的能力；并行是指同时发生的两个并发事件，具有并发的含义，而并发则不一定并行，也亦是说并发事件之间不一定要同一时刻发生。</p>
<p>并发的实质是一个物理CPU(也可以多个物理CPU) 在若干道程序之间多路复用，并发性是对有限物理资源强制行使多用户共享以提高效率。</p>
<p>并行性指两个或两个以上事件或活动在同一时刻发生。在多道程序环境下，并行性使多个程序同一时刻可在不同CPU上同时执行。</p>
<p>并发，是在同一个cpu上  同时（不是真正的同时，而是看来是同时，因为cpu要在多个程序间切换）运行多个程序。</p>
<p>并行，是每个cpu运行一个程序。</p>
<p>打个比方。并发，就像一个人（cpu）喂2个孩子（程序），轮换着每人喂一口，表面上两个孩子都在吃饭。并行，就是2个人喂2个孩子，两个孩子也同时在吃饭。</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>当我真正理解了扩展欧几里得定理</title>
    <url>/article/csdn/%E5%BD%93%E6%88%91%E7%9C%9F%E6%AD%A3%E7%90%86%E8%A7%A3%E4%BA%86%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E5%AE%9A%E7%90%86.html</url>
    <content><![CDATA[<p>首先、扩展欧几里得定理：对于两个不全为0的整数a、b，必存在一组解x,y，使得ax+by==gcd(a,b);</p>
<pre><code>void exgcd(long long  a, long long b, long long &amp; d, long long&amp; x, long long&amp; y)  
{  
    if (!b)  
    {  
        d = a;  
        x = 1;  
        y = 0;  
    }  
    else  
    {  
        exgcd(b,a%b,d,y,x);  
        y -= x *(a/b);  
    }  
}  
</code></pre><p>我个人觉得第一次看到这个程序你会有以上两个不明白的地方（见注释），下面我分别解释</p>
<p>不明处1：由扩展欧几里得定理：ax+by==gcd(a,b)—式1，而此时b==0，也就是说gcd(a,0)==a。原式变为ax+by==a –&gt;<br>x==1,y==0。应该够清楚了吧</p>
<p>不明处2：这里先说明一下我的一些规则，x,y表示第一次递归时的值，x1,y1表示第二次递归时的值。那么</p>
<p>gcd(a,b)==gcd(b,a%b)，同时都代入式1，有ax+by==b<em>x1+(a%b)</em>y1。将右边变形一下</p>
<p>b<em>x1+(a%b)</em>y1==b<em>x1+(a-(a/b)</em>b)<em>y1==a</em>y1+b<em>(x1-(a/b)</em>y1)，最终得到ax+by==a<em>y1+b</em>(x1-(a/b)*y1)</p>
<p>也就是说，上一深度的x等于下一深度的y1，上一深度的y等于下一深度的x1-(a/b)*y1。    需要注意，上面推导时用的除法都是整型除法</p>
<p>到这里为止，我们便得到了不定式ax+by==gcd(a,b)的一组解，x、y。</p>
<p>那么对于一般的不定式ax+by==c，它的解应该是什么呢。很简单，x1=x<em>(c/gcd(a,b)),y1=y</em>(c/gcd(a,b))。很好理解吧~</p>
<p>再深入一点，就解出这么一组解其实一般来说是解决不了什么问题的。没有哪个ACM的题这么简单吧。。。比如我们现在要得到所有的解，那么这所有的解究竟是什么呢？</p>
<p>直接说吧,假设d=gcd(a,b). 那么x=x0+b/d<em>t; y=y0-a/d</em>t;其中t为任意常整数。</p>
<p>这个是怎么推导出来的，说实话我也不知道，就先这么记着吧！</p>
<p>好了，说了这么多，光说不练也无济于事</p>
<p>先做一个最简单的题目，pku 1061青蛙的约会</p>
<p>先说一下大概题意：有两只青蛙，一只在坐标x，另一直在坐标y，青蛙x一次跳跃可以前进m单位距离，青蛙y一次跳跃可以前进n单位的距离，两青蛙都在同一纬度，该纬度长度为L。两只青蛙同方向同时跳啊跳，问你最少跳多少次，它们才可以相遇，如果不能相遇，输出impossble</p>
<p>分析：假设跳了T次以后，青蛙1的坐标便是x+m<em>T,青蛙2的坐标为y+n</em>T。它们能够相遇的情况为（x+m<em>T）-(y+n</em>T)==P*L，其中P为某一个整数，变形一下</p>
<p>得到(n-m)<em>T+P</em>L==x-y<br>我们设a=(n-m),b=L,c=x-y,T=x,P=y.于是便得到ax+by==c。激动啊，这不就是上面一样的式子吗~</p>
<p>直接套用扩展欧几里得函数，得到一组解x,y。由于问题是问最少跳多少次，于是只有x是我们需要的信息。那么再想，x是最小的吗？</p>
<p>答案是可能不是！那么如何得到最小解呢？  我们考虑x的所有解的式子：<br>x=x0+b/d<em>t。x0是我们刚刚求到的，很显然右边是有个单调函数，当t为某一个与x正负性质相反的数时，可以得到最小的x。<br>令x的正负性质为正，那么x=x0-b/d</em>t1<br>(t1==-t)。令x==0，那么t=x0<em>d/b，最小的x等于x0减去t</em>b/d。这里得到的x可能是负数，如果是负数，我们再为它加上一个b/d即是所求答案了！</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
usingnamespace std;

__int64 x,y,a,b,c,d;
__int64 n,m,X,Y,L;

__int64 gcd(__int64 a,__int64 b)
{
    __int64 t,d;
    if(b==0)
    {
        x=1;
        y=0;
        return a;
    }
    d=gcd(b,a%b);
    t=x;
    x=y;
    y=t-(a/b)*y;
    return d;
}

int main()
{
    while(scanf(&quot;%I64d%I64d%I64d%I64d%I64d&quot;,&amp;X,&amp;Y,&amp;m,&amp;n,&amp;L)==5)
    {
        a=n-m;
        b=L;
        c=X-Y;
        d=gcd(a,b);
        if(c%d!=0)
        {
            printf(&quot;Impossible\n&quot;);
            continue;
        }
        x=x*(c/d);
        y=y*(c/d);

        /*通解：
        x1=x+b/d*t;
        y1=y-a/d*t;
        t为任意整数
        */
        //找最小的x1，即求x+b/d*t最小，那么只有t为某一个数时才最小
        //显然t必须与x正负相反才有最小，那么就看做x-b/d*t,这个式子的最小值便是t=x/(b/d)时，注意这是整型除法
        __int64 k=x*d/b;
        k=x-k*b/d;
        if(k&lt;0)
            k+=b/d;
        printf(&quot;%I64d\n&quot;,k);
    }
    return0;
}
</code></pre><p>转自： <a href="http://www.cnblogs.com/ka200812/archive/2011/09/02/2164404.html" target="_blank" rel="noopener"> http://www.cnblogs.com/ka200812/archive/2011/09/02/2164404.html
</a></p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>循环有序数组查找值</title>
    <url>/article/csdn/%E5%BE%AA%E7%8E%AF%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE%E5%80%BC.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/51223682" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/51223682</a></p>
<p>循环数组，即有序的数组进行移位后的数组。<br>如：4，5，6，7，8，0，1，2，3</p>
<pre><code>查找值是否存在时，利用二分的思想。
步骤：
while(L&lt;R)
如果 a[mid] == key,return mid。
如果a[mid] &gt;　ａ[L],说明L-mid是有序的，mid+1 - R是循环的
       如果key&lt;a[mid] &amp;&amp; key &gt;= a[L]，则key在L - mid-1之间，
       否则key在mid+1 - R之间。
否则说明mid+1 - R之间是有序的，L-mid是循环的。
       如果key&gt;a[mid] &amp;&amp; key &lt;= a[L]，则key在mid+1 - R之间，
       否则key在L-mid - 1之间。
</code></pre><p>代码：</p>
<pre><code>int Find(int a[], int key, int n)
{
    int l = 0, r = n - 1;

    while (l &lt;= r)
    {
        int mid = (l + r) / 2;
        if (a[mid] == key)
            return mid;
        if (a[l] &lt; a[mid])
        {
            if (a[mid] &gt; key &amp;&amp; key &gt;= a[l])
                r = mid - 1;
            else
                l = mid + 1;
        }
        else
        {
            if (a[mid] &lt; key &amp;&amp; key &lt;= a[r])
                l = mid + 1;
            else
                r = mid - 1;
        }
    }

    return -1;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>当我真正理解素数线性筛法</title>
    <url>/article/csdn/%E5%BD%93%E6%88%91%E7%9C%9F%E6%AD%A3%E7%90%86%E8%A7%A3%E7%B4%A0%E6%95%B0%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B3%95.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44466461" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44466461</a></p>
<p>参考自： <a href="http://quartergeek.com/sieve-prime-in-linear-time/" target="_blank" rel="noopener"> 点击链接 </a><br>主要代码：</p>
<pre><code>const int MAXN = 10000010;  

bool com[MAXN];  
int primes, prime[MAXN/10]; 

void solve(int n)  
{  
    primes = 0;  
    memset(com,false,sizeof(com));  
    com[0] = com[1] = true;  
    for (int i = 2; i &lt;= n; ++i)  
    {  
        if (!com[i])  
        {  
            prime[++primes] = i;  
        }  
        for (int j = 1; j &lt;= primes &amp;&amp; i*prime[j] &lt;= n; ++j)  
        {  
            com[i*prime[j]] = true;  
            if (!(i % prime[j]))  
                break;  
        }  
    }  
}  


现在具体讲解一下证明：
最难理解的是：


if (!(i % prime[j]))  
                break;  


要从下面两个方面：
每个数至少被访问一次
每个数至多被访问一次
进行理解.
对于质数，一定会在i的循环中访问到，并确定为质数。
对于合数，一定可以分解为一个最小素因子和其他数的乘积。
比如：
合数 i = p（最小素因子）* a;
若 i%prime[k] ==0;
则 p * a * prime[k+1] 可以被后面的 a * prime[k+1] 再乘以素数 p 筛选出来，
    （显而p&lt;prime[k+1]） 所以i%prime[k] == 0 时要停止。
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>快速乘法计算模幂</title>
    <url>/article/csdn/%E5%BF%AB%E9%80%9F%E4%B9%98%E6%B3%95%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%B9%82.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44280737" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44280737</a></p>
<p>一般的快速模幂可能会产生整数溢出的情况 ，可以用快速乘法解决此问题 。</p>
<p>模板如下：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;

using namespace std;

long long mult_mod(long long a, long long b, long long c)
{
    a %= c;
    b %= c;
    long long ret = 0;
    long long tmp = a;
    while (b)
    {
        if (b &amp; 1)
        {
            ret += tmp;
            if (ret &gt; c)ret -= c;//直接取模慢很多
        }
        tmp &lt;&lt;= 1;
        if (tmp &gt; c)tmp -= c;
        b &gt;&gt;= 1;
    }
    return ret;
}
long long pow_mod(long long a, long long n, long long mod)
{
    long long ret = 1;
    long long temp = a%mod;
    while (n)
    {
        if (n &amp; 1)ret = mult_mod(ret, temp, mod);
        temp = mult_mod(temp, temp, mod);
        n &gt;&gt;= 1;
    }
    return ret;
}

int main()
{
    long long a, n, mod;
    while (scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;n, &amp;mod) != EOF)
    {
        printf(&quot;%lld\n&quot;,pow_mod(a,n,mod));//a^n%mod
    }
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>快速幂算法的理解</title>
    <url>/article/csdn/%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44493835" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44493835</a></p>
<p>首先给出代码：</p>
<pre><code>#include &lt;iostream&gt;     
using namespace std;     

//计算a^bmodn     
int modexp(int a,int b,int n)     
{     
    int ret=1;     
    int tmp=a;     
    while(b)     
    {       
       if(b&amp;1) 
           ret=ret*tmp%n;     
       tmp=tmp*tmp%n;     
       b&gt;&gt;=1;     
    }     
    return ret;     
}     

int main()     
{     
    cout&lt;&lt;modexp(2,10,3)&lt;&lt;endl;     
    return 0;     
}    
</code></pre><p>接下来进行讲解,快速幂算法，就是快速求 x^n mod (m) 的快速算法。<br>比如：</p>
<p>计算 12996^227 mod 37909<br>设m = 37909 ， b = 12996, 令a = 1, 将227二进制表示为：227 = 1 + 2 + 2^5 + 2^ 6 + 2^7;<br>依次计算 12996^227 = 12996 + 12996^2 + 12996^2^5 + 12996^2^ 6 + 12996^2^7;<br>运用二进制操作,也就是二分的思想,可以达到O(logn)。二进制扫描从最高位一直扫描到最低位。<br>运用上面的例子：</p>
<pre><code> if(227&amp;1) //也就是说存在2的某次幂不为0,所以需要计算; 
 ………………
 227&gt;&gt;=1 //右移一位，继续检查。
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>我是好人 【欧几里得定理的性质】</title>
    <url>/article/csdn/%E6%88%91%E6%98%AF%E5%A5%BD%E4%BA%BA_%E3%80%90%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E5%AE%9A%E7%90%86%E7%9A%84%E6%80%A7%E8%B4%A8%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44314659" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44314659</a></p>
<p>Description<br>众所周知，我是好人！</p>
<p>所以不会出太难的题，题意很简单 给你两个数n和m，问你有多少对正整数对最大公约数是n，最小公倍数是m</p>
<p>最后友情提供解题代码（我真是太好人了）</p>
<p>void solve()</p>
<p>{</p>
<p>long long n, m;</p>
<p>scanf(“%lld%lld”, &amp;n, &amp;m);</p>
<p>int ans = 0;</p>
<p>for (long long i = 1; i &lt;= m; i++)</p>
<p>{</p>
<pre><code>  for (long long j = i; j &lt;= m; j++)

  {

       if (gcd(i, j) == n &amp;&amp; lcm(i, j) == m) ans++;

  }
</code></pre><p>}</p>
<p>printf(“%d\n”, ans);</p>
<p>}</p>
<p>祝大家AC愉快！最好AK，送某扬兑现诺言^_^</p>
<p>Input<br>输入第1行是一个整数T，表示共T组数据。 接下来是T组数据，每组数据占1行，每一行有2个整数n，m（1 &lt;= n, m &lt;=<br>10000000000），两个数由一个空格隔开。</p>
<p>Output<br>结果输出T行，对应T组数据。（T&lt;=100）<br>每行输出这样的正整数对有多少对（看我多好人，不用你们输出所有整数对）</p>
<p>Sample Input<br>3<br>1 1<br>7 10086<br>4 16<br>Sample Output<br>1<br>0<br>1</p>
<p>解法：<br>一个非常重要的转化：求(x, y) = k, 1 &lt;= x, y &lt;= n的对数等于求(x, y) = 1, 1 &lt;= x, y &lt;= n/k的对数</p>
<pre><code>#include &lt;stdio.h&gt;    
#include &lt;iostream&gt;    
#include &lt;math.h&gt;    
#include &lt;stdlib.h&gt;    
#include &lt;ctype.h&gt;    
#include &lt;algorithm&gt;    
#include &lt;vector&gt;    
#include &lt;string.h&gt;    
#include &lt;queue&gt;    
#include &lt;stack&gt;    
#include &lt;set&gt;     
#include &lt;sstream&gt;    
#include &lt;time.h&gt;    
#include &lt;utility&gt;    
#include &lt;malloc.h&gt;    
#include &lt;stdexcept&gt;    
#include &lt;iomanip&gt;    
#include &lt;iterator&gt;  

using namespace std;

long long gcd(long long a, long long b)
{
    if (b == 0)
        return a;
    else
        return gcd(b,a%b);
}

void solve(long long N)
{
    int ans = 0;
    for (long long i = 1; i &lt;= sqrt(N*1.0); i++)
    {
        if (N%i == 0)
        {
            long long j = N / i;
            if (gcd(i, j) == 1)
                ans++;
        }
    }
    printf(&quot;%d\n&quot;,ans);
}

int main()
{
    int t;
    long long n, m;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);
        if (m % n != 0)
        {
            printf(&quot;0\n&quot;);
            continue;
        }
        long long tmp = m / n;
        solve(tmp);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title>指针函数与函数指针</title>
    <url>/article/csdn/%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48607637" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48607637</a></p>
<h2><span id="概念">概念</span></h2><p>【指针函数】：返回指针的函数。重点是它是一个函数，只是返回值由普通的值或对象变成了指针，也就是说这个函数返回的是一块内存的地址。</p>
<p>【函数指针】：指向函数的指针。重点是它是一个指针，只是它指向的内容由普通的变量或对象变成了函数，也就是说它可以指向函数的入口地址。</p>
<h2><span id="指针函数">指针函数</span></h2><pre><code>#include &lt;iostream&gt;
using namespace std;

class MyType{
public:
    MyType(int value):m_value(value){
        cout&lt;&lt;&quot;Construct.&quot;&lt;&lt;endl;
    }
    ~MyType(){
        cout&lt;&lt;&quot;Desconstruct.&quot;&lt;&lt;endl;
    }
public:
    int m_value;
};

MyType *getInstanceOfMyType(){
    MyType *mt = new MyType(10);
    cout&lt;&lt;mt&lt;&lt;endl;
    return mt;
}

int main(){

    MyType *mt = getInstanceOfMyType();
    cout&lt;&lt;mt&lt;&lt;endl;
    cout&lt;&lt;mt-&gt;m_value&lt;&lt;endl;

    system(&quot;pause&quot;);
    return 0;
}
</code></pre><p>这段程序的输出是什么呢？如下：</p>
<pre><code>Construct.
00754AA8
00754AA8
10
请按任意键继续. . .
</code></pre><p>可以看出，在函数”getInstanceOfMyType()”中的对象一直没有被调用析构函数，函数内和函数外的对象的地址是完全一样的，当然，对象里存储的内容m_value的值也是一样的。你可能会问，不是说函数调用完，就销毁局部变量吗？是的，它销毁了，但是它只销毁了”MyType<br>*mt”这个指针，它指向的内存却不会被销毁。所以，在外面我们仍然可以继续访问这个对象。这种情况下，我们一般是需要在函数调用外面加上我们自己的delete操作的，上面的程序没有添加这样的操作，严格上来讲是一个错误的程序。</p>
<p>使用指针函数时，直接返回函数内部对象的地址，这样就无需重新制造对象的副本，对效率的提升有帮助。但是需要注意的是，一定要记得在函数外部将函数内部申请的内存释放掉，否则就有内存溢出的风险。</p>
<h2><span id="函数指针">函数指针</span></h2><p>函数指针是一个很有用的技术，它使得我们可以通过指针就能执行某一个函数代码。对于技术高超的人来说，它是一把【绝世好剑】，能够解决很多问题。下面，我们就函数指针来探究一番。</p>
<p>首先，来看一段最简单的函数指针的代码，注意声明和调用的方式。</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

int printFunc(int value){
    cout&lt;&lt;&quot;this is a print function. the value is:&quot;&lt;&lt;value&lt;&lt;endl;
    return 0;
}

int main(){

    int (*pFunction)(int x); // 这是一个函数指针变量
    pFunction = printFunc;   // 这里将函数入口地址给函数指针
    (*pFunction)(7);         // 通过*运算符获取了函数，再传入参数7执行了函数

    system(&quot;pause&quot;);
    return 0;
}
</code></pre><p>对于函数指针，它有两个前提：①．就是指向的函数返回值要与声明的函数指针一致。②．指向的函数的参数类型及个数要与声明的函数指针一致。否则，是无法编译通过的。</p>
<h2><span id="函数指针类型">函数指针类型</span></h2><p>函数指针也可以借助typedef声明为一个类型，这样我们就可以像定义int型变量一样来定义一个函数指针了。定义函数指针类型代码如下：、</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

int printFunc(int value){
    cout&lt;&lt;&quot;this is a print function. the value is:&quot;&lt;&lt;value&lt;&lt;endl;
    return 0;
}
typedef int (*PFunction)(int x); // 函数指针类型，注意返回值和参数列表

int main(){

    PFunction ptrFunc; // 定义函数指针变量
    ptrFunc = printFunc;
    (*ptrFunc)(1); // 第一种调用方式
    ptrFunc(2);    // 第二种调用方式

    system(&quot;pause&quot;);
    return 0;
}
</code></pre><p>转自： <a href="http://www.cnblogs.com/alephsoul-
alephsoul/archive/2012/10/19/2730337.html" target="_blank" rel="noopener"> http://www.cnblogs.com/alephsoul-<br>alephsoul/archive/2012/10/19/2730337.html </a></p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>指针</tag>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title>排错公式</title>
    <url>/article/csdn/%E6%8E%92%E9%94%99%E5%85%AC%E5%BC%8F.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40650605" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40650605</a></p>
<p>排错公式</p>
<p>错排：n封信放入n个信封，要求全部放错，共有多少种放法，记n个元素的错排总数为f(n)</p>
<p>假设有n封信，第一封信可放在(2-n)的任一个信封里，共n-1种放法，设第一封信放在了第k个信封里，若此时第k封信放在了第1个信封里，则只要将剩下的n-<br>2错排，即f(n-2)，若第k封信没有放在了第1个信封里，可将第1封信的位置看成是“第k个位置”，即将n-1封信错排，即为f(n-1)</p>
<p>由递推可得,f(n)=(n-1)*(f(n-1)+f(n-2))</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>数位DP模板</title>
    <url>/article/csdn/%E6%95%B0%E4%BD%8DDP%E6%A8%A1%E6%9D%BF.html</url>
    <content><![CDATA[<p>通常的数位dp可以写成如下形式：</p>
<pre><code>int dfs(int i, int s, bool e) {
    if (i==-1) return s==target_s;
    if (!e &amp;&amp; ~f[i][s]) return f[i][s];
    int res = 0;
    int u = e?num[i]:9;
    for (int d = first?1:0; d &lt;= u; ++d)
        res += dfs(i-1, new_s(s, d), e&amp;&amp;d==u);
    return e?res:f[i][s]=res;
}
</code></pre><p>其中：</p>
<p>f为记忆化数组；</p>
<p>i为当前处理串的第i位（权重表示法，也即后面剩下i+1位待填数）；</p>
<p>s为之前数字的状态（如果要求后面的数满足什么状态，也可以再记一个目标状态t之类，for的时候枚举下t）；</p>
<p>e表示之前的数是否是上界的前缀（即后面的数能否任意填）。</p>
<p>for循环枚举数字时，要注意是否能枚举0，以及0对于状态的影响，有的题目前导0和中间的0是等价的，但有的不是，对于后者可以在dfs时再加一个状态变量z，表示前面是否全部是前导0，也可以看是否是首位，然后外面统计时候枚举一下位数。It<br>depends.</p>
<p>于是关键就在怎么设计状态。当然做多了之后状态一眼就可以瞄出来。</p>
<p>注意：</p>
<p>不满足区间减法性质的话（如hdu 4376），不能用solve(r)-solve(l-1)，状态设计会更加诡异。</p>
<p>转自： <a href="http://www.cnblogs.com/jffifa/archive/2012/08/17/2644847.html" target="_blank" rel="noopener"> http://www.cnblogs.com/jffifa/archive/2012/08/17/2644847.html
</a></p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库原理知识--B-树、B+树、B*树</title>
    <url>/article/csdn/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86--B-%E6%A0%91%E3%80%81B+%E6%A0%91%E3%80%81B*%E6%A0%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41241551" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41241551</a></p>
<p><strong>B-树</strong></p>
<p>是一种多路搜索树（并不是二叉的）：</p>
<p>1.定义任意非叶子结点最多只有M个儿子；且M &gt;2；</p>
<p>2.根结点的儿子数为[2, M]；</p>
<p>3.除根结点以外的非叶子结点的儿子数为[M/2, M]；</p>
<p>4.每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）</p>
<p>5.非叶子结点的关键字个数=指向儿子的指针个数-1；</p>
<p>6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</p>
<p>7.非叶子结点的指针：P[1], P[2], …,<br>P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</p>
<p>8.所有叶子结点位于同一层；</p>
<p>如：（M=3）</p>
<p><img src="https://img-
blog.csdn.net/20160919081552588?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">  </p>
<p>B-树的特性：</p>
<p>1.关键字集合分布在整颗树中；</p>
<p>2.任何一个关键字出现且只出现在一个结点中；</p>
<p>3.搜索有可能在非叶子结点结束；</p>
<p>4.其搜索性能等价于在关键字全集内做一次二分查找；</p>
<p>5.自动层次控制；</p>
<p><strong>B+树</strong></p>
<p>B+树是B-树的变体，也是一种多路搜索树：</p>
<p>1.其定义基本与B-树同，除了：</p>
<p>2.非叶子结点的子树指针与关键字个数相同；</p>
<p>3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；</p>
<p>5.为所有叶子结点增加一个链指针；</p>
<p>6.所有关键字都在叶子结点出现；</p>
<p>如：（M=3）</p>
<p><img src="https://img-
blog.csdn.net/20160919081712887?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">  </p>
<p>B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</p>
<p>B+的特性：</p>
<p>1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</p>
<p>2.不可能在非叶子结点命中；</p>
<p>3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</p>
<p>4.更适合文件索引系统；</p>
<p><strong>B*树</strong></p>
<p>是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；</p>
<p><img src="https://img-
blog.csdn.net/20160919081814779?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">  </p>
<p>B<em>树定义了非叶子结点关键字个数至少为(2/3)</em>M，即块的最低使用率为2/3（代替B+树的1/2）；</p>
<p>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；</p>
<p>B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；</p>
<p>所以，B*树分配新结点的概率比B+树要低，空间使用率更高；</p>
<p><strong>小结</strong></p>
<p>B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；</p>
<p>所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</p>
<p>B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</p>
<p>B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 课设一:停车场管理</title>
    <url>/article/csdn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E8%AF%BE%E8%AE%BE%E4%B8%80:%E5%81%9C%E8%BD%A6%E5%9C%BA%E7%AE%A1%E7%90%86.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40364159" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40364159</a></p>
<p>停车场管理</p>
<p>【问题描述】</p>
<p>设停车场是一个可停放n辆汽车的狭长通道，且只有一个大门可供</p>
<p>汽车进出。汽车在停车场内按车辆到达时间的先后顺序，依次由北向</p>
<p>南排列（大门在最南端），若停车场内已停满n辆汽车，则后来的汽车</p>
<p>只能在门外的便道上等候，一旦有车开走，则排在便道上的第一辆车即</p>
<p>可开入；当停车场内某辆车要离开时，在它之后进入的车辆必须先退出</p>
<p>车场为它让路，待该辆车开出大门外，其他车辆再按原次序进入车场，</p>
<p>每辆停放在车场的车在它离开停车场时必须按它停留的时间长短交纳费</p>
<p>用。试为停车场编制按上述要求进行管理的模拟程序。</p>
<p>【基本要求】</p>
<p>以栈模拟停车场，以队列模拟车场外的便道。栈以顺序结构实现，</p>
<p>队列以链表结构实现。</p>
<p>每一组输入数据包括：汽车“到达”或“离去”信息、汽车牌照号码</p>
<p>以及到达或离去的时刻。</p>
<p>输出信息：若是车辆到达，则输出汽车在停车场内或便道上的停车</p>
<p>位置；若是车辆离去，则输出汽车在停车场内停留的时间和应交纳的费</p>
<p>用（在便道上停留的时间不收费）。</p>
<p>【测试数据】</p>
<p>设n=2，输入数据为：（’A’,1,5），（’A’,2,10），（’D’,1,15），</p>
<p>（’A’,3,20），（’A’,4,25），（’A’,5,30），（’D’,2,35），</p>
<p>（’D’,4,40），（’E’,0,0）。其中：’A’表示到达；’D’表示离去；</p>
<p>’E’表示输入结束。</p>
<p>【实现提示】</p>
<p>需另设一个栈，临时停放为给要离去的汽车让路而从停车场退出来</p>
<p>的汽车，也可用顺序存储结构实现。输入数据按到达或离去的时刻有序。</p>
<p>栈中每个元素表示一辆汽车，包含两个数据项：汽车的牌照号码和进入</p>
<p>停车场的时刻。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;
#include &lt;sstream&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;

using namespace std;

struct BUS
{
    int num;
    int intime;
    int outtime;
}bus[10000],buss[1000];

struct seq//停车场
{
    int bus[10000];
    int top;
};

struct seqq
{
    int buss[1000];
    int topp;
};

struct Biandao
{
    int data;
    int time;
    int num;
    struct Biandao *next;
};

struct biandao
{
    Biandao *first;
    Biandao *rear;
}biandao;

int main()
{
    int x,t;
    int n;
    printf(&quot;请输入停车场车位数量n：\n&quot;);
    cin &gt;&gt; n;

    char a[5];

    seq s;
    s.top=0;
    seqq ss;
    ss.topp=0;
    biandao.first=NULL;
    biandao.rear =NULL;
    int num = 0;
    printf(&quot;请输入操作： 车牌号： 时间：\n&quot;);
    while (cin &gt;&gt; a)
    {

        if ( !strcmp (a,&quot;A&quot;))
        {
            cin&gt;&gt;x&gt;&gt;t;
            if ( s.top &gt;= n )//如果停车场已满
            {
                Biandao *p;
                p=(Biandao *)malloc(sizeof(Biandao));
                p-&gt;data=x;
                p-&gt;time=t;
                num++;
                p-&gt;next=NULL;

                if (biandao.rear != NULL)
                    biandao.rear-&gt;next=p;
                    biandao.rear=p;

                if (biandao.first==NULL)
                    biandao.first=p;

                printf(&quot;在便道的第%d位置\n&quot;,num);

            }
            else//停车场未满
            {
                bus[s.top].num=x;
                bus[s.top].intime=t;
                printf(&quot;停车场的第%d位置\n&quot;,s.top+1);
                s.top++;
            }
        }
        else if (!strcmp (a,&quot;D&quot;))
        {
            cin&gt;&gt;x&gt;&gt;t;
            if (s.top == 0)
            {
                printf(&quot;输入错误 重新输入\n&quot;);
            }

            else
            {
                int nu;
                for (int i=0;i&lt;=s.top;i++)
                    {
                        if (bus[i].num == x)
                        {
                            nu=i;
                        }
                    }
                bus[nu].outtime=t;
                printf(&quot;停留时间%d, 费用 %d \n&quot;, bus[nu].outtime - bus[nu].intime ,bus[nu].outtime - bus[nu].intime );

                for (int i=nu ;i&lt;=s.top;i++)//出停车站
                {
                    bus[i]=bus[i+1];
                }

                s.top--;

                if (biandao.first!=NULL)//如果便道上有车
                {
                    bus[s.top].num = biandao.first-&gt;data;
                    bus[s.top].intime = t;
                    s.top++;
                    num--;
                    Biandao *q;
                    q=biandao.first;
                    biandao.first=biandao.first-&gt;next;
                    free(q);
                }
            }
        }
        else if(!strcmp (a,&quot;E&quot;))
        {
            break;
        }
        else
        {
            printf(&quot;输入有误 重新输入\n&quot;);
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构 课设二 唯一地确定一棵二叉树</title>
    <url>/article/csdn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E8%AF%BE%E8%AE%BE%E4%BA%8C:_%E5%94%AF%E4%B8%80%E5%9C%B0%E7%A1%AE%E5%AE%9A%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40866187" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40866187</a></p>
<p>唯一地确定一棵二叉树  </p>
<p>【问题描述】<br>如果给出了遍历二叉树的前序序列和中序序列，则可以构造出唯<br>一的一棵二叉树。试编写实现上述功能的程序。  </p>
<p>【基本要求】<br>已知一棵二叉树的前序和中序序列，试设计完成下列任务的一个<br>算法：<br>（1）构造一棵二叉树；<br>（2）以凹入表形式输出二叉树。<br>（3）证明构造正确（即分别以前序和中序遍历该树，将得到的结  </p>
<p>果与给出的序列进行比较）。</p>
<p>【测试数据】<br>前序序列为ABDEGCFHIJ，中序序列为DBGEAHFIJC。  </p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;malloc.h&gt;
#include&lt;string.h&gt;

typedef struct Node
{
    char data;
    struct Node *leftChild;
    struct Node *rightChild;
}BiTreeNode;

void Initiate(BiTreeNode **root)
{
    *root=(BiTreeNode *)malloc(sizeof(BiTreeNode));
    (*root)-&gt;leftChild=NULL;
    (*root)-&gt;rightChild=NULL;
}
BiTreeNode *InsertLeftNode(BiTreeNode *curr,char x)
{
    BiTreeNode *s,*t;
    if(curr==NULL) return NULL;
    t=curr-&gt;leftChild;
    s=(BiTreeNode *)malloc(sizeof(BiTreeNode));
    s-&gt;data=x;
    s-&gt;leftChild=t;
    s-&gt;rightChild=NULL;
    curr-&gt;leftChild=s;
    return curr-&gt;leftChild;
}
BiTreeNode *InsertRightNode(BiTreeNode *curr,char x)
{
    BiTreeNode *s,*t;
    if(curr==NULL) return NULL;
    t=curr-&gt;rightChild;
    s=(BiTreeNode *)malloc(sizeof(BiTreeNode));
    s-&gt;data=x;
    s-&gt;rightChild=t;
    s-&gt;leftChild=NULL;
    curr-&gt;rightChild=s;
    return curr-&gt;rightChild;
}
void PrintBiTree(BiTreeNode *bt,int n)
{
    int i;
    if(bt==NULL) return;
    PrintBiTree(bt-&gt;rightChild,n+1);
    for(i=0;i&lt;n-1;i++) printf(&quot;   &quot;);
    if(n&gt;0)
    {
        printf(&quot;---&quot;);
        printf(&quot;%c\n&quot;,bt-&gt;data);
    }
    PrintBiTree(bt-&gt;leftChild,n+1);
}
void Visit(char item)
{
    printf(&quot;%c   &quot;,item);
}
void PreOrder(BiTreeNode *t,void Visit(char item))
{
    if(t!=NULL)
    {
        Visit(t-&gt;data);
        PreOrder(t-&gt;leftChild,Visit);
        PreOrder(t-&gt;rightChild,Visit);
    }
}
void InOrder(BiTreeNode *t,void Visit(char item))
{
    if(t!=NULL)
    {
        InOrder(t-&gt;leftChild,Visit);
        Visit(t-&gt;data);
        InOrder(t-&gt;rightChild,Visit);
    }
}
int Search(char str[],char t)
{
    int i=0;
    while(str[i]!=t)
        i++;
    return i;
}
int SearchLeft(int Num[],int t)
{
    int i;
    i=t;
    while(Num[i]!=1&amp;&amp;i&gt;=0)
        i--;
    if(Num[i]==1)
        return i;
    else return -1;
}
int SearchRight(int Num[],int t)
{
    int i;
    i=t;
    while(Num[i]!=1&amp;&amp;i&lt;=10000)
        i++;
    if(Num[i]==1)
        return i;
    else return -1;
}

int main()
{
    int i;
    BiTreeNode *q[10000];
    BiTreeNode *root;
    int left,right,temp;

    int Num[10000]={0};
    char strA[10000];
    char strB[10000];
    char point;
    int n;

    printf(&quot;请输入前序遍历:&quot;);

    scanf(&quot;%s&quot;,strA);

    printf(&quot;请输入中序遍历:&quot;);
    scanf(&quot;%s&quot;,strB);

    n=strlen(strA);
    Initiate(&amp;root);

    for(i=0;i&lt;n;i++)
    {
        point=strA[i];
        temp=Search(strB,point);
        left=SearchLeft(Num,temp);
        right=SearchRight(Num,temp);
        if(left==-1&amp;&amp;right==-1)
        {
            q[temp]=InsertLeftNode(root,point);
            Num[temp]=1;
        }
        else if(left!=-1&amp;&amp;q[left]-&gt;rightChild==NULL)
        {
            q[temp]=InsertRightNode(q[left],point);
            Num[temp]=1;
        }
        else if(right!=-1&amp;&amp;q[right]-&gt;leftChild==NULL)
        {
            q[temp]=InsertLeftNode(q[right],point);
            Num[temp]=1;
        }
    }
    PrintBiTree(root,0);

    printf(&quot;前序遍历: \n\n&quot;);
    PreOrder(root-&gt;leftChild,Visit);

    printf(&quot;\n中序遍历:\n&quot;);
    InOrder(root-&gt;leftChild,Visit);

    printf(&quot;\n\n                  by :192132 孟凡强\n&quot;);

    return 0;


}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>数的划分问题 【DP】</title>
    <url>/article/csdn/%E6%95%B0%E7%9A%84%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98_%E3%80%90DP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46383393" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46383393</a></p>
<p>问题：</p>
<p>把一个整数n分成k份，每份都不为0，有几种分法？</p>
<p>分析:</p>
<p>情况分为两类</p>
<p>一、</p>
<p>每份中不包含1的方法，为保证每份&gt;=2，先拿出K个1到每一份，然后把剩下的n-k分为k份，分法有dp[n-k][k]</p>
<p>二、</p>
<p>至少有一份包含1，拿出1个当为一份。剩下的n-1个分为k-1份，分法有dp[n-1][k-1].</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;cstdio&gt;  
#include &lt;cstring&gt;  
#include &lt;algorithm&gt;  
#include &lt;string&gt;  
#include &lt;queue&gt;  

using namespace std;

int n, k;
int dp[222][10];

int main()
{
    while (cin &gt;&gt; n &gt;&gt; k)
    {
        dp[0][0] = 1;
        for (int i = 1; i &lt;= n; i++)
        {
            for (int j = 1; j &lt;= k; j++)
            {
                if (i &gt;= j) dp[i][j] = dp[i - j][j] + dp[i - 1][j - 1];
            }
        }
        cout &lt;&lt; dp[n][k] &lt;&lt; endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>数组指针和指针数组</title>
    <url>/article/csdn/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46434541" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46434541</a></p>
<p>这两个名字不同当然所代表的意思也就不同。我刚开始看到这就吓到了，主要是中文太博大精深了，整这样的简称太专业了，把人都绕晕了。从英文解释或中文全称看就比较容易理解。</p>
<p>指针数组：array of pointers，即用于存储指针的数组，也就是数组元素都是指针</p>
<p>数组指针：a pointer to an array，即指向数组的指针</p>
<p>还要注意的是他们用法的区别，下面举例说明。</p>
<p>int* a[4] 指针数组</p>
<pre><code>         表示：数组a中的元素都为int型指针    

         元素表示：*a[i]   *(a[i])是一样的，因为[]优先级高于*
</code></pre><p>int (*a)[4] 数组指针</p>
<pre><code>         表示：指向数组a的指针

         元素表示：(*a)[i]



#include &lt;iostream&gt;

using namespace std;

int main()
{
int c[4]={1,2,3,4};
int *a[4]; //指针数组
int (*b)[4]; //数组指针
b=&amp;c;
//将数组c中元素赋给数组a
for(int i=0;i&lt;4;i++)
{
a[i]=&amp;c[i];
}
//输出看下结果
cout&lt;&lt;*a[1]&lt;&lt;endl; //输出2就对
cout&lt;&lt;(*b)[2]&lt;&lt;endl; //输出3就对
return 0;
}
</code></pre><p>注意：定义了数组指针，该指针指向这个数组的首地址，必须给指针指定一个地址，容易犯的错得就是，不给b地址，直接用(<em>b)[i]=c[i]给数组b中元素赋值，这时数组指针不知道指向哪里，调试时可能没错，但运行时肯定出现问题，使用指针时要注意这个问题。但为什么a就不用给他地址呢，a的元素是指针，实际上for循环内已经给数组a中元素指定地址了。但若在for循环内写</em>a[i]=c[i]，这同样会出问题。总之一句话，定义了指针一定要知道指针指向哪里，不然要悲剧。</p>
<h2><span id="分界线">分界线</span></h2><p>数组指针（也称行指针）定义 int(<em>p)[n];<br>()优先级高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度。<br>如要将二维数组赋给一指针，应这样赋值：<br>int a[3][4];<br>int (</em>p)[4]; //该语句是定义一个数组指针，指向含4个元素的一维数组。<br>p=a; //将该二维数组的首地址赋给p，也就是a[0]或&amp;a[0][0]<br>p++; //该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]</p>
<p>所以数组指针也称指向一维数组的指针，亦称行指针。</p>
<p>指针数组<br>定义 int <em>p[n];<br>[]优先级高，先与p结合成为一个数组，再由int</em>说明这是一个整型指针数组，它有n个指针类型的数组元素。这里执行p+1时，则p指向下一个数组元素，这样赋值是错误的：p=a；因为p是个不可知的表示，只存在p[0]、p[1]、p[2]…p[n-1],而且它们分别是指针变量可以用来存放变量地址。但可以这样<br><em>p=a; 这里</em>p表示指针数组第一个元素的值，a的首地址的值。<br>如要将二维数组赋给一指针数组:<br>int <em>p[3];<br>int a[3][4];<br>p++; //该语句表示p数组指向下一个数组元素。注：此数组每一个元素都是一个指针<br>for(i=0;i&lt;3;i++)<br>p[i]=a[i]<br>这里int </em>p[3] 表示一个一维数组内存放着三个指针变量，分别是p[0]、p[1]、p[2]<br>所以要分别赋值。</p>
<p>这样两者的区别就豁然开朗了，数组指针只是一个指针变量，似乎是C语言里专门用来指向二维数组的，它占有内存中一个指针的存储空间。指针数组是多个指针变量，以数组形式存在内存当中，占有多个指针的存储空间。<br>还需要说明的一点就是，同时用来指向二维数组时，其引用和用数组名引用都是一样的。<br>比如要表示数组中i行j列一个元素：<br><em>(p[i]+j)、</em> ( <em>(p+i)+j)、(</em> (p+i))[j]、p[i][j]</p>
<p>优先级：() &gt;[]&gt;*</p>
<h2><span id="指针数组和数组指针的内存布局">指针数组和数组指针的内存布局</span></h2><p>初学者总是分不出指针数组与数组指针的区别。其实很好理解：<br>指针数组：首先它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身的大小决定，每一个元素都是一个指针，在32 位系统下任何类型的指针永远是占4<br>个字节。它是“储存指针的数组”的简称。<br>数组指针：首先它是一个指针，它指向一个数组。在32 位系统下任何类型的指针永远是占4<br>个字节，至于它指向的数组占多少字节，不知道，具体要看数组大小。它是“指向数组的指针”的简称。</p>
<p>下面到底哪个是数组指针，哪个是指针数组呢：<br>A)<br>int <em>p1[10];<br>B)<br>int (</em>p2)[10];<br>每次上课问这个问题，总有弄不清楚的。这里需要明白一个符号之间的优先级问题。</p>
<p>“[]”的优先级比“ <em>”要高。p1 先与“[]”结合，构成一个数组的定义，数组名为p1，int</em><br>修饰的是数组的内容，即数组的每个元素。那现在我们清楚，这是一个数组，其包含10 个指向int 类型数据的指针，即指针数组。至于p2<br>就更好理解了，在这里“（）”的优先级比“[]”高，“*”号和p2 构成一个指针的定义，指针变量名为p2，int<br>修饰的是数组的内容，即数组的每个元素。数组在这里并没有名字，是个匿名数组。那现在我们清楚p2 是一个指针，它指向一个包含10 个int<br>类型数据的数组，即数组指针。</p>
<p><img src="https://img-blog.csdn.net/20160910184737307" alt="这里写图片描述"></p>
<p>转自：<br><a href="http://www.cnblogs.com/mq0036/p/3382732.html" target="_blank" rel="noopener"> http://www.cnblogs.com/mq0036/p/3382732.html
</a><br><a href="http://www.cnblogs.com/Romi/archive/2012/01/10/2317898.html" target="_blank" rel="noopener"> http://www.cnblogs.com/Romi/archive/2012/01/10/2317898.html
</a></p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>整数划分问题 【DP】</title>
    <url>/article/csdn/%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98_%E3%80%90DP%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46383327" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46383327</a></p>
<p>整数划分的定义：</p>
<p>n=m1+m2+…+mi; （其中mi为正整数，并且1 &lt;= mi &lt;= n），则{m1,m2,…,mi}为n的一个划分。<br>如果{m1,m2,…,mi}中的最大值不超过m，即max(m1,m2,…,mi)&lt;=m，则称它属于n的一个m划分。这里我们记n的m划分的个数为f(n,m);<br>举个例子，当n=5时我们可以获得以下这几种划分（注意，例子中m&gt;=5）<br>5 = 5<br>= 4 + 1<br>= 3 + 2<br>= 3 + 1 + 1<br>= 2 + 2 + 1<br>= 2 + 1 + 1 + 1<br>= 1 + 1 + 1 + 1 + 1</p>
<p>动规算法的解法：</p>
<p>根据n和m的关系，考虑以下几种情况：<br>1. 当n=1时，不论m的值为多少（m&gt;0)，只有一种划分即{1};<br>2. 当m=1时，不论n的值为多少，只有一种划分即n个1，{1,1,1,…,1};<br>3. 当n=m时，根据划分中是否包含n，可以分为两种情况：<br>(1) 划分中包含n的情况，只有一个即{n}；<br>(2) 划分中不包含n的情况，这时划分中最大的数字也一定比n小，即n的所有(n-1)划分。因此 f(n,n) =1 + f(n,n-1);<br>4. 当n</p>
<pre><code>#include&lt;stdlib.h&gt;  
#include&lt;ctype.h&gt;  
#include&lt;algorithm&gt;  
#include&lt;vector&gt;  
#include&lt;string&gt;  
#include&lt;queue&gt;  
#include&lt;stack&gt;  
#include&lt;set&gt;  
#include&lt;map&gt;  
#include &lt;string&gt;  
#include &lt;sstream&gt;  

using namespace std;

int n, m;
int dp[100][100];

int main()
{
    while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)
    {
        memset(dp,0,sizeof(dp));
        dp[1][1] = 1;
        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= m; j++)
            {
                if (i == 1 || j == 1)
                    dp[i][j] = 1;
                else if (i &lt; j)
                    dp[i][j] = dp[i][i];
                else if (i == j)
                    dp[i][j] = 1 + dp[i][i - 1];
                else if (n&gt;m)
                    dp[i][j] = dp[i][j - 1] + dp[i - j][j];
            }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>斯特灵公式</title>
    <url>/article/csdn/%E6%96%AF%E7%89%B9%E7%81%B5%E5%85%AC%E5%BC%8F.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40650853" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40650853</a></p>
<p>计算阶乘位数，利用斯特灵公式：</p>
<p>一  般来说，当n很大的时候，n阶乘的计算量十分大，所以斯特灵公式十分好用，</p>
<p>而且，</p>
<p>即使在n很小的时候，斯特灵公式的取值已经十分准确。</p>
<p>公式(1)推导:</p>
<p>ln(n!)=0.5<em>ln(2</em>PI<em>n)+n</em>ln(n/e)</p>
<p>=0.5<em>ln(2</em>PI<em>n)+n</em>ln(n)-n</p>
<p>根据换底公式ln(n)/ln(10)=log10(n)得：</p>
<p>log10(n!)=(0.5<em>log(2</em>PI<em>n)+n</em>log(n)-n)/log(10)</p>
<pre><code>#define PI 3.1415926 
int main()  
{
       int n,count;    
  while(scanf(&quot;%d&quot;,&amp;count)!=EOF)  
 {         
            while(count--)  
       {           
             scanf(&quot;%d&quot;,&amp;n);       
             printf(&quot;%d\n&quot;,(int)((n*log(n)-n+0.5*log(2*n*PI))/log(10.0))+1);         
     }         
 } 
return 0; 
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>最大化平均值 【二分法】</title>
    <url>/article/csdn/%E6%9C%80%E5%A4%A7%E5%8C%96%E5%B9%B3%E5%9D%87%E5%80%BC_%E3%80%90%E4%BA%8C%E5%88%86%E6%B3%95%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44680343" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44680343</a></p>
<p>n个物品重量价值分别为wi,vi；取k个值使得单位重量的价值最大。<br>输入：<br>n k<br>接下来n行表示重量<br>接下来n行表示价值</p>
<p>分析：<br>贪心是错的。<br>使的vi/wi最大 ，假设单位重量的最大价值为x。<br>则vi /wi &gt;=x<br>即vi-wi*x&gt;=0<br>所以按照上面公式排序二分求解。</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;

using namespace std;

const int MAXN = 1010;
int n, k;
struct node
{
    double w;
    double v;
}p[MAXN];

double q[MAXN];

bool cmp(double a, double b)
{
    return a &gt; b;
}

bool  c(double x)
{
    for (int i = 0; i &lt; n; i++)
        q[i] = p[i].v - x*p[i].w;
    sort(q, q + n,cmp);
    double sum = 0;
    for (int i = 0; i &lt; k; i++)
        sum += q[i];
    if (sum &gt;= 0)
        return true;
    else
        return false;
}

int main()
{
    while (cin &gt;&gt; n&gt;&gt;k)
    {
        for (int i = 0; i &lt; n; i++)
            cin &gt;&gt; p[i].w;
        for (int i = 0; i &lt; n; i++)
            cin &gt;&gt; p[i].v;

        double ans = 0;
        double down = 0, up = 1e9;

        for (int i = 0; i &lt; 100; i++)
        {
            double mid = (down + up) / 2;
            if (c(mid))
                down = mid;
            else
                up = mid;
        }
        printf(&quot;%.2lf\n&quot;,up);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>最大子串和--动态规划经典问题</title>
    <url>/article/csdn/%E6%9C%80%E5%A4%A7%E5%AD%90%E4%B8%B2%E5%92%8C--%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44080943" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44080943</a></p>
<p>【问题描述】<br>在长度为N的整形数组中，求连续子串的和的最大值，要求复杂度为O(N)。<br>例如：1 2 3 -1 -20 100 34，结果为134。</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;

using namespace std;

int n, p[10010];

int main()
{
    while (cin &gt;&gt; n)
    {
        for (int i = 0; i &lt; n; i++)
            cin &gt;&gt; p[i];
        int b = 0, sum = 0;

        for (int i = 0; i &lt; n; i++)
        {
            b += p[i];
            if (b &gt; sum)
                sum = b;
            if (b &lt; 0)
                b = 0;
        }
        cout &lt;&lt; sum &lt;&lt; endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>最大流SAP -邻接表模板</title>
    <url>/article/csdn/%E6%9C%80%E5%A4%A7%E6%B5%81SAP_-%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%A8%A1%E6%9D%BF.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46383235" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46383235</a></p>
<pre><code>const int MAXN = 1010;//点数的最大值
const int MAXM = 400010;//边数的最大值
const int INF = 0x3f3f3f3f;
struct Edge
{
    int to, next, cap, flow;
}edge[MAXM];//注意是MAXM
int tol;
int head[MAXN];
int gap[MAXN], dep[MAXN], pre[MAXN], cur[MAXN];
void init()
{
    tol = 0;
    memset(head, -1, sizeof(head));
}
//加边，单向图三个参数，双向图四个参数
void addedge(int u, int v, int w, int rw = 0)
{
    edge[tol].to = v; edge[tol].cap = w; edge[tol].next = head[u];
    edge[tol].flow = 0; head[u] = tol++;
    edge[tol].to = u; edge[tol].cap = rw; edge[tol].next = head[v];
    edge[tol].flow = 0; head[v] = tol++;
}
//输入参数：起点、终点、点的总数
//点的编号没有影响，只要输入点的总数
int sap(int start, int end, int N)
{
    memset(gap, 0, sizeof(gap));
    memset(dep, 0, sizeof(dep));
    memcpy(cur, head, sizeof(head));
    int u = start;
    pre[u] = -1;
    gap[0] = N;
    int ans = 0;
    while (dep[start] &lt; N)
    {
        if (u == end)
        {
            int Min = INF;
            for (int i = pre[u]; i != -1; i = pre[edge[i ^ 1].to])
                if (Min &gt; edge[i].cap - edge[i].flow)
                    Min = edge[i].cap - edge[i].flow;
            for (int i = pre[u]; i != -1; i = pre[edge[i ^ 1].to])
            {
                edge[i].flow += Min;
                edge[i ^ 1].flow -= Min;
            }
            u = start;
            ans += Min;
            continue;
        }
        bool flag = false;
        int v;
        for (int i = cur[u]; i != -1; i = edge[i].next)
        {
            v = edge[i].to;
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[v] + 1 == dep[u])
            {
                flag = true;
                cur[u] = pre[v] = i;
                break;
            }
        }
        if (flag)
        {
            u = v;
            continue;
        }
        int Min = N;
        for (int i = head[u]; i != -1; i = edge[i].next)
            if (edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min)
            {
                Min = dep[edge[i].to];
                cur[u] = i;
            }
        gap[dep[u]]--;
        if (!gap[dep[u]])return ans;
        dep[u] = Min + 1;
        gap[dep[u]]++;
        if (u != start) u = edge[pre[u] ^ 1].to;
    }
    return ans;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>最大流SAP模板（邻接矩阵）</title>
    <url>/article/csdn/%E6%9C%80%E5%A4%A7%E6%B5%81SAP%E6%A8%A1%E6%9D%BF%EF%BC%88%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%EF%BC%89.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46383251" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46383251</a></p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;  
#include &lt;ctype.h&gt;  
#include &lt;algorithm&gt;  
#include &lt;vector&gt;  
#include &lt;string.h&gt;  
#include &lt;queue&gt;  
#include &lt;stack&gt;  
#include &lt;set&gt;  
#include &lt;map&gt;  
#include &lt;string&gt;  
#include &lt;sstream&gt;  
#include &lt;malloc.h&gt;

using namespace std;
//结点编号0开始
const int MAXN = 1100;
int maze[MAXN][MAXN];
int gap[MAXN], dis[MAXN], pre[MAXN], cur[MAXN];
int sap(int start,int end,int nodenum)
{
    memset(cur, 0, sizeof(cur));
    memset(dis, 0, sizeof(dis));
    memset(gap, 0, sizeof(gap));
    int u = pre[start] = start, maxflow, aug = -1;
    gap[0] = nodenum;
    while (dis[start] &lt; nodenum)
    {
        loop:
        for (int v = cur[u]; v &lt; nodenum; v++)
            if (maze[u][v] &amp;&amp; dis[u] == dis[v] + 1)
            {
                if (aug == -1 || aug &gt; maze[u][v])
                    aug = maze[u][v];
                pre[v] = u;
                u = cur[u] = v;
                if (v == end)
                {
                    maxflow += aug;
                    for (u = pre[u]; v != start; v = u, u = pre[u])
                    {
                        maze[u][v] -= aug;
                        maze[v][u] += aug;
                    }
                    aug = -1;
                }
            goto loop;
            }
        int mindis = nodenum - 1;
        for (int v = 0; v &lt; nodenum;v++)
            if (maze[u][v] &amp;&amp; mindis &gt; dis[v])
            {
                cur[u] = v;
                mindis = dis[v];
            }
        if ((--gap[dis[u]]) == 0) break;
        gap[dis[u] = mindis + 1]++;
        u = pre[u];
    }
    return maxflow;
}

int main()
{
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>最小堆</title>
    <url>/article/csdn/%E6%9C%80%E5%B0%8F%E5%A0%86.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/50790795" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/50790795</a></p>
<p>最小堆:所有父亲节点的值都小于儿子节点。<br>插入操作:首先在末尾添加元素，再不断向上（父亲节点）调整位置<br>删除操作：把末尾的元素值赋给根，并且删除末尾项，并且从根向下（儿子节点）不断调整位置。</p>
<p>最大堆与最小堆类似。操作反过来即可。</p>
<p>代码：</p>
<pre><code>const int MAXN = 1010;

int heap[MAXN], sz = 0;

void push(int x)
{
    int i = sz++;
    while (i &gt; 0)
    {
        //父亲节点编号
        int p = (i - 1) / 2;
        //如果当前父亲节点的值小于x
        if (heap[p] &lt;= x)
            break;
        //不断向上交换
        heap[i] = heap[p];
        i = p;
    }
    //找到合适位置 
    heap[i] = x;
}

int pop()
{
    int ret = heap[0];
    int x = heap[--sz];

    int i = 0;
    while (i * 2 + 1 &lt; sz)
    {
        //两个儿子节点编号
        int s1 = i * 2 + 1;
        int s2 = i * 2 + 2;
        //寻找较小的儿子节点
        if (heap[s1] &gt; heap[s2])
            s1 = s2;
        //儿子节点值大于x
        if (heap[s1] &gt;= x)
            break;
        //不断向下交换
        heap[i] = heap[s1];
        i = s1;
    }
    //找到合适位置
    heap[i] = x;
    return ret;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习实战 第2章 k-近邻算法</title>
    <url>/article/csdn/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98_%E7%AC%AC2%E7%AB%A0_k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/50372072" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/50372072</a></p>
<p>原理：<br>选取k个最近的样本，样本中比例最大的种类即是新数据的分类。</p>
<p>简单的分类器：</p>
<pre><code>from numpy import *
import operator 

def createDataSet():
    group = array([[1.0,1.1],[1.0,1.0],[0,0],[0,0.1]])
    labels = [&#39;A&#39;,&#39;A&#39;,&#39;B&#39;,&#39;B&#39;]
    return group,labels

g,la = createDataSet()

def classify0(inx,dataSet,labels,k):
    dataSetSize = dataSet.shape[0]
    diffMat = tile(inx,(dataSetSize,1)) - dataSet
    sqDiffMat = diffMat**2
    sqDistances = sqDiffMat.sum(axis = 1)
    distances = sqDistances**0.5;
    sortedDis = distances.argsort()
    classCount = {}
    for i in range (k):
        votelabel = labels[sortedDis[i]]
        classCount[votelabel] = classCount.get(votelabel,0) + 1
    sortedClassCount = sorted(classCount.iteritems(),
                              key = operator.itemgetter(1),reverse = True)
    return sortedClassCount[0][0]

print classify0([0,0],g,la,3)
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习</title>
    <url>/article/csdn/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/49557471" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/49557471</a></p>
<p>记录一些资料及学习笔记。</p>
<p>斯坦福大学公开课 ：机器学习课程<br>网易： <a href="http://open.163.com/special/opencourse/machinelearning.html" target="_blank" rel="noopener"> http://open.163.com/special/opencourse/machinelearning.html
</a><br>斯坦福机器学习课程主页： <a href="http://cs229.stanford.edu/materials.html" target="_blank" rel="noopener"> http://cs229.stanford.edu/materials.html
</a><br>coursera: <a href="https://www.coursera.org/learn/machine-learning/" target="_blank" rel="noopener"> https://www.coursera.org/learn/machine-learning/
</a></p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>枚举全排列 STL next_permutation</title>
    <url>/article/csdn/%E6%9E%9A%E4%B8%BE%E5%85%A8%E6%8E%92%E5%88%97_STL_next_permutation.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41147197" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41147197</a></p>
<p>运用STL next_permutation 函数 ：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt;
#include&lt;malloc.h&gt;
#include&lt;stdexcept&gt;

using namespace std;

int  main ()
{
    int n;
    scanf (&quot;%d&quot;,&amp;n);
    int a[10];
    for(int i=0 ;i&lt;n;i++)
        cin&gt;&gt;a[i];
    sort (a,a+n);
    do
    {
        for(int i=0;i&lt;n;i++)
            cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;
        cout&lt;&lt;endl;
    }while( next_permutation(a,a+n) );
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>树状数组区间求和三种模型</title>
    <url>/article/csdn/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%9E%8B.html</url>
    <content><![CDATA[<p>树状数组在区间求和问题上有大用，其三种复杂度都比线段树要低很多……有关区间求和的问题主要有以下三个模型（以下设A[1..N]为一个长为N的序列，初始值为全0）：</p>
<p>（1）“改点求段”型，即对于序列A有以下操作：</p>
<p>【1】修改操作：将A[x]的值加上c；</p>
<p>【2】求和操作：求此时A[l..r]的和。</p>
<p>这是最容易的模型，不需要任何辅助数组。树状数组中从x开始不断减lowbit(x)（即x&amp;(-x)）可以得到整个[1..x]的和，而从x开始不断加lowbit(x)则可以得到x的所有前趋。代码：</p>
<p>void  ADD(  int  x,  int  c)<br>{<br>for  (  int  i  =  x; i  &lt;=  n; i  +=  i  &amp; (  -  i)) a[i]  +=  c;<br>}<br>int  SUM(  int  x)<br>{<br>int  s  =  0  ;<br>for  (  int  i  =  x; i  &gt; 0  ; i  -=  i  &amp; (  -  i)) s  +=  a[i];<br>return  s;<br>}  </p>
<p>操作【1】：ADD(x, c);</p>
<p>操作【2】：SUM(r)-SUM(l-1)。  </p>
<p>（2）“改段求点”型，即对于序列A有以下操作：</p>
<p>【1】修改操作：将A[l..r]之间的全部元素值加上c；</p>
<p>【2】求和操作：求此时A[x]的值。  </p>
<p>这个模型中需要设置一个辅助数组B：B[i]表示A[1..i]到目前为止共被整体加了多少（或者可以说成，到目前为止的所有ADD(i, c)操作中c的总和）。</p>
<p>则可以发现，对于之前的所有ADD(x,<br>c)操作，当且仅当x&gt;=i时，该操作会对A[i]的值造成影响（将A[i]加上c），又由于初始A[i]=0，所以有A[i] =<br>B[i..N]之和！而ADD(i, c)（将A[1..i]整体加上c），将B[i]加上c即可——只要对B数组进行操作就行了。</p>
<p>【首先对于每个数A定义集合up(A)表示{A, A+lowestbit(A),<br>A+lowestbit(A)+lowestbit(A+lowestbit(A))…} 定义集合down(A)表示{A, A-lowestbit(A),<br>A-lowestbit(A)-lowestbit(A-lowestbit(A)) … ,<br>0}。可以发现对于任何A&lt;B，up(A)和down(B)的交集有且仅有一个数。</p>
<p>翻转一个区间[A,B]（为了便于讨论先把原问题降为一维的情况），我们可以把down(B)的所有元素的翻转次数+1，再把down(A-1)的所有元素的翻转次数-1。而每次查询一个元素C时，只需要统计up(C)的所有元素的翻转次数之和，即为C实际被翻转的次数】</p>
<p>这样就把该模型转化成了“改点求点”型，只是有一点不同的是，SUM(x)不是求B[1..x]的和而是求B[x..N]的和，此时只需把ADD和SUM中的增减次序对调即可（模型1中是ADD加SUM减，这里是ADD减SUM加）。代码：  </p>
<p>void  ADD(  int  x,  int  c)<br>{<br>for  (  int  i  =  x; i  &gt; 0  ; i  -=  i  &amp; (  -  i)) b[i]  +=  c;<br>}<br>int  SUM(  int  x)<br>{<br>int  s  =  0  ;<br>for  (  int  i  =  x; i  &lt;=  n; i  +=  i  &amp; (  -  i)) s  +=  b[i];<br>return  s;<br>}</p>
<p>操作【1】：ADD(l-1, -c); ADD(r, c);  </p>
<p>操作【2】：SUM(x)。  </p>
<p>（3）“改段求段”型，即对于序列A有以下操作：  </p>
<p>【1】修改操作：将A[l..r]之间的全部元素值加上c；  </p>
<p>【2】求和操作：求此时A[l..r]的和。  </p>
<p>这是最复杂的模型，需要两个辅助数组：B[i]表示A[1..i]到目前为止共被整体加了多少（和模型2中的一样），C[i]表示A[1..i]到目前为止共被整体加了多少的总和（或者说，C[i]=B[i]*i）。  </p>
<p>对于ADD(x, c)，只要将B[x]加上c，同时C[x]加上c*x即可（根据C[x]和B[x]间的关系可得）；  </p>
<p>而ADD(x,<br>c)操作是这样影响A[1..i]的和的：若x&lt;i，则会将A[1..i]的和加上x<em>c，否则（x&gt;=i）会将A[1..i]的和加上i</em>c。也就是，A[1..i]之和<br>= B[i..N]之和 * i + C[1..i-1]之和。<br>这样对于B和C两个数组而言就变成了“改点求段”（不过B是求后缀和而C是求前缀和）。<br>另外，该模型中需要特别注意越界问题，即x=0时不能执行SUM_B操作和ADD_C操作！代码：  </p>
<p>void  ADD_B(  int  x,  int  c)<br>{<br>for  (  int  i  =  x; i  &gt; 0  ; i  -=  i  &amp; (  -  i)) B[i]  +=  c;<br>}<br>void  ADD_C(  int  x,  int  c)<br>{<br>for  (  int  i  =  x; i  &lt;=  n; i  +=  i  &amp; (  -  i)) C[i]  +=  x  <em>  c;<br>}<br>int  SUM_B(  int  x)<br>{<br>int  s  =  0  ;<br>for  (  int  i  =  x; i  &lt;=  n; i  +=  i  &amp; (  -  i)) s  +=  B[i];<br>return  s;<br>}<br>int  SUM_C(  int  x)<br>{<br>int  s  =  0  ;<br>for  (  int  i  =  x; i  &gt; 0  ; i  -=  i  &amp; (  -  i)) s  +=  C[i];<br>return  s;<br>}<br>inline  int  SUM(  int  x)<br>{<br>if  (x)  return  SUM_B(x)  </em>  x  +  SUM_C(x  -  1  );  else  return  0  ;<br>}</p>
<p>操作【1】：<br>ADD_B(r, c); ADD_C(r, c);<br>if (l &gt; 1) {ADD_B(l - 1, -c); ADD_C(l - 1, -c);}<br>操作【2】：SUM(r) - SUM(l - 1)。</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>c语言</tag>
        <tag>位运算</tag>
        <tag>树状数组</tag>
        <tag>amp</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉函数及其性质</title>
    <url>/article/csdn/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E6%80%A7%E8%B4%A8.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44200711" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44200711</a></p>
<p>对正整数n，欧拉函数是 &lt;= n的数中与n互质的数的数目。</p>
<p>例如euler(8)=4，因为1,3,5,7均和8互质。</p>
<p>Euler函数表达通式：euler(x)=x(1-1/p1)(1-1/p2)(1-1/p3)(1-1/p4)…(1-1/pn),其中p1,p2……pn为x的所有素因数，x是不为0的整数。euler(1)=1（唯一和1互质的数就是1本身）。  </p>
<p>欧拉公式的延伸：一个数的所有质因子之和是euler(n)*n/2。</p>
<p>特殊性质：当n为奇数时，φ(2n)=φ(n)  </p>
<p>欧拉函数是 <a href="http://baike.baidu.com/view/2046973.htm" target="_blank" rel="noopener"> 积性函数 </a><br>——若m,n互质，φ(mn)=φ(m)φ(n)。</p>
<p>若n是质数p的k次幂，φ(n)=p^k-p^(k-1)=(p-1)p^(k-1)，因为除了p的倍数外，其他数都跟n互质。</p>
<p>设a为N的质因数，若(N % a == 0 &amp;&amp; (N / a) % a == 0) 则有E(N)=E(N / a) <em> a；若(N % a == 0 &amp;&amp;<br>(N / a) % a != 0) 则有：E(N) = E(N / a) </em> (a - 1)。</p>
<p>欧拉定理：对于互质的正整数a和n，有a^φ(n) ≡ (1 mod n)。  </p>
<p>代码实现：</p>
<p>最高效率的线性时间筛法求素数和欧拉函数。</p>
<p>phi[MAXN] 数组保存的是欧拉函数，prime[MAXN]保存的是素数表。</p>
<pre><code>bool com[MAXN];
int primes, prime[MAXN], phi[MAXN];

phi[1] = 1;
for (int i = 2; i &lt;= n; ++i)
{
  if (!com[i])
  {
    prime[primes++] = i;
    phi[i] = i-1;
  }
  for (int j = 0; j &lt; primes &amp;&amp; i*prime[j] &lt;= n; ++j)
  {
    com[i*prime[j]] = true;
    if (i % prime[j])
      phi[i*prime[j]] = phi[i]*(prime[j]-1);
    else
      { phi[i*prime[j]] = phi[i]*prime[j]; break; }
  }
}
</code></pre><p><strong>  
</strong></p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>求二叉树节点的最大距离</title>
    <url>/article/csdn/%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47179983" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47179983</a></p>
<p>距离即为节点间的边数。</p>
<p>code:</p>
<pre><code>struct Node
{
    Node* left;
    Node* right;
    int nmaxleft;
    int nmaxright;
    int vhvalue;
};

int ans;//答案

int findmaxval(Node* root)
{
    if (root == NULL) return;
    if (root-&gt;left == NULL) return root-&gt;nmaxleft = 0;
    if (root-&gt;right == NULL) return root-&gt;nmaxright = 0;
    if (root-&gt;left != NULL) findmaxval(root-&gt;left);
    if (root-&gt;right != NULL) findmaxval(root-&gt;right);
    if (root-&gt;left != NULL)
    {
        int tmp = 0;
        if (root-&gt;left-&gt;nmaxleft &gt; root-&gt;left-&gt;nmaxright)
            tmp = root-&gt;left-&gt;nmaxleft;
        else
            tmp = root-&gt;left-&gt;nmaxright;
        root-&gt;nmaxleft = tmp + 1;
    }
    if (root-&gt;right != NULL)
    {
        int tmp = 0;
        if (root-&gt;right-&gt;nmaxleft &gt; root-&gt;right-&gt;nmaxright)
            tmp = root-&gt;right-&gt;nmaxleft;
        else
            tmp = root-&gt;right-&gt;nmaxright;
        root-&gt;nmaxright = tmp + 1;
    }

    ans = max(ans, root-&gt;nmaxleft + root-&gt;nmaxright);
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>漂洋过海来看你 【dfs or 最短路】</title>
    <url>/article/csdn/%E6%BC%82%E6%B4%8B%E8%BF%87%E6%B5%B7%E6%9D%A5%E7%9C%8B%E4%BD%A0_%E3%80%90dfs_or_%E6%9C%80%E7%9F%AD%E8%B7%AF%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44351051" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44351051</a></p>
<p>漂洋过海来看你<br>Description<br>BMan和hyx住在一个神奇的国度，这个国度有N个城市，这N个城市间只有N-1条路把这个N个城市连接起来。<br>现在BMan在第S号城市，他经常想起那个一起AC过的队友hyx，记忆它总是慢慢的累积，在他心中无法抹去，可是他并不知道hyx<br>在哪个城市，所以他决定用尽半年的积蓄漂洋过海去找hyx，现在BMan很想知道如果他想去hyx所在的第X号城市，必须经过的前<br>一个城市是第几号城市（放心，由于心系队友，BMan是不会选择走重复的路的~）<br>Input<br>第一行输入一个整数T表示测试数据共有T(1&lt;=T&lt;=10)组<br>每组测试数据的第一行输入一个正整数N(1&lt;=N&lt;=1000)和一个正整数S(1&lt;=S&lt;=1000)，N表示城市的总数，S是BMan所在城市的编号 随后的N-<br>1行，每行有两个正整数a,b(1&lt;=a,b&lt;=N)，表示第a号城市和第b号城市之间有一条路连通。<br>Output<br>每组测试数据输N个正整数，其中，第i个数表示从S走到i号城市，必须要经过的上一个城市的编号（其中i=S时，请输出-1）<br>Sample Input<br>1<br>10 1<br>1 9<br>1 8<br>8 10<br>10 3<br>8 6<br>1 2<br>10 4<br>9 5<br>3 7<br>Sample Output<br>-1 1 10 10 9 8 3 1 1 8 </p>
<p>最短路或dfs均可做</p>
<p>最短路代码：</p>
<pre><code>#include &lt;stdio.h&gt;    
#include &lt;iostream&gt;    
#include &lt;math.h&gt;    
#include &lt;stdlib.h&gt;    
#include &lt;ctype.h&gt;    
#include &lt;algorithm&gt;    
#include &lt;vector&gt;    
#include &lt;string.h&gt;    
#include &lt;queue&gt;    
#include &lt;stack&gt;    
#include &lt;set&gt;     
#include &lt;sstream&gt;    
#include &lt;time.h&gt;    
#include &lt;utility&gt;    
#include &lt;malloc.h&gt;    
#include &lt;stdexcept&gt;    
#include &lt;iomanip&gt;    
#include &lt;iterator&gt;  

using namespace std;
const int MAXV = 4010;
const int inf = 10000000;

int map[MAXV][MAXV];
int d[MAXV];
bool vis[MAXV];
int n, m;
int pre[MAXV];

void dijkstra(int s)
{
    for (int i = 1; i &lt;= n; i++)
    {
        vis[i] = 0;
        d[i] = map[s][i];
    }
    while (1)
    {
        int min = inf, v = -1;
        for (int i = 1; i &lt;= n; i++)
            if (!vis[i] &amp;&amp; d[i]&lt;min)
            {
                v = i;
                min = d[i];
            }
        if (v == -1)
            break;
        vis[v] = 1;
        for (int i = 1; i &lt;= n; i++)
            if (!vis[i] &amp;&amp; d[i] &gt;= d[v] + map[v][i])
            {
                d[i] = map[v][i] + d[v];
                pre[i] = v;
            }
    }
}
int t, a, b;

int main()
{
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= n; j++)
            {
                if (i == j)
                    map[i][i] = 0;
                else
                    map[i][j] = map[j][i] = inf;
            }
        memset(pre, 0, sizeof(pre));

        pre[m] = -1;

        for (int i = 1; i &lt; n; i++)
        {
            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
            map[a][b] = map[b][a] = 1;
        }
        dijkstra(m);
        for (int i = 1; i &lt; n; i++)
            printf(&quot;%d &quot;, pre[i]);
        printf(&quot;%d\n&quot;, pre[n]);
    }
    return 0;
}
</code></pre><p>dfs代码：</p>
<pre><code>#include &lt;stdio.h&gt;    
#include &lt;iostream&gt;    
#include &lt;math.h&gt;    
#include &lt;stdlib.h&gt;    
#include &lt;ctype.h&gt;    
#include &lt;algorithm&gt;    
#include &lt;vector&gt;    
#include &lt;string.h&gt;    
#include &lt;queue&gt;    
#include &lt;stack&gt;    
#include &lt;set&gt;     
#include &lt;sstream&gt;    
#include &lt;time.h&gt;    
#include &lt;utility&gt;    
#include &lt;malloc.h&gt;    
#include &lt;stdexcept&gt;    
#include &lt;iomanip&gt;    
#include &lt;iterator&gt;  

using namespace std;
const int MAXV = 4010;
const int inf = 10000000;

int map[MAXV][MAXV];
int d[MAXV];
bool vis[MAXV];
int n, m;
int pre[MAXV];
int t, a, b;

void dfs(int s)
{
    vis[s] = 1;
    for (int i = 1; i &lt;= n; i++)
    {
        if (!vis[i] &amp;&amp; map[s][i] == 1)
        {
            pre[i] = s;
            vis[i] = 1;
            dfs(i);
        }
    }
}

int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        memset(vis,0,sizeof(vis));
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
        memset(map,0,sizeof(map));
        memset(pre,0,sizeof(pre));
        pre[m] = -1;

        for (int i = 1; i &lt; n; i++)
        {
            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
            map[a][b] = map[b][a] = 1;
        }
        dfs(m);
        for (int i = 1; i &lt; n; i++)
            printf(&quot;%d &quot;,pre[i]);
        printf(&quot;%d\n&quot;,pre[n]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵旋转</title>
    <url>/article/csdn/%E7%9F%A9%E9%98%B5%E6%97%8B%E8%BD%AC.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40897873" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40897873</a></p>
<p>对于ｎ×ｎ矩阵：</p>
<p>90度旋转：</p>
<ul>
<li>列号变为行号 </li>
<li>（n - 行号 + 1）变成列号 </li>
<li>规律： a[i][j] = b[j][n - i + 1］ </li>
</ul>
<h3><span id="180度旋转">180度旋转：</span></h3><ul>
<li>（n - 行号 + 1）变为行号 </li>
<li>（n - 列号 + 1）变为列号 </li>
<li>规律：a[i][j] = b[n - i + 1][n - j + 1] </li>
</ul>
<h3><span id="270度旋转相当于逆时针旋转90度">270度旋转（相当于逆时针旋转90度）：</span></h3><ul>
<li>行号变为列号 </li>
<li>（n - 列号 + 1）变为行号 </li>
<li>规律：a[i][j] = b[n - j + 1][i] </li>
</ul>
<p>以逆时针旋转为例，代码：</p>
<p>借助辅助空间</p>
<pre><code>void rotate_90(int A[N][N], int B[N][N], int n)
{
    for (int i = 0; i &lt; n; ++i)
    {
        for (int j = 0; j &lt; n; ++j)
        {
            B[i][j] = A[j][n - 1 - i];
        }
    }
}
</code></pre><p>不借助辅助空间：</p>
<pre><code>void rotate90(int A[N][N], int n)
{

    int i1, j1;
    int nTmp1, nTmp2;
    int nIndxTmp;
    int k;

    for (int i = 0; i &lt; n / 2; i++)
    {
        for (int j = i; j &lt; n - 1 - i; j++)
        {
            i1 = i;
            j1 = j;
            nTmp1 = A[i1][j1];
            k = 0;
            while (k &lt; 4)
            {
                nTmp2 = A[n - 1 - j1][i1];
                A[n - 1 - j1][i1] = nTmp1;
                nTmp1 = nTmp2;

                nIndxTmp = i1;
                i1 = n - 1 - j1;
                j1 = nIndxTmp;

                k++;
            }
        }
    }
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>神奇的编码 【进制转换】</title>
    <url>/article/csdn/%E7%A5%9E%E5%A5%87%E7%9A%84%E7%BC%96%E7%A0%81_%E3%80%90%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44313217" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44313217</a></p>
<p>神奇的编码<br>Description<br>假如没有阿拉伯数字，我们要怎么表示数字呢<br>小明想了一个方法如下：<br>1 -&gt; A<br>2 -&gt; B<br>3 -&gt; C<br>….<br>25 -&gt; Y<br>26 -&gt; Z<br>27 -&gt; AA</p>
<p>28 -&gt; AB<br>….</p>
<p>现在请你写一个程序完成这个转换</p>
<p>Input<br>输入的第一个数为一个正整数T,表明接下来有T组数据。<br>每组数据为一个正整数n ( n &lt;= 1000)</p>
<p>Output<br>对于每个正整数n,输出他对应的字符串</p>
<p>Sample Input<br>3<br>1<br>10<br>27<br>Sample Output<br>A<br>J<br>AA</p>
<p>进制转换？</p>
<pre><code>#include &lt;stdio.h&gt;    
#include &lt;iostream&gt;    
#include &lt;math.h&gt;    
#include &lt;stdlib.h&gt;    
#include &lt;ctype.h&gt;    
#include &lt;algorithm&gt;    
#include &lt;vector&gt;    
#include &lt;string.h&gt;    
#include &lt;queue&gt;    
#include &lt;stack&gt;    
#include &lt;set&gt;     
#include &lt;sstream&gt;    
#include &lt;time.h&gt;    
#include &lt;utility&gt;    
#include &lt;malloc.h&gt;    
#include &lt;stdexcept&gt;    
#include &lt;iomanip&gt;    
#include &lt;iterator&gt;  

using namespace std;

int main()
{
    int n,t;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        scanf(&quot;%d&quot;,&amp;n);
        if (n &lt;= 26)
            printf(&quot;%c\n&quot;, &#39;A&#39; + n - 1);
        else if (n &lt;= 26 * 26 + 26)
        {
            n -= 27;
            int t = n / 26;
            printf(&quot;%c&quot;, &#39;A&#39; + t);
            n = n % 26;
            printf(&quot;%c\n&quot;, &#39;A&#39; + n);
        }
        else
        {
            n -= 27 + 26 * 26;
            printf(&quot;%c%c%c\n&quot;, &#39;A&#39; + char(n / 26 / 26), &#39;A&#39; + char((n / 26) % 26), &#39;A&#39; + char(n % 26));
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>简明 Vim 练级攻略</title>
    <url>/article/csdn/%E7%AE%80%E6%98%8E_Vim_%E7%BB%83%E7%BA%A7%E6%94%BB%E7%95%A5.html</url>
    <content><![CDATA[<p>很好的教程： <a href="http://coolshell.cn/articles/5426.html" target="_blank" rel="noopener"> http://coolshell.cn/articles/5426.html
</a></p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>等概率洗牌算法</title>
    <url>/article/csdn/%E7%AD%89%E6%A6%82%E7%8E%87%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40358581" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40358581</a></p>
<p>遍历数组，遇到第i个元素时，产生一个i到n-1之间的随机数，然后两个位子的数互换。  </p>
<pre><code>void shuff(int *ap, int n)

{

    int i;

    for (i=0; i&lt;n; i++)

    {

           int t = rand()%(n-i)+i;

           swap(a[i],a[t]);

    }

}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>算法-求二进制数中1的个数</title>
    <url>/article/csdn/%E7%AE%97%E6%B3%95-%E6%B1%82%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40650997" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40650997</a></p>
<pre><code>int BitCount(unsigned int n)
{
    unsigned int c =0 ; // 计数器
    while (n &gt;0)
    {
        if((n &amp;1) ==1) // 当前位是1
            ++c ; // 计数器加1
        n &gt;&gt;=1 ; // 移位
    }
    return c ;
}

2. 快速移位+计数

int BitCount2(unsigned int n)
{
    unsigned int c =0 ;
    while(n)

  {
        n &amp;= (n -1) ;

        c++;// 清除最低位的1
    }
    return c ;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>c语言</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>类型别名</title>
    <url>/article/csdn/%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/46420445" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/46420445</a></p>
<p>1。 传统方法 使用 typedef 关键字<br>用法 ：typedef LOL long long ;</p>
<p>2。 c11 新标准 ：using LOL = long long;<br>= 左边的名字规定为右侧的别名。</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>关键字</tag>
        <tag>using</tag>
      </tags>
  </entry>
  <entry>
    <title>给定两个正整数（二进制形式表示）A和B，问把A变为B需要改变多少位（bit）?也就是说，整数A和B的二进制表示中有多少位是不同的？</title>
    <url>/article/csdn/%E7%BB%99%E5%AE%9A%E4%B8%A4%E4%B8%AA%E6%AD%A3%E6%95%B4%E6%95%B0%EF%BC%88%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%BD%A2%E5%BC%8F%E8%A1%A8%E7%A4%BA%EF%BC%89A%E5%92%8CB%EF%BC%8C%E9%97%AE%E6%8A%8AA%E5%8F%98%E4%B8%BAB%E9%9C%80%E8%A6%81%E6%94%B9%E5%8F%98%E5%A4%9A%E5%B0%91%E4%BD%8D%EF%BC%88bit%EF%BC%89?%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%EF%BC%8C%E6%95%B4%E6%95%B0A%E5%92%8CB%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%AD%E6%9C%89%E5%A4%9A%E5%B0%91%E4%BD%8D%E6%98%AF%E4%B8%8D%E5%90%8C%E7%9A%84%EF%BC%9F.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40651041" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40651041</a></p>
<p>解法一：举例说明，为了减少复杂度，就使用八位二进制吧。设 A = 0010 1011， B = 0110 0101.<br>1. C = A &amp; B = 0010 0001；<br>2. D = A | B = 0110 1111；<br>3. E = C ^ D = 0100 1110；//异或运算<br>4. 结果E中有4个1，那么也就是说将A变成B，需要改变4位（bit）。<br>至于如何判断E的二进制表示中有几个1，可以采用快速移位与方法。<br>算法原理如下：<br>1. A &amp; B，得到的结果C中的1的位表明了A和B中相同的位都是1的位；<br>2. A | B， 得到的结果D中的1的位表明了A和B在该位至少有一个为1的位，包含了A 与 B 都是1的位数，<br>经过前两步的位运算，，C 中1的位表明了A 和 B在该位都是1，D中为0的位表明了A 和 B 在该位都是0 ，所以进行第三步。<br>3. C ^ D，E 中为1的位表明了A 和 B不同的位。</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>虚函数实现原理(转)</title>
    <url>/article/csdn/%E8%99%9A%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86(%E8%BD%AC).html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/52491723" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/52491723</a></p>
<p>虚函数表（Virtual Table），简称为V-<br>Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。在类的对象地址空间中存储一个该虚表的入口，占4个字节</p>
<p>虚函数表的指针存在于对象实例中最前面的位置。这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。</p>
<p>画个图解释一下</p>
<p><img src="https://img-blog.csdn.net/20160909234659177" alt="这里写图片描述"><br>上面这个图中，我在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“\0”一样，其标志了虚函数表的结束。</p>
<p>下面，我将分别说明“无覆盖”和“有覆盖”时的虚函数表的样子。没有覆盖父类的虚函数是毫无意义的。我之所以要讲述没有覆盖的情况，主要目的是为了给一个对比。在比较之下，我们可以更加清楚地知道其内部的具体实现。</p>
<h2><span id="一般继承无虚函数覆盖">一般继承（无虚函数覆盖）</span></h2><p>下面，再让我们来看看继承时的虚函数表是什么样的。假设有如下所示的一个继承关系：<br><img src="https://img-blog.csdn.net/20160909234824144" alt="这里写图片描述"></p>
<p>在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示：</p>
<p>对于实例：Derive d; 的虚函数表如下：<br><img src="https://img-blog.csdn.net/20160909234853850" alt="这里写图片描述"></p>
<p>我们可以看到下面几点：</p>
<p>1）虚函数按照其声明顺序放于表中。</p>
<p>2）父类的虚函数在子类的虚函数前面。</p>
<h2><span id="一般继承有虚函数覆盖">一般继承（有虚函数覆盖）</span></h2><p>覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。</p>
<p><img src="https://img-blog.csdn.net/20160909234939803" alt="这里写图片描述"></p>
<p>这个类的设计中，我只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子：<br><img src="https://img-blog.csdn.net/20160909235011132" alt="这里写图片描述"></p>
<p>从表中可以看到下面几点，</p>
<p>1）覆盖的f()函数被放到了虚表中原来父类虚函数的位置。</p>
<p>2）没有被覆盖的函数依旧。</p>
<pre><code>这样，我们就可以看到对于下面这样的程序，

Base *b = new Derive();

b-&gt;f();

由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。
</code></pre><h2><span id="多重继承无虚函数覆盖">多重继承（无虚函数覆盖）</span></h2><p>下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。<br><img src="https://img-blog.csdn.net/20160909235131399" alt="这里写图片描述"></p>
<p>对于子类实例中的虚函数表，是下面这个样子<br><img src="https://img-blog.csdn.net/20160909235200649" alt="这里写图片描述"></p>
<p>我们可以看到：</p>
<p>1） 每个父类都有自己的虚表。</p>
<p>2） 子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）</p>
<p>这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。</p>
<h2><span id="多重继承有虚函数覆盖">多重继承（有虚函数覆盖）</span></h2><p>下面我们再来看看，如果发生虚函数覆盖的情况。<br>下图中，我们在子类中覆盖了父类的f()函数。<br><img src="https://img-blog.csdn.net/20160909235327086" alt="这里写图片描述"><br>下面是对于子类实例中的虚函数表的图：<br><img src="https://img-blog.csdn.net/20160909235345620" alt="这里写图片描述"></p>
<p>可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。如：</p>
<pre><code>Derive d;

Base1 *b1 = &amp;d;

Base2 *b2 = &amp;d;

Base3 *b3 = &amp;d;

b1-&gt;f(); //Derive::f()

b2-&gt;f(); //Derive::f()

b3-&gt;f(); //Derive::f()

b1-&gt;g(); //Base1::g()

b2-&gt;g(); //Base2::g()

b3-&gt;g(); //Base3::g()
</code></pre><h2><span id="析构函数定义为虚函数原因">析构函数定义为虚函数原因</span></h2><p>用基类的指针指向派生类的时候，虚函数发挥了动态的作用。<br>析构函数执行时先调用派生类的析构函数，其次才调用基类的析构函数。如果析构函数不是虚函数，而程序执行时又要通过基类的指针去销毁派生类的动态对象，那么用delete销毁对象时，只调用了基类的析构函数，未调用派生类的析构函数。这样会造成销毁对象不完全。<br>如果一个类不用作基类或者不需具有多态性，便不应该为它声明虚析构器。</p>
<p>文章中大部分内容转自： <a href="http://blog.csdn.net/wanghaobo920/article/details/7674631" target="_blank" rel="noopener"> http://blog.csdn.net/wanghaobo920/article/details/7674631
</a></p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>观察表达式的规律，计算前n项的和</title>
    <url>/article/csdn/%E8%A7%82%E5%AF%9F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%A7%84%E5%BE%8B%EF%BC%8C%E8%AE%A1%E7%AE%97%E5%89%8Dn%E9%A1%B9%E7%9A%84%E5%92%8C.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44098115" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44098115</a></p>
<pre><code>观察下列表达式的规律，计算前n项的和

2/1 + 3/2 +5/3 +8/5 +13/8+ 21/13

思路：不能由斐波那契额数推分母分子分别为前两项分母分子的和，因为n == 100时，斐波那契数会很大，超出范围，所以找规律：F(n) = 1/F(n-1)+1;

#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;
#include &lt;iterator&gt;

using namespace std;

int n;
double a = 2;

int main()
{
    while (cin &gt;&gt; n)
    {
        double sum = 2;
        double b = a;
        for (int i = 2; i &lt;= n; i++)
        {
            sum += 1 / b + 1;
            b = 1 / b + 1;
        }
        cout &lt;&lt; sum &lt;&lt; endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>解决爆栈，手动加栈！</title>
    <url>/article/csdn/%E8%A7%A3%E5%86%B3%E7%88%86%E6%A0%88%EF%BC%8C%E6%89%8B%E5%8A%A8%E5%8A%A0%E6%A0%88%EF%BC%81.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/47130793" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/47130793</a></p>
<p>解决爆栈最好的方法是改变写法，用BFS，或者用数组模拟栈。</p>
<p>c++: 放在头文件前面</p>
<pre><code>#pragma comment(linker,&quot;/STACK:1024000000,1024000000&quot;)
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>费马小定理</title>
    <url>/article/csdn/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44593703" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44593703</a></p>
<p>费马小定理：<br>一个素数是p 则对任意的整数a有a^p=a(mod p);<br>公式变形：a^（p-1）=1(mod p);<br>威尔逊定理：<br>p为素数，则 (p-1)!=-1(mod p);<br>费马定理的应用：判断素数，大素数的生成；<br>若任意整数b有(b,n)==1,有b^(n-1)=1(mod n)<br>n为素数；<br>否则，若b有(b,n)==1,有b^(n-1)！=1(mod n)<br>n为合数。<br>伪素数：<br>n为一个奇合数，若b^(n-1)=1(mod n)<br>则n称为基于b的伪素数。</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>认识与学习bash</title>
    <url>/article/csdn/%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%AD%A6%E4%B9%A0bash.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/51019818" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/51019818</a></p>
<h3><span id="变量的显示与设置">变量的显示与设置</span></h3><p>变量的显示:<br>echo $[变量名]<br><img src="https://img-blog.csdn.net/20160330205504221" alt="这里写图片描述"></p>
<p>修改变量名：<br>用等号“＝”<br><img src="https://img-blog.csdn.net/20160330205927941" alt="这里写图片描述"><br>变量名只能由字母数字组成，且只能字母开头。</p>
<p>取消变量：<br>unset　变量名<br><img src="https://img-blog.csdn.net/20160330211258993" alt="这里写图片描述"></p>
<p>环境变量功能：<br>env查看环境变量及说明<br><img src="https://img-blog.csdn.net/20160330211916824" alt="这里写图片描述"></p>
<p>随机数变量RANDOM<br><img src="https://img-blog.csdn.net/20160330212326169" alt="这里写图片描述"><br>set查看所有变量（包括环境变量）<br><img src="https://img-blog.csdn.net/20160330212434669" alt="这里写图片描述"></p>
<p>如果想在子进程使用自己定义的环境变量，使用”export　变量名“。</p>
<p>显示语系变量：locale<br><img src="https://img-blog.csdn.net/20160330213358861" alt="这里写图片描述"></p>
<h3><span id="变量的读取数组和声明read-array-declare">变量的读取，数组和声明：read array declare</span></h3><p>read:<br><img src="https://img-blog.csdn.net/20160330214109254" alt="这里写图片描述"><br>declare<br><img src="https://img-blog.csdn.net/20160330214323598" alt="这里写图片描述"><br>数组：<br><img src="https://img-blog.csdn.net/20160330214908632" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20160330214815647" alt="这里写图片描述"></p>
<h3><span id="文件系统及程序的限制关系ulimit">文件系统及程序的限制关系：ulimit</span></h3><p><img src="https://img-blog.csdn.net/20160330215316352" alt="这里写图片描述"></p>
<h3><span id="命名别名与历史命令">命名别名与历史命令</span></h3><p>创建一个新命令　alias 删除命令　unalias<br><img src="https://img-blog.csdn.net/20160401162149123" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20160401162209607" alt="这里写图片描述"></p>
<p>历史命令history，之前执行过的命令。<br><img src="https://img-blog.csdn.net/20160401162507561" alt="这里写图片描述"><br>！number　执行第number条ｈｉｓｔｏｒｙ命令<br><img src="https://img-blog.csdn.net/20160401162849360" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>跳跃的舞者，舞蹈链（Dancing Links）算法——求解精确覆盖问题</title>
    <url>/article/csdn/%E8%B7%B3%E8%B7%83%E7%9A%84%E8%88%9E%E8%80%85%EF%BC%8C%E8%88%9E%E8%B9%88%E9%93%BE%EF%BC%88Dancing_Links%EF%BC%89%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%B1%82%E8%A7%A3%E7%B2%BE%E7%A1%AE%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<p>转自： <a href="http://www.cnblogs.com/grenet/p/3145800.htm" target="_blank" rel="noopener"> http://www.cnblogs.com/grenet/p/3145800.htm
</a></p>
<p>讲的很详细。</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>跳跃表 SkipList【数据结构】原理及实现</title>
    <url>/article/csdn/%E8%B7%B3%E8%B7%83%E8%A1%A8_SkipList%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/52454462" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/52454462</a></p>
<h3><span id="为什么选择跳表">为什么选择跳表</span></h3><p>目前经常使用的平衡数据结构有：B树，红黑树，AVL树，Splay Tree, Treep等。</p>
<p>想象一下，给你一张草稿纸，一只笔，一个编辑器，你能立即实现一颗红黑树，或者AVL树出来吗？<br>很难吧，这需要时间，要考虑很多细节，要参考一堆算法与数据结构之类的树，还要参考网上的代码，相当麻烦。</p>
<p>用跳表吧，跳表是一种随机化的数据结构，目前开源软件 Redis 和 LevelDB 都有用到它，它的效率和红黑树以及 AVL<br>树不相上下，但跳表的原理相当简单，只要你能熟练操作链表，就能轻松实现一个 SkipList。</p>
<h3><span id="有序表的搜索">有序表的搜索</span></h3><p>考虑一个有序表：<br><img src="https://img-blog.csdn.net/20160906223329182" alt="这里写图片描述"><br>从该有序表中搜索元素 &lt; 23, 43, 59 &gt; ，需要比较的次数分别为 &lt; 2, 4, 6 &gt;，总共比较的次数为 2 + 4 + 6 = 12<br>次。有没有优化的算法吗? 链表是有序的，但不能使用二分查找。类似二叉搜索树，我们把一些节点提取出来，作为索引。得到如下结构：</p>
<p><img src="https://img-blog.csdn.net/20160906223251963" alt="这里写图片描述"></p>
<p>提取出来作为一级索引，这样搜索的时候就可以减少比较次数了。<br>我们还可以再从一级索引提取一些元素出来，作为二级索引，三级索引…<br><img src="https://img-blog.csdn.net/20160906223151681" alt="这里写图片描述"><br>这里元素不多，体现不出优势，如果元素足够多，这种索引结构就能体现出优势来了。</p>
<h3><span id="跳表">跳表</span></h3><p>下面的结构是就是跳表：<br>其中 -1 表示 INT_MIN， 链表的最小值，1 表示 INT_MAX，链表的最大值。</p>
<p><img src="https://img-blog.csdn.net/20160906222654630" alt="这里写图片描述"></p>
<p>跳表具有如下性质：<br>(1) 由很多层结构组成<br>(2) 每一层都是一个有序的链表<br>(3) 最底层(Level 1)的链表包含所有元素<br>(4) 如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。<br>(5) 每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。</p>
<h4><span id="跳表的搜索">跳表的搜索</span></h4><p><img src="https://img-blog.csdn.net/20160906222733148" alt="这里写图片描述"></p>
<p>例子：查找元素 117<br>(1) 比较 21， 比 21 大，往后面找<br>(2) 比较 37, 比 37大，比链表最大值小，从 37 的下面一层开始找<br>(3) 比较 71, 比 71 大，比链表最大值小，从 71 的下面一层开始找<br>(4) 比较 85， 比 85 大，从后面找<br>(5) 比较 117， 等于 117， 找到了节点。</p>
<p>具体的搜索算法如下：</p>
<pre><code>/* 如果存在 x, 返回 x 所在的节点， 
 * 否则返回 x 的后继节点 */  
find(x)   
{  
    p = top;  
    while (1) {  
        while (p-&gt;next-&gt;key &lt; x)  
            p = p-&gt;next;  
        if (p-&gt;down == NULL)   
            return p-&gt;next;  
        p = p-&gt;down;  
    }  
}  
</code></pre><h4><span id="跳表的插入">跳表的插入</span></h4><p>先确定该元素要占据的层数 K（采用丢硬币的方式，这完全是随机的）<br>然后在 Level 1 … Level K 各个层的链表都插入元素。<br>例子：插入 119， K = 2<br><img src="https://img-blog.csdn.net/20160906222813944" alt="这里写图片描述"></p>
<p>如果 K 大于链表的层数，则要添加新的层。<br>例子：插入 119， K = 4</p>
<p><img src="https://img-blog.csdn.net/20160906222836993" alt="这里写图片描述"></p>
<p>丢硬币决定 K<br>插入元素的时候，元素所占有的层数完全是随机的，通过一下随机算法产生：</p>
<pre><code>int random_level()  
{  
    K = 1;  

    while (random(0,1))  
        K++;  

    return K;  
}  
</code></pre><p>相当与做一次丢硬币的实验，如果遇到正面，继续丢，遇到反面，则停止，<br>用实验中丢硬币的次数 K 作为元素占有的层数。显然随机变量 K 满足参数为 p = 1/2 的几何分布，<br>K 的期望值 E[K] = 1/p = 2. 就是说，各个元素的层数，期望值是 2 层。</p>
<p>跳表的高度。<br>n 个元素的跳表，每个元素插入的时候都要做一次实验，用来决定元素占据的层数 K，<br>跳表的高度等于这 n 次实验中产生的最大 K，待续。。。</p>
<p>跳表的空间复杂度分析<br>根据上面的分析，每个元素的期望高度为 2， 一个大小为 n 的跳表，其节点数目的<br>期望值是 2n。</p>
<h4><span id="跳表的删除">跳表的删除</span></h4><p>在各个层中找到包含 x 的节点，使用标准的 delete from list 方法删除该节点。<br>例子：删除 71</p>
<p><img src="https://img-blog.csdn.net/20160906222950196" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>输入输出外挂</title>
    <url>/article/csdn/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%A4%96%E6%8C%82.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44281183" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44281183</a></p>
<p>遇到卡时间比较死的题目的时候可以用</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;

using namespace std;

//适用于正负整形数

template &lt;class T&gt;
inline bool scan_d(T &amp;ret) 
{
    char c; int sgn;
    if (c = getchar(), c == EOF) return 0; //EOF
    while (c != &#39;-&#39; &amp;&amp; (c&lt;&#39;0&#39; || c&gt;&#39;9&#39;)) c = getchar();
    sgn = (c == &#39;-&#39;) ? -1 : 1;
    ret = (c == &#39;-&#39;) ? 0 : (c - &#39;0&#39;);
    while (c = getchar(), c &gt;= &#39;0&#39;&amp;&amp;c &lt;= &#39;9&#39;) ret = ret * 10 + (c - &#39;0&#39;);
    ret *= sgn;
    return 1;
}

inline void out(long long x)
{
    if (x &gt; 9)out(x / 10);
    putchar(x%10+&#39;0&#39;);
}

int main()
{
    int n;long long p[100];
    scanf(&quot;%d&quot;,&amp;n);
    for (int i = 0; i &lt; n; i++)
        scan_d(p[i]);
    for (int i = 0; i &lt; n; i++)
    {
        out(p[i]);
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>逆元</title>
    <url>/article/csdn/%E9%80%86%E5%85%83.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44494281" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44494281</a></p>
<p>数论中的逆元定义为：<br>设m是一个整数，a是满足（a,m）= 1 的整数，则存在唯一的整数a＃，１＜＝ａ＃＜ｍ，<br>使得 a ＊ａ＃ ＝ 1( ｍｏｄ　ｍ)；<br>ａ＃称为ａ的逆元；<br>求逆元的方法，可以用扩展欧几里得算法；<br>ｓａ＋ｔｍ＝（ａ，ｍ）＝１；<br>因此整数ａ＃满足ａ＃　ｍｏｄ　ｍ＝ｓ满足ａ＊ａ＃　＝　１(ｍｏｄ　ｍ)；</p>
<pre><code>long long ext_gcd(long long a,long long b,long long &amp;x,long long &amp;y)
{
    if (a == 0 &amp;&amp; b == 0) return -1;
    if (b == 0)
    {
        x = 1;
        y = 0;
        return a;
    }
    long long d = ext_gcd(b, a%b, y, x);
    y -= a / b*x;
    return d;
}

//求逆元素
// ax=1(mod n)
long long mod_reverse(long long a,long long n)
{
    long long x, y;
    long long d = ext_gcd(a,n,x,y);
    if (d == 1) 
        return (x%n + n) % n;
    else
        return -1;
}
</code></pre><p>acdreamer的逆元学习资料： <a href="http://blog.csdn.net/acdreamers/article/details/8220787" target="_blank" rel="noopener"> 点击链接
</a></p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>C++ inline 函数（转）</title>
    <url>/article/csdn/C++_inline_%E5%87%BD%E6%95%B0%EF%BC%88%E8%BD%AC%EF%BC%89.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44158235" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44158235</a></p>
<p>（一）inline函数（摘自C++ Primer的第三版）</p>
<p><strong> 在函数声明或定义中函数返回类型前加上关键字inline即把min（）指定为内联。  </strong></p>
<p>inline int min(int first, int secend) {/<em>**</em>/};</p>
<p>inline<br>函数对编译器而言必须是可见的，以便它能够在调用点内展开该函数。与非inline函数不同的是，inline函数必须在调用该函数的每个文本文件中定义。当然，对于同一程序的不同文件，如果inline函数出现的话，其定义必须相同。对于由两个文件compute.C和draw.C构成的程序来说，程序员不能定义这样的min()函数，它在compute.C中指一件事情，而在draw.C中指另外一件事情。如果两个定义不相同，程序将会有未定义的行为：</p>
<p>为保证不会发生这样的事情，建议把inline函数的定义放到头文件中。在每个调用该inline函数的文件中包含该头文件。这种方法保证对每个inline函数只有一个定义，且程序员无需复制代码，并且不可能在程序的生命期中引起无意的不匹配的事情。</p>
<p>（二）内联函数的编程风格(摘自高质量C++/C 编程指南)</p>
<p><strong>关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用</strong> 。</p>
<p>如下风格的函数Foo 不能成为内联函数：</p>
<p>inline void Foo(int x, int y); // inline 仅与函数声明放在一起</p>
<p>void Foo(int x, int y){}</p>
<p>而如下风格的函数Foo 则成为内联函数：</p>
<p>void Foo(int x, int y);</p>
<p>inline void Foo(int x, int y) // inline 与函数定义体放在一起{}</p>
<p>所以说，inline<br>是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline<br>关键字，但我认为inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C<br>程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。</p>
<p><strong>定义在类声明之中的成员函数将自动地成为内联函数</strong></p>
<p>例如</p>
<p>class A</p>
<p>{</p>
<p>public:void Foo(int x, int y) {  } // 自动地成为内联函数</p>
<p>}</p>
<p>将成员函数的定义体放在类声明之中虽然能带来书写上的方便，但不是一种良好的编程风格，上例应该改成：</p>
<p>// 头文件</p>
<p>class A</p>
<p>{</p>
<p>public:</p>
<p>void Foo(int x, int y);</p>
<p>}</p>
<p>// 定义文件</p>
<p>inline void A::Foo(int x, int y){} <em>**</em></p>
<p><strong>慎用内联</strong></p>
<p>内联能提高函数的执行效率，为什么不把所有的函数都定义成内联函数？如果所有的函数都是内联函数，还用得着“内联”这个关键字吗？内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</p>
<p><strong>以下情况不宜使用内联：</strong></p>
<p>（1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。</p>
<p>（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。类的构造函数和析构函数容易让人误解成使用内联更有效。要当心构造函数和析构函数可能会隐藏一些行为，如“偷偷地”执行了基类或成员对象的构造函数和析构函数。所以不要随便地将构造函数和析构函数的定义体放在类声明中。一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了<br>inline 不应该出现在函数的声明中）。</p>
<p><strong>注意点:</strong></p>
<p>内联函数既能够去除函数调用所带来的效率负担又能够保留一般函数的优点。然而，内联函数并不是万能药，在一些情况下，它甚至能够降低程序的性能。因此在使用的时候应该慎重。<br>1．我们先来看看内联函数给我们带来的好处：从一个用户的角度来看，内联函数看起来和普通函数一样，<br>它可以有参数和返回值，也可以有自己的作用域，然而它却不会引入一般函数调用所带来的负担。另外， 它可以比宏更安全更容易调试。<br>当然有一点应该意识到，inline<br>specifier仅仅是对编译器的建议，编译器有权利忽略这个建议。那么编译器是如何决定函数内联与否呢？一般情况下关键性因素包括函数体的大小，是否有局部对象被声明，函数的复杂性等等。<br>2．那么如果一个函数被声明为inline但是却没有被内联将会发生什么呢？理论上，当编译器拒绝内联一个<br>函数的时候，那个函数会像普通函数一样被对待，但是还会出现一些其他的问题。例如下面这段代码：      //   filename   Time.h</p>
<p>#include <ctime>      #include<iostream>      using   namespace   std;<br>class   Time      {      public:              inline   void   Show()</iostream></ctime></p>
<p>{                  for (int   i   =   0;   i&lt;10;   i++)<br>cout&lt;&lt;time(0)&lt;&lt;endl;           }      };<br>因为成员函数Time::Show()包括一个局部变量和一个for循环，所以编译器一般拒绝inline，并且把它当作一个普通的成员函数。但是这个包含类声明的头文件会被单独的#include进各个独立的编译单元中：<br>//   filename   f1.cpp      #include   “Time.h”      void   f1()      {<br>Time   t1;              t1.Show();      }      //   filename   f2.cpp</p>
<p>#include   “Time.h”      void   f2()      {              Time   t2;<br>t2.Show();      }      结果编译器为这个程序生成了两个相同成员函数的拷贝：      void   f1();      void<br>f2();      int   main()      {              f1();                f2();<br>return   0;      }<br>当程序被链接的时候，linker将会面对两个相同的Time::Show()拷贝，于是函数重定义的连接错误发生。但是老一些的C<br>++实现对付这种情况的办法是通过把一个un-<br>inlined函数当作static来处理。因此每一份函数拷贝仅仅在自己的编译单元中可见，这样链接错误就解决了，但是在程序中却会留下多份函数拷贝。在这种情况下，程序的性能不但没有提升，反而增加了编译和链接时间以及最终可执行体的大小。但是幸运的是，新的C<br>++标准中关于un-inlined函数的说法已经改变。一个符合标准C++实现应该只生成一份函数拷贝。然而，要想所有的编译器都支持这一点可能还需要很长时间。</p>
<p>另外关于内联函数还有两个更令人头疼的问题。第一个问题是该如何进行维护。一个函数开始的时候可能以内联的形式出现，但是随着系统的扩展，函数体可能要求添加额外的功能，结果内联函数就变得不太可能，因此需要把inline<br>specifier去除以及把函数体放到一个单独的源文件中。另一个问题是当内联函数被应用在代码库的时候产生。当内联函数改变的时候，用户必须重新编译他们的代码以反映这种改变。然而对于一个非内联函数，用户仅仅需要重新链接就可以了。</p>
<p>这里想要说的是，内联函数并不是一个增强性能的灵丹妙药。只有当函数非常短小的时候它才能得到我们想要的效果，但是如果函数并不是很短而且在很多地方都被调用的话，那么将会使得可执行体的体积增大。最令人烦恼的还是当编译器拒绝内联的时候。在老的实现中，结果很不尽人意，虽然在新的实现中有很大的改善，但是仍然还是不那么完善的。一些编译器能够足够的聪明来指出哪些函数可以内联哪些不能，但是，大多数编译器就不那么聪明了，因此这就需要我们的经验来判断。如果内联函数不能增强行能，就避免使用它！</p>
<p>转自：<a href="http://www.cnblogs.com/berry/articles/1582702.html" target="_blank" rel="noopener">http://www.cnblogs.com/berry/articles/1582702.html</a></p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>C++ static 关键字</title>
    <url>/article/csdn/C++_static_%E5%85%B3%E9%94%AE%E5%AD%97.html</url>
    <content><![CDATA[<p>C++的static有两种用法： 面向过程程序设计中的static 和<br>面向对象程序设计中的static。前者应用于普通变量和函数，不涉及类；后者主要说明static在类中的作用。<br>一、面向过程设计中的static<br>1、静态全局变量<br>在全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量。我们先举一个静态全局变量的例子，如下：  </p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/hackbuteer1/article/details/7487694#" title="view plain" target="_blank" rel="noopener"> view plain
</a> <a href="http://blog.csdn.net/hackbuteer1/article/details/7487694#" title="copy" target="_blank" rel="noopener"><br>copy </a></p>
<ol>
<li>#include <iostream></iostream></li>
<li>using  namespace  std; </li>
<li><ol start="4">
<li>static  int  n;  //定义静态全局变量 </li>
</ol>
</li>
<li><ol start="6">
<li>void  fn() </li>
</ol>
</li>
<li>{ </li>
<li>n++; </li>
<li>cout&lt;&lt;n&lt;&lt;endl; </li>
<li>} </li>
<li><ol start="12">
<li>int  main(  void  ) </li>
</ol>
</li>
<li>{ </li>
<li>n = 20; </li>
<li>cout&lt;&lt;n&lt;&lt;endl; </li>
<li>fn(); </li>
<li>return  0; </li>
<li>} </li>
</ol>
<p>静态全局变量有以下特点：</p>
<ul>
<li>该变量在全局数据区分配内存； </li>
<li>未经初始化的静态全局变量会被程序自动初始化为0（自动变量的值是随机的，除非它被显式初始化）； </li>
<li>静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的； </li>
</ul>
<p>静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量。对于一个完整的程序，在内存中的分布情况如下图：  </p>
<h2><span id="代码区">代码区  </span></h2><p>全局数据区<br>堆区<br>栈区  </p>
<p>一般程序的由new产生的动态数据存放在堆区，函数内部的自动变量存放在栈区。自动变量一般会随着函数的退出而释放空间，静态数据（即使是函数内部的静态局部变量）也存放在全局数据区。全局数据区的数据并不会因为函数的退出而释放空间。细心的读者可能会发现，Example<br>1中的代码中将</p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/hackbuteer1/article/details/7487694#" title="view plain" target="_blank" rel="noopener"> view plain
</a> <a href="http://blog.csdn.net/hackbuteer1/article/details/7487694#" title="copy" target="_blank" rel="noopener"><br>copy </a></p>
<ol>
<li>static  int  n;  //定义静态全局变量 </li>
</ol>
<p>改为</p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/hackbuteer1/article/details/7487694#" title="view plain" target="_blank" rel="noopener"> view plain
</a> <a href="http://blog.csdn.net/hackbuteer1/article/details/7487694#" title="copy" target="_blank" rel="noopener"><br>copy </a></p>
<ol>
<li>int  n;  //定义全局变量 </li>
</ol>
<p>程序照样正常运行。<br>的确，定义全局变量就可以实现变量在文件中的共享，但定义静态全局变量还有以下好处：<br>静态全局变量不能被其它文件所用；<br>其它文件中可以定义相同名字的变量，不会发生冲突；<br>您可以将上述示例代码改为如下：  </p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/hackbuteer1/article/details/7487694#" title="view plain" target="_blank" rel="noopener"> view plain
</a> <a href="http://blog.csdn.net/hackbuteer1/article/details/7487694#" title="copy" target="_blank" rel="noopener"><br>copy </a></p>
<ol>
<li>//File1 </li>
<li>#include <iostream></iostream></li>
<li>using  namespace  std; </li>
<li><ol start="5">
<li>void  fn(); </li>
</ol>
</li>
<li>static  int  n;  //定义静态全局变量 </li>
<li><ol start="8">
<li>int  main(  void  ) </li>
</ol>
</li>
<li>{ </li>
<li>n = 20; </li>
<li>cout&lt;&lt;n&lt;&lt;endl; </li>
<li>fn(); </li>
<li>return  0; </li>
<li>} </li>
<li><ol start="16">
<li>//File2 </li>
</ol>
</li>
<li>#include<iostream></iostream></li>
<li>using  namespace  std; </li>
<li><ol start="20">
<li>extern  int  n; </li>
</ol>
</li>
<li><ol start="22">
<li>void  fn() </li>
</ol>
</li>
<li>{ </li>
<li>n++; </li>
<li>cout&lt;&lt;n&lt;&lt;endl; </li>
<li>} </li>
</ol>
<p>编译并运行这个程序，您就会发现上述代码可以分别通过编译，但运行时出现错误。试着将</p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/hackbuteer1/article/details/7487694#" title="view plain" target="_blank" rel="noopener"> view plain
</a> <a href="http://blog.csdn.net/hackbuteer1/article/details/7487694#" title="copy" target="_blank" rel="noopener"><br>copy </a></p>
<ol>
<li>static  int  n;  //定义静态全局变量 </li>
</ol>
<p>改为</p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/hackbuteer1/article/details/7487694#" title="view plain" target="_blank" rel="noopener"> view plain
</a> <a href="http://blog.csdn.net/hackbuteer1/article/details/7487694#" title="copy" target="_blank" rel="noopener"><br>copy </a></p>
<ol>
<li>int  n;  //定义全局变量 </li>
</ol>
<p>再次编译运行程序，细心体会全局变量和静态全局变量的区别。<br>2、静态局部变量<br>在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。<br>我们先举一个静态局部变量的例子，如下：  </p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/hackbuteer1/article/details/7487694#" title="view plain" target="_blank" rel="noopener"> view plain
</a> <a href="http://blog.csdn.net/hackbuteer1/article/details/7487694#" title="copy" target="_blank" rel="noopener"><br>copy </a></p>
<ol>
<li>#include <iostream></iostream></li>
<li>using  namespace  std; </li>
<li><ol start="4">
<li>void  fn(); </li>
</ol>
</li>
<li><ol start="6">
<li>int  main(  void  ) </li>
</ol>
</li>
<li>{ </li>
<li>fn(); </li>
<li>fn(); </li>
<li>fn(); </li>
<li>return  0; </li>
<li>} </li>
<li><ol start="14">
<li>void  fn() </li>
</ol>
</li>
<li>{ </li>
<li>static  int  n = 10; </li>
<li>cout&lt;&lt;n&lt;&lt;endl; </li>
<li>n++; </li>
<li>} </li>
</ol>
<p>通常，在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。<br>但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。<br>静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。<br>静态局部变量有以下特点：<br>（1）该变量在全局数据区分配内存；<br>（2）静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；<br>（3）静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；<br>（4）它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；<br>3、静态函数<br>在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。<br>静态函数的例子：  </p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/hackbuteer1/article/details/7487694#" title="view plain" target="_blank" rel="noopener"> view plain
</a> <a href="http://blog.csdn.net/hackbuteer1/article/details/7487694#" title="copy" target="_blank" rel="noopener"><br>copy </a></p>
<ol>
<li>#include <iostream></iostream></li>
<li>using  namespace  std; </li>
<li><ol start="4">
<li>static  void  fn();  //声明静态函数 </li>
</ol>
</li>
<li><ol start="6">
<li>int  main(  void  ) </li>
</ol>
</li>
<li>{ </li>
<li>fn(); </li>
<li>return  0; </li>
<li>} </li>
<li><ol start="12">
<li>void  fn()  //定义静态函数 </li>
</ol>
</li>
<li>{ </li>
<li>int  n = 10; </li>
<li>cout&lt;&lt;n&lt;&lt;endl; </li>
<li>} </li>
</ol>
<p>定义静态函数的好处：<br>静态函数不能被其它文件所用；<br>其它文件中可以定义相同名字的函数，不会发生冲突；<br>二、面向对象的static关键字（类中的static关键字）<br>1、静态数据成员<br>在类内数据成员的声明前加上关键字static，该数据成员就是类内的静态数据成员。先举一个静态数据成员的例子。  </p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/hackbuteer1/article/details/7487694#" title="view plain" target="_blank" rel="noopener"> view plain
</a> <a href="http://blog.csdn.net/hackbuteer1/article/details/7487694#" title="copy" target="_blank" rel="noopener"><br>copy </a></p>
<ol>
<li>#include <iostream></iostream></li>
<li>using  namespace  std; </li>
<li><ol start="4">
<li>class  Myclass </li>
</ol>
</li>
<li>{ </li>
<li>private  : </li>
<li>int  a , b , c; </li>
<li>static  int  sum;  //声明静态数据成员 </li>
<li>public  : </li>
<li>Myclass(  int  a ,  int  b ,  int  c); </li>
<li>void  GetSum(); </li>
<li>}; </li>
<li><ol start="14">
<li>int  Myclass::sum = 0;  //定义并初始化静态数据成员 </li>
</ol>
</li>
<li><ol start="16">
<li>Myclass::Myclass(  int  a ,  int  b ,  int  c) </li>
</ol>
</li>
<li>{ </li>
<li>this  -&gt;a = a; </li>
<li>this  -&gt;b = b; </li>
<li>this  -&gt;c = c; </li>
<li>sum += a+b+c; </li>
<li>} </li>
<li>void  Myclass::GetSum() </li>
<li>{ </li>
<li>cout&lt;&lt; “sum=”  &lt;&lt;sum&lt;&lt;endl; </li>
<li>} </li>
<li><ol start="28">
<li>int  main(  void  ) </li>
</ol>
</li>
<li>{ </li>
<li>Myclass M(1 , 2 , 3); </li>
<li>M.GetSum(); </li>
<li>Myclass N(4 , 5 , 6); </li>
<li>N.GetSum(); </li>
<li>M.GetSum(); </li>
<li>return  0; </li>
<li>} </li>
</ol>
<p>可以看出，静态数据成员有以下特点：</p>
<ul>
<li>对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。也就是说，静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共用。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新； </li>
<li>静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。在Example 5中，语句int Myclass::Sum=0;是定义静态数据成员； </li>
<li>静态数据成员和普通数据成员一样遵从public,protected,private访问规则； </li>
<li>因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它； </li>
<li><p>静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为：<br>＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞</p>
</li>
<li><p>类的静态数据成员有两种访问形式：<br>＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞<br>如果静态数据成员的访问权限允许的话（即public的成员），可在程序中，按上述格式来引用静态数据成员 ；</p>
</li>
<li><p>静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，所以节省存储空间。第二，一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了； </p>
</li>
<li>同全局变量相比，使用静态数据成员有两个优势： </li>
</ul>
<ol>
<li>静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性； </li>
<li>可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能； </li>
</ol>
<p>2、静态成员函数  </p>
<p>与静态数据成员一样，我们也可以创建一个静态成员函数，它为类的全部服务而不是为某一个类的具体对象服务。静态成员函数与静态数据成员一样，都是类的内部实现，属于类定义的一部分。普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体的属于某个类的具体对象的。通常情况下，this是缺省的。如函数fn()实际上是this-&gt;fn()。<br><strong>但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上讲，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数。</strong><br>下面举个静态成员函数的例子。</p>
<p><strong>[cpp]</strong> <a href="http://blog.csdn.net/hackbuteer1/article/details/7487694#" title="view plain" target="_blank" rel="noopener"> view plain
</a> <a href="http://blog.csdn.net/hackbuteer1/article/details/7487694#" title="copy" target="_blank" rel="noopener"><br>copy </a></p>
<ol>
<li>#include <iostream></iostream></li>
<li>using  namespace  std; </li>
<li><ol start="4">
<li>class  Myclass </li>
</ol>
</li>
<li>{ </li>
<li>private  : </li>
<li>int  a , b , c; </li>
<li>static  int  sum;  //声明静态数据成员 </li>
<li>public  : </li>
<li>Myclass(  int  a ,  int  b ,  int  c); </li>
<li>static  void  GetSum();  //声明静态成员函数 </li>
<li>}; </li>
<li><ol start="14">
<li>int  Myclass::sum = 0;  //定义并初始化静态数据成员 </li>
</ol>
</li>
<li><ol start="16">
<li>Myclass::Myclass(  int  a ,  int  b ,  int  c) </li>
</ol>
</li>
<li>{ </li>
<li>this  -&gt;a = a; </li>
<li>this  -&gt;b = b; </li>
<li>this  -&gt;c = c; </li>
<li>sum += a+b+c;  //非静态成员函数可以访问静态数据成员 </li>
<li>} </li>
<li>void  Myclass::GetSum()  //静态成员函数的实现 </li>
<li>{ </li>
<li>//cout&lt;&lt;a&lt;&lt;endl;    //错误代码，a是非静态数据成员 </li>
<li>cout&lt;&lt; “sum=”  &lt;&lt;sum&lt;&lt;endl; </li>
<li>} </li>
<li><ol start="29">
<li>int  main(  void  ) </li>
</ol>
</li>
<li>{ </li>
<li>Myclass M(1 , 2 , 3); </li>
<li>M.GetSum(); </li>
<li>Myclass N(4 , 5 , 6); </li>
<li>N.GetSum(); </li>
<li>Myclass::GetSum(); </li>
<li>return  0; </li>
<li>} </li>
</ol>
<p>关于静态成员函数，可以总结为以下几点：</p>
<ul>
<li>出现在类体外的函数定义不能指定关键字static； </li>
<li>静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数； </li>
<li>非静态成员函数可以任意地访问静态成员函数和静态数据成员； </li>
<li>静态成员函数不能访问非静态成员函数和非静态数据成员； </li>
<li>由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长； </li>
<li><p>调用静态成员函数，可以用成员访问操作符(.)和(-&gt;)为一个类的对象或指向类对象的指针调用静态成员函数，也可以直接使用如下格式：<br>＜类名＞::＜静态成员函数名＞（＜参数表＞）<br>调用类的静态成员函数。</p>
<p>*</p>
</li>
</ul>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>C++单例模式【设计模式】（转）</title>
    <url>/article/csdn/C++%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%EF%BC%88%E8%BD%AC%EF%BC%89.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40450617" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40450617</a></p>
<p>单例模式也称为单件模式、单子模式，可能是使用最广泛的设计模式。其意图是保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。</p>
<p>单例模式通过类本身来管理其唯一实例，这种特性提供了解决问题的方法。唯一的实例是类的一个普通对象，但设计这个类时，让它只能创建一个实例并提供对此实例的全局访问。唯一实例类Singleton在静态成员函数中隐藏创建实例的操作。习惯上把这个成员函数叫做Instance()，它的返回值是唯一实例的指针。  </p>
<p>定义：</p>
<pre><code>class CSingleton
{
private:
    CSingleton()   //构造函数是私有的
    {
    }
    static CSingleton *m_pInstance;
public:
    static CSingleton * GetInstance()
    {
        if(m_pInstance == NULL)  //判断是否第一次调用
            m_pInstance = new CSingleton();
        return m_pInstance;
    }
};
</code></pre><p>用户访问唯一实例的方法只有GetInstance()成员函数。如果不通过这个函数，任何创建实例的尝试都将失败，因为类的构造函数是私有的。GetInstance()使用<br>懒惰初始化，也就是说它的返回值是当这个函数首次被访问时被创建的  。这是一种防弹设计——所有GetInstance()之后的调用都返回相同实例的指针。  </p>
<p>单例类CSingleton有以下特征：<br>1.它有一个  指向唯一实例的静态指针m_pInstance，并且是私有的；<br>2.它有一个公有的函数，可以获取这个唯一的实例，并且在需要的时候创建该实例；<br>3.它的构造函数是私有的，这样就不能从别处创建该类的实例。  </p>
<p>垃圾回收问题：</p>
<p>大多数时候，这样的实现都不会出现问题。有经验的读者可能会问，m_pInstance指向的空间什么时候释放呢？更严重的问题是，该实例的析构函数什么时候执行？<br>如果在类的析构行为中有必须的操作，比如关闭文件，释放外部资源，那么上面的代码无法实现这个要求。我们需要一种方法，正常的删除该实例。<br>可以在程序结束时调用GetInstance()，并对返回的指针掉用delete操作。这样做可以实现功能，但不仅很丑陋，而且容易出错。因为这样的附加代码很容易被忘记，而且也很难保证在delete之后，没有代码再调用GetInstance函数。<br>一个妥善的方法是让这个类自己知道在合适的时候把自己删除，或者说把删除自己的操作挂在操作系统中的某个合适的点上  ，使其在恰当的时候被自动执行。<br>我们知道，  程序在结束的时候，系统会自动析构所有的全局变量  。事实上，  系统也会析构所有的类的静态成员变量，就像这些静态成员也是全局变量一样<br>。利用这个特征，我们可以在单例类中定义一个这样的  静态成员变量  ，而它的  唯一工作<br>就是在析构函数中删除单例类的实例。如下面的代码中的CGarbo类（Garbo意为垃圾工人）：  </p>
<pre><code>class CSingleton
{
private:
    CSingleton()
    {
    }
    static CSingleton *m_pInstance;
    class CGarbo   //它的唯一工作就是在析构函数中删除CSingleton的实例
    {
    public:
        ~CGarbo()
        {
            if(CSingleton::m_pInstance)
                delete CSingleton::m_pInstance;
        }
    };
    static CGarbo Garbo;  //定义一个静态成员变量，程序结束时，系统会自动调用它的析构函数
public:
    static CSingleton * GetInstance()
    {
        if(m_pInstance == NULL)  //判断是否第一次调用
            m_pInstance = new CSingleton();
        return m_pInstance;
    }
};
</code></pre><p>类CGarbo被定义为CSingleton的  私有内嵌类  ，以防该类被在其他地方滥用。  </p>
<p>程序运行结束时，系统会调用CSingleton的静态成员Garbo的析构函数，该析构函数会删除单例的唯一实例。<br>使用这种方法释放单例对象有以下特征：<br>在单例类内部定义专有的嵌套类；<br>在单例类内定义私有的专门用于释放的静态成员；<br>利用程序在结束时析构全局变量的特性，选择最终的释放时机；<br>使用单例的代码不需要任何操作，不必关心对象的释放。  </p>
<p>进一步的讨论  </p>
<p>但是添加一个类的静态对象，总是让人不太满意，所以有人用如下方法来重新实现单例和解决它相应的问题，代码如下：</p>
<pre><code>class CSingleton
{
private:
    CSingleton()   //构造函数是私有的
    {
    }
public:
    static CSingleton &amp; GetInstance()
    {
        static CSingleton instance;   //局部静态变量
        return instance;
    }
};
</code></pre><p>使用  局部静态变量  ，非常强大的方法，完全实现了单例的特性，而且代码量更少，也不用担心单例销毁的问题。<br>但使用此种方法也会出现问题，当如下方法使用单例时问题来了，<br>Singleton singleton = Singleton :: GetInstance();<br>这么做就出现了一个  类拷贝的问题  ，这就违背了单例的特性。产生这个问题  原因在于  ：编译器会为类生成一个默认的构造函数，来支持类的拷贝。  </p>
<p>最后没有办法，我们要禁止类拷贝和类赋值，禁止程序员用这种方式来使用单例，当时领导的意思是GetInstance()函数返回一个指针而不是返回一个引用，函数的代码改为如下：</p>
<pre><code>class CSingleton
{
private:
    CSingleton()   //构造函数是私有的
    {
    }
public:
    static CSingleton * GetInstance()
    {
        static CSingleton instance;   //局部静态变量
        return &amp;instance;
    }
};
</code></pre><p>但我总觉的不好，为什么不让编译器不这么干呢。这时我才想起可以显示的声明类拷贝的构造函数，和重载 = 操作符，新的单例类如下：  </p>
<pre><code>class CSingleton
{
private:
    CSingleton()   //构造函数是私有的
    {
    }
    CSingleton(const CSingleton &amp;);
    CSingleton &amp; operator = (const CSingleton &amp;);
public:
    static CSingleton &amp; GetInstance()
    {
        static CSingleton instance;   //局部静态变量
        return instance;
    }
};
</code></pre><p>关于Singleton(const Singleton);和 Singleton &amp; operate = (const<br>Singleton&amp;);函数，需要声明成私有的，并且只声明不实现。这样，如  果用上面的方式来使用单例时，不管是在友元类中还是其他的，编译器都是报错。<br>不知道这样的单例类是否还会有问题，但在程序中这样子使用已经基本没有问题了。  </p>
<p>线程安全、异常安全，可以做以下扩展：  </p>
<pre><code>class Lock
{
private:       
    CCriticalSection m_cs;
public:
    Lock(CCriticalSection  cs) : m_cs(cs)
    {
        m_cs.Lock();
    }
    ~Lock()
    {
        m_cs.Unlock();
    }
};

class Singleton
{
private:
    Singleton();
    Singleton(const Singleton &amp;);
    Singleton&amp; operator = (const Singleton &amp;);

public:
    static Singleton *Instantialize();
    static Singleton *pInstance;
    static CCriticalSection cs;
};

Singleton* Singleton::pInstance = 0;

Singleton* Singleton::Instantialize()
{
    if(pInstance == NULL)
    {   //double check
        Lock lock(cs);           //用lock实现线程安全，用资源管理类，实现异常安全
        //使用资源管理类，在抛出异常的时候，资源管理类对象会被析构，析构总是发生的无论是因为异常抛出还是语句块结束。
        if(pInstance == NULL)
        {
            pInstance = new Singleton();
        }
    }
    return pInstance;
}
</code></pre><p>之所以在Instantialize函数里面对pInstance 是否为空做了两次判断，因为该方法调用一次就产生了对象，pInstance == NULL<br>大部分情况下都为false，如果按照原来的方法，每次获取实例都需要加锁，效率太低。而改进的方法只需要在第一次 调用的时候加锁，可大大提高效率。  </p>
<p>转自：<a href="http://blog.csdn.net/hackbuteer1/article/details/7460019" target="_blank" rel="noopener">http://blog.csdn.net/hackbuteer1/article/details/7460019</a></p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/article/csdn/Codeforces_Round_271_(Div._2)_A_B_D.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41865791" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41865791</a></p>
<p><a href="http://codeforces.com/contest/474" target="_blank" rel="noopener"> http://codeforces.com/contest/474 </a>  </p>
<p>A 水题 枚举每个字符即可</p>
<p>A. Keyboard</p>
<p>time limit per test</p>
<p>2 seconds</p>
<p>memory limit per test</p>
<p>256 megabytes</p>
<p>input</p>
<p>standard input</p>
<p>output</p>
<p>standard output</p>
<p>Our good friend Mole is trying to code a big message. He is typing on an<br>unusual keyboard with characters arranged in following way:</p>
<pre><code>qwertyuiop
asdfghjkl;
zxcvbnm,./
</code></pre><p>Unfortunately Mole is blind, so sometimes it is problem for him to put his<br>hands accurately. He accidentally moved both his hands with one position to<br>the left or to the right. That means that now he presses not a button he<br>wants, but one neighboring button (left or right, as specified in input).</p>
<p>We have a sequence of characters he has typed and we want to find the original<br>message.</p>
<p>Input</p>
<p>First line of the input contains one letter describing direction of shifting (<br>‘L’  or  ‘R’  respectively for left or right).</p>
<p>Second line contains a sequence of characters written by Mole. The size of<br>this sequence will be no more than  100  . Sequence contains only symbols that<br>appear on Mole’s keyboard. It doesn’t contain spaces as there is no space on<br>Mole’s keyboard.</p>
<p>It is guaranteed that even though Mole hands are moved, he is still pressing<br>buttons on keyboard and not hitting outside it.</p>
<p>Output</p>
<p>Print a line that contains the original message.</p>
<p>Sample test(s)</p>
<p>input</p>
<pre><code>R
s;;upimrrfod;pbr
</code></pre><p>output</p>
<pre><code>allyouneedislove





#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt;
#include&lt;malloc.h&gt;
#include&lt;stdexcept&gt;
#include&lt;iomanip&gt;
#include&lt;iterator&gt;

using namespace std;

int n,m;
char a[3];
char b[10000];

char p[10000] = {&quot;qwertyuiopasdfghjkl;zxcvbnm,./&quot;};

int main ()
{
    scanf(&quot;%s&quot;,a);
    scanf(&quot;%s&quot;,b);
    int l = strlen(b);
    if (a[0] == &#39;L&#39;)
    {
        for(int i=0;i&lt;l;i++)
        {
            for(int j=0;j&lt;30;j++)
            {
                if (p[j] == b[i])
                {
                    printf(&quot;%c&quot;,p[j+1]);
                    continue;
                }
            }
        }
        printf(&quot;\n&quot;);
    }
    else if (a[0] == &#39;R&#39;)
    {
        for(int i=0;i&lt;l;i++)
        {
            for(int j=0;j&lt;30;j++)
            {
                if (p[j] == b[i])
                {
                    printf(&quot;%c&quot;,p[j-1]);
                    continue;
                }
            }
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre><p>B. Worms</p>
<p>time limit per test</p>
<p>1 second</p>
<p>memory limit per test</p>
<p>256 megabytes</p>
<p>input</p>
<p>standard input</p>
<p>output</p>
<p>standard output</p>
<p>It is lunch time for Mole. His friend, Marmot, prepared him a nice game for<br>lunch.</p>
<p>Marmot brought Mole  _n_ ordered piles of worms such that  _i_ -th pile<br>contains  _a_ _i_ worms. He labeled all these worms with consecutive integers:<br>worms in first pile are labeled with numbers  1  to  _a_ 1  , worms in second<br>pile are labeled with numbers  _a_ 1  + 1  to  _a_ 1  + _a_ 2  and so on. See<br>the example for a better understanding.</p>
<p>Mole can’t eat all the worms (Marmot brought a lot) and, as we all know, Mole<br>is blind, so Marmot tells him the labels of the best juicy worms. Marmot will<br>only give Mole a worm if Mole says correctly in which pile this worm is<br>contained.</p>
<p>Poor Mole asks for your help. For all juicy worms said by Marmot, tell Mole<br>the correct answers.</p>
<p>Input</p>
<p>The first line contains a single integer  _n_ (  1 ≤ _n_ ≤ 10  5  ), the<br>number of piles.</p>
<p>The second line contains  _n_ integers  _a_ 1  , _a_ 2  , …, _a_ _n_ (  1 ≤<br>_a_ _i_ ≤ 10  3  ,  _a_ 1  + _a_ 2  + … + _a_ _n_ ≤ 10  6  ), where  _a_<br>_i_ is the number of worms in the  _i_ -th pile.</p>
<p>The third line contains single integer  _m_ (  1 ≤ _m_ ≤ 10  5  ), the number<br>of juicy worms said by Marmot.</p>
<p>The fourth line contains  _m_ integers  _q_ 1  , _q_ 2  , …, _q_ _m_ (  1 ≤<br>_q_ _i_ ≤ _a_ 1  + _a_ 2  + … + _a_ _n_ ), the labels of the juicy worms.</p>
<p>Output</p>
<p>Print  _m_ lines to the standard output. The  _i_ -th line should contain an<br>integer, representing the number of the pile where the worm labeled with the<br>number  _q_ _i_ is.</p>
<p>Sample test(s)</p>
<p>input</p>
<pre><code>5
2 7 3 4 9
3
1 25 11
</code></pre><p>output</p>
<pre><code>1
5
3
</code></pre><p>Note</p>
<p>For the sample input:</p>
<ul>
<li>The worms with labels from [  1  ,  2  ] are in the first pile. </li>
<li>The worms with labels from [  3  ,  9  ] are in the second pile. </li>
<li>The worms with labels from [  10  ,  12  ] are in the third pile. </li>
<li>The worms with labels from [  13  ,  16  ] are in the fourth pile. </li>
<li>The worms with labels from [  17  ,  25  ] are in the fifth pile. </li>
</ul>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt;
#include&lt;malloc.h&gt;
#include&lt;stdexcept&gt;
#include&lt;iomanip&gt;
#include&lt;iterator&gt;

using namespace std;

int n,m;

long long  a[1100000];
long long p[1100000];
int b;

int main ()
{
    while (scanf(&quot;%d&quot;,&amp;n)!=EOF)
    {
        for(int i=0;i&lt;n;i++)
            scanf(&quot;%I64d&quot;,&amp;a[i]);

        long long  sum = 0;
        for(int i=0;i&lt;n;i++)
        {
            for(int j = sum ;j&lt;sum + a[i];j++)
                p[j] = i;

            sum+=a[i];
        }

        scanf(&quot;%d&quot;,&amp;m);
        while (m--)
        {
            scanf(&quot;%d&quot;,&amp;b);
            printf(&quot;%I64d\n&quot;,p[b-1]+1);
        }

    }
    return 0;
}
</code></pre><p>D题 dp</p>
<p>D. Flowers</p>
<p>time limit per test</p>
<p>1.5 seconds</p>
<p>memory limit per test</p>
<p>256 megabytes</p>
<p>input</p>
<p>standard input</p>
<p>output</p>
<p>standard output</p>
<p>We saw the little game Marmot made for Mole’s lunch. Now it’s Marmot’s dinner<br>time and, as we all know, Marmot eats flowers. At every dinner he eats some<br>red and white flowers. Therefore a dinner can be represented as a sequence of<br>several flowers, some of them white and some of them red.</p>
<p>But, for a dinner to be tasty, there is a rule: Marmot wants to eat white<br>flowers only in groups of size  _k_ .</p>
<p>Now Marmot wonders in how many ways he can eat between  _a_ and  _b_ flowers.<br>As the number of ways could be very large, print it modulo  1000000007  (  10<br>9  + 7  ).</p>
<p>Input</p>
<p>Input contains several test cases.</p>
<p>The first line contains two integers  _t_ and  _k_ (  1 ≤ _t_ , _k_ ≤ 10  5<br>), where  _t_ represents the number of test cases.</p>
<p>The next  _t_ lines contain two integers  _a_ _i_ and  _b_ _i_ (  1 ≤ _a_ _i_<br>≤ _b_ _i_ ≤ 10  5  ), describing the  _i_ -th test.</p>
<p>Output</p>
<p>Print  _t_ lines to the standard output. The  _i_ -th line should contain the<br>number of ways in which Marmot can eat between  _a_ _i_ and  _b_ _i_ flowers<br>at dinner modulo  1000000007  (  10  9  + 7  ).</p>
<p>Sample test(s)</p>
<p>input</p>
<pre><code>3 2
1 3
2 3
4 4
</code></pre><p>output</p>
<pre><code>6
5
5
</code></pre><p>Note</p>
<ul>
<li>For  _K_ =  2  and length  1  Marmot can eat (  _R_ ). </li>
<li>For  _K_ =  2  and length  2  Marmot can eat (  _RR_ ) and (  _WW_ ). </li>
<li>For  _K_ =  2  and length  3  Marmot can eat (  <em>RRR</em> ), (  <em>RWW</em> ) and (  <em>WWR</em> ). </li>
<li>For  _K_ =  2  and length  4  Marmot can eat, for example, (  <em>WWWW</em> ) or (  <em>RWWR</em> ), but for example he can’t eat (  <em>WWWR</em> ). </li>
<li></li>
</ul>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt;
#include&lt;malloc.h&gt;
#include&lt;stdexcept&gt;
#include&lt;iomanip&gt;
#include&lt;iterator&gt;

using namespace std;

int n,m;
int k,t;

int a,b;
int mod = 1000000007;
long long ans[100010];

int main ()
{
    while (scanf(&quot;%d %d&quot;,&amp;t,&amp;k)!=EOF)
    {
        for(int i=1;i&lt;k;i++)
            ans[i] = 1;
        ans[k] = 2;

        for(int i=k+1;i&lt;=100002;i++)
            ans[i] = (ans[i-1] + ans[i-k]) % mod;

        for(int i=2;i&lt;=100002;i++)
            ans[i] = (ans[i] + ans[i-1]) % mod;

        for(int i=0;i&lt;t;i++)
        {
            scanf(&quot;%d %d&quot;,&amp;a,&amp;b);
            long long  anss = (ans[b] - ans[a-1])%mod;
            if (anss &lt; 0)
                    anss += mod;
            printf(&quot;%I64d\n&quot;,anss);
        }

    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/article/csdn/Codeforces_Round_279_(Div._2)_A_B_C.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41495521" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41495521</a></p>
<p><a href="http://codeforces.com/contest/490/problem/A" target="_blank" rel="noopener"> http://codeforces.com/contest/490/problem/A
</a>  </p>
<p>A 题 贪心水题</p>
<p>A. Team Olympiad</p>
<p>time limit per test</p>
<p>1 second</p>
<p>memory limit per test</p>
<p>256 megabytes</p>
<p>input</p>
<p>standard input</p>
<p>output</p>
<p>standard output</p>
<p>The School №0 of the capital of Berland has  _n_ children studying in it. All<br>the children in this school are gifted: some of them are good at programming,<br>some are good at maths, others are good at PE (Physical Education). Hence, for<br>each child we know value  _t_ _i_ :</p>
<ul>
<li>_t_ _i_ = 1  , if the  _i_ -th child is good at programming, </li>
<li>_t_ _i_ = 2  , if the  _i_ -th child is good at maths, </li>
<li>_t_ _i_ = 3  , if the  _i_ -th child is good at PE </li>
</ul>
<p>Each child happens to be good at exactly one of these three subjects.</p>
<p>The Team Scientific Decathlon Olympias requires teams of three students. The<br>school teachers decided that the teams will be composed of three children that<br>are good at different subjects. That is, each team must have one<br>mathematician, one programmer and one sportsman. Of course, each child can be<br>a member of no more than one team.</p>
<p>What is the maximum number of teams that the school will be able to present at<br>the Olympiad? How should the teams be formed for that?</p>
<p>Input</p>
<p>The first line contains integer  _n_ (  1 ≤ _n_ ≤ 5000  ) — the number of<br>children in the school. The second line contains  _n_ integers  _t_ 1  , _t_ 2<br>, …, _t_ _n_ (  1 ≤ _t_ _i_ ≤ 3  ), where  _t_ _i_ describes the skill of<br>the  _i_ -th child.</p>
<p>Output</p>
<p>In the first line output integer  _w_ — the largest possible number of teams.</p>
<p>Then print  _w_ lines, containing three numbers in each line. Each triple<br>represents the indexes of the children forming the team. You can print both<br>the teams, and the numbers in the triplets in any order. The children are<br>numbered from  1  to  _n_ in the order of their appearance in the input. Each<br>child must participate in no more than one team. If there are several<br>solutions, print any of them.</p>
<p>If no teams can be compiled, print the only line with value  _w_ equal to 0.</p>
<p>Sample test(s)</p>
<p>input</p>
<pre><code>7
1 3 1 3 2 1 2
</code></pre><p>output</p>
<pre><code>2
3 5 2
6 7 4
</code></pre><p>input</p>
<pre><code>4
2 1 1 2
</code></pre><p>output</p>
<pre><code>0


#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;sstream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;

using namespace std;

int n,m;
int t;

int a[5];
int b[5005];

int main ()
{
    while (scanf(&quot;%d&quot;,&amp;n)!=EOF)
    {
        memset(a,0,sizeof(a));
        for(int i=1;i&lt;=n;i++)
        {
            scanf(&quot;%d&quot;,&amp;t);
            b[i]=t;
            if(t == 1)
                a[1]++;
            if(t == 2)
                a[2]++;
            if(t == 3)
                a[3]++;
        }
        int ans = min (a[1],min(a[2],a[3]));
        printf(&quot;%d\n&quot;,ans);
        for(int i=1 ;i&lt;=ans;i++)
        {
            for(int j =1 ;j&lt;=5005;j++)
            {
                if(b[j] == 1)
                {
                    printf(&quot;%d &quot;,j);
                    b[j] = 0;
                    break;
                }

            }
            for(int j =1 ;j&lt;=n;j++)
            {
                if(b[j] == 2)
                {
                    printf(&quot;%d &quot;,j);
                    b[j] = 0;
                    break;
                }

            }
            for(int j =1;j&lt;=n;j++)
            {
                if(b[j] == 3)
                {
                    printf(&quot;%d\n&quot;,j);
                    b[j] = 0;
                    break;
                }
            }
        }
    }

    return 0;
}
</code></pre><p><a href="http://codeforces.com/contest/490/problem/B" target="_blank" rel="noopener"> http://codeforces.com/contest/490/problem/B
</a>  </p>
<p>B. Queue</p>
<p>time limit per test</p>
<p>2 seconds</p>
<p>memory limit per test</p>
<p>256 megabytes</p>
<p>input</p>
<p>standard input</p>
<p>output</p>
<p>standard output</p>
<p>During the lunch break all  _n_ Berland State University students lined up in<br>the food court. However, it turned out that the food court, too, has a lunch<br>break and it temporarily stopped working.</p>
<p>Standing in a queue that isn’t being served is so boring! So, each of the<br>students wrote down the number of the student ID of the student that stands in<br>line directly in front of him, and the student that stands in line directly<br>behind him. If no one stands before or after a student (that is, he is the<br>first one or the last one), then he writes down number  0  instead (in Berland<br>State University student IDs are numerated from  1  ).</p>
<p>After that, all the students went about their business. When they returned,<br>they found out that restoring the queue is not such an easy task.</p>
<p>Help the students to restore the state of the queue by the numbers of the<br>student ID’s of their neighbors in the queue.</p>
<p>Input</p>
<p>The first line contains integer  _n_ (  2 ≤ _n_ ≤ 2·10  5  ) — the number of<br>students in the queue.</p>
<p>Then  _n_ lines follow,  _i_ -th line contains the pair of integers  _a_ _i_ ,<br>_b_ _i_ (  0 ≤ _a_ _i_ , _b_ _i_ ≤ 10  6  ), where  _a_ _i_ is the ID number<br>of a person in front of a student and  _b_ _i_ is the ID number of a person<br>behind a student. The lines are given in the arbitrary order. Value  0  is<br>given instead of a neighbor’s ID number if the neighbor doesn’t exist.</p>
<p>The ID numbers of all students are distinct. It is guaranteed that the records<br>correspond too the queue where all the students stand in some order.</p>
<p>Output</p>
<p>Print a sequence of  _n_ integers  _x_ 1  , _x_ 2  , …, _x_ _n_ — the<br>sequence of ID numbers of all the students in the order they go in the queue<br>from the first student to the last one.</p>
<p>Sample test(s)</p>
<p>input</p>
<pre><code>4
92 31
0 7
31 0
7 141
</code></pre><p>output</p>
<pre><code>92 7 31 141 
</code></pre><p>Note</p>
<p>The picture illustrates the queue for the first sample.</p>
<p><img src="http://espresso.codeforces.com/f089a9d653e574dc26574dc9adce315a616191f9.png" alt=""></p>
<p>要将给的数据分为奇数位和偶数位来排。。用ne[]来存后继，pre[]存前驱。再用一个flag[]标记. 每次读入两个数 a，b 让ne[a] =<br>b,pre[b] = a ,flag [a] = flag[b] = 1;然后让nt从0开始扫一遍就能得到处在偶数位置的数。每次访问后将flag[]置0。<br>接下来找奇数位置的数。扫一遍flag 直到遇到flag[i]的值为1的时候退出循环。然后tmp = i<br>,然后从tmp开始扫一遍pre找到第一个位置的数，然后就可以填满奇数位置的数了。  </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;sstream&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;

using namespace std;

int n;
int ne[1000010],pre[1000010],flog[1000010];
int ans [1000010];
int a,b;

int main ()
{
    while (cin&gt;&gt;n)
    {
        memset (flog,0,sizeof(flog));
        memset (ne,-1,sizeof(ne));
        memset (pre,-1,sizeof(pre));
        memset (ans,0,sizeof(ans));

        for(int i=1;i&lt;=n;i++)
        {
            cin&gt;&gt;a&gt;&gt;b;
            ne[a] = b;
            pre[b] = a;
            flog[a] = 1;
            flog [b] = 1;
        }
        int tmp = 0;
        int k = 2;
        while (1)
        {
            ans[k]=ne[tmp];
            flog[tmp]=0;

            k+=2;
            tmp = ne[tmp];
            if(tmp &lt;= 0)
                break;
        }

        int cnt ;
        for(int i=1 ;i&lt;=1000000;i++)
        {
            if ( flog[i] )
            {
                cnt = i;
                break;
            }
        }

        tmp = cnt ;

        while (1)
        {
            if (pre[tmp] &lt; 0)
                break;
            tmp = pre[tmp];
        }

        k=1;

        while (1)
        {
            ans[k] = tmp;
            k+=2;
            tmp = ne[tmp];

            if (tmp&lt;=0)
                break;
        }
        for(int i=1;i&lt;=n;i++)
            cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;;
        cout&lt;&lt;endl;
    }
    return 0;
}
</code></pre><p><a href="http://codeforces.com/contest/490/problem/C" target="_blank" rel="noopener">http://codeforces.com/contest/490/problem/C</a>  </p>
<p>C. Hacking Cypher</p>
<p>time limit per test</p>
<p>1 second</p>
<p>memory limit per test</p>
<p>256 megabytes</p>
<p>input</p>
<p>standard input</p>
<p>output</p>
<p>standard output</p>
<p>Polycarpus participates in a competition for hacking into a new secure<br>messenger. He’s almost won.</p>
<p>Having carefully studied the interaction protocol, Polycarpus came to the<br>conclusion that the secret key can be obtained if he properly cuts the public<br>key of the application into two parts. The public key is a long integer which<br>may consist of even a million digits!</p>
<p>Polycarpus needs to find such a way to cut the public key into two nonempty<br>parts, that the first (left) part is divisible by  _a_ as a separate number,<br>and the second (right) part is divisible by  _b_ as a separate number. Both<br>parts should be  positive  integers that have no leading zeros. Polycarpus<br>knows values  _a_ and  _b_ .</p>
<p>Help Polycarpus and find any suitable method to cut the public key.</p>
<p>Input</p>
<p>The first line of the input contains the public key of the messenger — an<br>integer without leading zeroes, its length is in range from  1  to  10  6<br>digits. The second line contains a pair of space-separated positive integers<br>_a_ ,  _b_ (  1 ≤ _a_ , _b_ ≤ 10  8  ).</p>
<p>Output</p>
<p>In the first line print “  YES  “ (without the quotes), if the method<br>satisfying conditions above exists. In this case, next print two lines — the<br>left and right parts after the cut. These two parts, being concatenated, must<br>be exactly identical to the public key. The left part must be divisible by<br>_a_ , and the right part must be divisible by  _b_ . The two parts must be<br>positive integers having no leading zeros. If there are several answers, print<br>any of them.</p>
<p>If there is no answer, print in a single line “  NO  “ (without the quotes).</p>
<p>Sample test(s)</p>
<p>input</p>
<pre><code>116401024
97 1024
</code></pre><p>output</p>
<pre><code>YES
11640
1024
</code></pre><p>input</p>
<pre><code>284254589153928171911281811000
1009 1000
</code></pre><p>output</p>
<pre><code>YES
2842545891539
28171911281811000
</code></pre><p>input</p>
<pre><code>120
12 1
</code></pre><p>output</p>
<pre><code>NO







#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;utility&gt;

char s[1000000 + 5];
long long  a,b;
int ok_a[1000000 + 5],ok_b[1000000 + 5];

int main ()
{
    while (scanf(&quot;%s&quot;,s+1)!=EOF)
    {
        int len = strlen(s+1);
        scanf(&quot;%I64d %I64d&quot;,&amp;a,&amp;b);
        long long tmp ,t;
        tmp = 0;
        for(int i=1;i&lt;=len;i++)
        {
            tmp = (tmp*10 + s[i] - &#39;0&#39;)%a;
            if (tmp == 0)
                ok_a[i] = 1;
            else
                ok_a[i] = 0;
        }

        tmp = 0,t=1;
        for(int i = len;i&gt;=1;i--)
        {
            tmp = ( tmp + t*( s[i] - &#39;0&#39;) )%b;
            t = t*10%b;

            if (tmp == 0 )
                ok_b[i] = 1;
            else
                ok_b[i] = 0;
        }
        int ans ;
        int ok=0;
        int i;

        for (i = 2; i &lt;= len; ++i)
           if (ok_a[i - 1] &amp;&amp; ok_b[i] &amp;&amp; s[i] != &#39;0&#39;) break;

       if (i == len + 1) 
       {
           puts(&quot;NO&quot;);
           return 0;
       }
       puts(&quot;YES&quot;);
       for (int j = 1; j &lt; i; ++j)
            putchar(s[j]);
            puts(&quot;&quot;);
       for (int j = i; j &lt;= len; ++j)
           putchar(s[j]); puts(&quot;&quot;);
       return 0;
    }
        return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/article/csdn/Codeforces_Round_278_(Div._2)_A_B.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41382453" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41382453</a></p>
<p>A. Giga Tower</p>
<p>time limit per test</p>
<p>1 second</p>
<p>memory limit per test</p>
<p>256 megabytes</p>
<p>input</p>
<p>standard input</p>
<p>output</p>
<p>standard output</p>
<p>Giga Tower is the tallest and deepest building in Cyberland. There are  17 777<br>777 777  floors, numbered from  - 8 888 888 888  to  8 888 888 888  . In<br>particular, there is floor  0  between floor  - 1  and floor  1  . Every day,<br>thousands of tourists come to this place to enjoy the wonderful view.</p>
<p>In Cyberland, it is believed that the number “8” is a lucky number (that’s why<br>Giga Tower has  8 888 888 888  floors above the ground), and, an integer is<br>lucky  , if and only if its decimal notation contains at least one digit “8”.<br>For example,  8,  - 180, 808  are all  lucky  while  42,  - 10  are not. In<br>the Giga Tower, if you write code at a floor with lucky floor number, good<br>luck will always be with you (Well, this round is #278, also lucky, huh?).</p>
<p>Tourist Henry goes to the tower to seek good luck. Now he is at the floor<br>numbered  _a_ . He wants to find the minimum  positive  integer  _b_ , such<br>that, if he walks  _b_ floors higher, he will arrive at a floor with a  lucky<br>number.</p>
<p>Input</p>
<p>The only line of input contains an integer  _a_ (  - 10  9  ≤ _a_ ≤ 10  9  ).</p>
<p>Output</p>
<p>Print the minimum  _b_ in a line.</p>
<p>Sample test(s)</p>
<p>input</p>
<pre><code>179
</code></pre><p>output</p>
<pre><code>1
</code></pre><p>input</p>
<pre><code>-1
</code></pre><p>output</p>
<pre><code>9
</code></pre><p>input</p>
<pre><code>18
</code></pre><p>output</p>
<pre><code>10







#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;deque&gt;
#include &lt;vector&gt;
#include &lt;unordered_set&gt;
#include &lt;unordered_map&gt;
#include &lt;set&gt;
#include &lt;valarray&gt;
#include &lt;list&gt;
#include &lt;stack&gt;
#include &lt;array&gt;
#include &lt;iomanip&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;queue&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;stdio.h&gt;

using namespace std;

long long  n,m,x;

int check (long long a)
{
    if( a &lt; 0 )
             a = -a;
    while ( a )
    {
        if (a % 10 == 8 )
            return 1 ;
        a /= 10;
    }
    return 0;
}

int main()
{
    while (scanf(&quot;%I64d&quot;,&amp;n)!=EOF)
    {

        int ans =0 ;
        while (true)
        {
            ans ++;
            n++;
            if (check (n))
            {
                printf(&quot;%d\n&quot;,ans);
                break;
            }
        }
    }
    return 0;
}
</code></pre><p>B暴力</p>
<p><a href="http://codeforces.com/contest/488/problem/B" target="_blank" rel="noopener"> http://codeforces.com/contest/488/problem/B
</a>  </p>
<p>B. Candy Boxes</p>
<p>time limit per test</p>
<p>1 second</p>
<p>memory limit per test</p>
<p>256 megabytes</p>
<p>input</p>
<p>standard input</p>
<p>output</p>
<p>standard output</p>
<p>There is an old tradition of keeping  4  boxes of candies in the house in<br>Cyberland. The numbers of candies are  special  if their  arithmetic mean  ,<br>their  median  and their  range  are all equal. By definition, for a set  {<br>_x_ 1  , _x_ 2  , _x_ 3  , _x_ 4  }  (  _x_ 1  ≤ _x_ 2  ≤ _x_ 3  ≤ _x_ 4  )<br>arithmetic mean  is<br><img src="http://espresso.codeforces.com/daeb25d0b520beaea095158d4851903f527ffafc.png" alt=""><br>,  median  is<br><img src="http://espresso.codeforces.com/7655b731471163052bb5fbb4c5414c495a2ca2e2.png" alt=""><br>and  range  is  _x_ 4  - _x_ 1  .  The arithmetic mean and median are not<br>necessary integer.  It is well-known that if those three numbers are same,<br>boxes will create a “debugging field” and codes in the field will have no<br>bugs.</p>
<p>For example,  1, 1, 3, 3  is the example of  4  numbers meeting the condition<br>because their mean, median and range are all equal to  2  .</p>
<p>Jeff has  4  special boxes of candies. However, something bad has happened!<br>Some of the boxes could have been lost and now there are only  _n_ (  0 ≤ _n_<br>≤ 4  ) boxes remaining. The  _i_ -th remaining box contains  _a_ _i_ candies.</p>
<p>Now Jeff wants to know: is there a possible way to find the number of candies<br>of the  4 - _n_ missing boxes, meeting the condition above (the mean, median<br>and range are equal)?</p>
<p>Input</p>
<p>The first line of input contains an only integer  _n_ (  0 ≤ _n_ ≤ 4  ).</p>
<p>The next  _n_ lines contain integers  _a_ _i_ , denoting the number of candies<br>in the  _i_ -th box (  1 ≤ _a_ _i_ ≤ 500  ).</p>
<p>Output</p>
<p>In the first output line, print “  YES  “ if a solution exists, or print “  NO<br>“ if there is no solution.</p>
<p>If a solution exists, you should output  4 - _n_ more lines, each line<br>containing an integer  _b_ , denoting the number of candies in a missing box.</p>
<p>All your numbers  _b_ must satisfy inequality  1 ≤ _b_ ≤ 10  6  . It is<br>guaranteed that if there exists a positive integer solution, you can always<br>find such  _b_ ‘s meeting the condition. If there are multiple answers, you<br>are allowed to print any of them.</p>
<p>Given numbers  _a_ _i_ may follow in any order in the input, not necessary in<br>non-decreasing.</p>
<p>_a_ _i_ may have stood at any positions in the original set, not necessary on<br>lowest  _n_ first positions  .</p>
<p>Sample test(s)</p>
<p>input</p>
<pre><code>2
1
1
</code></pre><p>output</p>
<pre><code>YES
3
3
</code></pre><p>input</p>
<pre><code>3
1
1
1
</code></pre><p>output</p>
<pre><code>NO
</code></pre><p>input</p>
<pre><code>4
1
2
2
3
</code></pre><p>output</p>
<pre><code>YES
</code></pre><p>Note</p>
<p>For the first sample, the numbers of candies in  4  boxes can be  1, 1, 3, 3<br>. The arithmetic mean, the median and the range of them are all  2  .</p>
<p>For the second sample, it’s impossible to find the missing number of candies.</p>
<p>In the third example no box has been lost and numbers satisfy the condition.</p>
<p>You may output  _b_ in any order.</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;utility&gt;
#define inf 0x7fffffff

using namespace std;

const int maxn=100+10;

int main()
{
    int n;
    int an[5];
    while (scanf(&quot;%d&quot;,&amp;n)!=EOF)
    {
        for (int i=1 ;i&lt;=n ;i++) scanf(&quot;%d&quot;,&amp;an[i]);
        sort(an+1,an+n+1);
        if (n==0)
        {
            printf(&quot;YES\n&quot;);
            printf(&quot;1\n1\n3\n3\n&quot;);continue;
        }
        if (n==1)
        {
            int t=2*an[1];
            printf(&quot;YES\n&quot;);
            printf(&quot;%d\n%d\n%d\n&quot;,t/2,t/2*3,t/2*3);
            continue;
        }
        if (n==2)
        {
            int flag=0;
            // 1   2
            int t=2*an[1];
            int bn[5];
            bn[1]=an[1],bn[4]=3*bn[1];
            bn[2]=an[2];
            bn[3]=4*bn[1]-bn[2];
            if (bn[2]&gt;=bn[1] &amp;&amp; bn[3]&gt;=bn[2] &amp;&amp; bn[4]&gt;=bn[3] &amp;&amp; bn[4]&lt;=1000000)
            {
                flag=1;
                printf(&quot;YES\n&quot;);
                printf(&quot;%d\n%d\n&quot;,bn[3],bn[4]);
                continue;
            }
            // 1   3
            t=2*an[1];
            bn[1]=an[1];
            bn[3]=an[2];
            bn[2]=2*t-bn[3];
            bn[4]=bn[1]+t;
            if (bn[2]&gt;=bn[1] &amp;&amp; bn[3]&gt;=bn[2] &amp;&amp; bn[4]&gt;=bn[3] &amp;&amp; bn[4]&lt;=1000000)
            {
                flag=1;
                printf(&quot;YES\n&quot;);
                printf(&quot;%d\n%d\n&quot;,bn[2],bn[4]);
                continue;
            }
            // 1   4
            t=2*an[1];
            bn[1]=an[1];
            bn[4]=bn[1]+t;
            if (an[2]==bn[4])
            {
                bn[2]=bn[1];
                bn[3]=bn[4];
                if (bn[2]&gt;=bn[1] &amp;&amp; bn[3]&gt;=bn[2] &amp;&amp; bn[4]&gt;=bn[3] &amp;&amp; bn[4]&lt;=1000000)
                {
                    flag=1;
                    printf(&quot;YES\n&quot;);
                    printf(&quot;%d\n%d\n&quot;,bn[2],bn[3]);
                    continue;
                }
            }
            // 2   3
            double cn[5];
            double tt=(double)(an[1]+an[2])/2;
            cn[2]=an[1] ;cn[3]=an[2] ;
            cn[1]=tt/2.0;
            cn[4]=1.5*tt;
            if (cn[2]&gt;=cn[1] &amp;&amp; cn[3]&gt;=cn[2] &amp;&amp; cn[4]&gt;=cn[3] &amp;&amp; cn[4]&lt;=1000000)
            {
                flag=1;
                printf(&quot;YES\n&quot;);
                printf(&quot;%.0lf\n%.0lf\n&quot;,cn[3],cn[4]);
                continue;
            }
            // 2   4
            cn[4]=an[2];
            cn[2]=an[1];
            tt=2.0*cn[4]/3.0;
            cn[1]=tt/2.0;
            cn[3]=2.0*tt-cn[2];
            if (cn[2]&gt;=cn[1] &amp;&amp; cn[3]&gt;=cn[2] &amp;&amp; cn[4]&gt;=cn[3] &amp;&amp; cn[4]&lt;=1000000)
            {
                flag=1;
                printf(&quot;YES\n&quot;);
                printf(&quot;%.0lf\n%.0lf\n&quot;,cn[1],cn[3]);
                continue;
            }
            // 3   4
            cn[3]=an[1];
            cn[4]=an[2];
            tt=2.0*cn[4]/3.0;
            cn[1]=tt/2.0;
            cn[2]=2.0*tt-cn[3];
            if (cn[2]&gt;=cn[1] &amp;&amp; cn[3]&gt;=cn[2] &amp;&amp; cn[4]&gt;=cn[3] &amp;&amp; cn[4]&lt;=1000000)
            {
                flag=1;
                printf(&quot;YES\n&quot;);
                printf(&quot;%.0lf\n%.0lf\n&quot;,cn[1],cn[2]);
                continue;
            }
            if (!flag) printf(&quot;NO\n&quot;);
        }
        if (n==3)
        {
            // 1   2  3
            double cn[5];
            int flag=0;
            cn[1]=an[1] ;cn[2]=an[2] ;cn[3]=an[3] ;
            double tt=2.0*cn[1];
            cn[4]=1.5*tt;
            if (cn[2]+cn[3]==2.0*tt)
            {
                if (cn[2]&gt;=cn[1] &amp;&amp; cn[3]&gt;=cn[2] &amp;&amp; cn[4]&gt;=cn[3] &amp;&amp; cn[4]&lt;=1000000)
                {
                    flag=1;
                    printf(&quot;YES\n&quot;);
                    printf(&quot;%.0lf\n&quot;,cn[4]);
                    continue;
                }
            }
            // 1   2  4
            cn[1]=an[1] ;cn[2]=an[2] ;cn[4]=an[3];
            tt=2.0*cn[1];
            cn[3]=2.0*tt-cn[2];
            if (2.0*cn[4]==3.0*tt)
            {
                if (cn[2]&gt;=cn[1] &amp;&amp; cn[3]&gt;=cn[2] &amp;&amp; cn[4]&gt;=cn[3] &amp;&amp; cn[4]&lt;=1000000)
                {
                    flag=1;
                    printf(&quot;YES\n&quot;);
                    printf(&quot;%.0lf\n&quot;,cn[3]);
                    continue;
                }
            }
            // 2   3  4
            cn[2]=an[1] ;cn[3]=an[2] ;cn[4]=an[3] ;
            tt=(cn[2]+cn[3])/2.0;
            cn[1]=tt/2.0;
            if (cn[4]*2.0==3.0*tt)
            {
                if (cn[2]&gt;=cn[1] &amp;&amp; cn[3]&gt;=cn[2] &amp;&amp; cn[4]&gt;=cn[3] &amp;&amp; cn[4]&lt;=1000000)
                {
                    flag=1;
                    printf(&quot;YES\n&quot;);
                    printf(&quot;%.0lf\n&quot;,cn[1]);
                    continue;
                }
            }
            // 1   3  4
            cn[1]=an[1] ;cn[3]=an[2] ;cn[4]=an[3] ;
            tt=2.0*cn[1];
            cn[2]=2.0*tt-cn[3];
            if (2.0*cn[4]==3.0*tt)
            {
                if (cn[2]&gt;=cn[1] &amp;&amp; cn[3]&gt;=cn[2] &amp;&amp; cn[4]&gt;=cn[3] &amp;&amp; cn[4]&lt;=1000000)
                {
                    flag=1;
                    printf(&quot;YES\n&quot;);
                    printf(&quot;%.0lf\n&quot;,cn[2]);
                    continue;
                }
            }
            if (!flag) printf(&quot;NO\n&quot;);
        }
        if (n==4)
        {
            double tt=2.0*an[1];
            int flag=0;
            if (an[2]+an[3]==2.0*tt &amp;&amp; 2.0*an[4]==3.0*tt)
            {
                if (an[2]&gt;=an[1] &amp;&amp; an[3]&gt;=an[2] &amp;&amp; an[4]&gt;=an[3] &amp;&amp; an[4]&lt;=1000000)
                {
                    flag=1;
                    printf(&quot;YES\n&quot;);
                    continue;
                }
            }
            if (!flag) printf(&quot;NO\n&quot;);
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/article/csdn/Codeforces_Round_281_(Div._2)_A_B.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/41720951" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/41720951</a></p>
<p><a href="http://codeforces.com/contest/493" target="_blank" rel="noopener"> http://codeforces.com/contest/493 </a>  </p>
<p>A 第一次结构体开二维数组。。。</p>
<p>A. Vasya and Football</p>
<p>time limit per test</p>
<p>2 seconds</p>
<p>memory limit per test</p>
<p>256 megabytes</p>
<p>input</p>
<p>standard input</p>
<p>output</p>
<p>standard output</p>
<p>Vasya has started watching football games. He has learned that for some fouls<br>the players receive yellow cards, and for some fouls they receive red cards. A<br>player who receives the second yellow card automatically receives a red card.</p>
<p>Vasya is watching a recorded football match now and makes notes of all the<br>fouls that he would give a card for. Help Vasya determine all the moments in<br>time when players would be given red cards if Vasya were the judge. For each<br>player, Vasya wants to know only the  first  moment of time when he would<br>receive a red card from Vasya.</p>
<p>Input</p>
<p>The first line contains the name of the team playing at home. The second line<br>contains the name of the team playing away. Both lines are not empty. The<br>lengths of both lines do not exceed 20. Each line contains only of large<br>English letters. The names of the teams are distinct.</p>
<p>Next follows number  _n_ (  1 ≤ _n_ ≤ 90  ) — the number of fouls.</p>
<p>Each of the following  _n_ lines contains information about a foul in the<br>following form:</p>
<ul>
<li>first goes number  _t_ (  1 ≤ _t_ ≤ 90  ) — the minute when the foul occurs; </li>
<li>then goes letter “  h  “ or letter “  a  “ — if the letter is “  h  “, then the card was given to a home team player, otherwise the card was given to an away team player; </li>
<li>then goes the player’s number  _m_ (  1 ≤ _m_ ≤ 99  ); </li>
<li>then goes letter “  y  “ or letter “  r  “ — if the letter is “  y  “, that means that the yellow card was given, otherwise the red card was given. </li>
</ul>
<p>The players from different teams can have the same number. The players within<br>one team have distinct numbers. The fouls go chronologically, no two fouls<br>happened at the same minute.</p>
<p>Output</p>
<p>For each event when a player received his first red card  in a chronological<br>order  print a string containing the following information:</p>
<ul>
<li>The name of the team to which the player belongs; </li>
<li>the player’s number in his team; </li>
<li>the minute when he received the card. </li>
</ul>
<p>If no player received a card, then you do not need to print anything.</p>
<p>It is possible case that the program will not print anything to the output (if<br>there were no red cards).</p>
<p>Sample test(s)</p>
<p>input</p>
<pre><code>MC
CSKA
9
28 a 3 y
62 h 25 y
66 h 42 y
70 h 25 y
77 a 4 y
79 a 25 y
82 h 42 r
89 h 16 y
90 a 13 r
</code></pre><p>output</p>
<pre><code>MC 25 70
MC 42 82
CSKA 13 90


#include&lt;stdio.h&gt;  
#include&lt;iostream&gt;  
#include&lt;math.h&gt;  
#include&lt;stdlib.h&gt;  
#include&lt;ctype.h&gt;  
#include&lt;algorithm&gt;  
#include&lt;vector&gt;  
#include&lt;string.h&gt;  
#include&lt;queue&gt;  
#include&lt;stack&gt;  
#include&lt;set&gt;  
#include&lt;map&gt;  
#include&lt;sstream&gt;  
#include&lt;time.h&gt;  
#include&lt;utility&gt;  
#include&lt;malloc.h&gt;  
#include&lt;stdexcept&gt;  

using namespace std;  

char zhudui[25];
char kedui[25];

int n;

struct 
{
    char dui[25];
    int num;
    int vis;
    int p;
}p[2][100];

int T,NUM;
char DUI[2],P[2];

int main ()
{
    while (scanf(&quot;%s&quot;,zhudui)!=EOF)
    {
        scanf(&quot;%s&quot;,kedui);
        scanf(&quot;%d&quot;,&amp;n);

        for(int i=0;i&lt;=99;i++)
        {
            p[0][i].p = p[1][i].p = 0;
            p[1][i].vis = p[0][i].vis = 0;
        }

        for(int i=1;i&lt;=n;i++)
        {
            cin&gt;&gt;T&gt;&gt;DUI&gt;&gt;NUM&gt;&gt;P;
            if (DUI[0] == &#39;h&#39;)
            {
                strcpy (p[0][NUM].dui , zhudui);

                if (P[0]==&#39;y&#39;)
                    p[0][NUM].p+=1;
                else if (P[0] == &#39;r&#39;)
                    p[0][NUM].p+=2;

                if (p[0][NUM].p&gt;=2 &amp;&amp; p[0][NUM].vis == 0)
                {
                    cout&lt;&lt;p[0][NUM].dui&lt;&lt;&quot; &quot;&lt;&lt;NUM&lt;&lt;&quot; &quot;&lt;&lt;T&lt;&lt;endl;
                    p[0][NUM].vis = 1;
                }
            }
            else if (DUI[0] == &#39;a&#39;)
            {
                strcpy (p[1][NUM].dui , kedui);

                if (P[0]==&#39;y&#39;)
                    p[1][NUM].p+=1;
                else if (P[0] == &#39;r&#39;)
                    p[1][NUM].p+=2;

                if (p[1][NUM].p&gt;=2 &amp;&amp; p[1][NUM].vis == 0)
                {
                    cout&lt;&lt;p[1][NUM].dui&lt;&lt;&quot; &quot;&lt;&lt;NUM&lt;&lt;&quot; &quot;&lt;&lt;T&lt;&lt;endl;
                    p[1][NUM].vis = 1;
                }
            }
        }

    }
    return 0;
}
</code></pre><p>B 简单题</p>
<p>B. Vasya and Wrestling</p>
<p>time limit per test</p>
<p>2 seconds</p>
<p>memory limit per test</p>
<p>256 megabytes</p>
<p>input</p>
<p>standard input</p>
<p>output</p>
<p>standard output</p>
<p>Vasya has become interested in wrestling. In wrestling wrestlers use<br>techniques for which they are awarded points by judges. The wrestler who gets<br>the most points wins.</p>
<p>When the numbers of points of both wrestlers are equal, the wrestler whose<br>sequence of points is  lexicographically greater  , wins.</p>
<p>If the sequences of the awarded points coincide, the wrestler who performed<br>the last technique wins. Your task is to determine which wrestler won.</p>
<p>Input</p>
<p>The first line contains number  _n_ — the number of techniques that the<br>wrestlers have used (  1 ≤ _n_ ≤ 2·10  5  ).</p>
<p>The following  _n_ lines contain integer numbers  _a_ _i_ (  | _a_ _i_ | ≤ 10<br>9  ,  _a_ _i_ ≠ 0  ). If  _a_ _i_ is positive, that means that the first<br>wrestler performed the technique that was awarded with  _a_ _i_ points. And if<br>_a_ _i_ is negative, that means that the second wrestler performed the<br>technique that was awarded with  ( - _a_ _i_ )  points.</p>
<p>The techniques are given in chronological order.</p>
<p>Output</p>
<p>If the first wrestler wins, print string “  first  “, otherwise print “<br>second  “</p>
<p>Sample test(s)</p>
<p>input</p>
<pre><code>5
1
2
-3
-4
3
</code></pre><p>output</p>
<pre><code>second
</code></pre><p>input</p>
<pre><code>3
-1
-2
3
</code></pre><p>output</p>
<pre><code>first
</code></pre><p>input</p>
<pre><code>2
4
-4
</code></pre><p>output</p>
<pre><code>second
</code></pre><p>Note</p>
<p>Sequence  _x_ = _x_ 1  _x_ 2  … _x_ | _x_ |  is  lexicographically larger<br>than sequence  _y_ = _y_ 1  _y_ 2  … _y_ | _y_ |  , if either  | _x_ |   &gt;<br>| _y_ |  and  _x_ 1  = _y_ 1  , _x_ 2  = _y_ 2  , … , _x_ | _y_ |  = _y_ |<br>_y_ |  , or there is such number  _r_ (  _r_ &lt;  | _x_ |  ,  _r_ &lt;  | _y_ |  ),<br>that  _x_ 1  = _y_ 1  , _x_ 2  = _y_ 2  ,  … , _x_ _r_ = _y_ _r_ and  _x_<br>_r_ +  1  &gt; _y_ _r_ +  1  .</p>
<p>We use notation  | _a_ |  to denote length of sequence  _a_ .</p>
<pre><code>#include&lt;stdio.h&gt;  
#include&lt;iostream&gt;  
#include&lt;math.h&gt;  
#include&lt;stdlib.h&gt;  
#include&lt;ctype.h&gt;  
#include&lt;algorithm&gt;  
#include&lt;vector&gt;  
#include&lt;string.h&gt;  
#include&lt;queue&gt;  
#include&lt;stack&gt;  
#include&lt;set&gt;  
#include&lt;map&gt;  
#include&lt;sstream&gt;
#include&lt;time.h&gt;  
#include&lt;utility&gt;  
#include&lt;malloc.h&gt;  
#include&lt;stdexcept&gt;  

using namespace std;  

long long  a[200010];

int main()
{
    int n;
    while (cin &gt;&gt; n)
    {
        long long  sum = 0;
        vector&lt;int&gt; c, d;

        for (int i = 0; i &lt; n; i++) 
        {
            cin &gt;&gt; a[i];
            sum += a[i];
            if (a[i] &gt; 0)
                c.push_back(a[i]);
            else
                d.push_back(-a[i]); 
        }

        if (sum != 0) 
        {
            if (sum &gt; 0)
                cout &lt;&lt; &quot;first&quot; &lt;&lt; endl;
            else
                cout &lt;&lt; &quot;second&quot; &lt;&lt; endl;
            continue;       
        }

        int l = min(c.size(), d.size());

        bool flag = true;
        for (int i = 0; i &lt; l; i++) 
        {
            if (c[i] == d[i])
                continue;
            if (c[i] &lt; d[i]) {
                cout &lt;&lt; &quot;second&quot; &lt;&lt; endl;      
            }
            else {
                cout &lt;&lt; &quot;first&quot; &lt;&lt; endl;
            }
            flag = false;
            break;
        }
        if (!flag)
            continue;
        if (c.size() == d.size()) 
        {
            if (a[n-1] &gt; 0)
                cout &lt;&lt; &quot;first&quot; &lt;&lt; endl;
            else
                cout &lt;&lt; &quot;second&quot; &lt;&lt; endl;             
        }
        else 
        {
            if (c.size() &gt; d.size())
                cout &lt;&lt; &quot;first&quot; &lt;&lt; endl;
            else
                cout &lt;&lt; &quot;second&quot; &lt;&lt; endl;     
        }

    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round</title>
    <url>/article/csdn/Codeforces_Round_284_(Div._2).html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/42175629" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/42175629</a></p>
<p><a href="http://codeforces.com/contest/499" target="_blank" rel="noopener"> http://codeforces.com/contest/499 </a></p>
<p>A</p>
<p>水</p>
<p>A. Watching a movie</p>
<p>time limit per test</p>
<p>1 second</p>
<p>memory limit per test</p>
<p>256 megabytes</p>
<p>input</p>
<p>standard input</p>
<p>output</p>
<p>standard output</p>
<p>You have decided to watch the best moments of some movie. There are two<br>buttons on your player:</p>
<ol>
<li>Watch the current minute of the movie. By pressing this button, you watch the current minute of the movie and the player automatically proceeds to the next minute of the movie. </li>
<li>Skip exactly  _x_ minutes of the movie (  _x_ is some fixed positive integer). If the player is now at the  _t_ -th minute of the movie, then as a result of pressing this button, it proceeds to the minute  ( _t_ + _x_ )  . </li>
</ol>
<p>Initially the movie is turned on in the player on the first minute, and you<br>want to watch exactly  _n_ best moments of the movie, the  _i_ -th best moment<br>starts at the  _l_ _i_ -th minute and ends at the  _r_ _i_ -th minute (more<br>formally, the  _i_ -th best moment consists of minutes:  _l_ _i_ , _l_ _i_ +<br>1, …, _r_ _i_ ).</p>
<p>Determine, what is the minimum number of minutes of the movie you have to<br>watch if you want to watch all the best moments?</p>
<p>Input</p>
<p>The first line contains two space-separated integers  _n_ ,  _x_ (  1 ≤ _n_ ≤<br>50  ,  1 ≤ _x_ ≤ 10  5  ) — the number of the best moments of the movie and<br>the value of  _x_ for the second button.</p>
<p>The following  _n_ lines contain the descriptions of the best moments of the<br>movie, the  _i_ -th line of the description contains two integers separated by<br>a space  _l_ _i_ ,  _r_ _i_ (  1 ≤ _l_ _i_ ≤ _r_ _i_ ≤ 10  5  ).</p>
<p>It is guaranteed that for all integers  _i_ from  2  to  _n_ the following<br>condition holds:  _r_ _i_ - 1  &lt; _l_ _i_ .</p>
<p>Output</p>
<p>Output a single number — the answer to the problem.</p>
<p>Sample test(s)</p>
<p>input</p>
<pre><code>2 3
5 6
10 12
</code></pre><p>output</p>
<pre><code>6
</code></pre><p>input</p>
<pre><code>1 1
1 100000
</code></pre><p>output</p>
<pre><code>100000
</code></pre><p>Note</p>
<p>In the first sample, the player was initially standing on the first minute. As<br>the minutes from the  1  -st to the  4  -th one don’t contain interesting<br>moments, we press the second button. Now we can not press the second button<br>and skip  3  more minutes, because some of them contain interesting moments.<br>Therefore, we watch the movie from the  4  -th to the  6  -th minute, after<br>that the current time is  7  . Similarly, we again skip  3  minutes and then<br>watch from the  10  -th to the  12  -th minute of the movie. In total, we<br>watch  6  minutes of the movie.</p>
<p>In the second sample, the movie is very interesting, so you’ll have to watch<br>all  100000  minutes of the movie.</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;

using namespace std;

struct
{
    int s;
    int e;
}p[55];

int n,x;

int main()
{
    while (scanf(&quot;%d %d&quot;, &amp;n,&amp;x) != EOF)
    {
        for (int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d %d&quot;,&amp;p[i].s,&amp;p[i].e);
        }
        int pos = 1;
        int ans = 0;

        for (int i = 1; i &lt;= n; i++)
        {
            ans += ( p[i].s - pos ) % x;
            ans += p[i].e - p[i].s+1;
            pos = p[i].e + 1;
        }
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre><p>B</p>
<p>水</p>
<p>B. Lecture</p>
<p>time limit per test</p>
<p>1 second</p>
<p>memory limit per test</p>
<p>256 megabytes</p>
<p>input</p>
<p>standard input</p>
<p>output</p>
<p>standard output</p>
<p>You have a new professor of graph theory and he speaks very quickly. You come<br>up with the following plan to keep up with his lecture and make notes.</p>
<p>You know two languages, and the professor is giving the lecture in the first<br>one. The words in both languages consist of lowercase English characters, each<br>language consists of several words. For each language, all words are distinct,<br>i.e. they are spelled differently. Moreover, the words of these languages have<br>a one-to-one correspondence, that is, for each word in each language, there<br>exists exactly one word in the other language having has the same meaning.</p>
<p>You can write down every word the professor says in either the first language<br>or the second language. Of course, during the lecture you write down each word<br>in the language in which the word is shorter. In case of equal lengths of the<br>corresponding words you prefer the word of the first language.</p>
<p>You are given the text of the lecture the professor is going to read. Find out<br>how the lecture will be recorded in your notes.</p>
<p>Input</p>
<p>The first line contains two integers,  _n_ and  _m_ (  1 ≤ _n_ ≤ 3000  ,  1 ≤<br>_m_ ≤ 3000  ) — the number of words in the professor’s lecture and the number<br>of words in each of these languages.</p>
<p>The following  _m_ lines contain the words. The  _i_ -th line contains two<br>strings  _a_ _i_ ,  _b_ _i_ meaning that the word  _a_ _i_ belongs to the<br>first language, the word  _b_ _i_ belongs to the second language, and these<br>two words have the same meaning. It is guaranteed that no word occurs in both<br>languages, and each word occurs in its language exactly once.</p>
<p>The next line contains  _n_ space-separated strings  _c_ 1  , _c_ 2  , …,<br>_c_ _n_ — the text of the lecture. It is guaranteed that each of the strings<br>_c_ _i_ belongs to the set of strings  { _a_ 1  , _a_ 2  , … _a_ _m_ }  .</p>
<p>All the strings in the input are non-empty, each consisting of no more than<br>10  lowercase English letters.</p>
<p>Output</p>
<p>Output exactly  _n_ words: how you will record the lecture in your notebook.<br>Output the words of the lecture in the same order as in the input.</p>
<p>Sample test(s)</p>
<p>input</p>
<pre><code>4 3
codeforces codesecrof
contest round
letter message
codeforces contest letter contest
</code></pre><p>output</p>
<pre><code>codeforces round letter round
</code></pre><p>input</p>
<pre><code>5 3
joll wuqrd
euzf un
hbnyiyc rsoqqveh
hbnyiyc joll joll euzf joll
</code></pre><p>output</p>
<pre><code>hbnyiyc joll joll un joll






#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;map&gt;

using namespace std;

struct
{
    char s[10000];
    char e[10000];
}p[10000];

int main()
{
    int n, m;
    while (scanf(&quot;%d %d&quot;, &amp;n, &amp;m) != EOF)
    {

        for (int i = 1; i &lt;= m; i++)
        {
            scanf(&quot;%s %s&quot;,p[i].s,p[i].e);
            int l1 = strlen(p[i].s);
            int l2 = strlen(p[i].e);
            if (l1 &gt; l2)
            {
                char c[10000];
                strcpy(c,p[i].s);
                strcpy(p[i].s, p[i].e);
                strcpy(p[i].e, c);
            }
        }
        for (int i = 1; i &lt;= n; i++)
        {
            char c[10000];
            scanf(&quot;%s&quot;,c);
            for (int j = 1; j &lt;= m; j++)
            {
                if ( !strcmp(p[j].e, c) || !strcmp(p[j].s, c))
                {
                    if (i == n)
                    {
                        printf(&quot;%s\n&quot;, p[j].s);
                    }
                    else
                    {
                        printf(&quot;%s &quot;,p[j].s);
                    }
                    break;
                }
            }
        }
    }
    return 0;
}
</code></pre><p>C</p>
<p>C. Crazy Town</p>
<p>time limit per test</p>
<p>1 second</p>
<p>memory limit per test</p>
<p>256 megabytes</p>
<p>input</p>
<p>standard input</p>
<p>output</p>
<p>standard output</p>
<p>Crazy Town is a plane on which there are  _n_ infinite line roads. Each road<br>is defined by the equation  _a_ _i_ _x_ + _b_ _i_ _y_ + _c_ _i_ = 0  , where<br>_a_ _i_ and  _b_ _i_ are not both equal to the zero. The roads divide the<br>plane into connected regions, possibly of infinite space. Let’s call each such<br>region a block. We define an intersection as the point where at least two<br>different roads intersect.</p>
<p>Your home is located in one of the blocks. Today you need to get to the<br>University, also located in some block. In one step you can move from one<br>block to another, if the length of their common border is nonzero (in<br>particular, this means that if the blocks are adjacent to one intersection,<br>but have no shared nonzero boundary segment, then it are not allowed to move<br>from one to another one in one step).</p>
<p>Determine what is the minimum number of steps you have to perform to get to<br>the block containing the university. It is guaranteed that neither your home<br>nor the university is located on the road.</p>
<p>Input</p>
<p>The first line contains two space-separated integers  _x_ 1  ,  _y_ 1  (  - 10<br>6  ≤ _x_ 1  , _y_ 1  ≤ 10  6  ) — the coordinates of your home.</p>
<p>The second line contains two integers separated by a space  _x_ 2  ,  _y_ 2  (<br>- 10  6  ≤ _x_ 2  , _y_ 2  ≤ 10  6  ) — the coordinates of the university you<br>are studying at.</p>
<p>The third line contains an integer  _n_ (  1 ≤ _n_ ≤ 300  ) — the number of<br>roads in the city. The following  _n_ lines contain 3 space-separated integers<br>(  - 10  6  ≤ _a_ _i_ , _b_ _i_ , _c_ _i_ ≤ 10  6  ;  | _a_ _i_ | + | _b_ _i_<br>|  &gt; 0  ) — the coefficients of the line  _a_ _i_ _x_ + _b_ _i_ _y_ + _c_<br>_i_ = 0  , defining the  _i_ -th road. It is guaranteed that no two roads are<br>the same. In addition, neither your home nor the university lie on the road<br>(i.e. they do not belong to any one of the lines).</p>
<p>Output</p>
<p>Output the answer to the problem.</p>
<p>Sample test(s)</p>
<p>input</p>
<pre><code>1 1
-1 -1
2
0 1 0
1 0 0
</code></pre><p>output</p>
<pre><code>2
</code></pre><p>input</p>
<pre><code>1 1
-1 -1
3
1 0 0
0 1 0
1 1 -3
</code></pre><p>output</p>
<pre><code>2
</code></pre><p>Note</p>
<p>Pictures to the samples are presented below (A is the point representing the<br>house; B is the point representing the university, different blocks are filled<br>with different colors):</p>
<p><img src="http://espresso.codeforces.com/f97572ac84c56f590ec97fb132cf2185f6286790.png" alt=""><br><img src="http://espresso.codeforces.com/f78b0e061d0f773000df73a4fe26df1f6fd4ddb9.png" alt=""></p>
<p>带入两点， 判断使两点值符号不同直线有多少个，</p>
<p>不要直接判断 ，long long 不够存</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt; 
#include&lt;malloc.h&gt; 

using namespace std;

long long  sx, sy, ex, ey;
int n;

int main()
{
        cin &gt;&gt; sx &gt;&gt; sy;
        cin &gt;&gt; ex &gt;&gt; ey;
        cin &gt;&gt; n;
        int ans = 0;
        while (n--)
        {
            long long a, b, c;

            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
            int f1 = (sx * a + sy * b + c) &gt; 0 ? 1 : 0;
            int f2 = (ex * a + ey * b + c) &gt; 0 ? 1 : 0;
            if (f1 != f2)
            {
                ans++;
            }
        }
        cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Good Bye 2014 A B C</title>
    <url>/article/csdn/Good_Bye_2014_A_B_C.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/42287993" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/42287993</a></p>
<p>A. New Year Transportation</p>
<p>time limit per test</p>
<p>2 seconds</p>
<p>memory limit per test</p>
<p>256 megabytes</p>
<p>input</p>
<p>standard input</p>
<p>output</p>
<p>standard output</p>
<p>New Year is coming in Line World! In this world, there are  _n_ cells numbered<br>by integers from  1  to  _n_ , as a  1 × _n_ board. People live in cells.<br>However, it was hard to move between distinct cells, because of the difficulty<br>of escaping the cell. People wanted to meet people who live in other cells.</p>
<p>So, user tncks0121 has made a transportation system to move between these<br>cells, to celebrate the New Year. First, he thought of  _n_ - 1  positive<br>integers  _a_ 1  , _a_ 2  , …, _a_ _n_ - 1  . For every integer  _i_ where<br>1 ≤ _i_ ≤ _n_ - 1  the condition  1 ≤ _a_ _i_ ≤ _n_ - _i_ holds. Next, he<br>made  _n_ - 1  portals, numbered by integers from 1 to  _n_ - 1  . The  _i_<br>-th (  1 ≤ _i_ ≤ _n_ - 1  ) portal connects cell  _i_ and cell  ( _i_ + _a_<br>_i_ )  , and one can travel from cell  _i_ to cell  ( _i_ + _a_ _i_ )  using<br>the  _i_ -th portal. Unfortunately, one cannot use the portal backwards, which<br>means one cannot move from cell  ( _i_ + _a_ _i_ )  to cell  _i_ using the<br>_i_ -th portal. It is easy to see that because of condition  1 ≤ _a_ _i_ ≤ _n_<br>- _i_ one can’t leave the Line World using portals.</p>
<p>Currently, I am standing at cell  1  , and I want to go to cell  _t_ .<br>However, I don’t know whether it is possible to go there. Please determine<br>whether I can go to cell  _t_ by only using the construted transportation<br>system.</p>
<p>Input</p>
<p>The first line contains two space-separated integers  _n_ (  3 ≤ _n_ ≤ 3 × 10<br>4  ) and  _t_ (  2 ≤ _t_ ≤ _n_ ) — the number of cells, and the index of the<br>cell which I want to go to.</p>
<p>The second line contains  _n_ - 1  space-separated integers  _a_ 1  , _a_ 2  ,<br>…, _a_ _n_ - 1  (  1 ≤ _a_ _i_ ≤ _n_ - _i_ ). It is guaranteed, that using<br>the given transportation system, one cannot leave the Line World.</p>
<p>Output</p>
<p>If I can go to cell  _t_ using the transportation system, print “  YES  “.<br>Otherwise, print “  NO  “.</p>
<p>Sample test(s)</p>
<p>input</p>
<pre><code>8 4
1 2 1 2 1 2 1
</code></pre><p>output</p>
<pre><code>YES
</code></pre><p>input</p>
<pre><code>8 5
1 2 1 2 1 1 1
</code></pre><p>output</p>
<pre><code>NO
</code></pre><p>Note</p>
<p>In the first sample, the visited cells are:  1, 2, 4  ; so we can successfully<br>visit the cell  4  .</p>
<p>In the second sample, the possible cells to visit are:  1, 2, 4, 6, 7, 8  ; so<br>we can’t visit the cell  5  , which we want to visit.</p>
<p>A 水题</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt;
#include&lt;malloc.h&gt;

using namespace std;

int n, t;

int p[30010];

int main()
{
    while (cin &gt;&gt; n &gt;&gt; t)
    {
        for (int i = 1; i &lt;= n-1; i++)
            cin &gt;&gt; p[i];

        int pos = 1;

        for (int i = 1; i &lt;= n-1;i++)
        {
            if (pos &gt;= t)
                break;
            pos += p[pos];
        }
        if (pos == t)
            cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;
        else
            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;
    }
    return 0;
}
</code></pre><p>B. New Year Permutation</p>
<p>time limit per test</p>
<p>2 seconds</p>
<p>memory limit per test</p>
<p>256 megabytes</p>
<p>input</p>
<p>standard input</p>
<p>output</p>
<p>standard output</p>
<p>User ainta has a permutation  _p_ 1  , _p_ 2  , …, _p_ _n_ . As the New Year<br>is coming, he wants to make his permutation as pretty as possible.</p>
<p>Permutation  _a_ 1  , _a_ 2  , …, _a_ _n_ is  prettier  than permutation<br>_b_ 1  , _b_ 2  , …, _b_ _n_ , if and only if there exists an integer  _k_ (<br>1 ≤ _k_ ≤ _n_ ) where  _a_ 1  = _b_ 1  , _a_ 2  = _b_ 2  , …, _a_ _k_ - 1  =<br>_b_ _k_ - 1  and  _a_ _k_ &lt; _b_ _k_ all holds.</p>
<p>As known, permutation  _p_ is so sensitive that it could be only modified by<br>swapping two distinct elements. But swapping two elements is harder than you<br>think. Given an  _n_ × _n_ binary matrix  _A_ , user ainta can swap the values<br>of  _p_ _i_ and  _p_ _j_ (  1 ≤ _i_ , _j_ ≤ _n_ ,  _i_ ≠ _j_ ) if and only if<br>_A_ _i_ , _j_ = 1  .</p>
<p>Given the permutation  _p_ and the matrix  _A_ , user ainta wants to know the<br>prettiest permutation that he can obtain.</p>
<p>Input</p>
<p>The first line contains an integer  _n_ (  1 ≤ _n_ ≤ 300  ) — the size of the<br>permutation  _p_ .</p>
<p>The second line contains  _n_ space-separated integers  _p_ 1  , _p_ 2  , …,<br>_p_ _n_ — the permutation  _p_ that user ainta has. Each integer between  1<br>and  _n_ occurs exactly once in the given permutation.</p>
<p>Next  _n_ lines describe the matrix  _A_ . The  _i_ -th line contains  _n_<br>characters ‘  0  ‘ or ‘  1  ‘ and describes the  _i_ -th row of  _A_ . The<br>_j_ -th character of the  _i_ -th line  _A_ _i_ , _j_ is the element on the<br>intersection of the  _i_ -th row and the  _j_ -th column of A. It is<br>guaranteed that, for all integers  _i_ , _j_ where  1 ≤ _i_ &lt; _j_ ≤ _n_ ,  _A_<br>_i_ , _j_ = _A_ _j_ , _i_ holds. Also, for all integers  _i_ where  1 ≤ _i_ ≤<br>_n_ ,  _A_ _i_ , _i_ = 0  holds.</p>
<p>Output</p>
<p>In the first and only line, print  _n_ space-separated integers, describing<br>the prettiest permutation that can be obtained.</p>
<p>Sample test(s)</p>
<p>input</p>
<pre><code>7
5 2 4 3 6 7 1
0001001
0000000
0000010
1000001
0000000
0010000
1001000
</code></pre><p>output</p>
<pre><code>1 2 4 3 6 7 5
</code></pre><p>input</p>
<pre><code>5
4 2 1 5 3
00100
00011
10010
01101
01010
</code></pre><p>output</p>
<pre><code>1 2 3 4 5
</code></pre><p>Note</p>
<p>In the first sample, the swap needed to obtain the prettiest permutation is:<br>( _p_ 1  , _p_ 7  )  .</p>
<p>In the second sample, the swaps needed to obtain the prettiest permutation is<br>( _p_ 1  , _p_ 3  ), ( _p_ 4  , _p_ 5  ), ( _p_ 3  , _p_ 4  )  .</p>
<p><img src="http://espresso.codeforces.com/9b5f3d9ddb6b034c5fdb75722cfa3acc418fe643.png" alt=""></p>
<p>A  permutation  _p_ is a sequence of integers  _p_ 1  , _p_ 2  , …, _p_ _n_<br>, consisting of  _n_ distinct positive integers, each of them doesn’t exceed<br>_n_ . The  _i_ -th element of the permutation  _p_ is denoted as  _p_ _i_ .<br>The size of the permutation  _p_ is denoted as  _n_ .</p>
<p>B 弗洛伊德算法 ，并查集也可以做 ，有时间敲一下。</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;stdio.h&gt;  
#include &lt;math.h&gt;  
#include &lt;algorithm&gt;  
#include &lt;string.h&gt;  

using namespace std;

int p[305];
int b[305][305];

int n;

int main()
{
    while (cin &gt;&gt; n)
    {
        for (int i = 1; i &lt;= n; i++)
            cin &gt;&gt; p[i];
        getchar();
        for (int i = 1; i &lt;= n; i++)
        {
            for (int j = 1; j &lt;= n; j++)
            {
                char c = getchar();
                b[i][j] = (c == &#39;1&#39;);
            }
            getchar();
        }

        for (int k = 1; k &lt;= n;k++)
            for (int  i= 1; i &lt;= n; i++)
                for (int j = 1; j &lt;= n; j++)
                {
                    if (b[i][k] &amp; b[k][j])
                    {
                        b[i][j] = b[j][i] = 1;
                    }
                }

        for (int i = 1; i &lt;= n; i++)
            for (int j = i + 1; j &lt;= n; j++)
            {
                if (b[i][j] )
                {
                    if (p[i] &gt; p[j])
                    {
                        swap(p[i],p[j]);
                    }
                }
            }
        for (int i = 1; i &lt;= n; i++)
            cout &lt;&lt; p[i] &lt;&lt; &quot; &quot;;
    }
    return 0;
}
</code></pre><p>C. New Year Book Reading</p>
<p>New Year is coming, and Jaehyun decided to read many books during 2015, unlike<br>this year. He has  _n_ books numbered by integers from 1 to  _n_ . The weight<br>of the  _i_ -th (  1 ≤ _i_ ≤ _n_ ) book is  _w_ _i_ .</p>
<p>As Jaehyun’s house is not large enough to have a bookshelf, he keeps the  _n_<br>books by stacking them vertically. When he wants to read a certain book  _x_ ,<br>he follows the steps described below.</p>
<ol>
<li>He  lifts  all the books above book  _x_ . </li>
<li>He pushes book  _x_ out of the stack. </li>
<li>He puts down the lifted books without changing their order. </li>
<li>After reading book  _x_ , he puts book  _x_ on the top of the stack. </li>
</ol>
<p><img src="http://espresso.codeforces.com/16bdcfb1c75c6e60439f74c69133b7baaa9d8b13.png" alt=""></p>
<p>He decided to read books for  _m_ days. In the  _j_ -th (  1 ≤ _j_ ≤ _m_ )<br>day, he will read the book that is numbered with integer  _b_ _j_ (  1 ≤ _b_<br>_j_ ≤ _n_ ). To read the book, he has to use the process described in the<br>paragraph above. It is possible that he decides to re-read the same book<br>several times.</p>
<p>After making this plan, he realized that the total weight of books he should<br>lift  during  _m_ days would be too heavy. So, he decided to change the order<br>of the stacked books before the New Year comes, and minimize the total weight.<br>You may assume that books can be stacked in any possible order. Note that book<br>that he is going to read on certain step isn’t considered as  lifted  on that<br>step. Can you help him?</p>
<p>Input</p>
<p>The first line contains two space-separated integers  _n_ (  2 ≤ _n_ ≤ 500  )<br>and  _m_ (  1 ≤ _m_ ≤ 1000  ) — the number of books, and the number of days<br>for which Jaehyun would read books.</p>
<p>The second line contains  _n_ space-separated integers  _w_ 1  , _w_ 2  , …,<br>_w_ _n_ (  1 ≤ _w_ _i_ ≤ 100  ) — the weight of each book.</p>
<p>The third line contains  _m_ space separated integers  _b_ 1  , _b_ 2  , …,<br>_b_ _m_ (  1 ≤ _b_ _j_ ≤ _n_ ) — the order of books that he would read. Note<br>that he can read the same book more than once.</p>
<p>Output</p>
<p>Print the minimum total weight of books he should  lift  , which can be<br>achieved by rearranging the order of stacked books.</p>
<p>Sample test(s)</p>
<p>Input</p>
<pre><code>3 5
1 2 3
1 3 2 3 1
</code></pre><p>Output</p>
<pre><code>12
</code></pre><p>Note</p>
<p>Here’s a picture depicting the example. Each vertical column presents the<br>stacked books.</p>
<p><img src="http://espresso.codeforces.com/e0d6b73c8901945918e014ebece081e75529eb5c.png" alt=""></p>
<p>贪心后模拟。</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;sstream&gt;
#include&lt;time.h&gt;
#include&lt;utility&gt;
#include&lt;malloc.h&gt;

using namespace std;

int n, m;
int p[510];
int q[1010], qq[1010];
int vis[1010];

int main()
{
    while (cin &gt;&gt; n &gt;&gt; m)
    {
        for (int i = 1; i &lt;= n; i++)
        {
            cin &gt;&gt; p[i];
        }

        memset(vis,0,sizeof(vis));

        int pos = 1;
        for (int i = 1; i &lt;= m; i++)
        {
            int jjq;
            cin &gt;&gt; jjq;
            q[i] = jjq;
            if (!vis[jjq])
            {
                qq[pos++] = jjq;
                vis[jjq] = 1;
            }
        }

        long long ans = 0;
        for (int i = 1; i &lt;= m; i++)
        {
            int tt = q[i];
            for (int j = 1; j &lt;= n; j++)
            {
                if (qq[j] != tt)
                {
                    ans += p[qq[j]];
                }
                else 
                {
                    for (int k = j; k &gt; 1 ; k--)
                    {
                        qq[k] = qq[k-1];
                    }
                    qq[1] = tt;
                    break;
                }
            }
        }

        cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>acm</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>IO多路复用之select poll epoll</title>
    <url>/article/csdn/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8Bselect_poll_epoll.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/48686257" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/48686257</a></p>
<p>转自： <a href="http://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="noopener"> http://www.cnblogs.com/Anker/p/3265058.html
</a><br>基本概念</p>
<p>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：</p>
<p>（1）当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用I/O复用。</p>
<p>（2）当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</p>
<p>（3）如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。</p>
<p>（4）如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。</p>
<p>（5）如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。</p>
<p>与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。</p>
<h2><span id="select">select</span></h2><pre><code>#include &lt;sys/select.h&gt;
#include &lt;sys/time.h&gt;

int select(int maxfdp1,fd_set *readset,fd_set *writeset,fd_set *exceptset,const struct timeval *timeout)
返回值：就绪描述符的数目，超时返回0，出错返回-1
</code></pre><p>函数参数介绍如下：</p>
<p>（1）第一个参数maxfdp1指定待测试的描述字个数，它的值是待测试的最大描述字加1（因此把该参数命名为maxfdp1），描述字0、1、2…maxfdp1-1均将被测试。</p>
<p>因为文件描述符是从0开始的。</p>
<p>（2）中间的三个参数readset、writeset和exceptset指定我们要让内核测试读、写和异常条件的描述字。如果对某一个的条件不感兴趣，就可以把它设为空指针。struct<br>fd_set可以理解为一个集合，这个集合中存放的是文件描述符，可通过以下四个宏进行设置：</p>
<pre><code>      void FD_ZERO(fd_set *fdset);           //清空集合

      void FD_SET(int fd, fd_set *fdset);   //将一个给定的文件描述符加入集合之中

      void FD_CLR(int fd, fd_set *fdset);   //将一个给定的文件描述符从集合中删除

      int FD_ISSET(int fd, fd_set *fdset);   // 检查集合中指定的文件描述符是否可以读写 
</code></pre><p>（3）timeout告知内核等待所指定描述字中的任何一个就绪可花多少时间。其timeval结构用于指定这段时间的秒数和微秒数。</p>
<pre><code>     struct timeval{

               long tv_sec;   //seconds

               long tv_usec;  //microseconds

   };
</code></pre><p>这个参数有三种可能：<br>（1）永远等待下去：仅在有一个描述字准备好I/O时才返回。为此，把该参数设置为空指针NULL。<br>（2）等待一段固定时间：在有一个描述字准备好I/O时返回，但是不超过由该参数所指向的timeval结构中指定的秒数和微秒数。<br>（3）根本不等待：检查描述字后立即返回，这称为轮询。为此，该参数必须指向一个timeval结构，而且其中的定时器值必须为0。</p>
<p>原理图：<br><img src="https://img-blog.csdn.net/20160919135411278" alt="这里写图片描述"></p>
<h2><span id="poll">poll</span></h2><p>poll的机制与select类似，与select在本质上没有多大差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是poll没有最大文件描述符数量的限制。poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</p>
<pre><code># include &lt;poll.h&gt;
int poll ( struct pollfd * fds, unsigned int nfds, int timeout);

//pollfd结构体定义如下：

struct pollfd {

int fd;         /* 文件描述符 */
short events;         /* 等待的事件 */
short revents;       /* 实际发生了的事件 */
} ; 
</code></pre><h2><span id="epoll">epoll</span></h2><p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>
<pre><code>#include &lt;sys/epoll.h&gt;
int epoll_create(int size);
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
</code></pre><p>（1） int epoll_create(int size);<br>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p>
<p>（2）int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);<br>epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。第一个参数是epoll_create()的返回值，第二个参数表示动作，用三个宏来表示：<br>EPOLL_CTL_ADD：注册新的fd到epfd中；<br>EPOLL_CTL_MOD：修改已经注册的fd的监听事件；<br>EPOLL_CTL_DEL：从epfd中删除一个fd；<br>第三个参数是需要监听的fd，第四个参数是告诉内核需要监听什么事，struct epoll_event结构如下：</p>
<pre><code>struct epoll_event {
  __uint32_t events;  /* Epoll events */
  epoll_data_t data;  /* User data variable */
};
</code></pre><p>工作模式</p>
<p>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge<br>trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：</p>
<p>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</p>
<p>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>
<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<h2><span id="对比">对比</span></h2><p>select的调用过程如下所示：<br>（1）使用copy_from_user从用户空间拷贝fd_set到内核空间</p>
<p>（2）注册回调函数__pollwait</p>
<p>（3）遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll）</p>
<p>（4）以tcp_poll为例，其核心实现就是__pollwait，也就是上面注册的回调函数。</p>
<p>（5）__pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll来说，其等待队列是sk-&gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。</p>
<p>（6）poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。</p>
<p>（7）如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。</p>
<p>（8）把fd_set从内核空间拷贝到用户空间。</p>
<p>总结：</p>
<p>select的几大缺点：</p>
<p>（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</p>
<p>（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</p>
<p>（3）select支持的文件描述符数量太小了，默认是1024</p>
<p>epoll<br>epoll既然是对select和poll的改进，就应该能避免上述的三个缺点。那epoll都是怎么解决的呢？在此之前，我们先看一下epoll和select和poll的调用接口上的不同，select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。</p>
<p>对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。</p>
<p>对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。</p>
<p>对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat<br>/proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。</p>
<h2><span id="总结">总结：</span></h2><p>（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</p>
<p>（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>hdu 1134 Game of Connections 【卡特兰数+大数】</title>
    <url>/article/csdn/hdu_1134_Game_of_Connections_%E3%80%90%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0+%E5%A4%A7%E6%95%B0%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44133703" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44133703</a></p>
<h1><span id="game-of-connections">Game of Connections</span></h1><p><strong> Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K<br>(Java/Others)<br>Total Submission(s): 3327    Accepted Submission(s): 1896  
</strong>  </p>
<p>Problem Description</p>
<p>This is a small but ancient game. You are supposed to write down the numbers<br>1, 2, 3, … , 2n - 1, 2n consecutively in clockwise order on the ground to<br>form a circle, and then, to draw some straight line segments to connect them<br>into number pairs. Every number must be connected to exactly one another. And,<br>no two segments are allowed to intersect.  </p>
<p>It’s still a simple game, isn’t it? But after you’ve written down the 2n<br>numbers, can you tell me in how many different ways can you connect the<br>numbers into pairs? Life is harder, right?  </p>
<p>Input</p>
<p>Each line of the input file will be a single positive number n, except the<br>last line, which is a number -1. You may assume that 1  &lt;= n &lt;= 100.  </p>
<p>Output</p>
<p>For each n, print in a single line the number of ways to connect the 2n<br>numbers into pairs.  </p>
<p>Sample Input</p>
<p>2 3 -1</p>
<p>Sample Output</p>
<p>2 5</p>
<p>Source</p>
<p><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=Asia+2004%2C+Shanghai+%28Mainland+China%29%2C+Preliminary&amp;source=1&amp;searchmode=source" target="_blank" rel="noopener"> Asia 2004, Shanghai (Mainland China), Preliminary
</a></p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;
#include &lt;iterator&gt;

using namespace std;

#define MAXN 9999
#define MAXSIZE 1010
#define DLEN 4

class BigNum
{
private:
    int a[1000];  //可以控制大数的位数
    int len;
public:
    BigNum(){ len = 1; memset(a, 0, sizeof(a)); }  //构造函数
    BigNum(const int);     //将一个int类型的变量转化成大数
    BigNum(const char*);   //将一个字符串类型的变量转化为大数
    BigNum(const BigNum &amp;); //拷贝构造函数
    BigNum &amp;operator=(const BigNum &amp;); //重载赋值运算符，大数之间进行赋值运算
    friend istream&amp; operator&gt;&gt;(istream&amp;, BigNum&amp;); //重载输入运算符
    friend ostream&amp; operator&lt;&lt;(ostream&amp;, BigNum&amp;); //重载输出运算符

    BigNum operator+(const BigNum &amp;)const;  //重载加法运算符，两个大数之间的相加运算
    BigNum operator-(const BigNum &amp;)const;  //重载减法运算符，两个大数之间的相减运算
    BigNum operator*(const BigNum &amp;)const;  //重载乘法运算符，两个大数之间的相乘运算
    BigNum operator/(const int &amp;)const;     //重载除法运算符，大数对一个整数进行相除运算

    BigNum operator^(const int &amp;)const;     //大数的n次方运算
    int operator%(const int &amp;)const;        //大数对一个int类型的变量进行取模运算
    bool operator&gt;(const BigNum &amp;T)const;   //大数和另一个大数的大小比较
    bool operator&gt;(const int &amp;t)const;      //大数和一个int类型的变量的大小比较

    void print();        //输出大数
};
BigNum::BigNum(const int b)   //将一个int类型的变量转化为大数
{
    int c, d = b;
    len = 0;
    memset(a, 0, sizeof(a));
    while (d&gt;MAXN)
    {
        c = d - (d / (MAXN + 1))*(MAXN + 1);
        d = d / (MAXN + 1);
        a[len++] = c;
    }
    a[len++] = d;
}
BigNum::BigNum(const char *s)  //将一个字符串类型的变量转化为大数
{
    int t, k, index, L, i;
    memset(a, 0, sizeof(a));
    L = strlen(s);
    len = L / DLEN;
    if (L%DLEN)len++;
    index = 0;
    for (i = L - 1; i &gt;= 0; i -= DLEN)
    {
        t = 0;
        k = i - DLEN + 1;
        if (k&lt;0)k = 0;
        for (int j = k; j &lt;= i; j++)
            t = t * 10 + s[j] - &#39;0&#39;;
        a[index++] = t;
    }
}
BigNum::BigNum(const BigNum &amp;T) :len(T.len)  //拷贝构造函数
{
    int i;
    memset(a, 0, sizeof(a));
    for (i = 0; i&lt;len; i++)
        a[i] = T.a[i];
}
BigNum &amp; BigNum::operator=(const BigNum &amp;n)  //重载赋值运算符，大数之间赋值运算
{
    int i;
    len = n.len;
    memset(a, 0, sizeof(a));
    for (i = 0; i&lt;len; i++)
        a[i] = n.a[i];
    return *this;
}
istream&amp; operator&gt;&gt;(istream &amp;in, BigNum &amp;b)
{
    char ch[MAXSIZE * 4];
    int i = -1;
    in &gt;&gt; ch;
    int L = strlen(ch);
    int count = 0, sum = 0;
    for (i = L - 1; i &gt;= 0;)
    {
        sum = 0;
        int t = 1;
        for (int j = 0; j&lt;4 &amp;&amp; i &gt;= 0; j++, i--, t *= 10)
        {
            sum += (ch[i] - &#39;0&#39;)*t;
        }
        b.a[count] = sum;
        count++;
    }
    b.len = count++;
    return in;
}
ostream&amp; operator&lt;&lt;(ostream&amp; out, BigNum&amp; b)  //重载输出运算符
{
    int i;
    cout &lt;&lt; b.a[b.len - 1];
    for (i = b.len - 2; i &gt;= 0; i--)
    {
        printf(&quot;%04d&quot;, b.a[i]);
    }
    return out;
}
BigNum BigNum::operator+(const BigNum &amp;T)const   //两个大数之间的相加运算
{
    BigNum t(*this);
    int i, big;
    big = T.len&gt;len ? T.len : len;
    for (i = 0; i&lt;big; i++)
    {
        t.a[i] += T.a[i];
        if (t.a[i]&gt;MAXN)
        {
            t.a[i + 1]++;
            t.a[i] -= MAXN + 1;
        }
    }
    if (t.a[big] != 0)
        t.len = big + 1;
    else t.len = big;
    return t;
}
BigNum BigNum::operator-(const BigNum &amp;T)const  //两个大数之间的相减运算
{
    int i, j, big;
    bool flag;
    BigNum t1, t2;
    if (*this&gt;T)
    {
        t1 = *this;
        t2 = T;
        flag = 0;
    }
    else
    {
        t1 = T;
        t2 = *this;
        flag = 1;
    }
    big = t1.len;
    for (i = 0; i&lt;big; i++)
    {
        if (t1.a[i]&lt;t2.a[i])
        {
            j = i + 1;
            while (t1.a[j] == 0)
                j++;
            t1.a[j--]--;
            while (j&gt;i)
                t1.a[j--] += MAXN;
            t1.a[i] += MAXN + 1 - t2.a[i];
        }
        else t1.a[i] -= t2.a[i];
    }
    t1.len = big;
    while (t1.a[t1.len - 1] == 0 &amp;&amp; t1.len&gt;1)
    {
        t1.len--;
        big--;
    }
    if (flag)
        t1.a[big - 1] = 0 - t1.a[big - 1];
    return t1;
}
BigNum BigNum::operator*(const BigNum &amp;T)const  //两个大数之间的相乘
{
    BigNum ret;
    int i, j, up;
    int temp, temp1;
    for (i = 0; i&lt;len; i++)
    {
        up = 0;
        for (j = 0; j&lt;T.len; j++)
        {
            temp = a[i] * T.a[j] + ret.a[i + j] + up;
            if (temp&gt;MAXN)
            {
                temp1 = temp - temp / (MAXN + 1)*(MAXN + 1);
                up = temp / (MAXN + 1);
                ret.a[i + j] = temp1;
            }
            else
            {
                up = 0;
                ret.a[i + j] = temp;
            }
        }
        if (up != 0)
            ret.a[i + j] = up;
    }
    ret.len = i + j;
    while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len&gt;1)ret.len--;
    return ret;
}
BigNum BigNum::operator/(const int &amp;b)const  //大数对一个整数进行相除运算
{
    BigNum ret;
    int i, down = 0;
    for (i = len - 1; i &gt;= 0; i--)
    {
        ret.a[i] = (a[i] + down*(MAXN + 1)) / b;
        down = a[i] + down*(MAXN + 1) - ret.a[i] * b;
    }
    ret.len = len;
    while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len&gt;1)
        ret.len--;
    return ret;
}
int BigNum::operator%(const int &amp;b)const   //大数对一个 int类型的变量进行取模
{
    int i, d = 0;
    for (i = len - 1; i &gt;= 0; i--)
        d = ((d*(MAXN + 1)) % b + a[i]) % b;
    return d;
}
BigNum BigNum::operator^(const int &amp;n)const  //大数的n次方运算
{
    BigNum t, ret(1);
    int i;
    if (n&lt;0)exit(-1);
    if (n == 0)return 1;
    if (n == 1)return *this;
    int m = n;
    while (m&gt;1)
    {
        t = *this;
        for (i = 1; (i &lt;&lt; 1) &lt;= m; i &lt;&lt;= 1)
            t = t*t;
        m -= i;
        ret = ret*t;
        if (m == 1)ret = ret*(*this);
    }
    return ret;
}
bool BigNum::operator&gt;(const BigNum &amp;T)const    //大数和另一个大数的大小比较
{
    int ln;
    if (len&gt;T.len)return true;
    else if (len == T.len)
    {
        ln = len - 1;
        while (a[ln] == T.a[ln] &amp;&amp; ln &gt;= 0)
            ln--;
        if (ln &gt;= 0 &amp;&amp; a[ln]&gt;T.a[ln])
            return true;
        else
            return false;
    }
    else
        return false;
}
bool BigNum::operator&gt;(const int &amp;t)const  //大数和一个int类型的变量的大小比较
{
    BigNum b(t);
    return *this&gt;b;
}
void BigNum::print()   //输出大数
{
    int i;
    printf(&quot;%d&quot;, a[len - 1]);
    for (i = len - 2; i &gt;= 0; i--)
        printf(&quot;%04d&quot;, a[i]);
    printf(&quot;\n&quot;);
}

BigNum p[3010];


int main()
{
    int i, n;
    p[0] = 1;
    for (int i = 1; i&lt;= 100; i++)
        p[i] = p[i - 1] * (4 * i - 2) / (i + 1);

    while (cin&gt;&gt;n &amp;&amp; n!=-1)
    {
        p[n].print();
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>最强DE 战斗力 【大数】</title>
    <url>/article/csdn/%E6%9C%80%E5%BC%BADE_%E6%88%98%E6%96%97%E5%8A%9B_%E3%80%90%E5%A4%A7%E6%95%B0%E3%80%91.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44133613" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44133613</a></p>
<h2><span id="最强de-战斗力">最强DE 战斗力</span></h2><p>Time Limit:  1 Sec  Memory Limit:  128 MB<br>Submit:  86  Solved:  13<br>[ <a href="http://www.homeforaoge.com/submitpage.php?cid=1000&amp;pid=1&amp;langmask=0" target="_blank" rel="noopener"> Submit
</a> ][ <a href="http://www.homeforaoge.com/problemstatus.php?id=1003" target="_blank" rel="noopener"><br>Status </a> ][ <a href="http://www.homeforaoge.com/bbs.php?pid=1003&amp;cid=1000" target="_blank" rel="noopener"> Web Board
</a> ]</p>
<h2><span id="description">Description</span></h2><p>春秋战国时期，赵国地大物博，资源非常丰富，人民安居乐业。但许多国家对它虎视眈眈，准备联合起来对赵国发起一场战争。</p>
<p>显然，面对多个国家的部队去作战，赵国的兵力明显处于劣势。战斗力是决定战争成败的关键因素，一般来说，一支部队的战斗力与部队的兵力成正比。但当把一支部队分成若干个作战队伍时，这个部队的战斗力就会大大的增强。</p>
<p>一支部队的战斗力是可以通过以下两个规则计算出来的：</p>
<p>1.若一支作战队伍的兵力为N，则这支作战队伍的战斗力为N；</p>
<p>2.若将一支部队分为若干个作战队伍，则这支部队的总战斗力为这些作战队伍战斗力的乘积。</p>
<p>比如：一支部队的兵力为5时的战斗力分析如下：</p>
<p>情况</p>
<p>|</p>
<p>作战安排</p>
<p>|</p>
<p>总的战斗力  </p>
<p>—|—|—  </p>
<p>1</p>
<p>|</p>
<p>1，1，1，1，1（共分为5个作战队伍）</p>
<p>|</p>
<p>1<em>1</em>1<em>1</em>1=1  </p>
<p>2</p>
<p>|</p>
<p>1，1，1，2   （共分为4个作战队伍）</p>
<p>|</p>
<p>1<em>1</em>1*2=2  </p>
<p>3</p>
<p>|</p>
<p>1，2，2     （共分为3个作战队伍）</p>
<p>|</p>
<p>1<em>2</em>2=4  </p>
<p>4</p>
<p>|</p>
<p>1，1，3     （共分为3个作战队伍）</p>
<p>|</p>
<p>1<em>1</em>3=3  </p>
<p>5</p>
<p>|</p>
<p><strong>2，3</strong> （共分为2个作战队伍）</p>
<p>|</p>
<p><strong>2*3=6</strong>  </p>
<p>6</p>
<p>|</p>
<p>1，4        （共分为2个作战队伍）</p>
<p>|</p>
<p>1*4=4  </p>
<p>7</p>
<p>|</p>
<p>5           （共分为1个作战队伍）</p>
<p>|</p>
<p>5=5  </p>
<p>显然，将部队分为2个作战队伍（一个为2，另一个为3），总的战斗力达到最大！</p>
<h2><span id="input">Input</span></h2><p>第一行： <strong>N</strong> 表示有N组测试数据。  (2 &lt;=N&lt;=5)</p>
<p>接下来有N行，每行有一个整数Ti 代表赵国部队的兵力。 （1 &lt;= Ti &lt;= 1000）i=1，…N</p>
<h2><span id="output">Output</span></h2><p>对于每一行测试数据，输出占一行，仅一个整数S， 表示作战安排的最大战斗力。</p>
<h2><span id="sample-input">Sample Input</span></h2><pre><code>2


5


4
</code></pre><h2><span id="sample-output">Sample Output</span></h2><pre><code>6


4
</code></pre><h2><span id="hint">HINT</span></h2><pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;
#include &lt;iterator&gt;

using namespace std;

#define MAXN 9999
#define MAXSIZE 1010
#define DLEN 4

class BigNum
{
private:
    int a[1000];  //可以控制大数的位数
    int len;
public:
    BigNum(){ len = 1; memset(a, 0, sizeof(a)); }  //构造函数
    BigNum(const int);     //将一个int类型的变量转化成大数
    BigNum(const char*);   //将一个字符串类型的变量转化为大数
    BigNum(const BigNum &amp;); //拷贝构造函数
    BigNum &amp;operator=(const BigNum &amp;); //重载赋值运算符，大数之间进行赋值运算
    friend istream&amp; operator&gt;&gt;(istream&amp;, BigNum&amp;); //重载输入运算符
    friend ostream&amp; operator&lt;&lt;(ostream&amp;, BigNum&amp;); //重载输出运算符

    BigNum operator+(const BigNum &amp;)const;  //重载加法运算符，两个大数之间的相加运算
    BigNum operator-(const BigNum &amp;)const;  //重载减法运算符，两个大数之间的相减运算
    BigNum operator*(const BigNum &amp;)const;  //重载乘法运算符，两个大数之间的相乘运算
    BigNum operator/(const int &amp;)const;     //重载除法运算符，大数对一个整数进行相除运算

    BigNum operator^(const int &amp;)const;     //大数的n次方运算
    int operator%(const int &amp;)const;        //大数对一个int类型的变量进行取模运算
    bool operator&gt;(const BigNum &amp;T)const;   //大数和另一个大数的大小比较
    bool operator&gt;(const int &amp;t)const;      //大数和一个int类型的变量的大小比较

    void print();        //输出大数
};
BigNum::BigNum(const int b)   //将一个int类型的变量转化为大数
{
    int c, d = b;
    len = 0;
    memset(a, 0, sizeof(a));
    while (d&gt;MAXN)
    {
        c = d - (d / (MAXN + 1))*(MAXN + 1);
        d = d / (MAXN + 1);
        a[len++] = c;
    }
    a[len++] = d;
}
BigNum::BigNum(const char *s)  //将一个字符串类型的变量转化为大数
{
    int t, k, index, L, i;
    memset(a, 0, sizeof(a));
    L = strlen(s);
    len = L / DLEN;
    if (L%DLEN)len++;
    index = 0;
    for (i = L - 1; i &gt;= 0; i -= DLEN)
    {
        t = 0;
        k = i - DLEN + 1;
        if (k&lt;0)k = 0;
        for (int j = k; j &lt;= i; j++)
            t = t * 10 + s[j] - &#39;0&#39;;
        a[index++] = t;
    }
}
BigNum::BigNum(const BigNum &amp;T) :len(T.len)  //拷贝构造函数
{
    int i;
    memset(a, 0, sizeof(a));
    for (i = 0; i&lt;len; i++)
        a[i] = T.a[i];
}
BigNum &amp; BigNum::operator=(const BigNum &amp;n)  //重载赋值运算符，大数之间赋值运算
{
    int i;
    len = n.len;
    memset(a, 0, sizeof(a));
    for (i = 0; i&lt;len; i++)
        a[i] = n.a[i];
    return *this;
}
istream&amp; operator&gt;&gt;(istream &amp;in, BigNum &amp;b)
{
    char ch[MAXSIZE * 4];
    int i = -1;
    in &gt;&gt; ch;
    int L = strlen(ch);
    int count = 0, sum = 0;
    for (i = L - 1; i &gt;= 0;)
    {
        sum = 0;
        int t = 1;
        for (int j = 0; j&lt;4 &amp;&amp; i &gt;= 0; j++, i--, t *= 10)
        {
            sum += (ch[i] - &#39;0&#39;)*t;
        }
        b.a[count] = sum;
        count++;
    }
    b.len = count++;
    return in;
}
ostream&amp; operator&lt;&lt;(ostream&amp; out, BigNum&amp; b)  //重载输出运算符
{
    int i;
    cout &lt;&lt; b.a[b.len - 1];
    for (i = b.len - 2; i &gt;= 0; i--)
    {
        printf(&quot;%04d&quot;, b.a[i]);
    }
    return out;
}
BigNum BigNum::operator+(const BigNum &amp;T)const   //两个大数之间的相加运算
{
    BigNum t(*this);
    int i, big;
    big = T.len&gt;len ? T.len : len;
    for (i = 0; i&lt;big; i++)
    {
        t.a[i] += T.a[i];
        if (t.a[i]&gt;MAXN)
        {
            t.a[i + 1]++;
            t.a[i] -= MAXN + 1;
        }
    }
    if (t.a[big] != 0)
        t.len = big + 1;
    else t.len = big;
    return t;
}
BigNum BigNum::operator-(const BigNum &amp;T)const  //两个大数之间的相减运算
{
    int i, j, big;
    bool flag;
    BigNum t1, t2;
    if (*this&gt;T)
    {
        t1 = *this;
        t2 = T;
        flag = 0;
    }
    else
    {
        t1 = T;
        t2 = *this;
        flag = 1;
    }
    big = t1.len;
    for (i = 0; i&lt;big; i++)
    {
        if (t1.a[i]&lt;t2.a[i])
        {
            j = i + 1;
            while (t1.a[j] == 0)
                j++;
            t1.a[j--]--;
            while (j&gt;i)
                t1.a[j--] += MAXN;
            t1.a[i] += MAXN + 1 - t2.a[i];
        }
        else t1.a[i] -= t2.a[i];
    }
    t1.len = big;
    while (t1.a[t1.len - 1] == 0 &amp;&amp; t1.len&gt;1)
    {
        t1.len--;
        big--;
    }
    if (flag)
        t1.a[big - 1] = 0 - t1.a[big - 1];
    return t1;
}
BigNum BigNum::operator*(const BigNum &amp;T)const  //两个大数之间的相乘
{
    BigNum ret;
    int i, j, up;
    int temp, temp1;
    for (i = 0; i&lt;len; i++)
    {
        up = 0;
        for (j = 0; j&lt;T.len; j++)
        {
            temp = a[i] * T.a[j] + ret.a[i + j] + up;
            if (temp&gt;MAXN)
            {
                temp1 = temp - temp / (MAXN + 1)*(MAXN + 1);
                up = temp / (MAXN + 1);
                ret.a[i + j] = temp1;
            }
            else
            {
                up = 0;
                ret.a[i + j] = temp;
            }
        }
        if (up != 0)
            ret.a[i + j] = up;
    }
    ret.len = i + j;
    while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len&gt;1)ret.len--;
    return ret;
}
BigNum BigNum::operator/(const int &amp;b)const  //大数对一个整数进行相除运算
{
    BigNum ret;
    int i, down = 0;
    for (i = len - 1; i &gt;= 0; i--)
    {
        ret.a[i] = (a[i] + down*(MAXN + 1)) / b;
        down = a[i] + down*(MAXN + 1) - ret.a[i] * b;
    }
    ret.len = len;
    while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len&gt;1)
        ret.len--;
    return ret;
}
int BigNum::operator%(const int &amp;b)const   //大数对一个 int类型的变量进行取模
{
    int i, d = 0;
    for (i = len - 1; i &gt;= 0; i--)
        d = ((d*(MAXN + 1)) % b + a[i]) % b;
    return d;
}
BigNum BigNum::operator^(const int &amp;n)const  //大数的n次方运算
{
    BigNum t, ret(1);
    int i;
    if (n&lt;0)exit(-1);
    if (n == 0)return 1;
    if (n == 1)return *this;
    int m = n;
    while (m&gt;1)
    {
        t = *this;
        for (i = 1; (i &lt;&lt; 1) &lt;= m; i &lt;&lt;= 1)
            t = t*t;
        m -= i;
        ret = ret*t;
        if (m == 1)ret = ret*(*this);
    }
    return ret;
}
bool BigNum::operator&gt;(const BigNum &amp;T)const    //大数和另一个大数的大小比较
{
    int ln;
    if (len&gt;T.len)return true;
    else if (len == T.len)
    {
        ln = len - 1;
        while (a[ln] == T.a[ln] &amp;&amp; ln &gt;= 0)
            ln--;
        if (ln &gt;= 0 &amp;&amp; a[ln]&gt;T.a[ln])
            return true;
        else
            return false;
    }
    else
        return false;
}
bool BigNum::operator&gt;(const int &amp;t)const  //大数和一个int类型的变量的大小比较
{
    BigNum b(t);
    return *this&gt;b;
}
void BigNum::print()   //输出大数
{
    int i;
    printf(&quot;%d&quot;, a[len - 1]);
    for (i = len - 2; i &gt;= 0; i--)
        printf(&quot;%04d&quot;, a[i]);
    printf(&quot;\n&quot;);
}

int a[3010];
BigNum p[3010];


int main(void)
{
    int i, n;

    cin &gt;&gt; n;
    while (n--)
    {
        cin &gt;&gt; i;
        if (i == 1)
            cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;
        else
        {
            BigNum bign(1);
            while (i)
            {

                if (i == 1)
                {
                    bign = (bign / 3) * 4;
                    i -= 1;
                }
                else if (i == 2)
                {
                    bign = bign * 2;
                    i -= 2;
                }
                else
                {
                    bign = bign * 3;
                    i -= 3;
                }

            }
            bign.print();
        }
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>源代码到可执行文件过程</title>
    <url>/article/csdn/%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E8%BF%87%E7%A8%8B.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40357943" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40357943</a></p>
<p>转自：<a href="http://www.cnblogs.com/shihaochangeworld/p/5657224.html" target="_blank" rel="noopener">http://www.cnblogs.com/shihaochangeworld/p/5657224.html</a>  </p>
<p>编译，编译程序读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码，再由汇编程序转换为机器语言，并且按照操作系统对可执行文件格式的要求链接生成可执行程序。<br>源代码－－&gt;预处理－－&gt;编译－－&gt;优化－－&gt;汇编－－&gt;链接–&gt;可执行文件<br>Source–（编译）–&gt; Assembly–（汇编）–&gt;Obj–（链接）–&gt;PE/ELF<br>1.编译预处理<br>读取c源程序，对其中的伪指令（以#开头的指令）和特殊符号进行处理<br>[析] 伪指令主要包括以下四个方面<br>（1）宏定义指令，如#define Name<br>TokenString,#undef等。对于前一个伪指令，预编译所要做的是将程序中的所有Name用TokenString替换，但作为字符串常量的Name则不被替换。对于后者，则将取消对某个宏的定义，使以后该串的出现不再被替换。<br>（2）条件编译指令，如#ifdef,#ifndef,#else,#elif,#endif,等等。这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预编译程序将根据有关的文件，将那些不必要的代码过滤掉<br>（3）头文件包含指令，如#include “FileName”或者#include</p>
<p><filename>等。在头文件中一般用伪指令#define定义了大量的宏（最常见的是字符常量），同时包含有各种外部符号的声明。采用头文件的目的主要是为了使某些定义可以供多个不同的C源程序使用。因为在需要用到这些定义的C源程序中，只需加上一条#include语句即可，而不必再在此文件中将这些定义重复一遍。预编译程序将把头文件中的定义统统都加入到它所产生的输出文件中，以供编译程序对之进行处理。<br>包含到c源程序中的头文件可以是系统提供的，这些头文件一般被放在/usr/include目录下。在程序中#include它们要使用尖括号（&lt;&gt;）。另外开发人员也可以定义自己的头文件，这些文件一般与c源程序放在同一目录下，此时在#include中要用双引号（””）。<br>（4）特殊符号，预编译程序可以识别一些特殊的符号。例如在源程序中出现的LINE标识将被解释为当前行号（十进制数），FILE则被解释为当前被编译的C源程序的名称。预编译程序对于在源程序中出现的这些串将用合适的值进行替换。  </filename></p>
<p>预编译程序所完成的基本上是对源程序的“替代”工作。经过此种替代，生成一个没有宏定义、没有条件编译指令、没有特殊符号的输出文件。这个文件的含义同没有经过预处理的源文件是相同的，但内容有所不同。下一步，此输出文件将作为编译程序的输出而被翻译成为机器指令。<br>2.编译阶段<br>经过预编译得到的输出文件中，将只有常量。如数字、字符串、变量的定义，以及C语言的关键字，如main,if,else,for,while,{,},+,-,*,\，等等。预编译程序所要作得工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。<br>3.优化阶段<br>优化处理是编译系统中一项比较艰深的技术。它涉及到的问题不仅同编译技术本身有关，而且同机器的硬件环境也有很大的关系。优化一部分是对中间代码的优化。这种优化不依赖于具体的计算机。另一种优化则主要针对目标代码的生成而进行的。上图中，我们将优化阶段放在编译程序的后面，这是一种比较笼统的表示。<br>对于前一种优化，主要的工作是删除公共表达式、循环优化（代码外提、强度削弱、变换循环控制条件、已知量的合并等）、复写传播，以及无用赋值的删除，等等。<br>后一种类型的优化同机器的硬件结构密切相关，最主要的是考虑是如何充分利用机器的各个硬件寄存器存放的有关变量的值，以减少对于内存的访问次数。另外，如何根据机器硬件执行指令的特点（如流水线、RISC、CISC、VLIW等）而对指令进行一些调整使目标代码比较短，执行的效率比较高，也是一个重要的研究课题。<br>经过优化得到的汇编代码必须经过汇编程序的汇编转换成相应的机器指令，方可能被机器执行。<br>4.汇编过程<br>汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程。对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件。目标文件中所存放的也就是与源程序等效的目标的机器语言代码。<br>目标文件由段组成。通常一个目标文件中至少有两个段：<br>代码段 　该段中所包含的主要是程序的指令。该段一般是可读和可执行的，但一般却不可写。<br>数据段　 主要存放程序中要用到的各种全局变量或静态的数据。一般数据段都是可读，可写，可执行的。<br>UNIX环境下主要有三种类型的目标文件：<br>（1）可重定位文件 　其中包含有适合于其它目标文件链接来创建一个可执行的或者共享的目标文件的代码和数据。<br>（2）共享的目标文件<br>这种文件存放了适合于在两种上下文里链接的代码和数据。第一种事链接程序可把它与其它可重定位文件及共享的目标文件一起处理来创建另一个目标文件；第二种是动态链接程序将它与另一个可执行文件及其它的共享目标文件结合到一起，创建一个进程映象。<br>（3）可执行文件 　　它包含了一个可以被操作系统创建一个进程来执行之的文件。<br>汇编程序生成的实际上是第一种类型的目标文件。对于后两种还需要其他的一些处理方能得到，这个就是链接程序的工作了。<br>5.链接程序<br>由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或者函数调用等）；在程序中可能调用了某个库文件中的函数，等等。所有的这些问题，都需要经链接程序的处理方能得以解决。<br>链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够诶操作系统装入执行的统一整体。<br>根据开发人员指定的同库函数的链接方式的不同，链接处理可分为两种：<br>（1）静态链接<br>在这种链接方式下，函数的代码将从其所在地静态链接库中被拷贝到最终的可执行程序中。这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码。(个人备注：静态链接将链接库的代码复制到可执行程序中，使得可执行程序体积变大)<br>（2）动态链接<br>在此种方式下，函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。链接程序此时所作的只是在最终的可执行程序中记录下共享对象的名字以及其它少量的登记信息。在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码。（个人备注：动态链接指的是需要链接的代码放到一个共享对象中，共享对象映射到进程虚地址空间，链接程序记录可执行程序将来需要用的代码信息，根据这些信息迅速定位相应的代码片段。）<br>对于可执行文件中的函数调用，可分别采用动态链接或静态链接的方法。使用动态链接能够使最终的可执行文件比较短小，并且当共享对象被多个进程使用时能节约一些内存，因为在内存中只需要保存一份此共享对象的代码。但并不是使用动态链接就一定比使用静态链接要优越。在某些情况下动态链接可能带来一些性能上损害。<br>经过上述五个过程，C源程序就最终被转换成可执行文件了。缺省情况下这个可执行文件的名字被命名为a.out。</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>背包专题</title>
    <url>/article/csdn/%E8%83%8C%E5%8C%85%E4%B8%93%E9%A2%98.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/40592727" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/40592727</a></p>
<p>AC <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2602" target="_blank" rel="noopener"> Hdu 2602 Bone Collector
</a> 非常常规的  01<br>背包问题，用一维和二维数组都可以做，一维快相当多。</p>
<pre><code>#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

using namespace std;

int max(int a,int b)
{
    if(a&gt;b)
        return a;
    else
        return b;
}

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    int a[1000],c[1000],dp[10000];
    while(t--)
    {
        int n,v;
        scanf(&quot;%d%d&quot;,&amp;n,&amp;v);

        for(int i=0;i&lt;n;i++)
            scanf(&quot;%d&quot;,&amp;a[i]);
        for(int i=0;i&lt;n;i++)
            scanf(&quot;%d&quot;,&amp;c[i]);

            memset(dp,0,sizeof(dp));

            for(int i=0;i&lt;n;i++)
            for(int j=v;j&gt;=0;j--)
            {
                if(j-c[i]&gt;=0)
                    dp[j]=max(dp[j],dp[j-c[i]]+a[i]);
            }
            printf(&quot;%d\n&quot;,dp[v]);
    }
}
</code></pre><p>AC <a href="http://poj.org/problem?id=3624" target="_blank" rel="noopener"> Poj 3624 Charm Bracelet  </a> 赤裸裸的  01<br>背包问题。</p>
<pre><code>#include &quot;iostream&quot;
#include &quot;math.h&quot;

using namespace std;

int max(int a,int b)
{
    if(a&gt;b)
        return a;
    else
        return b;
}

int main()
{
    int n,m;
    int a[40000],b[40000];
    int dp[40000];
    while( cin&gt;&gt;n&gt;&gt;m )
    {
        for(int i=0;i&lt;n;i++)
            cin&gt;&gt;a[i]&gt;&gt;b[i];

memset(dp,0,sizeof(dp));
            for(int i=0;i&lt;n;i++)
                for(int j=m;j&gt;=0;j--)
            {
                if(j-a[i]&gt;=0)
                    dp[j]=max(dp[j],dp[j-a[i]]+b[i]);
            }
            cout&lt;&lt;dp[m]&lt;&lt;endl;
    }
}
</code></pre><p>AC <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2546" target="_blank" rel="noopener"> Hdu 2546  饭卡  </a> n<br>种菜选若干种使剩下的钱最少，背包容量是开始时的钱，物品体积是菜的价格，状态转移时记录答案。  </p>
<pre><code>#include &quot;iostream&quot;
#include &quot;cstdlib&quot;
#include &quot;cstring&quot;
#include &quot;cmath&quot;
#include &quot;algorithm&quot;
using namespace std;

int max(int a,int b)
{
    if(a&gt;b)
        return a;
    else 
        return b;
}
int main()
{
    int i,j,m,n,a[2000],d[2000];
    while( scanf(&quot;%d&quot;,&amp;n)!=EOF &amp;&amp; n )
    {
        for(i=0;i&lt;n;i++)
            scanf(&quot;%d&quot;,&amp;a[i]);
            scanf(&quot;%d&quot;,&amp;m);

        sort(a,a+n);
        memset(d,0,sizeof(d));

        if(m&gt;=5)
        {
            {
            for(i=0;i&lt;n-1;i++)
                for(j=m-5;j&gt;=a[i];j--)
                {
                    d[j]=max(d[j],d[j-a[i]]+a[i]);      
                }
            }
            printf(&quot;%d\n&quot;,m-d[m-5]-a[n-1]);
        }
        else 
            printf(&quot;%d\n&quot;,m);
    }
}

//先计算出m-5块钱在n-1个物品内最多买多少钱的菜，然后再减去最大价格的菜
</code></pre><p>AC <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2955" target="_blank" rel="noopener"> Hdu 2955 Robberies  </a> （推荐<br>)  抢劫方案最优问题，需要一个简单地转换，我们求的是不被抓的概率而非被抓的概率，各个银行的储蓄总和为背包容量，体积为单个银行 的储蓄，价值为不被抓概率。</p>
<pre><code>#include &quot;iostream&quot;
#include &quot;cstdlib&quot;
#include &quot;cstring&quot;
#include &quot;cmath&quot;
#include &quot;algorithm&quot;

using namespace std;

int max(int a,int b)
{
    if(a&gt;b)
        return a;
    else
        return b;
}

double p;
int n,t,sum;
int m[1000];
double q[1000];
double dp[10000];
int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    while(t--)
    {

        int ss;
        sum=0;
        scanf(&quot;%lf %d&quot;,&amp;p,&amp;n);
        for(int i=0;i&lt;n;i++)
        {
            scanf(&quot;%d%lf&quot;,&amp;m[i],&amp;q[i]);
            q[i]=1.0-q[i];
            sum+=m[i];
        }


        memset(dp,0,sizeof(dp));
        dp[0]=1;


        for(int i=0;i&lt;n;i++)
            for(int j=sum;j&gt;=0;j--)
            {
                if(j-m[i]&gt;=0)
                dp[j]=max(dp[j],dp[j-m[i]]*q[i]);
            }

        for(int i=0;i&lt;=sum;i++)
        {
            int big=-1;
            if( dp[i]&gt;big &amp;&amp; ( dp[i]&gt;=(1-p)) )
            {
                big=dp[i];
                ss=i;
            }
        }

        printf(&quot;%d\n&quot;,ss);



    }


}
</code></pre><p>AC <a href="http://poj.org/problem?id=2184" target="_blank" rel="noopener"> Poj 2184 Cow Exhibition  </a> （推荐  )  变形的<br>01  背包，其实问题的本质是保证智商和幽默感和不为负数情况下的最大和。智商属性体积，幽默感属性为价值，问题转换为求体积大等于  0  时的体积、价值总和。  </p>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;stdlib.h&quot;
#include &quot;algorithm&quot;
#include &quot;iostream&quot;
#include &quot;math.h&quot;
#include &quot;string.h&quot;

using namespace std;

#define max(a,b)    ((a)&gt;(b)?(a):(b))  

int a[110],b[110];
int dp[200000];

int main()
{
    int n;
    int t=10000;

    while(scanf(&quot;%d&quot;,&amp;n)!=EOF )
    {
        for(int i=0;i&lt;n;i++)
            scanf(&quot;%d%d&quot;,&amp;a[i],&amp;b[i]);

        memset(dp,-10000,sizeof(dp));

        dp[t]=0;

        for(int i=0;i&lt;n;i++)
        {
            if(a[i]&lt;0 &amp;&amp; b[i]&lt;0 )
                continue ;
            else if(a[i]&gt;0)
            {
                for(int j=199999;j&gt;=a[i];j--)
                dp[j]=max(dp[j-a[i]]+b[i],dp[j]);
            }
            else
            {
                for(int j=0;j&lt;200000+a[i];j++)
                dp[j]=max(dp[j-a[i]]+b[i],dp[j]);
            }
        }

        int ans=0;

        for(int i=t;i&lt;200000;i++)
            if(dp[i]&gt;0)
            ans=max(ans,i-t+dp[i]);

        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
</code></pre><p>AC  <a href="http://acm.hdu.edu.cn/showproblem.php?pid=3466" target="_blank" rel="noopener"> Hdu 3466 Proud Merchants
</a> 与顺序有关的  01  背包，先按  q-p<br>排序再来处理，难想容易敲。</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

using namespace std;

int dp[100000];

int max (int a,int b)
{
    if (a&gt;b )
        return a ;
    else 
        return b;
}

struct Ac
{
    int p;
    int q;
    int v;
}ac[1000000];

bool cmp(Ac ss ,Ac sss)
{
    return ( ss.q-ss.p )  &lt; ( sss.q- sss.p )  ; 
}


int main()
{
    int n,m;
    int t,s ,k;
    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF )
    {
        for(int i=0;i&lt;n;i++)
            scanf(&quot;%d%d%d&quot;,&amp;ac[i].p,&amp;ac[i].q,&amp;ac[i].v);

        memset(dp,0,sizeof(dp));

        sort(ac,ac+n,cmp);

            for (int i=0;i&lt;n;i++)
                for (int j=m;j&gt;=0;j--)
                {
                    if ( j-ac[i].q&gt;=0 ) 
                    dp[j]=max (dp[j],dp[j-ac[i].p]+ac[i].v); 
                }

                printf(&quot;%d\n&quot;,dp[m]);
    }
    return 0;
}
</code></pre><p>AC <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1114" target="_blank" rel="noopener"> Hdu 1114 Piggy-Bank  </a><br>简单多重背包，但当成  01  背包来暴力也完全没有问题</p>
<pre><code>#include &quot;iostream&quot;
#include &quot;cstdlib&quot;
#include &quot;cstring&quot;
#include &quot;cmath&quot;
#include &quot;algorithm&quot;

using namespace std;

int min(int a,int b)
{
    if(a&gt;b)
        return b;
    else 
        return a;
}

int main()
{
    int t,ok,k;
    int e,f,n,s;
    int p[1000],w[1000],dp[10000];
    scanf(&quot;%d&quot;,&amp;t);
    while(t--)
    {
        scanf(&quot;%d%d&quot;,&amp;e,&amp;f);
        scanf(&quot;%d&quot;,&amp;n);
        for(int i=0;i&lt;n;i++)
            scanf(&quot;%d%d&quot;,&amp;p[i],&amp;w[i]);


        memset(dp,1000000,sizeof(dp));
        dp[0]=0;

        s=f-e;
        ok=0;

        for(int i=0;i&lt;n;i++)
            for(int j=0;j&lt;=s;j++)
            {
                if(j-w[i]&gt;=0)
                    dp[j]=min(dp[j],dp[j-w[i]]+p[i]);
            }



                if(dp[s]!=1000000 &amp;&amp; dp[s]&lt;1000000)
                printf(&quot;The minimum amount of money in the piggy-bank is %d.\n&quot;,dp[s]);
                else
                    printf(&quot;This is impossible.\n&quot;);

    }

}
</code></pre><p>AC  <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1059" target="_blank" rel="noopener"> Hdu 1059 Dividing  </a><br>简单多重背包，体积为硬币数，价值为币值，可用二进制处理成  01  背包求解，可用  30  对  num  进行优化。</p>
<pre><code>//多重背包
//HDU 1059
//题意：价值分别为1,2,3,4,5,6的物品的个数分别为 a[1],a[2],````a[6]
//问能不能分成两堆价值相等的

#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int a[7];
int f[120005];
int v,k;
void ZeroOnePack(int cost,int weight)//cost 为费用， weight 为价值 
{
    for(int i=v;i&gt;=cost;i--)
       if(f[i-cost]+weight&gt;f[i]) f[i]=f[i-cost]+weight;
}    
void CompletePack(int cost,int weight)
{
    for(int i=cost;i&lt;=v;i++)
        if(f[i-cost]+weight&gt;f[i]) f[i]=f[i-cost]+weight;
}         
void MultiplePack(int cost ,int weight,int amount)
{
    if(cost*amount&gt;=v) CompletePack(cost,weight);
    else
    {
        for(int k=1;k&lt;amount;)
        {
            ZeroOnePack(k*cost,k*weight);
            amount-=k;
            k&lt;&lt;=1;
        }    
        ZeroOnePack(amount*cost,amount*weight);
    }    
}    
int main()
{
    int tol;
    int iCase=0;
    while(1)
    {
        iCase++;
        tol=0;
        for(int i=1;i&lt;7;i++)
        {
            scanf(&quot;%d&quot;,&amp;a[i]);
            tol+=a[i]*i;//总价值数 
        }  
        if(tol==0) break;
        if(tol%2==1)
        {
            printf(&quot;Collection #%d:\nCan&#39;t be divided.\n\n&quot;,iCase);
            continue;
        }      
        else
        {
            v=tol/2;
            memset(f,0,sizeof(f));
            for(int i=1;i&lt;7;i++)
              MultiplePack(i,i,a[i]);
            if(f[v]==v) 
              printf(&quot;Collection #%d:\nCan be divided.\n\n&quot;,iCase);
            else printf(&quot;Collection #%d:\nCan&#39;t be divided.\n\n&quot;,iCase);
        }    
    }    
    return 0;    
}
</code></pre><p>AC <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2191" target="_blank" rel="noopener"> Hdu 2191  悼念  512  汶川大地震遇难同胞  ——  珍惜现在，感恩生活
</a> 标题超长超简单的多重背包，可用  01  背包求解。</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;string.h&gt;  
#include &lt;algorithm&gt;  
using namespace std;  

const int INF = 0x3f3f3f3f;  
int n,m;  
int c[110],w[110],num[110],dp[110];  

 void ZeroOnePack(int cost, int weight)  
 {  
     for(int i = n; i &gt;= cost; i--)  
         dp[i] = max(dp[i],dp[i-cost]+weight);  
}  

void CompletePack(int cost, int weight)  
{  
    for(int i = cost; i &lt;= n; i++)  
        dp[i] = max(dp[i],dp[i-cost]+weight);  

}  

void MultiplePack(int cost, int weight, int amount)  
{  
    if(cost * amount &gt;= n)
    {  
        CompletePack(cost,weight);  
    }  
    else
   {  
        int k = 1;  
        while(k &lt; amount)  
        {  
           ZeroOnePack(k*cost,k*weight);  
            amount -= k;  
            k = k &lt;&lt; 1;  
       }  
        ZeroOnePack(amount*cost,amount*weight);  
   }  
}  

int main()  
{  
    int test;  
    scanf(&quot;%d&quot;,&amp;test);  
    while(test--)  
    {  
       scanf(&quot;%d %d&quot;,&amp;n,&amp;m);  
        for(int i = 1; i &lt;= m; i++)  
       {  
            scanf(&quot;%d %d %d&quot;,&amp;c[i],&amp;w[i],&amp;num[i]);  
        }  

        memset(dp,0,sizeof(dp));          

       for(int i = 1; i &lt;= m; i++)  
        {  
           MultiplePack(c[i],w[i],num[i]);  
        }  
       printf(&quot;%d\n&quot;,dp[n]);  
   }  
   return 0;  
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>迷宫问题 192132-01</title>
    <url>/article/csdn/%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98_192132-01.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44258487" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44258487</a></p>
<p>迷宫问题</p>
<p>以一个  m*n  的长方阵表示迷宫，  0  和  1<br>分别表示迷宫中的通路和障碍。设计一个程序，对任意设定的迷宫，求出一条从入口到出口的通路，或得出没有通路的结论。</p>
<p>要求：</p>
<p>（  1  ）首先实现一个以链表作存储结构的栈类型，然后编写一个求解迷宫的非递归程序。求得的通路以三元组  (i,j,d)  的形式输出，其中  (i,j)<br>指示迷宫中的一个坐标，  d  表示走到下一坐标的方向。</p>
<p>（  2  ）测试几组数据，数据的规模由小变大，即网格越来越小，障碍越来越复杂。</p>
<p>（  3  ）  实现该问题的可视化界面。</p>
<pre><code>#include&lt;stdio.h&gt;     
#include&lt;iostream&gt;     
#include&lt;math.h&gt;     
#include&lt;stdlib.h&gt;     
#include&lt;ctype.h&gt;     
#include&lt;algorithm&gt;     
#include&lt;vector&gt;     
#include&lt;string.h&gt;     
#include&lt;stack&gt;     
#include&lt;set&gt;     
#include&lt;map&gt;     
#include&lt;sstream&gt;     
#include&lt;time.h&gt;     
#include&lt;utility&gt;     
#include&lt;malloc.h&gt;     
#include&lt;stdexcept&gt;     
#include&lt;iomanip&gt;     
#include&lt;iterator&gt;     

using namespace std;  

int n, m, sx, sy, ex, ey, t;  
int p[110][110];  
char MAP[110][110];
int vis[110][110];  
int dir[4][2] = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };  

struct node  
{  
    int x;  
    int y;  
};  

struct node pre[30][30];//存储节点前一个位置   


//////////////////////////  栈   
#define DataType node                  

struct Node;                         
typedef struct Node *PNode;           

typedef struct Node                   
{  
    DataType info;                  
    PNode link;                     
}Node;  

typedef struct LinkStack             
{  
    PNode top;          
}LinkStack;  

typedef struct LinkStack * PLinkStack;     
PLinkStack createEmptyStack(void);  
int isEmptyStack(PLinkStack stack);  
int push(PLinkStack stack, DataType x);  
int pop(PLinkStack stack);  
DataType getTop(PLinkStack stack);  
void showStack(PLinkStack stack);  
void setEmpty(PLinkStack stack);  
void destroyStack(PLinkStack stack);  

PLinkStack createEmptyStack(void)  
{  
    PLinkStack stack = (PLinkStack)malloc(sizeof(struct LinkStack));  
    if (stack == NULL)  
        printf(&quot;存储分配失败，请重建栈！\n&quot;);  
    else  
        stack-&gt;top = NULL;  
    return stack;  
}  

int isEmptyStack(PLinkStack stack)  
{  
    return (stack-&gt;top == NULL);  
}  

int push(PLinkStack stack, DataType x)  
{  
    PNode p = (PNode)malloc(sizeof(struct Node));  
    if (p == NULL)  
    {  
        printf(&quot;新结点分配内存失败，进栈失败，请重试！\n&quot;);  
        return 0;  
    }  
    else  
    {  
        p-&gt;info = x;  
        p-&gt;link = stack-&gt;top;       
        stack-&gt;top = p;  
        return 1;  
    }  
}  

int pop(PLinkStack stack)  
{  
    if (isEmptyStack(stack))  
    {  
        printf(&quot;栈为空！\n&quot;);  
        return 0;  
    }  
    else  
    {  
        PNode p;  
        p = stack-&gt;top;   //删除最后一个结点     
        stack-&gt;top = stack-&gt;top-&gt;link;  
        free(p);  
        return 1;  
    }  
}  

DataType getTop(PLinkStack stack)  
{  
    if (isEmptyStack(stack))  
    {  
        printf(&quot;栈为空！取栈顶元素失败！\n&quot;);  
    }  
    return (stack-&gt;top-&gt;info);  
}  

void showStack(PLinkStack stack)  
{  
    if (isEmptyStack(stack))  
        printf(&quot;当前栈为空！无内容可显示。\n&quot;);  
    else  
    {  
        PNode p;  
        p = stack-&gt;top;  
        printf(&quot;顶--&gt; &quot;);  
        while (p-&gt;link != NULL)  
        {  
            printf(&quot;%d &quot;, p-&gt;info);  
            p = p-&gt;link;  
        }  
        printf(&quot;%d &quot;, p-&gt;info);     
        printf(&quot;--&gt;底\n&quot;);  
    }  
}  

void setEmpty(PLinkStack stack)  
{  
    stack-&gt;top = NULL;  
}  

void destroyStack(PLinkStack stack)  
{  
    if (stack)  
    {  
        stack-&gt;top = NULL;  
        free(stack);  
    }  
}  
///////////////////////////   

int check(int x, int y)  
{  
    if (x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n)  
        return 1;  
    return 0;  
}  

void printf_path()  
{  
    node ss,sss;  

    DataType data;  
    PLinkStack stack;  

    stack = createEmptyStack();  

    ss.x = ex;  
    ss.y = ey;  

    while (1)  
    {  
        push(stack, ss);  
        if (ss.x == sx &amp;&amp; ss.y == sy)  
            break;  
        ss = pre[ss.x][ss.y];  
    }  

    int pres, presy;  
    printf (&quot;           行走路径 文字描述如下：\n\n\n&quot;);
    while (!(isEmptyStack(stack)))  
    {  
        ss = getTop(stack);  
        pop(stack);  
        MAP[ss.x+1][ss.y+1] = &#39;*&#39;;
        if (!(isEmptyStack(stack)))  
            sss = getTop(stack);  
        printf(&quot;           &quot;);printf(&quot;此刻坐标(%d, %d)  &quot;, ss.x, ss.y);  

        if (!(isEmptyStack(stack)))  
        {  
            if (sss.x == ss.x &amp;&amp; sss.y == ss.y + 1)  
                    printf(&quot;向右走\n&quot;); 
            if (sss.x == ss.x &amp;&amp; sss.y == sss.y - 1)  
                    printf(&quot;向左走\n&quot;);  

            if (sss.x == ss.x + 1 &amp;&amp; sss.y == sss.y)  
                    printf(&quot;向下走\n&quot;);
            if (sss.x == ss.x - 1 &amp;&amp; sss.y == sss.y)  
                    printf(&quot;向上走\n&quot;); 
        }  
    }printf(&quot;到达终点!\n\n\n\n&quot;);  
    printf (&quot;           行走路径图如下：\n&quot;);

    for(int i=0;i&lt;=m+1;i++)
    {
        printf(&quot;           &quot;);
        for(int j=0;j&lt;=n+1;j++)
        {
            if (j==0 || j== n+1)
                printf(&quot;| &quot;);
            else if (i == 0 || i == m+1)
                printf(&quot;—&quot;);
            else 
                printf(&quot;%c &quot;,MAP[i][j]);
        }
        printf(&quot;\n&quot;);
    }
}  

////////////////////////队列   

#define Error( str )        FatalError( str )   
#define FatalError( str )   fprintf( stderr, &quot;%s\n&quot;, str ), exit( 1 )   
#define  ElementType node   

#define MAXQUEUE 100   

typedef struct NODE  
{  
    ElementType data;  
    struct NODE* nextNode;  
} NODE;  
typedef struct queue  
{  
    NODE* front;    // 对首指针   
    NODE* rear;     // 队尾指针   
    int items;      // 队列中项目个数   

} *ptrQueue;  
typedef ptrQueue Queue;  
int IsEmpty(Queue q);  
int IsFull(Queue q);  
Queue CreateQueue(void);  
void DisposeQueue(Queue q);  
void MakeEmpty(Queue q);  
void Enqueue(ElementType x, Queue q);  
ElementType Front(Queue q);  
void Dequeue(Queue q);  

int IsFull(Queue q)  
{  
    return q-&gt;items == MAXQUEUE;  
}  

int IsEmpty(Queue q)  
{  
    return q-&gt;items == 0;  
}  
Queue CreateQueue(void)  
{  
    Queue q;  

    q = (Queue)malloc(sizeof(struct NODE));  
    if (NULL == q)  
        Error(&quot;空间不足，队列内存分配失败！&quot;);  

    q-&gt;front = (NODE*)malloc(sizeof(NODE));  
    if (NULL == q-&gt;front)  
        Error(&quot;空间不足，队列首节点内存分配失败！&quot;);  

    q-&gt;rear = (NODE*)malloc(sizeof(NODE));  
    if (NULL == q-&gt;rear)  
        Error(&quot;空间不足，队列尾节点内存分配失败！&quot;);  

    q-&gt;items = 0;  

    return q;  
}  

void DisposeQueue(Queue q)  
{  
    MakeEmpty(q);  
    free(q);  
}  

void MakeEmpty(Queue q)  
{  
    if (q == NULL)  
        Error(&quot;必须先使用CreateQueue创建队列！&quot;);  

    while (IsEmpty(q))  
        Dequeue(q);  
}  

void Enqueue(ElementType x, Queue q)  
{  
    if (IsFull(q))  
        Error(&quot;队列已满！&quot;);  

    NODE* pnode;  
    pnode = (NODE*)malloc(sizeof(NODE));  
    if (NULL == pnode)  
        Error(&quot;新节点分配内存失败！&quot;);  

    pnode-&gt;data = x;  
    pnode-&gt;nextNode = NULL;  
    if (IsEmpty(q))  
        q-&gt;front = pnode;           // 项目位于首端   
    else  
        q-&gt;rear-&gt;nextNode = pnode;  // 链接到队列尾端   
    q-&gt;rear = pnode;                    // 记录队列尾端的位置   
    q-&gt;items++;                     // 项目数加1   

    return;  
}  

void Dequeue(Queue q)  
{  
    if (IsEmpty(q))  
        Error(&quot;队列本身为空！&quot;);  

    NODE* pnode;  
    pnode = q-&gt;front;  
    q-&gt;front = q-&gt;front-&gt;nextNode;  
    free(pnode);  

    q-&gt;items--;  
    if (q-&gt;items == 0)  
        q-&gt;rear = NULL;  

    return;  
}  

ElementType Front(Queue q)  
{  
    if (!IsEmpty(q))  
        return q-&gt;front-&gt;data;  
    Error(&quot;队列为空\n&quot;);  
}  

ElementType FrontAndDequeue(Queue q)  
{  
    ElementType x;  

    if (IsEmpty(q))  
        Error(&quot;队列为空！&quot;);  
    else  
    {  
        q-&gt;items--;  
        x = q-&gt;front-&gt;data;  
        q-&gt;front = q-&gt;front-&gt;nextNode;  
    }  

    return x;  
}  

///////////////////////   

int bfs()  
{  
    memset(vis, 0, sizeof(vis));  

    Queue sqQueue;  
    sqQueue = CreateQueue();  

    node qq, qqq;  

    qq.x = sx;  
    qq.y = sy;  
    vis[sx][sy] = 1;  

    Enqueue(qq, sqQueue);  

    while (!IsEmpty(sqQueue))  
    {  
        qq = Front(sqQueue);  
        Dequeue(sqQueue);  

        if (qq.x == ex &amp;&amp; qq.y == ey)  
        {  
            printf_path();  
            return 1;  
        }  

        for (int i = 0; i &lt; 4; i++)  
        {  
            int x = qq.x + dir[i][0];  
            int y = qq.y + dir[i][1];  

            if (!check(x, y) || vis[x][y] || p[x][y] == 1)  
                continue;  

            qqq = qq;  
            qqq.x = x;  
            qqq.y = y;  

            pre[qqq.x][qqq.y] = qq;  

            vis[x][y] = 1;  
            Enqueue(qqq, sqQueue);  
        }  
    }  
    return 0;  
}  


int main()  
{  
    printf(&quot;请输入迷宫长和宽\n&quot;);  
    while (cin &gt;&gt; m &gt;&gt; n)  
    {  
        printf(&quot;输入起点坐标和终点坐标\n&quot;);  
        scanf(&quot;%d%d%d%d&quot;,&amp;sx,&amp;sy,&amp;ex,&amp;ey);  
        printf(&quot;请输入迷宫\n&quot;);  
        for (int i = 0; i &lt; m; i++)  
        {  
            for (int j = 0; j &lt; n; j++)  
            {  
                cin &gt;&gt; p[i][j];  
                MAP[i+1][j+1] = p[i][j] + &#39;0&#39;;
            }  
        }  
        int ans = bfs();  
        if (ans == 0)  
            printf(&quot;不存在起点到终点的通路\n\n\n\n&quot;);  
        printf(&quot;\n\n\n\n&quot;);  
        printf(&quot;是否继续 1.yes 2.no\n &quot;);  
        scanf(&quot;%d&quot;,&amp;t);  
        if (t == 2) { printf(&quot;          再见   ,谢谢使用本系统！\n\n\n&quot;); return 0; }  
        printf(&quot;\n\n\n\n&quot;);  
        printf(&quot;请输入迷宫长和宽\n&quot;);  
    }  
    return 0;  
}  
</code></pre><p>测试数据：</p>
<p>5 5<br>0 0 4 4<br>0 1 0 0 0<br>0 1 0 1 0<br>0 0 0 0 0<br>0 1 1 1 1<br>0 0 0 1 0  </p>
<p>1<br>5 5<br>0 0 4 4<br>0 1 0 0 0<br>0 1 0 1 0<br>0 0 0 0 0<br>0 1 1 1 0<br>0 0 0 1 0</p>
<p>2</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>Linux虚拟地址空间分布</title>
    <url>/article/csdn/Linux%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%86%E5%B8%83.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/49951009" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/49951009</a></p>
<p>转自： <a href="http://www.cnblogs.com/clover-toeic/p/3754433.html" target="_blank" rel="noopener"> http://www.cnblogs.com/clover-toeic/p/3754433.html
</a></p>
<p>在多任务操作系统中，每个进程都运行在属于自己的内存沙盘中。这个沙盘就是虚拟地址空间(Virtual Address<br>Space)，在32位模式下它是一个4GB的内存地址块。在Linux系统中, 内核进程和用户进程所占的虚拟内存比例是1:3，而Windows系统为2:2<br>(通过设置Large-Address-Aware<br>Executables标志也可为1:3)。这并不意味着内核使用那么多物理内存，仅表示它可支配这部分地址空间，根据需要将其映射到物理内存。</p>
<p>虚拟地址通过页表(Page<br>Table)映射到物理内存，页表由操作系统维护并被处理器引用。内核空间在页表中拥有较高特权级，因此用户态程序试图访问这些页时会导致一个页错误(page<br>fault)。在Linux中，内核空间是持续存在的，并且在所有进程中都映射到同样的物理内存。内核代码和数据总是可寻址，随时准备处理中断和系统调用。与此相反，用户模式地址空间的映射随进程切换的发生而不断变化。</p>
<pre><code> Linux进程在虚拟内存中的标准内存段布局如下图所示：
</code></pre><p><img src="https://img-blog.csdn.net/20160919122820332" alt="这里写图片描述"></p>
<p>用户进程部分分段存储内容如下表所示(按地址递减顺序)：<br><img src="https://img-blog.csdn.net/20160919122926386" alt="这里写图片描述"></p>
<h2><span id="1-内核空间">1 内核空间</span></h2><p>内核总是驻留在内存中，是操作系统的一部分。内核空间为内核保留，不允许应用程序读写该区域的内容或直接调用内核代码定义的函数。</p>
<h2><span id="2-栈stack">2 栈(stack)</span></h2><p>栈又称堆栈，由编译器自动分配释放，行为类似数据结构中的栈(先进后出)。堆栈主要有三个用途：</p>
<p>为函数内部声明的非静态局部变量(C语言中称“自动变量”)提供存储空间。<br>记录函数调用过程相关的维护性信息，称为栈帧(Stack Frame)或过程活动记录(Procedure Activation<br>Record)。它包括函数返回地址，不适合装入寄存器的函数参数及一些寄存器值的保存。除递归调用外，堆栈并非必需。因为编译时可获知局部变量，参数和返回地址所需空间，并将其分配于BSS段。<br>临时存储区，用于暂存长算术表达式部分计算结果或alloca()函数分配的栈内内存。<br>持续地重用栈空间有助于使活跃的栈内存保持在CPU缓存中，从而加速访问。进程中的每个线程都有属于自己的栈。向栈中不断压入数据时，若超出其容量就会耗尽栈对应的内存区域，从而触发一个页错误。此时若栈的大小低于堆栈最大值RLIMIT_STACK(通常是8M)，则栈会动态增长，程序继续运行。映射的栈区扩展到所需大小后，不再收缩。</p>
<p>Linux中ulimit -s命令可查看和设置堆栈最大值，当程序使用的堆栈超过该值时, 发生栈溢出(Stack<br>Overflow)，程序收到一个段错误(Segmentation Fault)。注意，调高堆栈容量可能会增加内存开销和启动时间。</p>
<p>堆栈既可向下增长(向内存低地址)也可向上增长, 这依赖于具体的实现。本文所述堆栈向下增长。</p>
<pre><code> 堆栈的大小在运行时由内核动态调整。
</code></pre><h2><span id="3-内存映射段mmap">3 内存映射段(mmap)</span></h2><p>此处，内核将硬盘文件的内容直接映射到内存,<br>任何应用程序都可通过Linux的mmap()系统调用或Windows的CreateFileMapping()/MapViewOfFile()请求这种映射。内存映射是一种方便高效的文件I/O方式，<br>因而被用于装载动态共享库。用户也可创建匿名内存映射，该映射没有对应的文件, 可用于存放程序数据。在<br>Linux中，若通过malloc()请求一大块内存，C运行库将创建一个匿名内存映射，而不使用堆内存。”大块” 意味着比阈值<br>MMAP_THRESHOLD还大，缺省为128KB，可通过mallopt()调整。</p>
<p>该区域用于映射可执行文件用到的动态链接库。在Linux<br>2.4版本中，若可执行文件依赖共享库，则系统会为这些动态库在从0x40000000开始的地址分配相应空间，并在程序装载时将其载入到该空间。在Linux<br>2.6内核中，共享库的起始地址被往上移动至更靠近栈区的位置。</p>
<p>从进程地址空间的布局可以看到，在有共享库的情况下，留给堆的可用空间还有两处：一处是从.bss段到0x40000000，约不到1GB的空间；另一处是从共享库到栈之间的空间，约不到2GB。这两块空间大小取决于栈、共享库的大小和数量。这样来看，是否应用程序可申请的最大堆空间只有2GB？事实上，这与Linux内核版本有关。在上面给出的进程地址空间经典布局图中，共享库的装载地址为0x40000000，这实际上是Linux<br>kernel<br>2.6版本之前的情况了，在2.6版本里，共享库的装载地址已经被挪到靠近栈的位置，即位于0xBFxxxxxx附近，因此，此时的堆范围就不会被共享库分割成2个“碎片”，故kernel<br>2.6的32位Linux系统中，malloc申请的最大内存理论值在2.9GB左右。</p>
<h2><span id="4-堆heap">4 堆(heap)</span></h2><p>堆用于存放进程运行时动态分配的内存段，可动态扩张或缩减。堆中内容是匿名的，不能按名字直接访问，只能通过指针间接访问。当进程调用malloc(C)/new(C++)等函数分配内存时，新分配的内存动态添加到堆上(扩张)；当调用free(C)/delete(C++)等函数释放内存时，被释放的内存从堆中剔除(缩减)<br>。</p>
<p>分配的堆内存是经过字节对齐的空间，以适合原子操作。堆管理器通过链表管理每个申请的内存，由于堆申请和释放是无序的，最终会产生内存碎片。堆内存一般由应用程序分配释放，回收的内存可供重新使用。若程序员不释放，程序结束时操作系统可能会自动回收。</p>
<p>堆的末端由break指针标识，当堆管理器需要更多内存时，可通过系统调用brk()和sbrk()来移动break指针以扩张堆，一般由系统自动调用。</p>
<p>使用堆时经常出现两种问题：1)<br>释放或改写仍在使用的内存(“内存破坏”)；2)未释放不再使用的内存(“内存泄漏”)。当释放次数少于申请次数时，可能已造成内存泄漏。泄漏的内存往往比忘记释放的数据结构更大，因为所分配的内存通常会圆整为下个大于申请数量的2的幂次(如申请212B，会圆整为256B)。</p>
<p>注意，堆不同于数据结构中的”堆”，其行为类似链表。</p>
<p>【扩展阅读】栈和堆的区别</p>
<p>①管理方式：栈由编译器自动管理；堆由程序员控制，使用方便，但易产生内存泄露。</p>
<p>②生长方向：栈向低地址扩展(即”向下生长”)，是连续的内存区域；堆向高地址扩展(即”向上生长”)，是不连续的内存区域。这是由于系统用链表来存储空闲内存地址，自然不连续，而链表从低地址向高地址遍历。</p>
<p>③空间大小：栈顶地址和栈的最大容量由系统预先规定(通常默认2M或10M)；堆的大小则受限于计算机系统中有效的虚拟内存，32位Linux系统中堆内存可达2.9G空间。</p>
<p>④存储内容：栈在函数调用时，首先压入主调函数中下条指令(函数调用语句的下条可执行语句)的地址，然后是函数实参，然后是被调函数的局部变量。本次调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的指令地址，程序由该点继续运行下条可执行语句。堆通常在头部用一个字节存放其大小，堆用于存储生存期与函数调用无关的数据，具体内容由程序员安排。</p>
<p>⑤分配方式：栈可静态分配或动态分配。静态分配由编译器完成，如局部变量的分配。动态分配由alloca函数在栈上申请空间，用完后自动释放。堆只能动态分配且手工释放。</p>
<p>⑥分配效率：栈由计算机底层提供支持：分配专门的寄存器存放栈地址，压栈出栈由专门的指令执行，因此效率较高。堆由函数库提供，机制复杂，效率比栈低得多。Windows系统中VirtualAlloc可直接在进程地址空间中分配一块内存，快速且灵活。</p>
<p>⑦分配后系统响应：只要栈剩余空间大于所申请空间，系统将为程序提供内存，否则报告异常提示栈溢出。</p>
<p>操作系统为堆维护一个记录空闲内存地址的链表。当系统收到程序的内存分配申请时，会遍历该链表寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点空间分配给程序。若无足够大小的空间(可能由于内存碎片太多)，有可能调用系统功能去增加程序数据段的内存空间，以便有机会分到足够大小的内存，然后进行返回。，大多数系统会在该内存空间首地址处记录本次分配的内存大小，供后续的释放函数(如free/delete)正确释放本内存空间。</p>
<p>此外，由于找到的堆结点大小不一定正好等于申请的大小，系统会自动将多余的部分重新放入空闲链表中。</p>
<p>⑧碎片问题：栈不会存在碎片问题，因为栈是先进后出的队列，内存块弹出栈之前，在其上面的后进的栈内容已弹出。而频繁申请释放操作会造成堆内存空间的不连续，从而造成大量碎片，使程序效率降低。</p>
<p>可见，堆容易造成内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和内核态切换，内存申请的代价更为昂贵。所以栈在程序中应用最广泛，函数调用也利用栈来完成，调用过程中的参数、返回地址、栈基指针和局部变量等都采用栈的方式存放。所以，建议尽量使用栈，仅在分配大量或大块内存空间时使用堆。</p>
<p>使用栈和堆时应避免越界发生，否则可能程序崩溃或破坏程序堆、栈结构，产生意想不到的后果。</p>
<h2><span id="5-bss段">5 BSS段</span></h2><pre><code> BSS(Block Started by Symbol)段中通常存放程序中以下符号：
</code></pre><p>未初始化的全局变量和静态局部变量<br>初始值为0的全局变量和静态局部变量(依赖于编译器实现)<br>未定义且初值不为0的符号(该初值即common block的大小)<br>C语言中，未显式初始化的静态分配变量被初始化为0(算术类型)或空指针(指针类型)。由于程序加载时，BSS会被操作系统清零，所以未赋初值或初值为0的全局变量都在BSS中。BSS段仅为未初始化的静态分配变量预留位置，在目标文件中并不占据空间，这样可减少目标文件体积。但程序运行时需为变量分配内存空间，故目标文件必须记录所有未初始化的静态分配变量大小总和(通过start_bss和end_bss地址写入机器代码)。当加载器(loader)加载程序时，将为BSS段分配的内存初始化为0。在嵌入式软件中，进入main()函数之前BSS段被C运行时系统映射到初始化为全零的内存(效率较高)。</p>
<p>注意，尽管均放置于BSS段，但初值为0的全局变量是强符号，而未初始化的全局变量是弱符号。若其他地方已定义同名的强符号(初值可能非0)，则弱符号与之链接时不会引起重定义错误，但运行时的初值可能并非期望值(会被强符号覆盖)。因此，定义全局变量时，若只有本文件使用，则尽量使用static关键字修饰；否则需要为全局变量定义赋初值(哪怕0值)，保证该变量为强符号，以便链接时发现变量名冲突，而不是被未知值覆盖。</p>
<p>某些编译器将未初始化的全局变量保存在common段，链接时再将其放入BSS段。在编译阶段可通过-fno-<br>common选项来禁止将未初始化的全局变量放入common段。</p>
<p>此外，由于目标文件不含BSS段，故程序烧入存储器(Flash)后BSS段地址空间内容未知。U-Boot启动过程中，将U-<br>Boot的Stage2代码(通常位于lib_xxxx/board.c文件)搬迁(拷贝)到SDRAM空间后必须人为添加清零BSS段的代码，而不可依赖于Stage2代码中变量定义时赋0值。</p>
<h2><span id="6-数据段data">6 数据段(Data)</span></h2><p>数据段通常用于存放程序中已初始化且初值不为0的全局变量和静态局部变量。数据段属于静态内存分配(静态存储区)，可读可写。</p>
<p>数据段保存在目标文件中(在嵌入式系统里一般固化在镜像文件中)，其内容由程序初始化。例如，对于全局变量int gVar =<br>10，必须在目标文件数据段中保存10这个数据，然后在程序加载时复制到相应的内存。</p>
<p>数据段与BSS段的区别如下：</p>
<p>1) BSS段不占用物理文件尺寸，但占用内存空间；数据段占用物理文件，也占用内存空间。<br>对于大型数组如int ar0[10000] = {1, 2, 3, …}和int<br>ar1[10000]，ar1放在BSS段，只记录共有10000*4个字节需要初始化为0，而不是像ar0那样记录每个数据1、2、3…，此时BSS为目标文件所节省的磁盘空间相当可观。</p>
<p>2)<br>当程序读取数据段的数据时，系统会出发缺页故障，从而分配相应的物理内存；当程序读取BSS段的数据时，内核会将其转到一个全零页面，不会发生缺页故障，也不会为其分配相应的物理内存。</p>
<p>运行时数据段和BSS段的整个区段通常称为数据区。某些资料中“数据段”指代数据段 + BSS段 + 堆。</p>
<h2><span id="7-代码段text">7 代码段(text)</span></h2><p>代码段也称正文段或文本段，通常用于存放程序执行代码(即CPU执行的机器指令)。一般C语言执行语句都编译成机器代码保存在代码段。通常代码段是可共享的，因此频繁执行的程序只需要在内存中拥有一份拷贝即可。代码段通常属于只读，以防止其他程序意外地修改其指令(对该段的写操作将导致段错误)。某些架构也允许代码段为可写，即允许修改程序。</p>
<p>代码段指令根据程序设计流程依次执行，对于顺序指令，只会执行一次(每个进程)；若有反复，则需使用跳转指令；若进行递归，则需要借助栈来实现。</p>
<p>代码段指令中包括操作码和操作对象(或对象地址引用)。若操作对象是立即数(具体数值)，将直接包含在代码中；若是局部数据，将在栈区分配空间，然后引用该数据地址；若位于BSS段和数据段，同样引用该数据地址。</p>
<p>代码段最容易受优化措施影响。<br>8 保留区<br>位于虚拟地址空间的最低部分，未赋予物理地址。任何对它的引用都是非法的，用于捕捉使用空指针和小整型值指针引用内存的异常情况。</p>
<p>它并不是一个单一的内存区域，而是对地址空间中受到操作系统保护而禁止用户进程访问的地址区域的总称。大多数操作系统中，极小的地址通常都是不允许访问的，如NULL。C语言将无效指针赋值为0也是出于这种考虑，因为0地址上正常情况下不会存放有效的可访问数据。</p>
<h2><span id="扩展阅读分段的好处">【扩展阅读】分段的好处</span></h2><p>进程运行过程中，代码指令根据流程依次执行，只需访问一次(当然跳转和递归可能使代码执行多次)；而数据(数据段和BSS段)通常需要访问多次，因此单独开辟空间以方便访问和节约空间。具体解释如下：</p>
<p>当程序被装载后，数据和指令分别映射到两个虚存区域。数据区对于进程而言可读写，而指令区对于进程只读。两区的权限可分别设置为可读写和只读。以防止程序指令被有意或无意地改写。</p>
<p>现代CPU具有极为强大的缓存(Cache)体系，程序必须尽量提高缓存命中率。指令区和数据区的分离有利于提高程序的局部性。现代CPU一般数据缓存和指令缓存分离，故程序的指令和数据分开存放有利于提高CPU缓存命中率。</p>
<p>当系统中运行多个该程序的副本时，其指令相同，故内存中只须保存一份该程序的指令部分。若系统中运行数百进程，通过共享指令将节省大量空间(尤其对于有动态链接的系统)。其他只读数据如程序里的图标、图片、文本等资源也可共享。而每个副本进程的数据区域不同，它们是进程私有的。</p>
<p>此外，临时数据及需要再次使用的代码在运行时放入栈区中，生命周期短。全局数据和静态数据可能在整个程序执行过程中都需要访问，因此单独存储管理。堆区由用户自由分配，以便管理。</p>
]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>各种查找算法效率比较</title>
    <url>/article/csdn/%E5%90%84%E7%A7%8D%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E6%AF%94%E8%BE%83.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44598923" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44598923</a></p>
<p>题目描述：<br>给定一个已经排好序的N个整数的序列（数据从1到N），在该序列中查找指定的整数，并观察不同算法的运行时间。考查3类查找算法：折半查找，平衡二叉排序树的查找，B-树的查找。<br>要求：<br>（1）构造树表的算法要考虑各种可能的输入数据序列；<br>（2）可根据要求输出树表结构；<br>（3）分析最坏情况下，三种查找算法的复杂度；<br>（4）测量并比较三种算法在N=100，500，1000，2000，4000，6000，8000，10000时的性能，要求完成以下三个方面的工作：<br>① 对每个测试数据集，统计计算每种查找算法的ASL；<br>② 对每个测试数据集运行多次获得运行时间的平均值；<br>③ 绘制算法实际运行结果（ASL和运行时间）的曲线图，验证和理论分析的时间复杂度的吻合性。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;malloc.h&gt;

using namespace std;

#define CLOCKS_PER_SEC ((clock_t)1000)
#define MaxSize 100002
#define M 100
int Step;
int Bjishu;
using namespace std;

typedef struct
{
    int key;

}DataType;
typedef struct
{
    DataType list[MaxSize];
    int size;
}SeqList;

typedef struct node
{
    DataType data;
    struct node *LeftChild;//
    struct node *RightChild;//
    struct node *Parent;
    int i;//height
}BITreeNode, BTnode, *Tree;//二叉平衡树结构体

typedef struct Node
{
    struct Node *parent;        /*指向双亲结点*/
    int key[M];              /*关键字向量，0号单元未用(M-1阶)*/
    struct Node *ptr[M];        /*子树指针向量*/
}B_TNode;//B_树结构体


void ListInitiate(SeqList *L)
{
    L-&gt;size = 0;
}
int ListLength(SeqList L)
{
    return L.size;
}
int ListInsert(SeqList *L, int x)
{
    // int j;
    if (L-&gt;size &gt;= MaxSize)
    {
        printf(&quot;顺序表已满\n&quot;);
        return 0;
    }
    else
    {
        //for(j=L-&gt;size;j&gt;i;j--)L-&gt;list[j]=L-&gt;list[j-1];
        L-&gt;list[L-&gt;size].key = x;
        L-&gt;size++;
        return 1;
    }
}
int BInarySearch(SeqList S, DataType x)//折半查找
{
    int js = 1;                        //次数记录
    int low = 0;
    int high = S.size - 1;
    int mid;
    while (low &lt;= high)
    {
        mid = (low + high) / 2;             //中间位置
        if (S.list[mid].key == x.key)return js;
        else if (S.list[mid].key&lt;x.key)low = mid + 1;
        else if (S.list[mid].key&gt;x.key)high = mid - 1;
        js++;
    }
    return -1;
}
int Hetree(BTnode *Root)
{
    if (Root == NULL)return 0;
    return
        Hetree(Root-&gt;LeftChild)&gt;Hetree(Root-&gt;RightChild) ? Hetree(Root-&gt;LeftChild) + 1 : Hetree(Root-&gt;RightChild) + 1;
}


int IsBlance(BTnode *Root)//判断二叉树的平衡)
{
    int bf;
    if (Root != NULL)
    {
        bf = Hetree(Root-&gt;LeftChild) - Hetree(Root-&gt;RightChild);
        if ((bf&lt;-1) || (bf&gt;1))
            return 0;//不平衡
        else
        {
            if (IsBlance(Root-&gt;LeftChild) &amp;&amp; IsBlance(Root-&gt;RightChild))
                return 1;
            else
                return 0;
        }
    }
    return 1;
}
BTnode *R_Rotate(BTnode *Root, BTnode *p)//LL型调平衡(右旋)
{
    BTnode *b, *q, *c, *d;
    q = p-&gt;Parent;
    b = p-&gt;LeftChild;
    c = b-&gt;LeftChild;
    d = b-&gt;RightChild;
    p-&gt;LeftChild = d;
    if (d != NULL)
        d-&gt;Parent = p;
    b-&gt;RightChild = p;
    p-&gt;Parent = b;
    if (q == NULL)
    {
        Root = b;
        b-&gt;Parent = NULL;            //b的父结点为空，即b就是根结点
    }
    else if (q-&gt;LeftChild == p)        //如果a是父结点的左孩子
    {
        q-&gt;LeftChild = b;            //将b赋值给q的左孩子
        b-&gt;Parent = q;            //b的父结点是q
    }
    else if (q-&gt;RightChild == p)        //如果a是父结点的右孩子
    {
        q-&gt;RightChild = b;            //将b赋值给q的右孩子
        b-&gt;Parent = q;            //b的父结点是q
    }
    return Root;
}


BTnode *L_Rotate(BTnode *Root, BTnode *p)//RR型调平衡
{
    BTnode *b, *q, *c, *d;
    q = p-&gt;Parent;

    b = p-&gt;RightChild;
    c = b-&gt;RightChild;
    d = b-&gt;LeftChild;

    p-&gt;RightChild = d;
    if (d != NULL)
        d-&gt;Parent = p;

    b-&gt;LeftChild = p;
    p-&gt;Parent = b;

    if (q == NULL)
    {
        Root = b;                //二叉树的根结点就是b，把b赋值给树Root
        b-&gt;Parent = NULL;        //b的父结点为空，即b就是根结点
    }
    else if (q-&gt;LeftChild == p)    //如果p是父结点的左孩子
    {
        q-&gt;LeftChild = b;        //将b赋值给q的左孩子
        b-&gt;Parent = q;        //b的父结点是q
    }
    else if (q-&gt;RightChild == p)    //如果p是父结点的右孩子
    {
        q-&gt;RightChild = b;        //将b赋值给q的右孩子
        b-&gt;Parent = q;        //b的父结点是q
    }

    return Root;
}
BTnode *LR_Rotate(BTnode *Root, BTnode *p)
{
    BTnode *b, *q, *c, *d;
    q = p-&gt;Parent;
    b = p-&gt;LeftChild;
    c = b-&gt;LeftChild;
    d = b-&gt;RightChild;
    p-&gt;LeftChild = d;
    if (d != NULL)
        d-&gt;Parent = p;
    b-&gt;RightChild = p;
    p-&gt;Parent = b;
    if (q == NULL)
    {
        Root = b;
        b-&gt;Parent = NULL;            //b的父结点为空，即b就是根结点
    }
    else if (q-&gt;LeftChild == p)        //如果a是父结点的右孩子
    {
        q-&gt;LeftChild = b;            //将b赋值给q的左孩子
        b-&gt;Parent = q;            //b的父结点是q
    }
    else if (q-&gt;RightChild == p)        //如果a是父结点的左孩子
    {
        q-&gt;RightChild = b;            //将b赋值给q的右孩子
        b-&gt;Parent = q;            //b的父结点是q
    }
    return Root;
}
BTnode *RL_Rotate(BTnode *Root, BTnode *p)
{
    BTnode *b, *q, *c, *d;
    q = p-&gt;Parent;

    b = p-&gt;RightChild;
    c = b-&gt;RightChild;
    d = b-&gt;LeftChild;

    p-&gt;RightChild = d;
    if (d != NULL)
        d-&gt;Parent = p;

    b-&gt;LeftChild = p;
    p-&gt;Parent = b;

    if (q == NULL)
    {
        Root = b;                //二叉树的根结点就是b，把b赋值给树Root
        b-&gt;Parent = NULL;        //b的父结点为空，即b就是根结点
    }
    else if (q-&gt;LeftChild == p)    //如果p是父结点的右孩子
    {
        q-&gt;LeftChild = b;        //将b赋值给q的左孩子
        b-&gt;Parent = q;        //b的父结点是q
    }
    else if (q-&gt;RightChild == p)    //如果p是父结点的左孩子
    {
        q-&gt;RightChild = b;        //将b赋值给q的右孩子
        b-&gt;Parent = q;        //b的父结点是q
    }

    return Root;
}
int blancebinarytreesearch(BTnode *Root, int x)//查找平衡二叉排序树
{
    BTnode *p;
    int count = 0;
    if (Root != NULL)
    {
        p = Root;
        while (p != NULL)
        {
            count++;
            if (p-&gt;i == x)return count;
            else if (x&lt;p-&gt;i)p = p-&gt;LeftChild;
            else if (x&gt;p-&gt;i)p = p-&gt;RightChild;
        }
    }
    return 0;
}
int InPEtree(BTnode **Root, int x)//创建平衡二叉排序树的函数
{
    BTnode *cur, *parent = NULL, *p, *q;
    cur = *Root;
    while (cur != NULL)
    {
        if (x == cur-&gt;i)return 0;
        parent = cur;
        if (x&lt;cur-&gt;i)cur = cur-&gt;LeftChild;
        else if (x&gt;cur-&gt;i)cur = cur-&gt;RightChild;
    }
    p = (BTnode *)malloc(sizeof(BTnode));
    p-&gt;i = x;
    p-&gt;LeftChild = NULL;
    p-&gt;RightChild = NULL;
    p-&gt;Parent = NULL;
    if (parent == NULL)*Root = p;
    else if (x&lt;parent-&gt;i)
    {
        parent-&gt;LeftChild = p;
        p-&gt;Parent = parent;
    }
    else if (x&gt;parent-&gt;i)
    {
        parent-&gt;RightChild = p;
        p-&gt;Parent = parent;
    }

    int bf;

    if (IsBlance(*Root) == 0)        //如果二叉树是不平衡的
    {
        bf = Hetree(parent-&gt;LeftChild) - Hetree(parent-&gt;RightChild);
        while ((bf &gt;= -1) &amp;&amp; (bf &lt;= 1))
        {
            parent = parent-&gt;Parent;
            bf = Hetree(parent-&gt;LeftChild) - Hetree(parent-&gt;RightChild);
        }
        q = parent;///找到离插入点最近的不平衡点
        if (p-&gt;i&gt;q-&gt;i&amp;&amp;p-&gt;i&gt;q-&gt;RightChild-&gt;i)//新结点插入在q结点的右孩子的右子树中。
        {
            *Root = L_Rotate(*Root, q);
        }
        else if (p-&gt;i&gt;q-&gt;i&amp;&amp;p-&gt;i&lt;q-&gt;RightChild-&gt;i)//新结点插入在A结点的右孩子的左子树中
        {
            *Root = RL_Rotate(*Root, q);
        }
        else if (p-&gt;i&lt;q-&gt;i&amp;&amp;p-&gt;i&gt;q-&gt;LeftChild-&gt;i)//新结点插入在q结点的左孩子的右子树中
        {
            *Root = LR_Rotate(*Root, q);
        }
        else //结点插入在A结点的左孩子的左子树中
        {
            *Root = R_Rotate(*Root, q);
        }
    }
    return 1;
}

void PrintBiTree(BTnode *root, int n)
{
    int i;
    if (root == NULL)return;
    PrintBiTree(root-&gt;RightChild, n + 1);
    for (i = 0; i&lt;n - 1; i++)printf(&quot;     &quot;);
    if (n&gt;0)
    {
        printf(&quot;-----&quot;);
        printf(&quot;%d\n&quot;, root-&gt;i);
    }
    if (n == 0)
    {
        //printf(&quot;--&quot;);
        printf(&quot;%d\n&quot;, root-&gt;i);
    }
    PrintBiTree(root-&gt;LeftChild, n + 1);
}

int B_treetreesearch(B_TNode *Root, int x)//查找B-树
{
    int i;
    if (Root == NULL)return 0;
    for (i = 1; i &lt;= Root-&gt;key[0]; i++)
    {
        Bjishu++;
        if (x&lt;Root-&gt;key[i])break;
        if (x == Root-&gt;key[i])return Bjishu;
    }
    return B_treetreesearch(Root-&gt;ptr[i - 1], x);
}

B_TNode* B_treetreeinsert(B_TNode *Root, int x)//3.B-树的插入函数
{
    int i;
    if (Root == NULL)//B_树为空
    {
        Root = (B_TNode *)malloc(sizeof(B_TNode));
        Root-&gt;key[0] = 1;
        Root-&gt;key[1] = x;
        for (i = 0; i&lt;M; i++)
            Root-&gt;ptr[i] = NULL;
        Root-&gt;parent = NULL;
        return Root;
    }
    B_TNode *p = Root, *q, *s;
    q = p;
    while (p != NULL)
    {
        for (i = 1; i &lt;= p-&gt;key[0]; i++)
            if (x&lt;p-&gt;key[i])break;
        q = p;
        p = p-&gt;ptr[i - 1];
    }
    int j;
    q-&gt;key[i] = x;

    for (j = q-&gt;key[0]; j &gt;= i; j--)
    {
        q-&gt;key[j + 1] = q-&gt;key[j];
        q-&gt;ptr[j + 1] = q-&gt;ptr[j];
    }
    q-&gt;key[0]++;
    int temp;
    i = q-&gt;key[0];
    int m, num = 0;
    while (q-&gt;key[0] == Step + 1 - 1)
    {
        num++;
        temp = q-&gt;key[(i - 1) / 2 + 1];
        p = q-&gt;parent;
        q-&gt;key[0] = (i - 1) / 2;//分裂左树
        m = (i - 1) / 2 + 1;
        //加到双亲结点
        if (p == NULL)
        {
            p = (B_TNode *)malloc(sizeof(B_TNode));
            for (i = 0; i&lt;M; i++)
                p-&gt;ptr[i] = NULL;
            Root = p;
            Root-&gt;parent = NULL;
            p-&gt;key[0] = 1;
            p-&gt;key[1] = temp;
            p-&gt;ptr[0] = q;
            p-&gt;parent = NULL;
        }
        else
        {
            for (i = 1; i &lt;= p-&gt;key[0]; i++)
                if (temp&lt;p-&gt;key[i])break;
            for (j = p-&gt;key[0]; j &gt;= i; j--)
            {
                p-&gt;key[j + 1] = p-&gt;key[j];
                p-&gt;ptr[j + 1] = p-&gt;ptr[j];
            }
            p-&gt;key[i] = temp;//
            p-&gt;ptr[i - 1] = q;//
            p-&gt;key[0]++;
        }
        //分配右树
        s = (B_TNode *)malloc(sizeof(B_TNode));
        for (i = 0; i&lt;M; i++)
            s-&gt;ptr[i] = NULL;
        p-&gt;ptr[p-&gt;key[0]] = s;
        p-&gt;ptr[p-&gt;key[0] - 1] = q;
        s-&gt;key[0] = Step + 1 - 1 - m;
        s-&gt;parent = p;
        q-&gt;parent = p;
        for (i = 1; i &lt;= s-&gt;key[0]; i++)
        {
            s-&gt;key[i] = q-&gt;key[i + m];
            s-&gt;ptr[i - 1] = q-&gt;ptr[i + m - 1];    ////////////////

        }
        if (num&gt;1)s-&gt;ptr[i - 1] = q-&gt;ptr[i + m - 1];
        for (i = 0; i &lt;= s-&gt;key[0]; i++)
        {
            if (s-&gt;ptr[i] != NULL)s-&gt;ptr[i]-&gt;parent = s;////////////////
        }
        q = p;
        i = q-&gt;key[0];
    }
    return Root;
}
int B_treetreeprint(B_TNode *Root, int n)
{
    int i, j;
    if (Root == NULL)return 0;

    for (i = Root-&gt;key[0]; i&gt;0; i--)
    {
        B_treetreeprint(Root-&gt;ptr[i], n + 1);
        for (j = 0; j&lt;n; j++)
            printf(&quot;----&quot;);
        cout &lt;&lt; Root-&gt;key[i] &lt;&lt; endl;
    }
    B_treetreeprint(Root-&gt;ptr[0], n + 1);
}
/*
int B_treetreeprint(B_TNode *Root,int n)
{
int i;
if(Root==NULL)return 0;
if(Root-&gt;key[0]&gt;=2)
{

B_treetreeprint(Root-&gt;ptr[2],n+1);
for(i=0;i&lt;n;i++)
printf(&quot;--&quot;);
printf(&quot;%d  &quot;,Root-&gt;key[2]);
printf(&quot;\n&quot;);
}
if(Root-&gt;key[0]&gt;=1)
{
B_treetreeprint(Root-&gt;ptr[1],n+1);
for(i=0;i&lt;n;i++)
printf(&quot;--&quot;);

printf(&quot;%d  &quot;,Root-&gt;key[1]);
printf(&quot;\n&quot;);        //printf(&quot;\n&quot;);
}
if(Root-&gt;ptr[0]!=NULL)
{

B_treetreeprint(Root-&gt;ptr[0],n+1);
//    for(i=0;i&lt;n;i++)
//    printf(&quot;---&quot;);
}
}


int B_treetreeprint(B_TNode *Root,int n)
{
int i;
if(Root==NULL)return 0;
if(Root-&gt;key[0]&gt;=2)
{

B_treetreeprint(Root-&gt;ptr[2],n+1);
for(i=0;i&lt;n;i++)
printf(&quot;--&quot;);
printf(&quot;%d  &quot;,Root-&gt;key[2]);
printf(&quot;\n&quot;);
}
if(Root-&gt;key[0]&gt;=1)
{
B_treetreeprint(Root-&gt;ptr[1],n+1);
for(i=0;i&lt;n;i++)
printf(&quot;--&quot;);

printf(&quot;%d  &quot;,Root-&gt;key[1]);
printf(&quot;\n&quot;);        //printf(&quot;\n&quot;);
}
if(Root-&gt;ptr[0]!=NULL)
{

B_treetreeprint(Root-&gt;ptr[0],n+1);
//    for(i=0;i&lt;n;i++)
//    printf(&quot;---&quot;);
}
}
*/
int main()
{
    int i;
    int s, j, k, k1, k2, k3, Size, Sizex;
    int x;
    SeqList L;
    DataType Me;
    double runtime;
    double Start, End;
    printf(&quot;请输入序列中数的个数Size：&quot;);
    //while (scanf(&quot;%d&quot;, &amp;Size) != EOF&amp;&amp;Size != 0)
    scanf(&quot;%d&quot;, &amp;Size);
    {
        ListInitiate(&amp;L); //初始化线性表
        Tree t = NULL;   //初始化二叉平衡树
        Tree zt = NULL; //初始化折半查找树
        B_TNode *Root = NULL;
        s = 0;
        printf(&quot;请输入B_树的阶：&quot;);
        scanf(&quot;%d&quot;, &amp;Step);
        for (i = 0; i&lt;Size; i++)
        {
            InPEtree(&amp;t, i + 1); //Insert (&amp;t,i+1);创建二叉平衡树
            ListInsert(&amp;L, i + 1);//创建线性表
            Root = B_treetreeinsert(Root, i + 1);//创建B_树
        }
        printf(&quot;平衡二叉树\n&quot;);
        PrintBiTree(t, 0);//打印二叉平衡树PrintfTree(t,1);
        printf(&quot;\nB_树\n&quot;);
        B_treetreeprint(Root, 0);
        //printf(&quot;请输入需要查找的数（1~Size）：&quot;);
        Sizex = Size;
        printf(&quot;输入要查找的数\n&quot;);
        scanf(&quot;%d&quot;,&amp;Sizex);
        if (Sizex &lt;0 || Sizex &gt;Size)
        {
            printf(&quot;查找失败，不存在此数！\n&quot;);
            return 0;
        }
        //while (Sizex &gt;= 1)
        {

            k1 = 0;  k2 = 0; k3 = 0;          //记次数
            k1 = blancebinarytreesearch(t, Sizex);
            printf(&quot;平衡二叉树查询%d用了%d次\n&quot;, Sizex, k1);
            Me.key = Sizex;
            k2 = BInarySearch(L, Me);
            printf(&quot;折半查找法查询%d用了%d次\n&quot;, Sizex, k2);
            Bjishu = 0;
            printf(&quot;B_树查找%d用了%d次\n&quot;, Sizex, B_treetreesearch(Root, Sizex));
            //printf(&quot;请输入需要查找的数（1~Size）：&quot;);
        }

        k = 0;
        Start = clock();//开始计时
        for (i = 0; i&lt;Size; i++)
        {
            k += blancebinarytreesearch(t, i + 1);//SearchBST(t,i+1,s);
        }
        End = clock();//结束计时】
        runtime = (double)(End - Start) / (CLOCKS_PER_SEC*Size);
        printf(&quot;%d个数的数组\n\t\t 平衡二叉排序树ASL= %.2f \t平均时间：%lf ms\n&quot;, Size, (float)k / Size, runtime);

        k = 0;
        Start = clock();
        for (i = 0; i&lt;Size; i++)
        {
            Me.key = i + 1;
            k += BInarySearch(L, Me);
        }
        End = clock();
        runtime = (double)(End - Start) / (CLOCKS_PER_SEC*Size);
        printf(&quot;\t\t 折半查找法ASL= %.2f \t 平均时间：%lf ms\n&quot;, (float)k / Size, runtime);

        Bjishu = 0;
        Start = clock();
        for (i = 0; i&lt;Size; i++)
        {
            B_treetreesearch(Root, i + 1);
        }
        End = clock();
        runtime = (double)(End - Start) / (CLOCKS_PER_SEC*Size);
        printf(&quot;\t\t B_树查找ASL= %.2f \t    平均时间：%lf ms\n&quot;, (float)Bjishu / Size, runtime);

    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
  <entry>
    <title>文件目录管理与显示</title>
    <url>/article/csdn/%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%E4%B8%8E%E6%98%BE%E7%A4%BA.html</url>
    <content><![CDATA[<p>版权声明：转载请注明出处。 <a href="https://blog.csdn.net/u014427196/article/details/44458849" target="_blank" rel="noopener">https://blog.csdn.net/u014427196/article/details/44458849</a></p>
<p>文件目录管理与显示<br>给出目录和文件信息，编程实现将其排列成一棵有一定缩进的树。<br>要求：<br>（1）设计文件和目录信息树的存储结构。<br>（2）从文件或键盘输入目录和文件信息，输入格式采用绝对路径法，即：<br>\A<br>\A\AA1<br>\A\AA1\aa1.doc<br>…<br>创建时要检查同一路径下不能有同名的目录或文件名。<br>（3）设计文件和目录信息树的输出格式（以凹入表的形式显示）。<br>（4）查找指定目录和文件。<br>（5）添加新目录或新文件。<br>（6）删除指定目录或文件，子目录能够被删除的前提是其为空，既不包含任何子目录和文件；根目录不能删除。<br>（7）扩充目录或文件信息，如创建时间、读写权限、文件长度或子目录包含的子目录和文件数等。<br>（8）对同一层次下的子目录或文件按创建时间有序输出。<br>（9）通配符的使用。如用“？”代表任意一个字符，用“*”表示任意多个任意字符。<br>扩展内容：<br>实现相对路径表示法。</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;malloc.h&gt;  
#include &lt;string&gt;  
#include &lt;iostream&gt;  
#include &lt;sstream&gt;  

using namespace std;  

#include &quot;Sibtree.h&quot;  

void add(SibTree *t1)  
{  
    printf(&quot;输入目录文件信息以输入0结束:\n&quot;);  
    SibTreeNode *r, *r1, *r2;  
    char ifm[1000] = { &#39;\0&#39; }, name1[50], name2[50];  
    char *str;  
    int i, j, n;  
    while (1)  
    {  
        cin &gt;&gt; ifm;  
        str = ifm;  
        if (*str == &#39;0&#39;)break;  
        r = t1-&gt;root;  
        if (r == NULL)  
        {  
            for (i = 0, str += 1; *str != &#39;\\&#39;&amp;&amp;*str != &#39;\0&#39;; str++, i++)  
            {  
                name1[i] = *str;  
            }  
            name1[i] = &#39;\0&#39;;  
            if (*str == &#39;\0&#39;)insertRoot(t1, name1);  
            else  
                printf(&quot;%s的路径不存在，不能添加\n&quot;, name1);  
        }  
        else  
        {  
            for (i = 0, str += 1; *str != &#39;\\&#39;&amp;&amp;*str != &#39;\0&#39;; str++, i++)  
            {  
                name1[i] = *str;  
            }  
            name1[i] = &#39;\0&#39;;  
            if (search(t1, name1) == 0 &amp;&amp; *str == &#39;\0&#39;)  
            {  
                insertnextSibing(t1, r, name1);  
            }  
            if (search(t1, name1) == 0 &amp;&amp; *str != &#39;\0&#39;)printf(&quot;%s的路径不存在，不能添加\n&quot;, name1);  
            r1 = LevelOrderTraverse(t1-&gt;root, name1);  
            while (r1 != NULL)  
            {  
                if (*str == &#39;\0&#39;)break;  
                for (i = 0, str += 1; *str != &#39;\\&#39;&amp;&amp;*str != &#39;\0&#39;; str++, i++)  
                {  
                    name2[i] = *str;  
                }  
                name2[i] = &#39;\0&#39;;  
                if (*str == &#39;\0&#39;)  
                {  
                    if (insertChild(t1, r1, name2)){ break; }  
                }  
                else  
                {  
                    n = children(r1);  
                    for (j = 1; j &lt;= n; j++)  
                    {  
                        if (strcmp(child(r1, j)-&gt;data, name2) == 0)break;  
                    }  
                    if (j &lt;= n)r2 = child(r1, j);  
                    else r2 = NULL;  
                    if (r2 == NULL)printf(&quot;%s的路径不存在，不能添加\n&quot;, name2);  
                }  
                n = children(r1);  
                for (j = 1; j &lt;= n; j++)  
                {  
                    if (strcmp(child(r1, j)-&gt;data, name2) == 0)break;  
                }  
                if (j &lt;= n)r1 = child(r1, j);  
                else r1 = NULL;  
            }  
        }  
    }  
}  
void check(SibTree *t)  
{  
    SibTreeNode *r;  
    printf(&quot;输入要查找的文件名:&quot;);  
    char name[50];  
    cin &gt;&gt; name;  
    r = mohu1LevelOrderTraverse(t-&gt;root, name);  
    if (r == NULL)
        //printf(&quot;没有此文件\n&quot;);
        printf(&quot;\n&quot;);
    else  
    {  
        printf(&quot;此文件找到,创建时间为:&quot;);  
        printf(&quot;%d/%d/%d %d:%d:%d&quot;, r-&gt;year, r-&gt;month, r-&gt;day, r-&gt;hour, r-&gt;minute, r-&gt;second);  
        printf(&quot;\t子目录个数为:&quot;);  
        printf(&quot;%d\n&quot;, children(r));  
    }  
} 

void Delete(SibTree *t)  
{  
    SibTreeNode *r, *p, *kid;  
    printf(&quot;输入要删除的文件名:&quot;);  
    char name[50];  
    cin &gt;&gt; name;  
    r = LevelOrderTraverse(t-&gt;root, name);  
    if (r == NULL)printf(&quot;没有此文件!\n&quot;);  
    else  
    {  
        if (r-&gt;firstChild != NULL)printf(&quot;有子文件不能删除!\n&quot;);  
        else  
        {  
            p = r-&gt;parent;  
            kid = p-&gt;firstChild;  
            if (strcmp(kid-&gt;data, r-&gt;data) == 0)p-&gt;firstChild = kid-&gt;nextSibling;  
            else  
            {  
                while (strcmp(kid-&gt;nextSibling-&gt;data, r-&gt;data))kid = kid-&gt;nextSibling;  
                kid-&gt;nextSibling = kid-&gt;nextSibling-&gt;nextSibling;  
            }  
            printf(&quot;已删除!\n&quot;);  
        }  
    }  
}  
void out(SibTree *t)  
{  
    printf(&quot;输出文件目录的信息:\n&quot;);  
    printf(&quot;root:\n&quot;);  
    printf(&quot;%s&quot;, toString(t).c_str());  
}  
void repair(SibTree *t)//修改扩充  
{  
    SibTreeNode *r, *p, *kid;  
    printf(&quot;输入想要扩充或修改的文件或目录的名称\n&quot;);  
    char name[100];  
    cin &gt;&gt; name;  
    r = LevelOrderTraverse(t-&gt;root, name);  
    if (r == NULL)  
        printf(&quot;没有此文件!\n&quot;);  
    else  
    {  
        printf(&quot;   查找成功\n\n   1 修改or 2扩充?\n\n\n&quot;);  
        int k;  
        cin &gt;&gt; k;  
        if (k == 1)  
        {  
            printf(&quot;输入目录或文件的新名称 \n&quot;);  
            char Name[100];  
            cin &gt;&gt; Name;  
            strcpy(r-&gt;data, Name);  
            printf(&quot; 修改成功！\n\n&quot;);  
            printf(&quot; 修改时间为:&quot;);  
            printf(&quot;%d年/%d月/%d日 %d时:%d分:%d秒\n\n\n&quot;, sys.wYear, sys.wMonth, sys.wDay, sys.wHour, sys.wMinute, sys.wSecond);  
            r-&gt;year = sys.wYear;  
            r-&gt;month = sys.wMonth;  
            r-&gt;day = sys.wDay;  
            r-&gt;hour = sys.wHour;  
            r-&gt;minute = sys.wMinute;  
            r-&gt;second = sys.wSecond;  
        }  
        else  
        {  
            printf(&quot;当前目录的信息为：\n 限制子目录的个数 %d 个 限制子文件的个数 %d 个\n&quot;, r-&gt;sonmulu, r-&gt;sonfile);  
            printf(&quot;请输入修改后的限制子目录的个数和限制子文件的个数:\n&quot;);  
            int a, b;  
            cin &gt;&gt; a &gt;&gt; b;  
            r-&gt;sonmulu = a;  
            r-&gt;sonfile = b;  
            printf(&quot;修改成功！\n\n\n&quot;);  
        }  
    }  
}  

void mohucheck(SibTree *t)  
{  
    SibTreeNode *r;  
    printf(&quot;输入要查找的文件或目录名:&quot;);  
    char name[50];  
    cin &gt;&gt; name;  
    r = mohuLevelOrderTraverse(t-&gt;root, name);  
    if (r == NULL) //printf(&quot;没有此文件\n&quot;);  
        printf(&quot;\n&quot;);  
    else  
    {  
        printf(&quot;此文件或目录找到,创建时间为:&quot;);  
        printf(&quot;%d/%d/%d %d:%d:%d&quot;, r-&gt;year, r-&gt;month, r-&gt;day, r-&gt;hour, r-&gt;minute, r-&gt;second);  
        printf(&quot;\t子目录个数为:&quot;);  
        printf(&quot;%d\n&quot;, children(r));  
    }  
}  

void main()  
{  
    SibTree t1;  
    int k;  
    TreeInitiate(&amp;t1);  
    while (1)  
    {  
        printf(&quot;\n&quot;);  
        printf(&quot;\t                      文件管理                        \t\n&quot;);  
        printf(&quot;\t********************************************************\t\n&quot;);  
        printf(&quot;\t  *************对照号码输入你要进行的操作*************\n&quot;);  
        printf(&quot;\t                     1 ——&gt;添加目录或文件      \n&quot;);  
        printf(&quot;\t                     2 ——&gt;查找目录或文件      \n&quot;);  
        printf(&quot;\t                     3 ——&gt;删除目录或文件      \n&quot;);  
        printf(&quot;\t                     4 ——&gt;输出文件信息        \n&quot;);  
        printf(&quot;\t                     5 ——&gt;扩充目录或文件信息   \n&quot;);  
        printf(&quot;\t                     6 ——&gt;模糊查找            \n&quot;);  
        printf(&quot;\t                     7 ——&gt;退出                \n&quot;);  
        printf(&quot;输入你想进行的操作号码:&quot;);  
        scanf(&quot;%d&quot;, &amp;k);  
        if (k == 7)break;  
        switch (k)  
        {  
        case 1: add(&amp;t1); break;  
        case 2: check(&amp;t1); break;  
        case 3: Delete(&amp;t1); break;  
        case 4: out(&amp;t1); break;  
        case 5: repair(&amp;t1); break;  
        case 6: mohucheck(&amp;t1); break;  
        default:  
            printf(&quot;输入号码错误!\n&quot;);  
        }  
    }  
}  


#include &lt;windows.h&gt;  
#include &lt;queue&gt;
SYSTEMTIME sys;  
int ok;  
typedef struct SibTreeNode  
{  
    char data[50];  
    int valid;  
    int year;  
    int month;  
    int day;  
    int hour;  
    int minute;  
    int second;  
    int sonmulu;  
    int sonfile;  
    struct SibTreeNode * parent;  
    struct SibTreeNode *firstChild;  
    struct SibTreeNode *nextSibling;  
}SibTreeNode;  

typedef struct  
{  
    SibTreeNode *root;  
    int size;  
}SibTree;  

typedef SibTreeNode *QueueDataType;  
#include &quot;SeqCQueue.h&quot;  

int IsTreeEmpty(SibTree *t)  
{  
    return t-&gt;size == 0;  
}  

int isValidNode(SibTreeNode *p)  
{  
    if (p)  
        return p-&gt;valid;  
    else return 0;  
}  
//创建一个空树  
void  TreeInitiate(SibTree *t)  
{  
    t-&gt;root = NULL;  
    t-&gt;size = 0;  
}  

//创建结点  
SibTreeNode * newSibTreeNode(char x[50])  
{  
    GetLocalTime(&amp;sys);  
    SibTreeNode *p = (SibTreeNode *)malloc(sizeof(SibTreeNode));  
    strcpy(p-&gt;data, x);  
    p-&gt;valid = true;  
    p-&gt;year = sys.wYear;  
    p-&gt;month = sys.wMonth;  
    p-&gt;day = sys.wDay;  
    p-&gt;hour = sys.wHour;  
    p-&gt;minute = sys.wMinute;  
    p-&gt;second = sys.wSecond;  
    p-&gt;sonmulu = 5;    //扩充的信息，限制子目录的个数  
    p-&gt;sonfile = 2;     //限制子文件的个数  
    p-&gt;parent = NULL;  
    p-&gt;firstChild = NULL;  
    p-&gt;nextSibling = NULL;  
    return  p;  
}  

//创建包含一个结点的树  
void onenodeSibTree(SibTree *t, char x[50])  
{  
    t-&gt;root = newSibTreeNode(x);  
    strcpy(t-&gt;root-&gt;data, x);  
    t-&gt;size = 1;  
}  

//输出当前结点的父亲节点  
SibTreeNode *root(SibTreeNode *p)  
{  
    if (p == NULL)  
    {  
        p = (SibTreeNode*)malloc(sizeof(SibTreeNode));  
        return p;  
    }  
    else  
    {  
        return p;  
    }  
}  
//插入根节点  
void insertRoot(SibTree *t, char x[50])  
{  
    SibTreeNode * newRoot = newSibTreeNode(x);  
    newRoot-&gt;firstChild = t-&gt;root;  
    if (t-&gt;root != NULL)  
    {  
        t-&gt;root-&gt;parent = newRoot;  
    }  
    t-&gt;root = newRoot;  
    t-&gt;size++;  
}  

// 输出树的大小  
int size(SibTree *t)  
{  
    return t-&gt;size;  
}  


// 构造一个不合法的结点  
SibTreeNode * invalidSibTreeNode()  
{  
    SibTreeNode *p = (SibTreeNode *)malloc(sizeof(SibTreeNode));  
    p-&gt;valid = false;  
    return  p;  
}  

//当前结点的孩子的个数  
int children(SibTreeNode *p)  
{  
    int count = 0;  
    SibTreeNode *countNode;  
    if (isValidNode(p))  
    {  
        countNode = p-&gt;firstChild;  
        while (countNode != NULL)  
        {  
            count++;  
            countNode = countNode-&gt;nextSibling;  
        }  
        return count;  
    }  
    else  
    {  
        return 0;  
    }  
}  

//返回当前结点的cth孩子结点  
SibTreeNode *child(SibTreeNode *p, int c)  
{  
    if (isValidNode(p))  
    {  
        if (c &lt; 1)  
        {  
            return invalidSibTreeNode();  
        }  
        SibTreeNode *kid = p-&gt;firstChild;  
        while ((kid != NULL) &amp;&amp; (c &gt; 1))  
        {  
            kid = kid-&gt;nextSibling;  
            c--;  
        }  
        if (kid == NULL)  
        {  
            return invalidSibTreeNode();  
        }  
        else  
        {  
            return kid;  
        }  
    }  
    else  
        throw &quot;the node is not a valid node!&quot;;  

}  

//返回当前结点的兄弟结点  
SibTreeNode *nextSibling(SibTreeNode *p)  
{  
    if (isValidNode(p))  
    {  
        if (p-&gt;nextSibling == NULL)  
        {  
            return invalidSibTreeNode();  
        }  
        else  
        {  
            return p-&gt;nextSibling;  
        }  
    }  
    else  
    {  
        throw &quot;the node is not a valid node!&quot;;  
        return invalidSibTreeNode();  
    }  
}  

//插入孩子结点  
int insertChild(SibTree *t, SibTreeNode *p, char x[50])  
{  
    SibTreeNode *n;  
    int i, flog = 0;  
    for (i = 0; x[i] != &#39;\0&#39;; i++)  
    {  
        if (x[i] == &#39;.&#39;){ flog = 1; break; }  
    }  

    if (isValidNode(p))  
    {  
        n = p-&gt;firstChild;  
        if (n == NULL)  
        {  
            p-&gt;firstChild = newSibTreeNode(x);  
            p-&gt;firstChild-&gt;parent = p;  
        }  
        else  
        {  
            while (n != NULL)  
            {  
                if (strcmp(n-&gt;data, x) == 0){ printf(&quot;输入的文件有重名,请更改名字!&quot;); break; }  
                if (n-&gt;nextSibling == NULL)break;  
                n = n-&gt;nextSibling;  
            }  
            if (strcmp(n-&gt;data, x) != 0)  
            {  
                if (flog == 1 &amp;&amp; children(n-&gt;parent)&lt;n-&gt;parent-&gt;sonfile)  
                {  
                    n-&gt;nextSibling = newSibTreeNode(x); n-&gt;nextSibling-&gt;parent = p;  
                }  
                else  
                    if (flog == 1)printf(&quot;文件数超出，不能继续存储\n&quot;);  
                    else  
                        if (flog == 0 &amp;&amp; children(n-&gt;parent)&lt;n-&gt;parent-&gt;sonmulu)  { n-&gt;nextSibling = newSibTreeNode(x); n-&gt;nextSibling-&gt;parent = p; }  
                        else if (flog == 0)printf(&quot;子目录超出，不能继续存储\n&quot;);  

            }  
        }  
        t-&gt;size++;  
        return 1;  
    }  
    else return 0;  
}  
//为当前结点插入兄弟结点  
int insertnextSibing(SibTree *t, SibTreeNode *p, char x[50])  
{  
    SibTreeNode *n;  
    if (isValidNode(p))  
    {  
        n = p-&gt;nextSibling;  
        if (n == NULL)p-&gt;nextSibling = newSibTreeNode(x);  
        else  
        {  
            while (n-&gt;nextSibling != NULL)n = n-&gt;nextSibling;  
            n-&gt;nextSibling = newSibTreeNode(x);  
            n-&gt;nextSibling-&gt;parent = p-&gt;parent;  
        }  
        t-&gt;size++;  
        return 1;  
    }  
    else return 0;  
}  

int mohucheck(char a[], char b[])  
{  
    int len = strlen(b);  
    int len1 = strlen(a);  
    for (int i = 0; i &lt; len; i++)  
    {  
        if (b[i] == &#39;*&#39;)  
        {  
            int j = len - 1;  
            int k = len1 - 1;  

            while (j != i)  
            {  
                if (b[j] != a[k])  
                    return 0;  
                --j;   
                --k;  
            }  
            return 1;  
        }  
        else if (b[i] != &#39;?&#39;)  
        {  
            if (a[i] != b[i])  
                return 0;  
        }  
    }  
    return 1;  
}  

//模糊查找  
SibTreeNode *mohuLevelOrderTraverse(SibTreeNode *t, char a[50])  
{  
    int ok = 0;  
    SeqCQueue Q;  
    SibTreeNode *x;  
    if (t == NULL)return NULL;  
    QueueInitiate(&amp;Q);  
    QueueAppend(&amp;Q, t);  
    x = t-&gt;nextSibling;  
    while (x != NULL)  
    {  
        QueueAppend(&amp;Q, x);  
        x = x-&gt;nextSibling;  
    }  
    while (QueueNotEmpty(Q))  
    {  
        QueueDelete(&amp;Q, &amp;x);  
        if (mohucheck(x-&gt;data, a) == 1)  
        {  
            ok = 1;
            printf(&quot;查找到符合条件的有&quot;);//%s\n&quot;,x-&gt;data);
            ////////
            SibTreeNode *xx;
            xx = x;



            char sss[100][100];
            char gan = &#39;\\&#39;;
            int len = 0;
            while (xx!=root(t) )//&amp;&amp; xx-&gt;parent != NULL)
            {
                strcpy(sss[len++],xx-&gt;data);
                //printf(&quot;\%s   &quot;,xx-&gt;data);
                xx=xx-&gt;parent;
            }
            if (strcmp(sss[len-1],&quot;\\&quot;)!=0)
                printf(&quot;%ca&quot;,gan);
            for(int i=len-1;i&gt;=0;i--)
            {
                printf(&quot;%c&quot;,gan);
                printf(&quot;%s&quot;,sss[i]);
            }
            printf(&quot;\n&quot;);
           ///////////
        }  
        x = x-&gt;firstChild;  
        while (x != NULL)  
        {  
            QueueAppend(&amp;Q, x);  
            x = x-&gt;nextSibling;  
        }  
    }  
    if (!ok) printf(&quot;不存在此文件或目录\n&quot;);  
    return x;  
}  

SibTreeNode *mohu1LevelOrderTraverse(SibTreeNode *t, char a[50])  
{  
    int ok = 0;  
    SeqCQueue Q;  
    SibTreeNode *x;  
    if (t == NULL)return NULL;  
    QueueInitiate(&amp;Q);  
    QueueAppend(&amp;Q, t);  
    x = t-&gt;nextSibling;  
    while (x != NULL)  
    {  
        QueueAppend(&amp;Q, x);  
        x = x-&gt;nextSibling;  
    }  
    while (QueueNotEmpty(Q))  
    {  
        QueueDelete(&amp;Q, &amp;x);  
        if (strcmp(x-&gt;data, a) == 0)  
        {  
            ok = 1;
            printf(&quot;查找到符合条件的有&quot;);//%s\n&quot;,x-&gt;data);
            ////////
            SibTreeNode *xx;
            xx = x;



            char sss[100][100];
            char gan = &#39;\\&#39;;
            int len = 0;
            while (xx!=root(t) )//&amp;&amp; xx-&gt;parent != NULL)
            {
                strcpy(sss[len++],xx-&gt;data);
                //printf(&quot;\%s   &quot;,xx-&gt;data);
                xx=xx-&gt;parent;
            }
            if (strcmp(sss[len-1],&quot;\\&quot;)!=0)
                printf(&quot;%ca&quot;,gan);
            for(int i=len-1;i&gt;=0;i--)
            {
                printf(&quot;%c&quot;,gan);
                printf(&quot;%s&quot;,sss[i]);
            }
            printf(&quot;\n&quot;);
            ///////////
        }  
        x = x-&gt;firstChild;  
        while (x != NULL)  
        {  
            QueueAppend(&amp;Q, x);  
            x = x-&gt;nextSibling;  
        }  
    }  
    if (!ok) printf(&quot;不存在此文件或目录\n&quot;);  
    return x;  
}  

//层序遍历  
SibTreeNode *LevelOrderTraverse(SibTreeNode *t, char a[50])  
{  
    SeqCQueue Q;  
    SibTreeNode *x;  
    if (t == NULL)return NULL;  
    QueueInitiate(&amp;Q);  
    QueueAppend(&amp;Q, t);  
    x = t-&gt;nextSibling;  
    while (x != NULL)  
    {  
        QueueAppend(&amp;Q, x);  
        x = x-&gt;nextSibling;  
    }  
    while (QueueNotEmpty(Q))  
    {  
        QueueDelete(&amp;Q, &amp;x);  
        if (strcmp(x-&gt;data, a) == 0)break;  
        x = x-&gt;firstChild;  
        while (x != NULL)  
        {  
            QueueAppend(&amp;Q, x);  
            x = x-&gt;nextSibling;  
        }  
    }  
    return x;  
}  

//查找是否存在  
int search(SibTree *t, char x[50])  
{  
    if (LevelOrderTraverse(t-&gt;root, x) == NULL)return 0;  
    else return 1;  
}  

string preorderString(SibTreeNode *currentNode, int depth)  
{  
    string s = &quot;    &quot;;  
    stringstream out;  
    if (currentNode == NULL)  
    {  
        return &quot;&quot;;  
    }  

    for (int i = 0; i &lt; depth; i++)  
    {  
        s = s + &quot;   &quot;;  
    }  
    out &lt;&lt; currentNode-&gt;data;  
    s += out.str();  
    s += &quot;\n&quot;;  
    s += preorderString(currentNode-&gt;firstChild, depth + 1);  
    s += preorderString(currentNode-&gt;nextSibling, depth);  
    return s;  
}  

string toString(SibTree *t)  
{  
    return preorderString(t-&gt;root, 0);  
}  



typedef  struct  
{  
    QueueDataType  queue[50];  
    int front;  
    int rear;  
    int count; /* 队列的当前表长 */  
} SeqCQueue;  

//初始化  
void QueueInitiate(SeqCQueue *Q)  
{  
    Q-&gt;front = 0;  
    Q-&gt;rear = 0;  
    Q-&gt;count = 0;  
}  

//判断队列非空  
int QueueNotEmpty(SeqCQueue Q)  
{  
    if (Q.count != 0) return 1;  
    else return 0;  
}  

//入队列  
int QueueAppend(SeqCQueue *Q, QueueDataType x)  
{  
    if (Q-&gt;count&gt;0 &amp;&amp; Q-&gt;rear == Q-&gt;front)  
    {  
        printf(&quot;队列已满无法插入！\n&quot;);  
        return 0;  
    }  
    else  
    {  
        Q-&gt;queue[Q-&gt;rear] = x;  
        Q-&gt;rear = (Q-&gt;rear + 1) % 50;  
        Q-&gt;count++;  
        return 1;  
    }  
}  
//出队列  
int QueueDelete(SeqCQueue *Q, QueueDataType *x)  
{  
    if (Q-&gt;count == 0)  
    {  
        printf(&quot;队列已空无数据元素出队列！\n&quot;);  
        return 0;  
    }  
    else  
    {  
        *x = Q-&gt;queue[Q-&gt;front];  
        Q-&gt;front = (Q-&gt;front + 1) % 50;  
        Q-&gt;count--;  
        return 1;  
    }  
}  
//取对头数据元素  
int QueueGet(SeqCQueue *Q, QueueDataType *x)  
{  
    if (Q-&gt;count == 0)  
    {  
        printf(&quot;队列已空无数据元素出队列！\n&quot;);  
        return 0;  
    }  
    else  
    {  
        *x = Q-&gt;queue[Q-&gt;front];  
        return 1;  
    }  
}  
</code></pre><p>测试数据：</p>
<pre><code>1  
\a  
\a\aad
\a\abcde
\a\abcde\fghij
\a\abcde\fghij\aaaaabbbbb.doc
\a\aad\aa
\a\aad\aa\aaa  
\a\aad\aa\aaa\aaaaaa.doc 
0  
4  
2  
aa  
3  
aaaaaa.doc
4  
5  
aaa  
1  
asd  
4  
5  
asd  
2  
12 3  
6  
a?d  
4  
1  
\a\aad\aa\asd\aaaaabbbbb.doc
0  
4  
6  
aa*bb.doc
6  
aa*cc.doc
4  
6  
a*
</code></pre>]]></content>
      <categories>
        <category>CSDN备份</category>
      </categories>
  </entry>
</search>
