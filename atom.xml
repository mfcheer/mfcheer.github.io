<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mfcheer</title>
  
  <subtitle>help change the world</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mfcheer.github.io/"/>
  <updated>2021-10-09T16:19:39.695Z</updated>
  <id>https://mfcheer.github.io/</id>
  
  <author>
    <name>mfcheer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>小米路由器通过Clash设置代理</title>
    <link href="https://mfcheer.github.io/article/%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A8%E9%80%9A%E8%BF%87Clash%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86.html"/>
    <id>https://mfcheer.github.io/article/小米路由器通过Clash设置代理.html</id>
    <published>2021-10-09T15:40:05.000Z</published>
    <updated>2021-10-09T16:19:39.695Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>分为以下几个步骤：</p><ul><li>首先开启路由器SSH功能</li><li>SSH登录到路由器</li><li>在路由器下载Clash</li><li>配置Clash，重启生效</li></ul><h4><span id="开启ssh权限">开启SSH权限</span></h4><p>首先登陆你的路由器管理界面，点击路由状态页签，此时地址栏应该显示如下地址：</p><p><a href="http://miwifi.com/cgi-bin/luci/;stok=xxxxxxx****/web/home#router***" target="_blank" rel="noopener">http://miwifi.com/cgi-bin/luci/;stok=xxxxxxx****/web/home#router***</a>*</p><p>或者</p><p><a href="http://192.168.31.1/cgi-bin/luci/;stok=xxxxxxx****/web/home#router" target="_blank" rel="noopener">http://192.168.31.1/cgi-bin/luci/;stok=xxxxxxx****/web/home#router</a></p><p>将/web/home#router 替换为如下文本，之后输入回车访问，此时页面返回{“code”:0}，即可使用ssh工具测试是否开启成功。</p><pre class="line-numbers language-shell"><code class="language-shell">/api/misystem/set_config_iotdev?bssid=Xiaomi&user_id=longdike&ssid=-h%3B%20nvram%20set%20ssh_en%3D1%3B%20nvram%20commit%3B%20sed%20-i%20's%2Fchannel%3D.*%2Fchannel%3D%5C%22debug%5C%22%2Fg'%20%2Fetc%2Finit.d%2Fdropbear%3B%20%2Fetc%2Finit.d%2Fdropbear%20start%3B%20echo%20-e%20'admin%5Cnadmin'%20%7C%20passwd%20root%3B<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4><span id="登陆ssh">登陆SSH</span></h4><p>Mac下的iTerm即可  ssh <a href="mailto:root@192.168.31.1" target="_blank" rel="noopener">root@192.168.31.1</a>  默认密码为 admin （刚刚那串破解码中设定的密码）</p><h4><span id="安装shellclash">安装ShellClash</span></h4><p>成功登陆SSH后，直接输入以下命令</p><pre class="line-numbers language-shell"><code class="language-shell">sh -c "$(curl -kfsSl https://cdn.jsdelivr.net/gh/juewuy/clash-for-Miwifi@master/install.sh)" && source /etc/profile &> /dev/null<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按照提示即可完成安装！<br>安装完成后，直接在SSH中使用：</p><pre class="line-numbers language-shell"><code class="language-shell">clash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令即可管理脚本</p><h4><span id="导入clash配置文件">导入clash配置文件</span></h4><p>订阅是用的 cmy.network，使用该邀请链接注册可增加时长！  邀请链接：<a href="http://www.gotomony.com/register?aff=S33P5H" target="_blank" rel="noopener">http://www.gotomony.com/register?aff=S33P5H</a></p><p>然后通过  <a href="https://acl4ssr-sub.github.io/" target="_blank" rel="noopener">ACL4SSR 在线订阅转换</a>  转化cmy.network的订阅链接为clash配置链接</p><p>最后添加clash配置链接到路由器即可使用</p><ul><li>可视化界面：clash服务成功启动后可以通过在浏览器访问 <a href="http://192.168.31.1:9999/ui" target="_blank" rel="noopener">http://192.168.31.1:9999/ui</a> 设置代理 </li></ul><p>参考：</p><p><a href="https://qust.me/post/ax9000_shellclash/" target="_blank" rel="noopener">小米 AX9000 解锁 SSH 安装 ShellClash 教程｜地表最强硬路由💪 | 酱紫表 (qust.me)</a></p><p><a href="https://juewuy.github.io/post/clash-for-miwifi-an-zhuang-ji-shi-yong-jiao-cheng/" target="_blank" rel="noopener">在路由器上安装及使用ShellClash的教程 | Juewuy’s Blog</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;分为以下几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先开启路由器SSH功能&lt;/li&gt;
&lt;li&gt;SSH登录到路由器&lt;/li&gt;
&lt;li&gt;在路由器下载Clash&lt;/li&gt;
&lt;li&gt;配置Clash，重启生效&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;span 
      
    
    </summary>
    
      <category term="工具" scheme="https://mfcheer.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Go-基准测试</title>
    <link href="https://mfcheer.github.io/article/Go-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95.html"/>
    <id>https://mfcheer.github.io/article/Go-基准测试.html</id>
    <published>2019-02-23T00:30:50.000Z</published>
    <updated>2021-03-25T11:47:42.007Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="go-test">go test</span></h2><p>Go语言拥有一套单元测试和性能测试系统，go test 命令，会自动读取源码目录下面名为 *_test.go 的文件，生成并运行测试用的可执行文件</p><ul><li>测试用例文件不会参与正常源码编译，不会被包含到可执行文件中</li><li>命名文件时需要让文件必须以_test结尾</li><li>每个测试用例函数需要以Test为前缀</li></ul><p>常用的参数：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token operator">-</span>v 显示测试的详细命令<span class="token operator">-</span>run regexp 只运行 regexp 匹配的函数，例如 <span class="token operator">-</span>run<span class="token operator">=</span>Array 那么就执行包含有 Array 开头的函数<span class="token operator">-</span>cover 开启测试覆盖率<span class="token operator">-</span>bench regexp 执行相应的 benchmarks，例如 <span class="token operator">-</span>bench<span class="token operator">=</span><span class="token punctuation">.</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>单元测试源码<em>_test文件可以由多个测试用例组成，每个测试用例函数需要以Test为前缀，一般参数为 </em>testing.T</p><p>日志：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token operator">*</span>t testing<span class="token punctuation">.</span>Tt<span class="token punctuation">.</span>Logt<span class="token punctuation">.</span>Logft<span class="token punctuation">.</span>Errort<span class="token punctuation">.</span>Errorft<span class="token punctuation">.</span>Fatalt<span class="token punctuation">.</span>Fatalf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是例子：<br>文件</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token string">"testing"</span><span class="token keyword">func</span> <span class="token function">TestA</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>    t<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">TestAB</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>    t<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"AB"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">TestC</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>    t<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go"><code class="language-go">执行：<span class="token keyword">go</span> test <span class="token operator">-</span>v <span class="token operator">-</span>run TestA select_test<span class="token punctuation">.</span><span class="token keyword">go</span>输出：<span class="token operator">==</span><span class="token operator">=</span> RUN   TestA<span class="token operator">--</span><span class="token operator">-</span> PASS<span class="token punctuation">:</span> <span class="token function">TestA</span> <span class="token punctuation">(</span><span class="token number">0.</span>00s<span class="token punctuation">)</span>        select_test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">:</span> A<span class="token operator">==</span><span class="token operator">=</span> RUN   TestAB<span class="token operator">--</span><span class="token operator">-</span> PASS<span class="token punctuation">:</span> <span class="token function">TestAB</span> <span class="token punctuation">(</span><span class="token number">0.</span>00s<span class="token punctuation">)</span>        select_test<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">:</span> ABPASSok          command<span class="token operator">-</span>line<span class="token operator">-</span>arguments        <span class="token number">0.</span>003s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TestA 和 TestAB 的测试用例都被执行，原因是-run跟随的测试用例的名称支持正则表达式，使用-run TestA$即可只执行 TestA 测试用例。</p><h2><span id="基准测试">基准测试</span></h2><p>go test包支持基准测试，区别是传入的参数改为 b *testing.B，函数名称为 Benchmark为前缀。默认执行go test时是不执行基准的，需要使用 -bench标时</p><ul><li>可以使用-cpu标识更改测试使用的GOMAXPROCS 值</li><li>如果函数耗时高，1s内不能准确测试性能的话， 可以使用-benchtime标识增加运行时间：go test -bench=. -benchtime=10s</li><li>执行测试次数过多的话，测试结果会受GC等影响，可以使用-count参数多次运行基准测试来解决，go test -count=10 </li><li>-run=none  表示过滤掉单元测试</li><li>-bench=.   表示的是运行所有的基准测试，. 表示全部</li><li>-benchmem:表示显示memory的指标</li><li>有些测试需要一定的启动和初始化时间，如果从 Benchmark() 函数开始计时会很大程度上影响测试结果的精准性。StopTimer() 可以停止这个计数过程，做一些耗时的操作，通过 StartTimer() 重新开始计时。ResetTimer() 可以重置计数器的数据</li></ul><p>b.N 标示函数需要执行的次数。b.N 从 1 开始，如果基准测试函数在1秒内就完成 (默认值)，则 b.N 增加，并再次运行基准测试函数。b.N 在近似这样的序列中不断增加；1, 2, 3, 5, 10, 20, 30, 50, 100 等等。 基准框架试图变得聪明，如果它看到当b.N较小而且测试很快就完成的时候，它将让序列增加地更快。</p><p>例子：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">BenchmarkFuncA</span><span class="token punctuation">(</span>b <span class="token operator">*</span>testing<span class="token punctuation">.</span>B<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        b<span class="token punctuation">.</span><span class="token function">ResetTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> n <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>N<span class="token punctuation">;</span> n<span class="token operator">++</span> <span class="token punctuation">{</span>                <span class="token function">FuncA</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 运行 Fib 函数 N 次</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">go</span> test <span class="token operator">-</span>bench<span class="token operator">=</span>FuncA <span class="token operator">-</span>count<span class="token operator">=</span><span class="token number">10</span> <span class="token operator">-</span>benchtime<span class="token operator">=</span>10s <span class="token operator">-</span>cpu<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token operator">-</span>run<span class="token operator">=</span>none<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;go-test&quot;&gt;go test&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;Go语言拥有一套单元测试和性能测试系统，go test 命令，会自动读取源码目录下面名为 *_test.go 的文件，生成并运行测试用的可执行文件&lt;/p&gt;
      
    
    </summary>
    
      <category term="Go" scheme="https://mfcheer.github.io/categories/Go/"/>
    
    
  </entry>
  
  <entry>
    <title>Go-并发基础组件</title>
    <link href="https://mfcheer.github.io/article/Go-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6.html"/>
    <id>https://mfcheer.github.io/article/Go-并发基础组件.html</id>
    <published>2019-02-20T15:56:33.000Z</published>
    <updated>2022-03-12T17:41:16.372Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="go语言的csp模型">Go语言的CSP模型</span></h2><p>CSP 是 Communicating Sequential Process 的简称，中文可以叫做通信顺序进程，是一种并发编程模型。<br>Go 通过 channel 实现 CSP 通信模型，主要用于 goroutine 之间的消息传递和事件通知。</p><h2><span id="goroutine">goroutine</span></h2><p>goroutine上下文切换的耗时，相较于Linux线程上下文之间切换 降低90%(1.46us-&gt;0.225us)，且消耗的内存少，8G内存即可创建百万级别的协程</p><h3><span id="并发中的闭包">并发中的闭包</span></h3><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    runtime<span class="token punctuation">.</span><span class="token function">GOMAXPROCS</span><span class="token punctuation">(</span>runtime<span class="token punctuation">.</span><span class="token function">NumCPU</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>            wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：5 5 5 5 5<br>为什么呢？ for循环内每次都会调用一个goroutine，但是调用的goroutine启动的速度远比循环要慢，可以把i认为处于主函数的goroutine中。因此当循环中的goroutine开始执行的时候，i的值已经被赋为5，所以打印的值都是共享的i也就是5</p><p>解决：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>            wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="sync包">sync包</span></h2><h3><span id="waitgroup">WaitGroup</span></h3><h3><span id="互斥锁与读写锁">互斥锁与读写锁</span></h3><ul><li>sync.Mutex互斥锁</li><li>sync.RWMutex读写锁</li></ul><p>将程序对资源的访问分为读操作和写操作，这样它的效率就比Mutex要高些。<br>1、当有人还在占用写锁时，不允计有人读数据<br>2、多个人（线程）读取数据（拥有读锁）时，互不影响不会造成阻塞</p><p>RWMutex 里提供了两种锁：<br>读锁：调用 RLock 方法开启锁，调用 RUnlock 释放锁<br>写锁：调用 Lock 方法开启锁，调用 Unlock 释放锁（和 Mutex类似）</p><p>例子：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"sync"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    lock <span class="token operator">:=</span> <span class="token operator">&amp;</span>sync<span class="token punctuation">.</span>RWMutex<span class="token punctuation">{</span><span class="token punctuation">}</span>    lock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"第 %d 个协程准备开始... \n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>            lock<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"第 %d 个协程获得读锁, sleep 1s 后，释放锁\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>            time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>            lock<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"准备释放写锁，读锁不再阻塞"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 写锁一释放，读锁就自由了</span>    lock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 由于会等到读锁全部释放，才能获得写锁</span>    <span class="token comment" spellcheck="true">// 因为这里一定会在上面 4 个协程全部完成才能往下走</span>    lock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"程序退出..."</span><span class="token punctuation">)</span>    lock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*第 1 个协程准备开始... 第 0 个协程准备开始... 第 3 个协程准备开始... 第 2 个协程准备开始... 准备释放写锁，读锁不再阻塞第 2 个协程获得读锁, sleep 1s 后，释放锁第 3 个协程获得读锁, sleep 1s 后，释放锁第 1 个协程获得读锁, sleep 1s 后，释放锁第 0 个协程获得读锁, sleep 1s 后，释放锁程序退出...*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3><span id="cond">cond</span></h3><p>用途：goroutine 的集合点，或等待或发布一个event。一个cond 是&gt;=2个goroutine之间的任意信号。当条件还没有达成的时候，后续的 goroutine 都会被阻塞。一旦条件达成，被阻塞的 goroutine 会被唤醒。</p><p>Cond 的初始化需要传入一个 Locker 接口的实例（通常传入 Mutex 和 RWMutex）如：c := sync.NewCond(&amp;sync.Mutex{})</p><p>Wait、Signal 和 Broadcast</p><p>调用Wait方法的 goroutine 会被放到 Cond 的等待队列中并阻塞，直到被 Signal 或者 Broadcast 方法唤醒。调用 Wait 方法的时候一定要持有锁 c.L 。c.Wait 并不会阻塞，只是挂起了当前的 goroutine，并允许其他goroutine继续在os上运行<br>Signal 和 Broadcast两种方式发送信号给其他的goroutine，Signal 是唤醒其中一个，Broadcast唤醒全部</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"sync"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">var</span> m sync<span class="token punctuation">.</span>Mutex<span class="token keyword">var</span> c <span class="token operator">=</span> sync<span class="token punctuation">.</span><span class="token function">NewCond</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token keyword">var</span> n <span class="token operator">=</span> <span class="token number">5</span><span class="token keyword">func</span> <span class="token function">syncCondtest</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">,</span> running <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    c<span class="token punctuation">.</span>L<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"goroutine:%d wait\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>    running <span class="token operator">&lt;-</span> i    c<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    c<span class="token punctuation">.</span>L<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"goroutine:%d quit \n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    running <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token keyword">go</span> <span class="token function">syncCondtest</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> running<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//wait all goroutine running if no goroutine running c.Signal do nothing</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token operator">&lt;-</span>running    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"one goroutine runnningn"</span><span class="token punctuation">)</span>    c<span class="token punctuation">.</span><span class="token function">Signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"all goroutine runnningn"</span><span class="token punctuation">)</span>    c<span class="token punctuation">.</span><span class="token function">Broadcast</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token comment" spellcheck="true">/*goroutine:4 waitgoroutine:1 waitgoroutine:0 waitgoroutine:2 waitgoroutine:3 waitone goroutine runnningngoroutine:4 quit all goroutine runnningngoroutine:1 quit goroutine:3 quit goroutine:2 quit goroutine:0 quit*/</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3><span id="once">once</span></h3><p>sync.Once</p><p>var one sync.Once<br>one.Do(xxx)保证传入的xxx只会调用一次，one再次使用是无效的，因为one保证的是Do方法只被调用一次</p><h3><span id="syncpool池">sync.Pool池</span></h3><p>池是用来做缓存进行 存取 对象的池子，较少GC带来的损耗，避免重复的创建、销毁<br>通过Get方法获取对象，Put方法存入对象</p><p>初始化 Pool时，需要设置好 New 函数。当调用 Get 方法时，如果池子里缓存了对象，就直接返回缓存的对象。如果没有存货，则调用 New 函数创建一个新的对象。</p><p>下面的例子：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"sync"</span><span class="token punctuation">)</span><span class="token keyword">var</span> pool <span class="token operator">*</span>sync<span class="token punctuation">.</span>Pool<span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Name <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">initPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    pool <span class="token operator">=</span> <span class="token operator">&amp;</span>sync<span class="token punctuation">.</span>Pool <span class="token punctuation">{</span>        New<span class="token punctuation">:</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Creating a new Person"</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token operator">&amp;</span>Person<span class="token punctuation">{</span>Name<span class="token punctuation">:</span> <span class="token string">"None"</span><span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">initPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    p <span class="token operator">:=</span> pool<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>Person<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// A</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"首次从 pool 里获取："</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span>    p<span class="token punctuation">.</span>Name <span class="token operator">=</span> <span class="token string">"first"</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"设置 p.Name = %s\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span>Name<span class="token punctuation">)</span>    pool<span class="token punctuation">.</span><span class="token function">Put</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Pool 里已有一个对象，调用 Get: "</span><span class="token punctuation">,</span> pool<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>Person<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// B</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Pool 没有对象了，调用 Get: "</span><span class="token punctuation">,</span> pool<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>Person<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// C</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*Creating a new Person首次从 pool 里获取： &amp;{None}设置 p.Name = firstPool 里已有一个对象，调用 Get:  &amp;{first}Creating a new PersonPool 没有对象了，调用 Get:  &amp;{None}运行结束，执行耗时：1毫秒*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>A、C处获取对象时，池中已为空，所以获取到的是New的新对象</p><h2><span id="channel">channel</span></h2><p>充当goroutine之间通信的管道</p><p>channel 是阻塞的，当从空的channel读取数据时如果 channel为空，则会等待有数据写入channel<br>下面的例子：main的goroutine并不会退出导致而创建的匿名goroutine无法写入内容，反而会阻塞等待写入</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    stringStream <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        stringStream <span class="token operator">&lt;-</span> <span class="token string">"hello"</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>stringStream<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="select语句">select语句</span></h2><p>当select 的 case中多个channel 可用时，Go会随机选取其中一个进行读取<br>如果没有channel可用，我们可以选取超时机制避免阻塞</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">var</span> c <span class="token operator">&lt;-</span> <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token keyword">select</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>c<span class="token punctuation">:</span> xxx    <span class="token keyword">case</span> time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">:</span> xxx<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者使用default</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">var</span> c <span class="token operator">&lt;-</span> <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token keyword">select</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>c<span class="token punctuation">:</span> xxx    <span class="token keyword">default</span><span class="token punctuation">:</span> xxx<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="gomaxprocs控制">GOMAXPROCS控制</span></h2><p>runtime的GOMAXPROCS函数，控制使用的CPU核数。<br><a href="https://zhuanlan.zhihu.com/p/111346689" target="_blank" rel="noopener">Go 为什么这么“快”</a>  中讲解了Go的GPM模型</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;go语言的csp模型&quot;&gt;Go语言的CSP模型&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;CSP 是 Communicating Sequential Process 的简称，中文可以叫做通信顺序进程，是一种并发编程模型。&lt;br&gt;G
      
    
    </summary>
    
      <category term="Go" scheme="https://mfcheer.github.io/categories/Go/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习：L1/L2正则化</title>
    <link href="https://mfcheer.github.io/article/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-L1-L2%E6%AD%A3%E5%88%99%E5%8C%96.html"/>
    <id>https://mfcheer.github.io/article/机器学习-L1-L2正则化.html</id>
    <published>2018-10-17T23:49:46.000Z</published>
    <updated>2021-02-07T03:31:28.726Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1><span id="正则化概念">正则化概念</span></h1><p>是机器学习中一种常用的技术，其主要目的是控制模型复杂度，减小过拟合。最基本的正则化方法是在原目标（代价）函数 中添加惩罚项，对复杂度高的模型进行“惩罚”。</p><p>下面图中黑色的折线就是过拟合的例子：<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos2/2.png" alt=""></p><p>常用的正则化函数有两种，L1正则化和L2正则化<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos2/3.png" alt=""></p><p>其中，<br>L1正则化表示某个向量中所有元素绝对值的和。<br>性质是能产生稀疏性，导致 W 中许多项变成零。会使原最优解的元素产生不同量的偏移，并使某些元素为0或趋近于0。</p><p>L2正则化表示某个向量中所有元素平方和再开根， 也就是欧几里得距离公式。<br>不具有产生稀疏解的能力，计算量上并没有得到提升。 L2正则化的效果是对原最优解的每个元素进行不同比例的放缩。</p><p>引用知乎上文章的解释：<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos2/6.png" alt=""></p><p>上图中，若不加正则项，最优解是靠近中心点的等高线，加入正则项之后，最优解对应的等高线不会离中心太近，避免了过拟合。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1&gt;&lt;span id=&quot;正则化概念&quot;&gt;正则化概念&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;是机器学习中一种常用的技术，其主要目的是控制模型复杂度，减小过拟合。最基本的正则化方法是在原目标（代价）函数 中添加惩罚项，对复杂度高的模型进行“惩罚”。&lt;/p&gt;
      
    
    </summary>
    
      <category term="机器学习" scheme="https://mfcheer.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习：决策树之ID3算法与C4.5算法</title>
    <link href="https://mfcheer.github.io/article/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%86%B3%E7%AD%96%E6%A0%91%E4%B9%8BID3%E7%AE%97%E6%B3%95%E4%B8%8EC4.5%E7%AE%97%E6%B3%95.html"/>
    <id>https://mfcheer.github.io/article/机器学习：决策树之ID3算法与C4.5算法.html</id>
    <published>2018-10-17T14:38:23.000Z</published>
    <updated>2021-02-07T03:31:28.728Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1><span id="id3概念">ID3概念</span></h1><p>即Iterative Dichotomiser 3，迭代二叉树3代。该算法是以信息论为基础，以信息熵和信息增益为衡量标准。</p><h2><span id="信息熵">信息熵</span></h2><p>描述信息的混乱程度，熵越大，表示信息越混乱。<br>信息熵的计算公式：其中P(Xi)表示类别Xi在样本出现的概率。<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos2/1.png" alt=""></p><h2><span id="信息增益">信息增益</span></h2><p>用于度量属性A降低样本集合X熵的贡献大小。信息增益越大，越适于对X分类。<br>Gain(A, X) = H(X) - Sum(|Xv| / |X| * H(Xv))  {v: A的所有可能值}，Xv表示A中所有为v的值；|Xv|表示A中所有为v的值的数量；</p><h1><span id="算法流程">算法流程</span></h1><p>ID3算法就是在每次需要分裂时，计算每个属性的增益率，然后选择增益率最大的属性进行分裂。</p><h1><span id="c45算法">C4.5算法</span></h1><p>它是对ID3算法的改进，改进如下</p><ul><li>1）用信息增益率来选择属性</li><li>2）在决策树的构造过程中对树进行剪枝</li><li>3）对非离散数据也能处理</li><li>4）能够对不完整数据进行处理</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1&gt;&lt;span id=&quot;id3概念&quot;&gt;ID3概念&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;即Iterative Dichotomiser 3，迭代二叉树3代。该算法是以信息论为基础，以信息熵和信息增益为衡量标准。&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;信
      
    
    </summary>
    
      <category term="机器学习" scheme="https://mfcheer.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习：决策树之CART算法</title>
    <link href="https://mfcheer.github.io/article/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%86%B3%E7%AD%96%E6%A0%91%E4%B9%8BCART%E7%AE%97%E6%B3%95.html"/>
    <id>https://mfcheer.github.io/article/机器学习：决策树之CART算法.html</id>
    <published>2018-10-17T12:29:09.000Z</published>
    <updated>2021-02-07T03:31:28.728Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1><span id="cart算法概念">CART算法概念</span></h1><p>Classification And Regression Tree，即分类回归树算法。它是决策树的一种实现。</p><p>CART是一种二分的分割技术，把当前的样本划分成两个子样本，每个非叶子节点都有两个分支，生成的决策树是二叉树。</p><h1><span id="cart算法流程">CART算法流程</span></h1><p>使用基尼系数判断样本集的“不纯度”，尽可能“纯”就是尽量让一个分裂子集中待分类项属于同一类别。基尼系数越低越好。</p><p>基尼系数的公式：<br>其中，C样本分类的数量。Pi表示属于i类的概率。<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/90.png" alt=""></p><p>下面举例CART中基尼系数的计算，图片来自网络。<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/86.png" alt=""><br>属性有3个，分别是有房情况，婚姻状况和年收入。房和婚姻是离散值，收入是连续值，是否贷款是分类结果。</p><p><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/87.png" alt=""></p><p>下面是婚姻状况属性，有三种情况。<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/88.jpg" alt=""></p><p>最后是收入属性，它是连续值，连续值的计算使用分裂点的方法，选择基尼系数最小的点作为决策树的划分。<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/89.png" alt=""></p><p>根据这样的分裂规则CART算法就能完成建树过程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1&gt;&lt;span id=&quot;cart算法概念&quot;&gt;CART算法概念&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;Classification And Regression Tree，即分类回归树算法。它是决策树的一种实现。&lt;/p&gt;
&lt;p&gt;CART是一种二分的分割
      
    
    </summary>
    
      <category term="机器学习" scheme="https://mfcheer.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>Java BIO/NIO/AIO</title>
    <link href="https://mfcheer.github.io/article/Java-BIO-NIO-AIO.html"/>
    <id>https://mfcheer.github.io/article/Java-BIO-NIO-AIO.html</id>
    <published>2018-10-10T16:23:03.000Z</published>
    <updated>2021-02-07T03:31:28.509Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="三种io">三种IO</span></h1><h2><span id="java-bio">Java BIO</span></h2><p>同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理。</p><h2><span id="java-nio准备好了再通知我">Java NIO：准备好了再通知我</span></h2><p>同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。JDK1.4开始支持。</p><h2><span id="java-aionio2读完了再通知我">Java AIO(NIO.2)：读完了再通知我</span></h2><p>异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。JDK7开始支持。</p><h1><span id="关于nio">关于NIO</span></h1><ul><li>缓冲区Buffer</li></ul><p>Buffer是一个对象，包含一些要写入或者读出的数据。在NIO库中，所有数据都是用缓冲区处理的。缓冲区实际上是一个数组，并提供了对数据结构化访问以及维护读写位置等信息。具体的缓存区有这些：ByteBuffe、CharBuffer、 ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer。</p><ul><li>通道Channel</li></ul><p>我们对数据的读取和写入要通过Channel，它就像水管一样，是一个通道。通道不同于流的地方就是通道是双向的，可以用于读、写和同时读写操作。Channel主要分两大类，SelectableChannel用于网络读写，FileChannel用于文件操作。</p><ul><li>多路复用器Selector</li></ul><p>Selector可以不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作。一个Selector可以同时轮询多个Channel，因为JDK使用了epoll()代替传统的select实现，所以没有最大连接句柄1024/2048的限制。所以，只需要一个线程负责Selector的轮询，就可以接入成千上万的客户端。</p><h1><span id="适用场景分析">适用场景分析</span></h1><p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，但程序直观简单易理解。</p><p>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂。</p><p>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂。<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;三种IO&quot;&gt;&lt;a href=&quot;#三种IO&quot; class=&quot;headerlink&quot; title=&quot;三种IO&quot;&gt;&lt;/a&gt;三种IO&lt;/h1&gt;&lt;h2 id=&quot;Java-BIO&quot;&gt;&lt;a href=&quot;#Java-BIO&quot; class=&quot;headerlink&quot; title=&quot;Java BIO&quot;&gt;&lt;/a&gt;Java BIO&lt;/h2&gt;&lt;p&gt;同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理。&lt;/p&gt;
&lt;h2 id=&quot;Java-NIO：准备好了再通知我&quot;&gt;&lt;a href=&quot;#Java-NIO：准备好了再通知我&quot; class=&quot;headerlink&quot; title=&quot;Java NIO：准备好了再通知我&quot;&gt;&lt;/a&gt;Java NIO：准备好了再通知我&lt;/h2&gt;&lt;p&gt;同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。JDK1.4开始支持。&lt;/p&gt;
&lt;h2 id=&quot;Java-AIO-NIO-2-：读完了再通知我&quot;&gt;&lt;a href=&quot;#Java-AIO-NIO-2-：读完了再通知我&quot; class=&quot;headerlink&quot; title=&quot;Java AIO(NIO.2)：读完了再通知我&quot;&gt;&lt;/a&gt;Java AIO(NIO.2)：读完了再通知我&lt;/h2&gt;&lt;p&gt;异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。JDK7开始支持。&lt;/p&gt;
&lt;h1 id=&quot;关于NIO&quot;&gt;&lt;a href=&quot;#关于NIO&quot; class=&quot;headerlink&quot; title=&quot;关于NIO&quot;&gt;&lt;/a&gt;关于NIO&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;缓冲区Buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Buffer是一个对象，包含一些要写入或者读出的数据。在NIO库中，所有数据都是用缓冲区处理的。缓冲区实际上是一个数组，并提供了对数据结构化访问以及维护读写位置等信息。具体的缓存区有这些：ByteBuffe、CharBuffer、 ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通道Channel&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们对数据的读取和写入要通过Channel，它就像水管一样，是一个通道。通道不同于流的地方就是通道是双向的，可以用于读、写和同时读写操作。Channel主要分两大类，SelectableChannel用于网络读写，FileChannel用于文件操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多路复用器Selector&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Selector可以不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作。一个Selector可以同时轮询多个Channel，因为JDK使用了epoll()代替传统的select实现，所以没有最大连接句柄1024/2048的限制。所以，只需要一个线程负责Selector的轮询，就可以接入成千上万的客户端。&lt;/p&gt;
&lt;h1 id=&quot;适用场景分析&quot;&gt;&lt;a href=&quot;#适用场景分析&quot; class=&quot;headerlink&quot; title=&quot;适用场景分析&quot;&gt;&lt;/a&gt;适用场景分析&lt;/h1&gt;&lt;p&gt;BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，但程序直观简单易理解。&lt;/p&gt;
&lt;p&gt;NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂。&lt;/p&gt;
&lt;p&gt;AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mfcheer.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java：JVM内存分配总结</title>
    <link href="https://mfcheer.github.io/article/Java%EF%BC%9AJVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%80%BB%E7%BB%93.html"/>
    <id>https://mfcheer.github.io/article/Java：JVM内存分配总结.html</id>
    <published>2018-08-07T02:22:40.000Z</published>
    <updated>2021-02-07T03:31:28.514Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1><span id="java虚拟机运行时数据区">Java虚拟机运行时数据区</span></h1><p>包括如下几部分<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/83.png" alt=""></p><h2><span id="程序计数器">程序计数器</span></h2><p>线程私有内存。用于保存当前正常执行的程序的内存地址。Java虚拟机的多线程就是通过线程轮流切换并分配处理器时间来实现的，为了线程切换后能恢复到正确的位置，每条线程都需要一个独立的程序计数器，互不影响，该区域为“线程私有”。</p><h2><span id="虚拟机栈">虚拟机栈</span></h2><p>线程私有内存，用于存储局部变量表，操作栈，方法返回值。局部变量表放着基本数据类型，还有对象的引用。 </p><h2><span id="本地方法栈">本地方法栈</span></h2><p>与虚拟机栈一样，只不过服务的是Native方法，也就是调用C、C++代码时。</p><h2><span id="java堆">Java堆</span></h2><p>所有线程共享区域,对象实例几乎都在这分配内存。垃圾回收区域就在此。可细分为新生代和老年代，再可细分为Eden区，From Survivor<br>区，To Survivor区。用来存储程序中的一些对象，比如你用new关键字创建的对象，它就会被存储在堆内存中，但是这个对象在堆内存中的首地址会存储在栈中。</p><h2><span id="方法区">方法区</span></h2><p>所有线程共享区域。储存虚拟机加载的类信息，常量，静态变量，编译后的代码。</p><h3><span id="运行时常量池">运行时常量池</span></h3><p>属于方法区的一部分,代表运行时每个class文件中的常量表。包括几种常量：编译时的数字常量、方法或者域的引用。</p><h1><span id="常用jvm参数">常用JVM参数</span></h1><h2><span id="栈设置">栈设置</span></h2><ul><li>-Xss256K:每个线程的栈大小<h2><span id="堆设置">堆设置</span></h2></li><li>-Xms:初始堆大小</li><li>-Xmx:最大堆大小</li><li>-XX:NewSize=n:设置年轻代大小</li><li>-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4</li><li>-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5</li><li>-XX:MaxPermSize=n:设置持久代大小</li></ul><h2><span id="收集器设置">收集器设置</span></h2><ul><li>-XX:+UseSerialGC:设置串行收集器</li><li>-XX:+UseParallelGC:设置并行收集器</li><li>-XX:+UseParalledlOldGC:设置并行年老代收集器</li><li>-XX:+UseConcMarkSweepGC:设置并发收集器</li></ul><h2><span id="垃圾回收统计信息">垃圾回收统计信息</span></h2><ul><li>-XX:+PrintGC</li><li>-XX:+PrintGCDetails</li><li>-XX:+PrintGCTimeStamps</li><li>-Xloggc:filename</li></ul><h2><span id="并行收集器设置">并行收集器设置</span></h2><ul><li>-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。</li><li>-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间</li><li>-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</li><li>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。</li><li>-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</li></ul><h1><span id="java-new一个对象的过程">Java new一个对象的过程</span></h1><ul><li>检测类是否被加载</li><li>为新生对象分配内存</li><li>将分配到的内存空间都初始化为零值（不包括对象头）</li><li>对对象进行必要的设置（例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中）</li><li>执行init方法（构造方法）</li></ul><h1><span id="java-内存分配原则">Java 内存分配原则</span></h1><ul><li>对象优先分配在Eden区</li><li>大对象直接进入年老带</li><li>长期存活对象进入年老带</li><li>动态对象年龄判断</li><li>空间分配担保</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1&gt;&lt;span id=&quot;java虚拟机运行时数据区&quot;&gt;Java虚拟机运行时数据区&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;包括如下几部分&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/mfcheer/Ma
      
    
    </summary>
    
      <category term="Java" scheme="https://mfcheer.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java：通过JNI调用Fasttext模型</title>
    <link href="https://mfcheer.github.io/article/%E9%80%9A%E8%BF%87JNI%E8%B0%83%E7%94%A8Fasttext%E6%A8%A1%E5%9E%8B.html"/>
    <id>https://mfcheer.github.io/article/通过JNI调用Fasttext模型.html</id>
    <published>2018-06-25T00:35:21.000Z</published>
    <updated>2021-02-09T14:28:39.663Z</updated>
    
    <content type="html"><![CDATA[<p>fastText是facebook开源的一个词向量与文本分类工具<br><a href="https://github.com/facebookresearch/fastText" target="_blank" rel="noopener">https://github.com/facebookresearch/fastText</a></p><p>提供了python和c的接口。<br>通过Java使用fastText，搜到了这个项目 <a href="https://github.com/vinhkhuc/JFastText" target="_blank" rel="noopener">https://github.com/vinhkhuc/JFastText</a> ，使用起来很方便，性能也不错；但是有一个问题，就是如果模型多次更新，就会产生僵尸进程导致程序挂掉，并引起机器的负载升高。</p><p>所以决定使用JNI的方式调用fastText</p><p>步骤：<br>1、编写Java程序</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FastTextJNI</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> FastTextJNI ftJNI<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String LIB_PATH <span class="token operator">=</span> ConstantsConfig<span class="token punctuation">.</span>CONFIG_BASE_PATH <span class="token operator">+</span> <span class="token string">"libfasttext.so"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">long</span> <span class="token function">FastTextJNILoadModel</span><span class="token punctuation">(</span>String fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">float</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">FastTextSentenceVector</span><span class="token punctuation">(</span><span class="token keyword">long</span> modelHandle<span class="token punctuation">,</span> String words<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">FastTextJNIReleaseModel</span><span class="token punctuation">(</span><span class="token keyword">long</span> modelHandle<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>LIB_PATH<span class="token punctuation">)</span><span class="token punctuation">;</span>        ftJNI <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FastTextJNI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">FastTextJNI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">FastTextJNI</span><span class="token punctuation">(</span>String fileName<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">FastTextJNILoadModel</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">float</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getSentenceVector</span><span class="token punctuation">(</span><span class="token keyword">long</span> modelHandle<span class="token punctuation">,</span> String words<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">FastTextSentenceVector</span><span class="token punctuation">(</span>modelHandle<span class="token punctuation">,</span> words<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span>Long modelHandle<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">FastTextJNIReleaseModel</span><span class="token punctuation">(</span>modelHandle<span class="token punctuation">)</span><span class="token punctuation">;</span>        modelHandle <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><a id="more"></a><p>2、编译Java程序 javac FastTextJNI.java</p><p>3、继续编译生成c的头文件（给c/c++程序用）<br>javah -jni -classpath . FastTextJNI，生成了头文件FastTextJNI.h</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/* DO NOT EDIT THIS FILE - it is machine generated */</span>#include <span class="token operator">&lt;</span>jni<span class="token punctuation">.</span>h<span class="token operator">></span><span class="token comment" spellcheck="true">/* Header for class FastTextJNI */</span>#ifndef FastTextJNI#define FastTextJNI#ifdef __cplusplusextern <span class="token string">"C"</span> <span class="token punctuation">{</span>#endifJNIEXPORT jlong JNICALL <span class="token function">Java_FastTextJNI_FastTextJNILoadModel</span>  <span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span><span class="token punctuation">,</span> jobject<span class="token punctuation">,</span> jstring<span class="token punctuation">)</span><span class="token punctuation">;</span>JNIEXPORT jfloatArray JNICALL <span class="token function">Java_FastTextJNI_FastTextSentenceVector</span>  <span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span><span class="token punctuation">,</span> jobject<span class="token punctuation">,</span> jlong<span class="token punctuation">,</span> jstring<span class="token punctuation">)</span><span class="token punctuation">;</span>JNIEXPORT <span class="token keyword">void</span> JNICALL <span class="token function">Java_FastTextJNI_FastTextJNIReleaseModel</span>  <span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span><span class="token punctuation">,</span> jobject<span class="token punctuation">,</span> jlong<span class="token punctuation">)</span><span class="token punctuation">;</span>#ifdef __cplusplus<span class="token punctuation">}</span>#endif#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、新建cpp文件，实现jni编译生成的头文件中的函数</p><pre class="line-numbers language-java"><code class="language-java">#include <span class="token operator">&lt;</span>iostream<span class="token operator">></span>#include <span class="token operator">&lt;</span>sstream<span class="token operator">></span>#include <span class="token string">"FastTextJNI.h"</span>#include <span class="token string">"fastText/src/fasttext.h"</span>using namespace fasttext<span class="token punctuation">;</span>JNIEXPORT jlong JNICALL <span class="token function">Java_FastTextJNI_FastTextJNILoadModel</span>  <span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span>jenv<span class="token punctuation">,</span> jobject jobj<span class="token punctuation">,</span> jstring jmodelName<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> modelName <span class="token operator">=</span> jenv<span class="token operator">-</span><span class="token operator">></span><span class="token function">GetStringUTFChars</span><span class="token punctuation">(</span>jmodelName<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    FastText <span class="token operator">*</span>fastText <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FastText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    fastText<span class="token operator">-</span><span class="token operator">></span><span class="token function">loadModel</span><span class="token punctuation">(</span>modelName<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>modelName<span class="token punctuation">)</span>     <span class="token punctuation">{</span>        jenv<span class="token operator">-</span><span class="token operator">></span><span class="token function">ReleaseStringUTFChars</span><span class="token punctuation">(</span>jmodelName<span class="token punctuation">,</span> modelName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>jlong<span class="token punctuation">)</span>fastText<span class="token punctuation">;</span><span class="token punctuation">}</span>JNIEXPORT jfloatArray JNICALL <span class="token function">Java_FastTextJNI_FastTextSentenceVector</span>  <span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span>jenv<span class="token punctuation">,</span> jobject jobj<span class="token punctuation">,</span> jlong jmodelHandle<span class="token punctuation">,</span> jstring jwords<span class="token punctuation">)</span><span class="token punctuation">{</span>       FastText<span class="token operator">*</span> fastText <span class="token operator">=</span> <span class="token punctuation">(</span>FastText<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>jmodelHandle<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> words <span class="token operator">=</span> jenv<span class="token operator">-</span><span class="token operator">></span><span class="token function">GetStringUTFChars</span><span class="token punctuation">(</span>jwords<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span><span class="token operator">*</span> wordschar <span class="token operator">=</span> const_cast<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">:</span><span class="token operator">:</span>istringstream <span class="token function">in</span><span class="token punctuation">(</span>wordschar<span class="token punctuation">)</span><span class="token punctuation">;</span>        fasttext<span class="token operator">:</span><span class="token operator">:</span>Vector <span class="token function">vec</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span><span class="token punctuation">{</span>        fastText<span class="token operator">-</span><span class="token operator">></span><span class="token function">getSentenceVector</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> vec<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>std<span class="token operator">:</span><span class="token operator">:</span>exception<span class="token operator">&amp;</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">:</span><span class="token operator">:</span>cout <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">:</span><span class="token operator">:</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">float</span><span class="token operator">*</span> data <span class="token operator">=</span> vec<span class="token punctuation">.</span>data_<span class="token punctuation">;</span>    jfloatArray result<span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>    result <span class="token operator">=</span> jenv<span class="token operator">-</span><span class="token operator">></span><span class="token function">NewFloatArray</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>    jenv<span class="token operator">-</span><span class="token operator">></span><span class="token function">SetFloatArrayRegion</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span>JNIEXPORT <span class="token keyword">void</span> JNICALL <span class="token function">Java_FastTextJNI_FastTextJNIReleaseModel</span>  <span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span>jenv<span class="token punctuation">,</span> jobject jobj<span class="token punctuation">,</span> jlong jmodelHandle<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>jmodelHandle<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">delete</span> <span class="token punctuation">(</span>FastText<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>jmodelHandle<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5、最后编译so库，生成 libfasttext.so 文件使用</p><pre class="line-numbers language-java"><code class="language-java">g<span class="token operator">++</span> <span class="token operator">-</span>fpic <span class="token operator">-</span>shared a<span class="token punctuation">.</span>cpp <span class="token operator">-</span>o libfasttext<span class="token punctuation">.</span>so <span class="token operator">-</span>I<span class="token punctuation">.</span>/ <span class="token operator">-</span>I<span class="token operator">/</span>opt<span class="token operator">/</span>soft<span class="token operator">/</span>jdk<span class="token operator">/</span>jdk1<span class="token number">.6</span><span class="token punctuation">.</span>0_45<span class="token operator">/</span>include <span class="token operator">-</span>I<span class="token operator">/</span>opt<span class="token operator">/</span>soft<span class="token operator">/</span>jdk<span class="token operator">/</span>jdk1<span class="token number">.6</span><span class="token punctuation">.</span>0_45<span class="token operator">/</span>include<span class="token operator">/</span>linux<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成so库之后，执行ldd libfasttext.so，如果有关联其他库说明生成库没有问题</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;fastText是facebook开源的一个词向量与文本分类工具&lt;br&gt;&lt;a href=&quot;https://github.com/facebookresearch/fastText&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/facebookresearch/fastText&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;提供了python和c的接口。&lt;br&gt;通过Java使用fastText，搜到了这个项目 &lt;a href=&quot;https://github.com/vinhkhuc/JFastText&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/vinhkhuc/JFastText&lt;/a&gt; ，使用起来很方便，性能也不错；但是有一个问题，就是如果模型多次更新，就会产生僵尸进程导致程序挂掉，并引起机器的负载升高。&lt;/p&gt;
&lt;p&gt;所以决定使用JNI的方式调用fastText&lt;/p&gt;
&lt;p&gt;步骤：&lt;br&gt;1、编写Java程序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class FastTextJNI {

    public static FastTextJNI ftJNI;

    private static String LIB_PATH = ConstantsConfig.CONFIG_BASE_PATH + &amp;quot;libfasttext.so&amp;quot;;

    public native long FastTextJNILoadModel(String fileName);

    public native float[] FastTextSentenceVector(long modelHandle, String words);

    public native void FastTextJNIReleaseModel(long modelHandle);

    public static void init(){
        System.load(LIB_PATH);
        ftJNI = new FastTextJNI();
    }

    public FastTextJNI(){
    }

    public FastTextJNI(String fileName){
        FastTextJNILoadModel(fileName);
    }

    public float[] getSentenceVector(long modelHandle, String words){
        return FastTextSentenceVector(modelHandle, words);
    }

    public void finalize(Long modelHandle){
        FastTextJNIReleaseModel(modelHandle);
        modelHandle = (long) 0;
    }

}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mfcheer.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java：HttpServletRequest对象</title>
    <link href="https://mfcheer.github.io/article/Java%EF%BC%9AHttpServletRequest%E5%AF%B9%E8%B1%A1.html"/>
    <id>https://mfcheer.github.io/article/Java：HttpServletRequest对象.html</id>
    <published>2018-05-11T03:27:04.000Z</published>
    <updated>2021-02-07T03:31:28.514Z</updated>
    
    <content type="html"><![CDATA[<p>HttpServletRequest对象代表客户端的请求，当客户端通过HTTP协议访问服务器时，HTTP请求头中的所有信息都封装在这个对象中，通过这个对象的方法，可以获得请求信息。</p><h2><span id="httpservletrequest常用方法">HttpServletRequest常用方法</span></h2><pre><code>getRequestURL方法返回客户端发出请求时的完整URL。getRequestURI方法返回请求行中的资源名部分。getQueryString 方法返回请求行中的参数部分。getPathInfo方法返回请求URL中的额外路径信息。额外路径信息是请求URL中的位于Servlet的路径之后和查询参数之前的内容，它以“/”开头。getRemoteAddr方法返回发出请求的客户机的IP地址。getRemoteHost方法返回发出请求的客户机的完整主机名。getRemotePort方法返回客户机所使用的网络端口号。getLocalAddr方法返回WEB服务器的IP地址。getLocalName方法返回WEB服务器的主机名。getHeader(string name)方法:String getHeaders(String name)方法:Enumeration getHeaderNames()方法获得客户机请求参数:getParameter(String)方法(常用)getParameterValues(String name)方法(常用)getParameterNames()方法(不常用)getParameterMap()方法(编写框架时常用)参数放入request域对象：setAttribute(String name,Object o)方法，将数据作为request对象的一个属性存放到request对象中，例如：request.setAttribute(&quot;data&quot;, data);getAttribute(String name)方法，获取request对象的name属性的属性值，例如：request.getAttribute(&quot;data&quot;)removeAttribute(String name)方法，移除request对象的name属性，例如：request.removeAttribute(&quot;data&quot;)getAttributeNames方法，获取request对象的所有属性名，返回的是一个，例如：Enumeration&lt;String&gt; attrNames = request.getAttributeNames();</code></pre><h2><span id="请求重定向和请求转发的区别">请求重定向和请求转发的区别</span></h2><ul><li>一个web资源收到客户端请求后，通知服务器去调用另外一个web资源进行处理，称之为请求转发/307。</li><li>一个web资源收到客户端请求后，通知浏览器去访问另外一个web资源进行处理，称之为请求重定向/302。</li></ul><p>参考:<a href="http://www.cnblogs.com/xdp-gacl/p/3798347.html" target="_blank" rel="noopener">http://www.cnblogs.com/xdp-gacl/p/3798347.html</a><br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HttpServletRequest对象代表客户端的请求，当客户端通过HTTP协议访问服务器时，HTTP请求头中的所有信息都封装在这个对象中，通过这个对象的方法，可以获得请求信息。&lt;/p&gt;
&lt;h2 id=&quot;HttpServletRequest常用方法&quot;&gt;&lt;a href=&quot;#HttpServletRequest常用方法&quot; class=&quot;headerlink&quot; title=&quot;HttpServletRequest常用方法&quot;&gt;&lt;/a&gt;HttpServletRequest常用方法&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;getRequestURL方法返回客户端发出请求时的完整URL。
getRequestURI方法返回请求行中的资源名部分。
getQueryString 方法返回请求行中的参数部分。
getPathInfo方法返回请求URL中的额外路径信息。额外路径信息是请求URL中的位于Servlet的路径之后和查询参数之前的内容，它以“/”开头。
getRemoteAddr方法返回发出请求的客户机的IP地址。
getRemoteHost方法返回发出请求的客户机的完整主机名。
getRemotePort方法返回客户机所使用的网络端口号。
getLocalAddr方法返回WEB服务器的IP地址。
getLocalName方法返回WEB服务器的主机名。
getHeader(string name)方法:String 
getHeaders(String name)方法:Enumeration 
getHeaderNames()方法

获得客户机请求参数:
getParameter(String)方法(常用)
getParameterValues(String name)方法(常用)
getParameterNames()方法(不常用)
getParameterMap()方法(编写框架时常用)

参数放入request域对象：
setAttribute(String name,Object o)方法，将数据作为request对象的一个属性存放到request对象中，例如：request.setAttribute(&amp;quot;data&amp;quot;, data);
getAttribute(String name)方法，获取request对象的name属性的属性值，例如：request.getAttribute(&amp;quot;data&amp;quot;)
removeAttribute(String name)方法，移除request对象的name属性，例如：request.removeAttribute(&amp;quot;data&amp;quot;)
getAttributeNames方法，获取request对象的所有属性名，返回的是一个，例如：Enumeration&amp;lt;String&amp;gt; attrNames = request.getAttributeNames();
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;请求重定向和请求转发的区别&quot;&gt;&lt;a href=&quot;#请求重定向和请求转发的区别&quot; class=&quot;headerlink&quot; title=&quot;请求重定向和请求转发的区别&quot;&gt;&lt;/a&gt;请求重定向和请求转发的区别&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一个web资源收到客户端请求后，通知服务器去调用另外一个web资源进行处理，称之为请求转发/307。&lt;/li&gt;
&lt;li&gt;一个web资源收到客户端请求后，通知浏览器去访问另外一个web资源进行处理，称之为请求重定向/302。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考:&lt;a href=&quot;http://www.cnblogs.com/xdp-gacl/p/3798347.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.cnblogs.com/xdp-gacl/p/3798347.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mfcheer.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL：数据库索引</title>
    <link href="https://mfcheer.github.io/article/MySQL%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95.html"/>
    <id>https://mfcheer.github.io/article/MySQL：数据库索引.html</id>
    <published>2018-05-07T11:53:31.000Z</published>
    <updated>2021-02-07T03:31:28.519Z</updated>
    
    <content type="html"><![CDATA[<p>mysql中索引是对数据库表中一列或多列的值进行排序的一种结构。</p><h1><span id="mysql数据库索引种类">MySQL数据库索引种类</span></h1><ul><li>主键索引。数据列不允许重复，不允许为NULL.一个表只能有一个主键</li><li>唯一索引。数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</li><li>普通索引。基本的索引类型，没有唯一性的限制，允许为NULL值。</li><li>全文索引。</li></ul><h1><span id="索引使用的规则">索引使用的规则</span></h1><ul><li>索引的列是出现在where子句中的列，或者连接子句中指定的列</li><li>数量较少的列，没有必要在此列建立索引。</li><li>使用短索引。如果对长字符串列进行索引，指定一个前缀长度，能够节省大量索引空间。</li><li>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构。</li><li>最左前缀<br>顾名思义，就是最左优先。在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。 </li></ul><h1><span id="索引实现算法">索引实现算法</span></h1><ul><li>B树<br>B树实现的索引可以被用在=,&gt;,&gt;=,&lt;,&lt;=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量.</li><li>Hash<br>Hash索引只能用于对等比较，例如=,&lt;=&gt;（相当于=）操作符。</li></ul><h1><span id="in-和exists">in 和exists</span></h1><p>mysql中的in语句是把外表和内表作连接，而exists语句是对外表作循环，每次循环再对内表进行查询。</p><ul><li>如果查询两个表大小相当，那么用in和exists差别不大。</li><li>如果两个表大小差距较大，则子查询表大的用exists，子查询表小的用in。</li><li>not in 和not exists，查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。</li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysql中索引是对数据库表中一列或多列的值进行排序的一种结构。&lt;/p&gt;
&lt;h1 id=&quot;MySQL数据库索引种类&quot;&gt;&lt;a href=&quot;#MySQL数据库索引种类&quot; class=&quot;headerlink&quot; title=&quot;MySQL数据库索引种类&quot;&gt;&lt;/a&gt;MySQL数据库索引种类&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;主键索引。数据列不允许重复，不允许为NULL.一个表只能有一个主键&lt;/li&gt;
&lt;li&gt;唯一索引。数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。&lt;/li&gt;
&lt;li&gt;普通索引。基本的索引类型，没有唯一性的限制，允许为NULL值。&lt;/li&gt;
&lt;li&gt;全文索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;索引使用的规则&quot;&gt;&lt;a href=&quot;#索引使用的规则&quot; class=&quot;headerlink&quot; title=&quot;索引使用的规则&quot;&gt;&lt;/a&gt;索引使用的规则&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;索引的列是出现在where子句中的列，或者连接子句中指定的列&lt;/li&gt;
&lt;li&gt;数量较少的列，没有必要在此列建立索引。&lt;/li&gt;
&lt;li&gt;使用短索引。如果对长字符串列进行索引，指定一个前缀长度，能够节省大量索引空间。&lt;/li&gt;
&lt;li&gt;不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构。&lt;/li&gt;
&lt;li&gt;最左前缀&lt;br&gt;顾名思义，就是最左优先。在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。 &lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;索引实现算法&quot;&gt;&lt;a href=&quot;#索引实现算法&quot; class=&quot;headerlink&quot; title=&quot;索引实现算法&quot;&gt;&lt;/a&gt;索引实现算法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;B树&lt;br&gt;B树实现的索引可以被用在=,&amp;gt;,&amp;gt;=,&amp;lt;,&amp;lt;=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量.&lt;/li&gt;
&lt;li&gt;Hash&lt;br&gt;Hash索引只能用于对等比较，例如=,&amp;lt;=&amp;gt;（相当于=）操作符。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;in-和exists&quot;&gt;&lt;a href=&quot;#in-和exists&quot; class=&quot;headerlink&quot; title=&quot;in 和exists&quot;&gt;&lt;/a&gt;in 和exists&lt;/h1&gt;&lt;p&gt;mysql中的in语句是把外表和内表作连接，而exists语句是对外表作循环，每次循环再对内表进行查询。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果查询两个表大小相当，那么用in和exists差别不大。&lt;/li&gt;
&lt;li&gt;如果两个表大小差距较大，则子查询表大的用exists，子查询表小的用in。&lt;/li&gt;
&lt;li&gt;not in 和not exists，查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://mfcheer.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习：ROC曲线及AUC含义</title>
    <link href="https://mfcheer.github.io/article/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%9AROC%E6%9B%B2%E7%BA%BF%E5%8F%8AAUC%E5%90%AB%E4%B9%89.html"/>
    <id>https://mfcheer.github.io/article/机器学习：ROC曲线及AUC含义.html</id>
    <published>2018-05-01T11:10:48.000Z</published>
    <updated>2021-02-07T03:31:28.728Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="roc曲线">ROC曲线</span></h1><p>Receiver Operating Characteristic curve（受试者工作特征曲线）</p><p>我们将二分类器的所有可能取值，做一个方格图如下：<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/81.png" alt=""></p><ul><li>TP —— True Positive （真正, TP）被模型预测为正的正样本（原来为正预测为正）</li><li>TN —— True Negative（真负 , TN）被模型预测为负的负样本（原来为负预测为负）</li><li>FP ——False Positive （假正, FP）被模型预测为正的负样本（原来为负预测为正）</li><li>FN—— False Negative（假负 , FN）被模型预测为负的正样本 （原来为正预测为负）</li></ul><p>TP + TN + FP + FN = 样本总数。<br>两个指标，准确率和召回率</p><ul><li>准确率 P = TP/(TP + FP)</li><li>召回率 R = TP/(TP + FN)</li></ul><p>下图为ROC曲线图：<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/82.png" alt=""><br>图像的横轴是False Positive rate值（不是FP值），也就是实际为负并且预测错误的个数占总的负值的比例；图像的纵轴是True Positive rate值（不是TP值），也就是实际为正值并且预测正确的个数占总的正值的比例。</p><h2><span id="roc曲线中的四点一线">ROC曲线中的“四点一线”</span></h2><ul><li>第一个点，(0,1)，即FPR=0, TPR=1，这意味着FN（false negative）=0，并且FP（false positive）=0。这是一个完美的分类器，它将所有的样本都正确分类。</li><li>第二个点，(1,0)，即FPR=1，TPR=0，类似地分析可以发现这是一个最糟糕的分类器，因为它成功避开了所有的正确答案。</li><li>第三个点，(0,0)，即FPR=TPR=0，即FP（false positive）=TP（true positive）=0，可以发现该分类器预测所有的样本都为负样本（negative）。</li><li>第四个点（1,1），分类器实际上预测所有的样本都为正样本。</li></ul><p>对于ROC曲线，我们可以这样理解，对于二分类问题，曲线的每一个点都代表一个阈值，分类器给每个样本一个得分，得分大于阈值的我们认为是正样本，小于阈值的我们认为是负样本。</p><ul><li>若学习器A的ROC曲线将另外一个学习器B的曲线完全包住，则A的性能一定比B好</li><li>AUC值等于0.5时，我们可以认为分类器不起作用</li></ul><h1><span id="auc值">AUC值</span></h1><p>Area Under Curve score (曲线下面积值)，也就是ROC曲线之下与坐标轴围成的面积。<br>AUC值是一个概率值，当你随机挑选一个正样本以及一个负样本，当前的分类算法根据计算得到的Score值将这个正样本排在负样本前面的概率就是AUC值。AUC值越大，当前的分类算法越有可能将正样本排在负样本前面，即能够更好的分类。</p><h1><span id="下面是觉得不错的相关文章">下面是觉得不错的相关文章</span></h1><p><a href="https://zhuanlan.zhihu.com/p/52930683" target="_blank" rel="noopener">乱弹机器学习评估指标AUC</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;roc曲线&quot;&gt;ROC曲线&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;Receiver Operating Characteristic curve（受试者工作特征曲线）&lt;/p&gt;
&lt;p&gt;我们将二分类器的所有可能取值，做一个方格图如下：&lt;br&gt;&lt;img src=&quot;htt
      
    
    </summary>
    
      <category term="机器学习" scheme="https://mfcheer.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>mlens-SuperLearner 模型集成</title>
    <link href="https://mfcheer.github.io/article/mlens-SuperLearner-%E6%A8%A1%E5%9E%8B%E9%9B%86%E6%88%90.html"/>
    <id>https://mfcheer.github.io/article/mlens-SuperLearner-模型集成.html</id>
    <published>2018-04-29T15:17:49.000Z</published>
    <updated>2021-02-07T03:31:28.724Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>SuperLearner所做的事情就是将多个模型的输出结果作为特征输入选择的基模型，弥补单个模型准召的不足。</p><p><a href="https://zhuanlan.zhihu.com/p/32949396" target="_blank" rel="noopener">每个Kaggle冠军的获胜法门：揭秘Python中的模型集成</a></p><p><a href="https://zhuanlan.zhihu.com/p/36161812" target="_blank" rel="noopener">集成学习三大法宝-bagging、boosting、stacking</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;SuperLearner所做的事情就是将多个模型的输出结果作为特征输入选择的基模型，弥补单个模型准召的不足。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32949396&quot; target=&quot;_
      
    
    </summary>
    
      <category term="机器学习" scheme="https://mfcheer.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL：Limit分页优化</title>
    <link href="https://mfcheer.github.io/article/MySQL%EF%BC%9ALimit%E5%88%86%E9%A1%B5%E4%BC%98%E5%8C%96.html"/>
    <id>https://mfcheer.github.io/article/MySQL：Limit分页优化.html</id>
    <published>2018-04-29T03:34:33.000Z</published>
    <updated>2021-02-07T03:31:28.518Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="传统分页">传统分页：</span></h2><p>Select * from table limit 10000,10;</p><p>Limit 10000,10 偏移量越大则越慢，这句 SQL 的执行逻辑是:<br>1.从数据表中读取第N条数据添加到数据集中<br>2.重复第一步直到 N = 10000 + 10<br>3.根据 offset 抛弃前面 10000 条数<br>4.返回剩余的 10 条数据</p><h2><span id="推荐分页">推荐分页：</span></h2><ul><li>分页方式一：<br>Select * from table WHERE id&gt;=23434 limit 11;</li><li>分页方式二：<br>Select * from table WHERE id &gt;= ( select id from table limit 10000,1 ) limit 10;</li><li>分页方式三：<br>Select * from table INNER JOIN (SELECT id from table limit 10000,10) USING(id)</li><li>分页方式四：<br>程序取ID: Select id from table limit 10000,10;<br>Select * from table WHERE ID in(123,456…);<a id="more"></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;传统分页：&quot;&gt;&lt;a href=&quot;#传统分页：&quot; class=&quot;headerlink&quot; title=&quot;传统分页：&quot;&gt;&lt;/a&gt;传统分页：&lt;/h2&gt;&lt;p&gt;Select * from table limit 10000,10;&lt;/p&gt;
&lt;p&gt;Limit 10000,10 偏移量越大则越慢，这句 SQL 的执行逻辑是:&lt;br&gt;1.从数据表中读取第N条数据添加到数据集中&lt;br&gt;2.重复第一步直到 N = 10000 + 10&lt;br&gt;3.根据 offset 抛弃前面 10000 条数&lt;br&gt;4.返回剩余的 10 条数据&lt;/p&gt;
&lt;h2 id=&quot;推荐分页：&quot;&gt;&lt;a href=&quot;#推荐分页：&quot; class=&quot;headerlink&quot; title=&quot;推荐分页：&quot;&gt;&lt;/a&gt;推荐分页：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;分页方式一：&lt;br&gt;Select * from table WHERE id&amp;gt;=23434 limit 11;&lt;/li&gt;
&lt;li&gt;分页方式二：&lt;br&gt;Select * from table WHERE id &amp;gt;= ( select id from table limit 10000,1 ) limit 10;&lt;/li&gt;
&lt;li&gt;分页方式三：&lt;br&gt;Select * from table INNER JOIN (SELECT id from table limit 10000,10) USING(id)&lt;/li&gt;
&lt;li&gt;分页方式四：&lt;br&gt;程序取ID: Select id from table limit 10000,10;&lt;br&gt;Select * from table WHERE ID in(123,456…);
    
    </summary>
    
      <category term="数据库" scheme="https://mfcheer.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习：K-Means算法</title>
    <link href="https://mfcheer.github.io/article/K-Means%E7%AE%97%E6%B3%95.html"/>
    <id>https://mfcheer.github.io/article/K-Means算法.html</id>
    <published>2018-04-22T17:06:24.000Z</published>
    <updated>2021-02-07T03:31:28.515Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="原理">原理</span></h1><p>K-Means算法属于基于划分的聚类算法，对N维欧氏空间中的点进行聚类，是一种最简单的无监督学习方法。它通过迭代来实现，其基本思想是：每次确定K个类别中心，然后将各个结点归属到与之距离最近的中心点所在的Cluster，然后将类别中心更新为属于各Cluster的所有样本的均值，反复迭代，直至类别中心不再发生变化或变化小于某阈值。</p><h1><span id="算法描述">算法描述</span></h1><p>（1）随机生成c个类的初始中心；<br>（2）在第k次迭代中，对任意一个样本，求其到c各中心的距离，将该样本归到距离最短的那个中心所在的类；<br>（3）利用均值等方法更新该类的中心值；<br>（4）对于所有的C个聚类中心，如果利用（2）（3）的迭代法更新后，值保持不变，则迭代结束；否则继续迭代。<br><a id="more"></a></p><p>不同的初始化k值和中心点的选择有可能引起不同的聚类结果</p><h1><span id="聚类数k的选取评价方法">聚类数k的选取评价方法</span></h1><h3><span id="1-事前的数据分析选取合适的k值">1、事前的数据分析，选取合适的k值</span></h3><h3><span id="2-手肘法">2、手肘法</span></h3><p>手肘法的核心指标是SSE(误差平方和)。取名的原因是拟合曲线形状和手肘形状相似。</p><p>手肘法的核心思想是：随着聚类数k的增大，样本划分会更加精细，每个簇的聚合程度会逐渐提高，那么误差平方和SSE自然会逐渐变小。并且，当k小于真实聚类数时，由于k的增大会大幅增加每个簇的聚合程度，故SSE的下降幅度会很大，而当k到达真实聚类数时，再增加k所得到的聚合程度回报会迅速变小，所以SSE的下降幅度会骤减，然后随着k值的继续增大而趋于平缓，也就是说SSE和k的关系图是一个手肘的形状，而这个肘部对应的k值就是数据的真实聚类数。当然，这也是该方法被称为手肘法的原因。</p><h3><span id="3-轮廓系数法">3、轮廓系数法</span></h3><p>轮廓系数的公式为 s = (a-b)/max(a,b)。其中a为当前样本点x与同簇的其他样本的平均距离，称为凝聚度，b为x与最近簇中所有样本的平均距离，称为分离度。顾名思义，最近簇为除了同簇的最近的簇。</p><p>求出所有样本的轮廓系数后再求平均值就得到了平均轮廓系数。平均轮廓系数的取值范围为[-1,1]，且簇内样本的距离越近，簇间样本距离越远，平均轮廓系数越大，聚类效果越好。</p><h1><span id="随机点的选取评价方法">随机点的选取评价方法</span></h1><h3><span id="1-事前的数据分析选取合适中心点">1、事前的数据分析，选取合适中心点</span></h3><h3><span id="2-随机化选择">2、随机化选择</span></h3><p>第一个簇心A随机找；第二个簇心B要找距离A最远的，是因为簇心之间要相距远一些，如果很近的话，很容易当作一类，影响聚类效果；第三个簇心C也是同样的，它得离A、B远一些；如此类推。</p><h1><span id="时间复杂度">时间复杂度</span></h1><p>k-means算法的时间复杂度为：<br>O(mnkd)，m为迭代次数。n为数据集中数据样本数量，k为聚类个数，d为数据的维数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;K-Means算法属于基于划分的聚类算法，对N维欧氏空间中的点进行聚类，是一种最简单的无监督学习方法。它通过迭代来实现，其基本思想是：每次确定K个类别中心，然后将各个结点归属到与之距离最近的中心点所在的Cluster，然后将类别中心更新为属于各Cluster的所有样本的均值，反复迭代，直至类别中心不再发生变化或变化小于某阈值。&lt;/p&gt;
&lt;h1 id=&quot;算法描述&quot;&gt;&lt;a href=&quot;#算法描述&quot; class=&quot;headerlink&quot; title=&quot;算法描述&quot;&gt;&lt;/a&gt;算法描述&lt;/h1&gt;&lt;p&gt;（1）随机生成c个类的初始中心；&lt;br&gt;（2）在第k次迭代中，对任意一个样本，求其到c各中心的距离，将该样本归到距离最短的那个中心所在的类；&lt;br&gt;（3）利用均值等方法更新该类的中心值；&lt;br&gt;（4）对于所有的C个聚类中心，如果利用（2）（3）的迭代法更新后，值保持不变，则迭代结束；否则继续迭代。&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://mfcheer.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习：常用损失函数</title>
    <link href="https://mfcheer.github.io/article/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B8%B8%E7%94%A8%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0.html"/>
    <id>https://mfcheer.github.io/article/机器学习常用损失函数.html</id>
    <published>2018-04-19T16:30:44.000Z</published>
    <updated>2021-02-07T03:31:28.726Z</updated>
    
    <content type="html"><![CDATA[<ol><li>铰链损失（Hinge Loss）：主要用于支持向量机（SVM） 中； </li><li>互熵损失 （Cross Entropy Loss，Softmax Loss ）：用于Logistic 回归与Softmax 分类中； </li><li>平方损失（Square Loss）：主要是最小二乘法（OLS）中； </li><li>指数损失（Exponential Loss） ：主要用于Adaboost 集成学习算法中； </li><li>其他损失（如0-1损失，绝对值损失）<a id="more"></a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;铰链损失（Hinge Loss）：主要用于支持向量机（SVM） 中； &lt;/li&gt;
&lt;li&gt;互熵损失 （Cross Entropy Loss，Softmax Loss ）：用于Logistic 回归与Softmax 分类中； &lt;/li&gt;
&lt;li&gt;平方损失（Square Loss）：主要是最小二乘法（OLS）中； &lt;/li&gt;
&lt;li&gt;指数损失（Exponential Loss） ：主要用于Adaboost 集成学习算法中； &lt;/li&gt;
&lt;li&gt;其他损失（如0-1损失，绝对值损失）
    
    </summary>
    
      <category term="机器学习" scheme="https://mfcheer.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习：KNN算法</title>
    <link href="https://mfcheer.github.io/article/KNN%E7%AE%97%E6%B3%95.html"/>
    <id>https://mfcheer.github.io/article/KNN算法.html</id>
    <published>2018-04-16T16:55:03.000Z</published>
    <updated>2021-02-07T03:31:28.515Z</updated>
    
    <content type="html"><![CDATA[<p>KNN（K Nearest Neighbor）算法是机器学习里面常用的一种分类算法，假设一个样本空间被分为几类，然后给定一个待分类所有的特征数据，通过计算距离该数据的最近的K个样本来判断这个数据属于哪一类。如果距离待分类属性最近的K个类大多数都属于某一个特定的类，那么这个待分类的数据也就属于这个类。</p><p><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/78.jpg" alt=""></p><p>如图所示，假设现在需要对中间绿色的圆进行分类，假设我们寻找距离这个绿色圆最近的3个样本，即K=3，那么可以看出这个绿色圆属于红色三角形所在的类；如果K=5，因为蓝色方框最多，所以此时绿色圆属于蓝色方框所在的类。从而得到当K值取值不同时，得到的分类结果也可能不一样，所以很多时候K值得选取很关键，这就是KNN的核心思想。如果类别个数为偶数，那么K通常会设置为一个奇数；如果类别个数为奇数，K通常设置为偶数，这样就能保证不会有平局的发生。</p><p>每预测一个新样本的所属类别时，都会对整体样本进行遍历，可以看出KNN的效率实际上是十分低下的。<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;KNN（K Nearest Neighbor）算法是机器学习里面常用的一种分类算法，假设一个样本空间被分为几类，然后给定一个待分类所有的特征数据，通过计算距离该数据的最近的K个样本来判断这个数据属于哪一类。如果距离待分类属性最近的K个类大多数都属于某一个特定的类，那么这个待分类的数据也就属于这个类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/78.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如图所示，假设现在需要对中间绿色的圆进行分类，假设我们寻找距离这个绿色圆最近的3个样本，即K=3，那么可以看出这个绿色圆属于红色三角形所在的类；如果K=5，因为蓝色方框最多，所以此时绿色圆属于蓝色方框所在的类。从而得到当K值取值不同时，得到的分类结果也可能不一样，所以很多时候K值得选取很关键，这就是KNN的核心思想。如果类别个数为偶数，那么K通常会设置为一个奇数；如果类别个数为奇数，K通常设置为偶数，这样就能保证不会有平局的发生。&lt;/p&gt;
&lt;p&gt;每预测一个新样本的所属类别时，都会对整体样本进行遍历，可以看出KNN的效率实际上是十分低下的。&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://mfcheer.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习：集成学习方法</title>
    <link href="https://mfcheer.github.io/article/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%9A%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95.html"/>
    <id>https://mfcheer.github.io/article/机器学习：集成学习方法.html</id>
    <published>2018-04-02T15:24:28.000Z</published>
    <updated>2021-02-07T03:31:28.729Z</updated>
    
    <content type="html"><![CDATA[<p>集成学习是通过构建并结合多个学习器来完成学习任务。</p><h1><span id="bagging-和-boosting">bagging 和 boosting</span></h1><ul><li>bagging 是一种与 boosting 很类似的技术, 所使用的多个分类器的类型（数据量和特征量）都是一致的。</li><li>bagging 是由不同的分类器（1.数据随机化 2.特征随机化）经过训练，综合得出的出现最多分类结果；boosting 是通过调整已有分类器错分的那些数据来获得新的分类器，得出目前最优的结果。</li><li>bagging 中的分类器权重是相等的；而 boosting 中的分类器加权求和，所以权重并不相等，每个权重代表的是其对应分类器在上一轮迭代中的成功度。</li></ul><a id="more"></a><h1><span id="随机森林">随机森林</span></h1><p>Bagging + 决策树 = 随机森林<br>构建n个决策树进行投票</p><h1><span id="adaboost">AdaBoost</span></h1><p>boosting的adaboost每次训练的时候用的是同一个数据集，但是前一棵决策树分错的样本在后面的权重会升高，相当于说，后面的决策树利用了前面决策树学习的结果，不断的优化这个结果，也就是说，后面的决策树恰恰擅长的是前面决策树不擅长（分错）的样本.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;集成学习是通过构建并结合多个学习器来完成学习任务。&lt;/p&gt;
&lt;h1 id=&quot;bagging-和-boosting&quot;&gt;&lt;a href=&quot;#bagging-和-boosting&quot; class=&quot;headerlink&quot; title=&quot;bagging 和 boosting&quot;&gt;&lt;/a&gt;bagging 和 boosting&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;bagging 是一种与 boosting 很类似的技术, 所使用的多个分类器的类型（数据量和特征量）都是一致的。&lt;/li&gt;
&lt;li&gt;bagging 是由不同的分类器（1.数据随机化 2.特征随机化）经过训练，综合得出的出现最多分类结果；boosting 是通过调整已有分类器错分的那些数据来获得新的分类器，得出目前最优的结果。&lt;/li&gt;
&lt;li&gt;bagging 中的分类器权重是相等的；而 boosting 中的分类器加权求和，所以权重并不相等，每个权重代表的是其对应分类器在上一轮迭代中的成功度。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://mfcheer.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习笔记：XGBoost</title>
    <link href="https://mfcheer.github.io/article/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AXGBoost.html"/>
    <id>https://mfcheer.github.io/article/机器学习笔记：XGBoost.html</id>
    <published>2018-03-24T15:22:32.000Z</published>
    <updated>2021-02-07T03:31:28.726Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="xgboost">XGBoost</span></h1><p>XGBoost可以看做是GBDT的一种实现方式，目前在竞赛和工业界都被大量应用，并取得了很好的效果。</p><h2><span id="boostedtree">BoostedTree</span></h2><h3><span id="回归树">回归树</span></h3><p>BoostedTree的基本组成部分是回归树（Classification And Regression Tree），称作CART。<br>回归树会把输入的数据，分配到叶子节点上去，每个叶子节点都对应一个实数，非叶子节点都是一个二叉树。属于决策树的一种。<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/52.png" alt=""></p><a id="more"></a><p>决策树自上而下建立，根据属性值大小分裂为左右两个节点。</p><h3><span id="treeensemble">TreeEnsemble</span></h3><p>一颗回归树往往无法正确的做出预测，所以可以将多棵树的预测进行一个组合，得到最终的结果。<br>预测结果就是各个回归树的和。<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/53.png" alt=""></p><h2><span id="模型组成">模型组成</span></h2><h3><span id="模型和参数">模型和参数</span></h3><p>简单来说，模型是指给定xi如何去预测yi.<br>比较常见的模型如线性模型，yi=w*xi+z,其中w和z就是我们需要预测的值。</p><h3><span id="目标函数误差函数正则项">目标函数=误差函数+正则项</span></h3><p><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/54.png" alt=""></p><p>误差函数又称损失函数，是为了尽可能的提高模型预测正确性。一般代表误差，如平方误差等。<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos1/84.png" alt=""></p><p>正则项是为了防止过拟合样本数据。常见线性模型有L1、L2正则。</p><h2><span id="模型原理">模型原理</span></h2><p>boosting的过程中，每次保留前面的模型不变，加入一个新的函数到模型中，目标函数如下：<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/55.png" alt=""></p><p>每次加入怎样的函数呢？当然是使得目标函数尽量小的函数<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/56.png" alt=""></p><p>如果为平方误差的情形下，目前函数可以写成<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/57.png" alt=""></p><p>对于不是平方误差的情况，我们会采用如下的泰勒展开近似来定义一个近似的目标函数，方便我们进行这一步的计算。<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/58.png" alt=""></p><p>当我们把常数项移除之后，我们会发现如下一个比较统一的目标函数。这一个目标函数有一个非常明显的特点，它只依赖于每个数据点的在误差函数上的一阶导数和二阶导数. 误差函数为<br><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/59.png" alt=""></p><p>一阶导数、二阶导数为</p><p><img src="https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/60.png" alt=""></p><h2><span id="模型参数">模型参数</span></h2><h3><span id="增加随机性">增加随机性</span></h3><ul><li>eta 为了防止过拟合，更新过程中用到的收缩步长。</li><li>subsample 这个就是随机森林的方式，每次不是取出全部样本，而是有放回地取出部分样本。有人把这个称为行抽取，subsample就表示抽取比例</li><li>colsample_bytree和colsample_bylevel 这个是模仿随机森林的方式，这是列抽取。colsample_bytree是每次准备构造一棵新树时，选取部分特征来构造，colsample_bytree就是抽取比例。colsample_bylevel表示的是每次分割节点时，抽取特征的比例。</li><li>max_delta_step 这个是构造树时，允许得到ft(x)的最大值。如果为0，表示无限制。也是为了后续构造树留出空间，和eta相似</li></ul><h3><span id="控制模型复杂度">控制模型复杂度</span></h3><ul><li>max_depth 树的最大深度</li><li>min_child_weight 叶节点最小样本数</li><li>gamma 每次分开一个节点后，造成的最小下降的分数。类似于上面的Gain</li><li>alpha和lambda就是目标函数里的表示模型复杂度中的L1范数和L2范数前面的系数</li></ul><h3><span id="其他参数">其他参数</span></h3><ul><li>num_class 分类数</li><li>booster 表示用哪种模型，一共有gbtree, gbline, dart三种选择。一般用gbtree。</li><li>nthread 并行线成数。如果不设置就是能采用的最大线程。</li><li>sketch_eps 这个就是近似算法里的ϵ。</li><li>scale_pos_weight 这个是针对二分类问题时，正负样例的数量差距过大。</li></ul><h2><span id="控制过拟合">控制过拟合</span></h2><p>通常可以通过两种方式来控制xgboost中的过拟合</p><ul><li>第一种方式是直接控制模型的复杂性<br>包括参数：max_depth，min_child_weight 和 gamma</li><li>第二种方法是增加随机性<br>包括参数：subsample，colsample_bytree，eta</li></ul><h2><span id="与gbdt的差别">与GBDT的差别</span></h2><ul><li>传统GBDT以CART作为基分类器，xgboost还支持线性分类器。</li><li>传统GBDT在优化时只用到一阶导数信息，xgboost则对代价函数进行了二阶泰勒展开，同时用到了一阶和二阶导数。</li><li>xgboost在代价函数里加入了正则项，用于控制模型的复杂度。</li><li>xgboost的权重衰减。</li><li>xgboost支持更好的并行。</li></ul><h1><span id="如何画xgboost里面的决策树">如何画XGBoost里面的决策树</span></h1><p><a href="https://zhuanlan.zhihu.com/p/32943164" target="_blank" rel="noopener">如何画XGBoost里面的决策树</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;XGBoost&quot;&gt;&lt;a href=&quot;#XGBoost&quot; class=&quot;headerlink&quot; title=&quot;XGBoost&quot;&gt;&lt;/a&gt;XGBoost&lt;/h1&gt;&lt;p&gt;XGBoost可以看做是GBDT的一种实现方式，目前在竞赛和工业界都被大量应用，并取得了很好的效果。&lt;/p&gt;
&lt;h2 id=&quot;BoostedTree&quot;&gt;&lt;a href=&quot;#BoostedTree&quot; class=&quot;headerlink&quot; title=&quot;BoostedTree&quot;&gt;&lt;/a&gt;BoostedTree&lt;/h2&gt;&lt;h3 id=&quot;回归树&quot;&gt;&lt;a href=&quot;#回归树&quot; class=&quot;headerlink&quot; title=&quot;回归树&quot;&gt;&lt;/a&gt;回归树&lt;/h3&gt;&lt;p&gt;BoostedTree的基本组成部分是回归树（Classification And Regression Tree），称作CART。&lt;br&gt;回归树会把输入的数据，分配到叶子节点上去，每个叶子节点都对应一个实数，非叶子节点都是一个二叉树。属于决策树的一种。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/mfcheer/MarkdownPhotos/master/photos/52.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://mfcheer.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习笔记：特征工程基本方法</title>
    <link href="https://mfcheer.github.io/article/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95.html"/>
    <id>https://mfcheer.github.io/article/机器学习笔记：特征工程基本方法.html</id>
    <published>2018-03-13T14:12:03.000Z</published>
    <updated>2021-02-07T03:31:28.726Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="为什么要做特征工程">为什么要做特征工程？</span></h1><p>“数据和特征决定了机器学习的上限，而模型和算法是在逼近这个上限而已”，所以数据是机器学习的基础。数据来源是各种各样的，文本、语音、视频、图片等，原始的数据必须以特征的形式，加入到模型中，才能进行训练</p><h1><span id="特征工程方法">特征工程方法</span></h1><h2><span id="1-one-hot编码">1、One-Hot编码</span></h2><p>避免连续值导致模型的“误解”</p><h2><span id="2-离散化">2、离散化</span></h2><p>对数据进行分区分桶操作</p><h2><span id="3-连续值">3、连续值</span></h2><p>使用属性的连续值，某些模型对连续型的特征处理有比较好的效果</p><h2><span id="4-特征交叉">4、特征交叉</span></h2><p>两个甚至多个特征，进行特征组合，形成一组新的特征</p><h2><span id="5-归一化">5、归一化</span></h2><p>机器学习中，对数据进行分析之前，都会对数据进行归一化处理，这样做是为了消除部分特征数据对整体结果的影响。一般来说，是通过特定的方法，对数据的区间进行缩放处理，使之达到一个合适值，使各个指标处于同一个数量级。常见的是将数值处理成[0,1]之间的小数</p><h3><span id="51-最大最小标准化">5.1 最大最小标准化</span></h3><p>通过特征的最大最小值，将每个值处理成[0,1]区间的数字，公式如下<br>设最大maxA,最小值为minA，y=(x-minA)/(maxA-minA)</p><h3><span id="52-对数函数">5.2 对数函数</span></h3><p>y=log10(x)</p><h3><span id="53-z-score标准化">5.3 z-score标准化</span></h3><p>通过特征的平均值和标准差，进行数据处理，公式为：<br>y=(x-μ)/σ 其中x为某一分数，μ为平均数，σ为标准差。<br>y的含义就是x与平均值之间的距离，衡量单位是标准差</p><h1><span id="6-二值化">6、二值化</span></h1><p>取值为 0,1</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;为什么要做特征工程&quot;&gt;为什么要做特征工程？&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;“数据和特征决定了机器学习的上限，而模型和算法是在逼近这个上限而已”，所以数据是机器学习的基础。数据来源是各种各样的，文本、语音、视频、图片等，原始的数据必须以特征的形式，加入到模
      
    
    </summary>
    
      <category term="机器学习" scheme="https://mfcheer.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
</feed>
